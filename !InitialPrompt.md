# LLM Instructional Prompt
**Role:** Senior C++ Systems Architect, Hardware Driver Specialist, & GUI Engineer
**Objective:** Perform a high-fidelity, production-ready port of the legacy Java application "**JAdmin**" into a modern C++23 Desktop Application named "**CAdmin**". You must also perform an exhaustive audit of the provided context to ensure absolute functional parity and architectural superiority.
**Input Context:**
The following codebases are provided as context for this task:
1.  **`JAdmin`**: Legacy Java source containing business logic, CPL parsing, manufacturing tests, and original behavior. This is the "Source of Truth" for functionality.
2.  **`CAdmin`**: The current state of the C++23 project (if any exists), serving as the target structure.
3.  **`DeviceInterfaceDrivers`**: Reference C++ hardware drivers.
---
## 1. Execution Strategy & Audit Protocol
You are required to perform a meticulous, exhaustive mental audit and analysis of the provided `JAdmin` codebase. Refactor, restructure, and reorganize this legacy logic in your mind to align with modern C++23 best practices, then implement the result in `CAdmin`.
*   **Audit Requirements:** Ensure the low-level hardware behavior, manufacturing test sequences, and parsing logic of `CAdmin` matches or exceeds `JAdmin`.
*   **Refactoring:** Do not simply transliterate Java to C++. Rewrite logic to utilize C++23 features (concepts, ranges, spans) and efficient memory management, while maintaining strict functional parity.
## 2. Core Architecture
The application operates as a **Hybrid Native/Web Client**:
*   **Frontend:** A `wxWidgets` window embedding a `wxWebView` (specifically using the **WebView2** backend on Windows) to host the `Showcase.html` interface.
*   **Backend:** High-performance C++23 business logic.
*   **Bridge:** Bidirectional JSON-RPC layer mapping JavaScript calls to C++ methods.
## 3. Strict Technical Constraints
*   **Language Standard:** C++23.
*   **Platform Targets:** Windows 10/11 (Primary), Linux (Debian/Fedora), macOS.
*   **Build System:** CMake.
*   **External Libraries:**
    *   `wxWidgets 3.2+` (GUI, WebView).
    *   `Boost` (Asio, Beast, JSON, FileSystem, System).
    *   `liblzma` (LZMA2 Compression).
    *   `libusb-1.0` (Cross-platform USB).
    *   **Note:** Prefer C++23 standard library over Boost where reasonable, *except* for the forbidden types below.
*   **Forbidden Types:** You must **NOT** use `std::optional`, `std::expected`, nor `std::any`. Use `boost::optional` or error codes/exceptions.
*   **Security:** All internal string literals (commands, keys) must be obfuscated at compile-time using a `consteval` XOR cipher macro (e.g., `OBF("string")`).
## 4. Hardware Abstraction Layer (HAL) Requirements
You must implement a unified `Cognitive::Device` interface. The low-level behavior must align with the following specific driver protocols:
*   **Bluetooth (`BTDevice`):**
    *   **Do NOT** use SimpleBLE or generic wrappers. You must use **Native Host OS APIs**.
    *   *Windows:* WinSock for Classic (RFCOMM/SPP); WinRT (`winrt::Windows::Devices::Bluetooth`) for BLE.
    *   *Linux:* BlueZ via DBus.
    *   *macOS:* IOBluetooth framework.
    *   Support **both** Classic (SPP) and LE (GATT) in a single class.
*   **USB (`USBDevice`):**
    *   *Windows:* Primary connection method must be **native Win32** (`CreateFile`, `WinUsb`). If native access fails, seamlessly fallback to `libusb`.
    *   *Non-Windows:* Use `libusb` as the primary interface.
    *   Logic must support bulk transfer and endpoint detection.
*   **Network (`LANDevice`):**
    *   Use `boost::asio`.
    *   Support both **Ethernet and WiFi** connections.
    *   Implement UDP Broadcast (Ports 9100/3001) for device discovery.
*   **Legacy Ports (`COMDevice` / `LPTDevice`):**
    *   Implement serial (`boost::asio::serial_port`) and parallel port communication with robust error handling.
## 5. Coding Standards & Output Format
*   **Zero Elision:** Generate **100% complete, immediately executable source code**. Never use placeholders (e.g., `// ...`, `/* rest of code */`), stubs, mocks, or simplified implementations.
*   **No Comments in Source:** Do **NOT** include comments in `.cpp` files. Remove pre-existing comments during porting.
*   **Documentation:** Provide multi-line documentation comments (`/** ... */`) **only** in `.hpp` header files.
*   **Error Handling:** If a dependency is missing or a task is impossible, output a specific `//TODO: [Description]` comment.
*   **Output Structure:**
    1.  **Header Generation:** Output all `.hpp` files first, sorted by dependency.
    2.  **Source Generation:** Output all `.cpp` files, implementing every method defined in the headers.
## 6. Implementation Roadmap
1.  **Infrastructure:** `CMakeLists.txt`, `Obfuscation.hpp`, `Compression.hpp` (LZMA2).
2.  **HAL:** `Device.hpp`, `USBDevice.cpp`, `BTDevice.cpp` (PIMPL idiom), `LANDevice.cpp`.
3.  **Business Logic:** Port `TestEngine.java` (Manufacturing tests), `PrinterHelper.java` (CPL generation), and `CPLParser.java` (Response parsing). Ensure Java synchronous waits (`Thread.sleep`) are converted to non-blocking C++ mechanisms to prevent UI freezing.
4.  **Networking:** `HttpServer.hpp` (Boost.Beast) for firmware/logs.
5.  **UI Bridge:** `WebBridge.cpp` (JSON-RPC binding C++ to JS).
6.  **UI Shell:** `MainFrame` (`wxFrame`) hosting `wxWebView`.
**Immediate Action:**
Begin by generating the necessary **Header Files (.hpp)** for the Core Application and Hardware Abstraction Layer. Ensure all classes mirror the functional requirements of `JAdmin` while adhering to the C++23 constraints defined above.
`````InitialCodebase
````CAdmin
This file is a merged representation of the entire codebase, combined into a single document by Repomix.
The content has been processed where comments have been removed, empty lines have been removed, content has been formatted for parsing in markdown style, security check has been disabled.
# File Summary
## Purpose
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
## File Format
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
a. A header with the file path (## File: path/to/file)
b. The full contents of the file in a code block
## Usage Guidelines
- This file should be treated as read-only. Any changes should be made to the
original repository files, not this packed version.
- When processing this file, use the file path to distinguish
between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
the same level of security as you would the original repository.
## Notes
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Code comments have been removed from supported file types
- Empty lines have been removed from all files
- Content has been formatted for parsing in markdown style
- Security check has been disabled - content may contain sensitive information
- Files are sorted by Git change count (files with more changes are at the bottom)
# Directory Structure
```
CAdmin/
Backend/
Application.cpp
Application.hpp
Base64.hpp
BTDevice.cpp
BTDevice.hpp
Compression.cpp
Compression.hpp
Configurator.cpp
Configurator.hpp
CPLParser.cpp
CPLParser.hpp
Debug.hpp
Device.cpp
Device.hpp
DeviceManager.cpp
DeviceManager.hpp
HttpClient.cpp
HttpClient.hpp
HttpServer.cpp
HttpServer.hpp
LANDevice.cpp
LANDevice.hpp
main.cpp
MainFrame.cpp
MainFrame.hpp
Obfuscation.cpp
Obfuscation.hpp
PrinterHelper.cpp
PrinterHelper.hpp
SerialDevice.cpp
SerialDevice.hpp
ShowcaseResource.cpp
ShowcaseResource.hpp
TestEngine.cpp
TestEngine.hpp
USBDevice.cpp
USBDevice.hpp
WebBridge.cpp
WebBridge.hpp
CAdmin.sln
CAdmin.vcxproj
CAdmin.vcxproj.filters
CAdmin.vcxproj.user
CMakeLists.txt
vcpkg.json
```
# Files
## File: CAdmin/Backend/Application.cpp
```cpp
#include "Application.hpp"
#include "MainFrame.hpp"
#include "DeviceManager.hpp"
#include "Configurator.hpp"
#include "Debug.hpp"
#include <wx/stdpaths.h>
#include <wx/filename.h>
#include <wx/log.h>
#include <thread>
#include <filesystem>
#include <iostream>
#ifdef _WIN32
#include <windows.h>
#endif
namespace Cognitive::App {
static Application* s_instance = nullptr;
Application::Application() {
s_instance = this;
}
Application::~Application() {
s_instance = nullptr;
}
Application* Application::GetInstance() {
return s_instance;
}
bool Application::OnInit() {
#ifdef _WIN32
if (AttachConsole(ATTACH_PARENT_PROCESS)) {
FILE* pCout;
freopen_s(&pCout, "CONOUT$", "w", stdout);
freopen_s(&pCout, "CONOUT$", "w", stderr);
std::cout.clear();
std::cerr.clear();
}
#endif
CADMIN_LOG_DEBUG("Application::OnInit() starting...");
if (!wxApp::OnInit()) {
CADMIN_LOG_ERROR("wxApp::OnInit() failed");
return false;
}
CADMIN_LOG_DEBUG("Initializing image handlers...");
wxInitAllImageHandlers();
SetAppName("CAdminCPP");
SetAppDisplayName("Cognitive LLC Printer Administrator");
SetVendorName("Cognitive LLC");
CADMIN_LOG_DEBUG("Parsing command line...");
parseCommandLine();
CADMIN_LOG_DEBUG("Initializing IO context...");
initializeIOContext();
CADMIN_LOG_DEBUG("Loading configuration...");
loadConfiguration();
CADMIN_LOG_DEBUG("Creating main frame...");
mainFrame_ = new MainFrame();
CADMIN_LOG_DEBUG("Showing main frame...");
mainFrame_->Show();
SetTopWindow(mainFrame_);
CADMIN_LOG_DEBUG("Starting device discovery...");
HAL::DeviceManager::instance().discoverAllAsync([](const std::vector<HAL::DeviceInfo>&) {
});
CADMIN_LOG_DEBUG("Application::OnInit() completed successfully");
return true;
}
int Application::OnExit() {
shutdownIOContext();
HAL::DeviceManager::instance().stopDiscovery();
HAL::DeviceManager::instance().disconnectAll();
return wxApp::OnExit();
}
void Application::OnUnhandledException() {
try {
throw;
} catch (const std::exception& e) {
wxLogError("Unhandled exception: %s", e.what());
} catch (...) {
wxLogError("Unknown unhandled exception");
}
}
bool Application::OnExceptionInMainLoop() {
try {
throw;
} catch (const std::exception& e) {
wxLogError("Exception in main loop: %s", e.what());
return true;
} catch (...) {
return false;
}
}
void Application::initializeIOContext() {
initializeIOThreadPool();
}
void Application::shutdownIOContext() {
shutdownIOThreadPool();
}
void Application::initializeIOThreadPool() {
ioThreadPoolRunning_ = true;
ioWork_ = std::make_unique<boost::asio::executor_work_guard<boost::asio::io_context::executor_type>>(
boost::asio::make_work_guard(ioContext_)
);
size_t numThreads = std::thread::hardware_concurrency();
if (numThreads == 0) numThreads = 4;
for (size_t i = 0; i < numThreads; ++i) {
ioThreads_.emplace_back([this]() {
while (ioThreadPoolRunning_) {
try {
ioContext_.run();
break;
} catch (const std::exception& e) {
wxLogError("IO thread exception: %s", e.what());
}
}
});
}
}
void Application::shutdownIOThreadPool() {
ioThreadPoolRunning_ = false;
ioWork_.reset();
ioContext_.stop();
for (auto& thread : ioThreads_) {
if (thread.joinable()) {
thread.join();
}
}
ioThreads_.clear();
}
boost::asio::io_context& Application::getIOContext() {
return ioContext_;
}
void Application::postToIOThread(std::function<void()> task) {
boost::asio::post(ioContext_, std::move(task));
}
void Application::postToMainThread(std::function<void()> task) {
wxTheApp->CallAfter(std::move(task));
}
void Application::loadConfiguration() {
wxString configDir = wxStandardPaths::Get().GetUserDataDir();
if (!wxDirExists(configDir)) {
wxFileName::Mkdir(configDir, wxS_DIR_DEFAULT, wxPATH_MKDIR_FULL);
}
std::string configPath = std::string(configDir.ToUTF8()) + "/config.json";
auto& config = Business::Configurator::global();
if (std::filesystem::exists(configPath)) {
config.load(configPath);
} else {
setDefaultConfiguration();
}
configFilePath_ = configPath;
}
void Application::saveConfiguration() {
if (!configFilePath_.empty()) {
Business::Configurator::global().save(configFilePath_);
}
}
void Application::setDefaultConfiguration() {
auto& config = Business::Configurator::global();
config.set("ui.theme", "modern");
config.set("ui.fontSize", "12");
config.set("ui.showStatusBar", "true");
config.set("ui.showToolbar", "true");
config.set("connection.timeout", "5000");
config.set("connection.retryCount", "3");
config.set("connection.autoReconnect", "true");
config.set("print.defaultDarkness", "50");
config.set("print.defaultSpeed", "4");
config.set("print.defaultMediaType", "continuous");
config.set("network.discoveryPort", "9100");
config.set("network.serverPort", "8080");
config.set("network.enableServer", "false");
config.set("logging.level", "info");
config.set("logging.maxFileSize", "10485760");
config.set("logging.maxFiles", "5");
}
void Application::parseCommandLine() {
}
std::string Application::getAppVersion() const {
return "1.0.0";
}
std::string Application::getAppDataPath() const {
return std::string(wxStandardPaths::Get().GetUserDataDir().ToUTF8());
}
std::string Application::getTempPath() const {
return std::string(wxStandardPaths::Get().GetTempDir().ToUTF8());
}
std::string Application::GetVersion() {
return "1.0.0";
}
std::string Application::GetBuildInfo() {
return "Built with C++23, wxWidgets 3.3, Boost 1.89";
}
void Application::LogInfo(const std::string& message) {
wxLogMessage("%s", message.c_str());
}
void Application::LogError(const std::string& message) {
wxLogError("%s", message.c_str());
}
void Application::LogDebug(const std::string& message) {
wxLogDebug("%s", message.c_str());
}
}
```
## File: CAdmin/Backend/Application.hpp
```
#pragma once
#include <atomic>
#include <boost/asio.hpp>
#include <functional>
#include <memory>
#include <thread>
#include <vector>
#include <wx/wx.h>
namespace Cognitive::App {
class MainFrame;
struct AppConfig {
std::string windowTitle = "CognitiveTPG Printer Administrator";
int windowWidth = 1200;
int windowHeight = 900;
bool startMaximized = false;
bool enableDevTools = false;
int ioThreadCount = 4;
std::string logLevel = "info";
std::string configPath;
};
class Application : public wxApp {
public:
Application();
~Application() override;
bool OnInit() override;
int OnExit() override;
void OnUnhandledException() override;
bool OnExceptionInMainLoop() override;
static Application* GetInstance();
MainFrame* GetMainFrame() const { return mainFrame_; }
const AppConfig& GetConfig() const { return config_; }
boost::asio::io_context& getIOContext();
void postToIOThread(std::function<void()> task);
void postToMainThread(std::function<void()> task);
void loadConfiguration();
void saveConfiguration();
std::string getAppVersion() const;
std::string getAppDataPath() const;
std::string getTempPath() const;
static void LogInfo(const std::string& message);
static void LogError(const std::string& message);
static void LogDebug(const std::string& message);
static std::string GetVersion();
static std::string GetBuildInfo();
private:
MainFrame* mainFrame_ = nullptr;
AppConfig config_;
std::string configFilePath_;
boost::asio::io_context ioContext_;
std::unique_ptr<boost::asio::executor_work_guard<boost::asio::io_context::executor_type>> ioWork_;
std::vector<std::thread> ioThreads_;
std::atomic<bool> ioThreadPoolRunning_{false};
void initializeIOContext();
void shutdownIOContext();
void initializeIOThreadPool();
void shutdownIOThreadPool();
void setDefaultConfiguration();
void parseCommandLine();
};
wxDECLARE_APP(Application);
}
```
## File: CAdmin/Backend/Base64.hpp
```
#pragma once
#include <array>
#include <string>
#include <vector>
#include <cstdint>
#include <cctype>
namespace Cognitive::Utilities {
class Base64 {
public:
[[nodiscard]] static std::string encode(const std::vector<uint8_t>& data) {
static constexpr const char* chars =
"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
std::string encoded;
encoded.reserve(((data.size() + 2) / 3) * 4);
int val = 0;
int valb = -6;
for (uint8_t c : data) {
val = (val << 8) + c;
valb += 8;
while (valb >= 0) {
encoded.push_back(chars[(val >> valb) & 0x3F]);
valb -= 6;
}
}
if (valb > -6) {
encoded.push_back(chars[((val << 8) >> (valb + 8)) & 0x3F]);
}
while (encoded.size() % 4) {
encoded.push_back('=');
}
return encoded;
}
[[nodiscard]] static std::string encode(const uint8_t* data, size_t length) {
return encode(std::vector<uint8_t>(data, data + length));
}
[[nodiscard]] static std::string encode(const std::string& str) {
return encode(std::vector<uint8_t>(str.begin(), str.end()));
}
[[nodiscard]] static std::vector<uint8_t> decode(const std::string& encoded) {
static constexpr const char* chars =
"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
static const auto makeTable = []() {
std::array<int, 256> table{};
table.fill(-1);
for (int i = 0; i < 64; ++i) {
table[static_cast<unsigned char>(chars[i])] = i;
}
return table;
};
static const auto table = makeTable();
std::vector<uint8_t> decoded;
decoded.reserve((encoded.size() * 3) / 4);
int val = 0;
int valb = -8;
for (char c : encoded) {
if (c == '=' || c == '\n' || c == '\r' || c == ' ') {
continue;
}
int idx = table[static_cast<unsigned char>(c)];
if (idx < 0) {
continue;
}
val = (val << 6) + idx;
valb += 6;
if (valb >= 0) {
decoded.push_back(static_cast<uint8_t>((val >> valb) & 0xFF));
valb -= 8;
}
}
return decoded;
}
[[nodiscard]] static std::string decodeToString(const std::string& encoded) {
auto data = decode(encoded);
return std::string(data.begin(), data.end());
}
[[nodiscard]] static bool isValidChar(char c) {
return std::isalnum(static_cast<unsigned char>(c)) || c == '+' || c == '/' || c == '=';
}
[[nodiscard]] static bool isValid(const std::string& str) {
size_t validChars = 0;
size_t paddingChars = 0;
bool inPadding = false;
for (char c : str) {
if (c == '\n' || c == '\r' || c == ' ') {
continue;
}
if (c == '=') {
inPadding = true;
paddingChars++;
if (paddingChars > 2) return false;
} else if (inPadding) {
return false;
} else if (!isValidChar(c)) {
return false;
} else {
validChars++;
}
}
return (validChars + paddingChars) % 4 == 0;
}
[[nodiscard]] static size_t decodedSize(const std::string& encoded) {
size_t len = 0;
size_t padding = 0;
for (char c : encoded) {
if (c == '=') {
padding++;
} else if (isValidChar(c)) {
len++;
}
}
return (len * 3) / 4 - padding;
}
};
}
```
## File: CAdmin/Backend/BTDevice.cpp
```cpp
#include "BTDevice.hpp"
#include <cstring>
#ifdef _WIN32
#include <winsock2.h>
#include <ws2bth.h>
#include <bluetoothapis.h>
#pragma comment(lib, "ws2_32.lib")
#pragma comment(lib, "bthprops.lib")
#elif defined(__APPLE__)
#include <unistd.h>
#else
#include <sys/socket.h>
#include <sys/time.h>
#include <bluetooth/bluetooth.h>
#include <bluetooth/rfcomm.h>
#include <bluetooth/hci.h>
#include <bluetooth/hci_lib.h>
#include <unistd.h>
#endif
namespace Cognitive::HAL {
struct BTDevice::Impl {
#ifdef _WIN32
SOCKET sock = INVALID_SOCKET;
bool wsaInitialized = false;
BTH_ADDR deviceAddress = 0;
#elif defined(__APPLE__)
int sock = -1;
#else
int sock = -1;
bdaddr_t deviceAddress;
#endif
std::string path;
std::string lastError;
bool isOpen = false;
uint8_t channel = 1;
BTProtocol protocol = BTProtocol::Classic;
std::vector<GATTCharacteristic> characteristics;
BTDeviceInfo deviceInfo;
BLENotifyCallback notifyCallback;
};
BTDevice::BTDevice() : pImpl_(std::make_unique<Impl>()) {
}
BTDevice::~BTDevice() {
close();
}
BTDevice::BTDevice(BTDevice&&) noexcept = default;
BTDevice& BTDevice::operator=(BTDevice&&) noexcept = default;
bool BTDevice::open(const std::string& path) {
pImpl_->path = path;
std::string address = path;
bool isBLE = false;
auto lePos = path.find("/LE");
if (lePos != std::string::npos) {
isBLE = true;
address = path.substr(0, lePos);
pImpl_->protocol = BTProtocol::BLE;
}
auto colonPos = address.rfind(':');
if (colonPos != std::string::npos && colonPos > 14) {
try {
pImpl_->channel = static_cast<uint8_t>(std::stoi(address.substr(colonPos + 1)));
address = address.substr(0, colonPos);
} catch (...) {
}
}
return openWithProtocol(address, isBLE ? BTProtocol::BLE : BTProtocol::Classic);
}
bool BTDevice::openWithProtocol(const std::string& address, BTProtocol protocol) {
pImpl_->protocol = protocol;
pImpl_->deviceInfo.address = address;
pImpl_->deviceInfo.protocol = protocol;
if (protocol == BTProtocol::BLE) {
#ifdef _WIN32
pImpl_->lastError = "BLE requires WinRT - not yet implemented";
return false;
#elif defined(__APPLE__)
pImpl_->lastError = "BLE not implemented for macOS";
return false;
#else
pImpl_->lastError = "BLE not implemented for Linux";
return false;
#endif
}
#ifdef _WIN32
WSADATA wsaData;
if (WSAStartup(MAKEWORD(2, 2), &wsaData) != 0) {
pImpl_->lastError = "WSAStartup failed";
return false;
}
pImpl_->wsaInitialized = true;
pImpl_->sock = socket(AF_BTH, SOCK_STREAM, BTHPROTO_RFCOMM);
if (pImpl_->sock == INVALID_SOCKET) {
pImpl_->lastError = "Failed to create Bluetooth socket: " + std::to_string(WSAGetLastError());
return false;
}
SOCKADDR_BTH btAddr{};
btAddr.addressFamily = AF_BTH;
btAddr.port = pImpl_->channel;
unsigned int bytes[6];
if (sscanf(address.c_str(), "%02x:%02x:%02x:%02x:%02x:%02x",
&bytes[5], &bytes[4], &bytes[3], &bytes[2], &bytes[1], &bytes[0]) != 6) {
pImpl_->lastError = "Invalid Bluetooth address format";
closesocket(pImpl_->sock);
pImpl_->sock = INVALID_SOCKET;
return false;
}
pImpl_->deviceAddress = 0;
for (int i = 0; i < 6; i++) {
pImpl_->deviceAddress |= (static_cast<BTH_ADDR>(bytes[i]) << (i * 8));
}
btAddr.btAddr = pImpl_->deviceAddress;
if (connect(pImpl_->sock, reinterpret_cast<sockaddr*>(&btAddr), sizeof(btAddr)) != 0) {
pImpl_->lastError = "Failed to connect: " + std::to_string(WSAGetLastError());
closesocket(pImpl_->sock);
pImpl_->sock = INVALID_SOCKET;
return false;
}
pImpl_->isOpen = true;
pImpl_->deviceInfo.connected = true;
return true;
#elif defined(__APPLE__)
pImpl_->lastError = "Classic Bluetooth not implemented for macOS";
return false;
#else
pImpl_->sock = socket(AF_BLUETOOTH, SOCK_STREAM, BTPROTO_RFCOMM);
if (pImpl_->sock < 0) {
pImpl_->lastError = "Failed to create Bluetooth socket";
return false;
}
struct sockaddr_rc addr{};
addr.rc_family = AF_BLUETOOTH;
addr.rc_channel = pImpl_->channel;
str2ba(address.c_str(), &addr.rc_bdaddr);
pImpl_->deviceAddress = addr.rc_bdaddr;
if (connect(pImpl_->sock, reinterpret_cast<sockaddr*>(&addr), sizeof(addr)) < 0) {
pImpl_->lastError = "Failed to connect to Bluetooth device";
::close(pImpl_->sock);
pImpl_->sock = -1;
return false;
}
pImpl_->isOpen = true;
pImpl_->deviceInfo.connected = true;
return true;
#endif
}
void BTDevice::close() {
if (!pImpl_->isOpen) return;
#ifdef _WIN32
if (pImpl_->sock != INVALID_SOCKET) {
closesocket(pImpl_->sock);
pImpl_->sock = INVALID_SOCKET;
}
if (pImpl_->wsaInitialized) {
WSACleanup();
pImpl_->wsaInitialized = false;
}
#elif defined(__APPLE__)
if (pImpl_->sock >= 0) {
::close(pImpl_->sock);
pImpl_->sock = -1;
}
#else
if (pImpl_->sock >= 0) {
::close(pImpl_->sock);
pImpl_->sock = -1;
}
#endif
pImpl_->isOpen = false;
pImpl_->deviceInfo.connected = false;
}
bool BTDevice::isOpen() const {
return pImpl_->isOpen;
}
bool BTDevice::write(std::span<const uint8_t> data) {
if (!pImpl_->isOpen) {
pImpl_->lastError = "Device not open";
return false;
}
#ifdef _WIN32
int sent = send(pImpl_->sock, reinterpret_cast<const char*>(data.data()),
static_cast<int>(data.size()), 0);
if (sent == SOCKET_ERROR) {
pImpl_->lastError = "send failed: " + std::to_string(WSAGetLastError());
return false;
}
return sent == static_cast<int>(data.size());
#else
ssize_t sent = ::write(pImpl_->sock, data.data(), data.size());
if (sent < 0) {
pImpl_->lastError = "write failed";
return false;
}
return sent == static_cast<ssize_t>(data.size());
#endif
}
std::vector<uint8_t> BTDevice::read(size_t maxBytes, std::chrono::milliseconds timeout) {
std::vector<uint8_t> buffer(maxBytes);
if (!pImpl_->isOpen) {
pImpl_->lastError = "Device not open";
return {};
}
#ifdef _WIN32
DWORD timeoutMs = static_cast<DWORD>(timeout.count());
setsockopt(pImpl_->sock, SOL_SOCKET, SO_RCVTIMEO,
reinterpret_cast<const char*>(&timeoutMs), sizeof(timeoutMs));
int received = recv(pImpl_->sock, reinterpret_cast<char*>(buffer.data()),
static_cast<int>(maxBytes), 0);
if (received > 0) {
buffer.resize(received);
return buffer;
}
return {};
#else
struct timeval tv;
tv.tv_sec = static_cast<time_t>(timeout.count() / 1000);
tv.tv_usec = static_cast<suseconds_t>((timeout.count() % 1000) * 1000);
setsockopt(pImpl_->sock, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv));
ssize_t received = ::read(pImpl_->sock, buffer.data(), maxBytes);
if (received > 0) {
buffer.resize(received);
return buffer;
}
return {};
#endif
}
std::string BTDevice::getPath() const {
return pImpl_->path;
}
std::string BTDevice::getDescription() const {
std::string desc = (pImpl_->protocol == BTProtocol::BLE) ? "Bluetooth LE Device" : "Bluetooth Device";
if (!pImpl_->deviceInfo.name.empty()) {
desc += " - " + pImpl_->deviceInfo.name;
}
return desc;
}
DeviceInfo BTDevice::getInfo() const {
DeviceInfo info;
info.id = pImpl_->deviceInfo.address;
info.path = pImpl_->path;
info.description = getDescription();
info.manufacturer = "Unknown";
info.serialNumber = "";
info.type = DeviceType::Bluetooth;
info.state = pImpl_->isOpen ? DeviceState::Connected : DeviceState::Disconnected;
return info;
}
// ==================== Bluetooth-Specific Methods ====================
BTProtocol BTDevice::getProtocol() const {
return pImpl_->protocol;
}
BTDeviceInfo BTDevice::getBTInfo() const {
return pImpl_->deviceInfo;
}
void BTDevice::setRFCOMMChannel(uint8_t channel) {
if (pImpl_->isOpen) {
pImpl_->lastError = "Cannot change channel while connected";
return;
}
pImpl_->channel = channel;
}
int BTDevice::getRSSI() const {
return pImpl_->deviceInfo.rssi;
}
std::vector<GATTCharacteristic> BTDevice::discoverCharacteristics() {
if (pImpl_->protocol != BTProtocol::BLE) {
pImpl_->lastError = "GATT services only available in BLE mode";
return {};
}
return pImpl_->characteristics;
}
bool BTDevice::writeCharacteristic(const GATTCharacteristic& characteristic,
std::span<const uint8_t> data,
bool withResponse) {
if (pImpl_->protocol != BTProtocol::BLE) {
pImpl_->lastError = "GATT write only available in BLE mode";
return false;
}
(void)characteristic;
(void)data;
(void)withResponse;
return false;
}
std::vector<uint8_t> BTDevice::readCharacteristic(const GATTCharacteristic& characteristic) {
if (pImpl_->protocol != BTProtocol::BLE) {
pImpl_->lastError = "GATT read only available in BLE mode";
return {};
}
(void)characteristic;
return {};
}
bool BTDevice::enableNotifications(const GATTCharacteristic& characteristic,
BLENotifyCallback callback) {
if (pImpl_->protocol != BTProtocol::BLE) {
pImpl_->lastError = "GATT notifications only available in BLE mode";
return false;
}
(void)characteristic;
pImpl_->notifyCallback = std::move(callback);
return false;
}
bool BTDevice::disableNotifications(const GATTCharacteristic& characteristic) {
if (pImpl_->protocol != BTProtocol::BLE) {
pImpl_->lastError = "GATT notifications only available in BLE mode";
return false;
}
(void)characteristic;
pImpl_->notifyCallback = nullptr;
return false;
}
std::vector<std::string> BTDevice::enumerate() {
std::vector<std::string> devices;
#ifdef _WIN32
BLUETOOTH_DEVICE_SEARCH_PARAMS searchParams{};
searchParams.dwSize = sizeof(BLUETOOTH_DEVICE_SEARCH_PARAMS);
searchParams.fReturnAuthenticated = TRUE;
searchParams.fReturnConnected = TRUE;
searchParams.fReturnRemembered = TRUE;
searchParams.fReturnUnknown = TRUE;
searchParams.fIssueInquiry = FALSE;
searchParams.cTimeoutMultiplier = 2;
BLUETOOTH_DEVICE_INFO deviceInfo{};
deviceInfo.dwSize = sizeof(BLUETOOTH_DEVICE_INFO);
HBLUETOOTH_DEVICE_FIND hFind = BluetoothFindFirstDevice(&searchParams, &deviceInfo);
if (hFind) {
do {
char addrStr[18];
snprintf(addrStr, sizeof(addrStr), "%02X:%02X:%02X:%02X:%02X:%02X",
static_cast<int>((deviceInfo.Address.ullLong >> 40) & 0xFF),
static_cast<int>((deviceInfo.Address.ullLong >> 32) & 0xFF),
static_cast<int>((deviceInfo.Address.ullLong >> 24) & 0xFF),
static_cast<int>((deviceInfo.Address.ullLong >> 16) & 0xFF),
static_cast<int>((deviceInfo.Address.ullLong >> 8) & 0xFF),
static_cast<int>(deviceInfo.Address.ullLong & 0xFF));
devices.push_back(addrStr);
} while (BluetoothFindNextDevice(hFind, &deviceInfo));
BluetoothFindDeviceClose(hFind);
}
#elif defined(__APPLE__)
#else
int deviceId = hci_get_route(nullptr);
if (deviceId >= 0) {
int sock = hci_open_dev(deviceId);
if (sock >= 0) {
inquiry_info* inquiryInfo = nullptr;
int maxRsp = 255;
int flags = IREQ_CACHE_FLUSH;
int numRsp = hci_inquiry(deviceId, 8, maxRsp, nullptr, &inquiryInfo, flags);
if (numRsp > 0 && inquiryInfo) {
for (int i = 0; i < numRsp; i++) {
char addrStr[18];
ba2str(&inquiryInfo[i].bdaddr, addrStr);
devices.push_back(addrStr);
}
free(inquiryInfo);
}
hci_close_dev(sock);
}
}
#endif
return devices;
}
std::vector<BTDeviceInfo> BTDevice::enumerateDetailed() {
std::vector<BTDeviceInfo> devices;
#ifdef _WIN32
BLUETOOTH_DEVICE_SEARCH_PARAMS searchParams{};
searchParams.dwSize = sizeof(BLUETOOTH_DEVICE_SEARCH_PARAMS);
searchParams.fReturnAuthenticated = TRUE;
searchParams.fReturnConnected = TRUE;
searchParams.fReturnRemembered = TRUE;
searchParams.fReturnUnknown = TRUE;
searchParams.fIssueInquiry = FALSE;
searchParams.cTimeoutMultiplier = 2;
BLUETOOTH_DEVICE_INFO deviceInfo{};
deviceInfo.dwSize = sizeof(BLUETOOTH_DEVICE_INFO);
HBLUETOOTH_DEVICE_FIND hFind = BluetoothFindFirstDevice(&searchParams, &deviceInfo);
if (hFind) {
do {
BTDeviceInfo info;
char addrStr[18];
snprintf(addrStr, sizeof(addrStr), "%02X:%02X:%02X:%02X:%02X:%02X",
static_cast<int>((deviceInfo.Address.ullLong >> 40) & 0xFF),
static_cast<int>((deviceInfo.Address.ullLong >> 32) & 0xFF),
static_cast<int>((deviceInfo.Address.ullLong >> 24) & 0xFF),
static_cast<int>((deviceInfo.Address.ullLong >> 16) & 0xFF),
static_cast<int>((deviceInfo.Address.ullLong >> 8) & 0xFF),
static_cast<int>(deviceInfo.Address.ullLong & 0xFF));
info.address = addrStr;
char nameBuf[256];
WideCharToMultiByte(CP_UTF8, 0, deviceInfo.szName, -1, nameBuf, sizeof(nameBuf), nullptr, nullptr);
info.name = nameBuf;
info.protocol = BTProtocol::Classic;
info.paired = deviceInfo.fAuthenticated;
info.connected = deviceInfo.fConnected;
info.rssi = 0;
devices.push_back(info);
} while (BluetoothFindNextDevice(hFind, &deviceInfo));
BluetoothFindDeviceClose(hFind);
}
#elif defined(__APPLE__)
#else
int deviceId = hci_get_route(nullptr);
if (deviceId >= 0) {
int sock = hci_open_dev(deviceId);
if (sock >= 0) {
inquiry_info* inquiryInfo = nullptr;
int maxRsp = 255;
int flags = IREQ_CACHE_FLUSH;
int numRsp = hci_inquiry(deviceId, 8, maxRsp, nullptr, &inquiryInfo, flags);
if (numRsp > 0 && inquiryInfo) {
for (int i = 0; i < numRsp; i++) {
BTDeviceInfo info;
char addrStr[18];
ba2str(&inquiryInfo[i].bdaddr, addrStr);
info.address = addrStr;
char name[248] = {0};
if (hci_read_remote_name(sock, &inquiryInfo[i].bdaddr, sizeof(name), name, 0) >= 0) {
info.name = name;
}
info.protocol = BTProtocol::Classic;
info.rssi = 0;
info.paired = false;
info.connected = false;
devices.push_back(info);
}
free(inquiryInfo);
}
hci_close_dev(sock);
}
}
#endif
return devices;
}
bool BTDevice::startDiscovery(std::chrono::seconds timeout,
std::function<void(const BTDeviceInfo&)> callback) {
if (!callback) {
return false;
}
(void)timeout;
auto devices = enumerateDetailed();
for (const auto& dev : devices) {
callback(dev);
}
return !devices.empty();
}
void BTDevice::stopDiscovery() {
}
}
```
## File: CAdmin/Backend/BTDevice.hpp
```
#pragma once
#include "Device.hpp"
#include <memory>
namespace Cognitive::HAL {
enum class BTProtocol {
Classic,
BLE
};
struct BTDeviceInfo {
std::string address;
std::string name;
BTProtocol protocol;
int rssi;
bool paired;
bool connected;
BTDeviceInfo() : protocol(BTProtocol::Classic), rssi(0), paired(false), connected(false) {}
};
struct GATTCharacteristic {
std::string uuid;
std::string serviceUuid;
uint16_t handle;
bool canRead;
bool canWrite;
bool canNotify;
GATTCharacteristic() : handle(0), canRead(false), canWrite(false), canNotify(false) {}
};
using BLENotifyCallback = std::function<void(const std::vector<uint8_t>& data)>;
class BTDevice : public Device {
public:
BTDevice();
~BTDevice() override;
BTDevice(const BTDevice&) = delete;
BTDevice& operator=(const BTDevice&) = delete;
BTDevice(BTDevice&&) noexcept;
BTDevice& operator=(BTDevice&&) noexcept;
bool open(const std::string& path) override;
void close() override;
[[nodiscard]] bool isOpen() const override;
bool write(std::span<const uint8_t> data) override;
std::vector<uint8_t> read(size_t maxBytes, std::chrono::milliseconds timeout) override;
[[nodiscard]] DeviceType getType() const override { return DeviceType::Bluetooth; }
[[nodiscard]] std::string getPath() const override;
[[nodiscard]] std::string getDescription() const override;
[[nodiscard]] DeviceInfo getInfo() const override;
static std::vector<std::string> enumerate();
static std::vector<BTDeviceInfo> enumerateDetailed();
static bool startDiscovery(std::chrono::seconds timeout,
std::function<void(const BTDeviceInfo&)> callback);
static void stopDiscovery();
bool openWithProtocol(const std::string& address, BTProtocol protocol);
[[nodiscard]] BTProtocol getProtocol() const;
[[nodiscard]] BTDeviceInfo getBTInfo() const;
std::vector<GATTCharacteristic> discoverCharacteristics();
bool writeCharacteristic(const GATTCharacteristic& characteristic,
std::span<const uint8_t> data,
bool withResponse = true);
std::vector<uint8_t> readCharacteristic(const GATTCharacteristic& characteristic);
bool enableNotifications(const GATTCharacteristic& characteristic,
BLENotifyCallback callback);
bool disableNotifications(const GATTCharacteristic& characteristic);
void setRFCOMMChannel(uint8_t channel);
[[nodiscard]] int getRSSI() const;
private:
struct Impl;
std::unique_ptr<Impl> pImpl_;
};
}
```
## File: CAdmin/Backend/Compression.cpp
```cpp
#include "Compression.hpp"
#include <cstring>
#include <lzma.h>
#include <stdexcept>
namespace Cognitive::Utilities {
std::vector<uint8_t> Compression::compress(std::span<const uint8_t> input, int level) {
if (input.empty()) return {};
if (level < 0) level = 0;
if (level > 9) level = 9;
lzma_stream strm = LZMA_STREAM_INIT;
lzma_ret ret = lzma_easy_encoder(&strm, static_cast<uint32_t>(level), LZMA_CHECK_CRC64);
if (ret != LZMA_OK) {
throw std::runtime_error("LZMA encoder initialization failed: " + getLzmaErrorString(ret));
}
std::vector<uint8_t> output;
output.resize(estimateCompressedSize(input.size()));
strm.next_in = input.data();
strm.avail_in = input.size();
strm.next_out = output.data();
strm.avail_out = output.size();
while (true) {
ret = lzma_code(&strm, strm.avail_in == 0 ? LZMA_FINISH : LZMA_RUN);
if (ret == LZMA_STREAM_END) {
break;
}
if (ret != LZMA_OK) {
lzma_end(&strm);
throw std::runtime_error("LZMA compression failed: " + getLzmaErrorString(ret));
}
if (strm.avail_out == 0) {
size_t oldSize = output.size();
output.resize(oldSize * 2);
strm.next_out = output.data() + oldSize;
strm.avail_out = oldSize;
}
}
output.resize(strm.total_out);
lzma_end(&strm);
return output;
}
std::vector<uint8_t> Compression::decompress(std::span<const uint8_t> input) {
if (input.empty()) return {};
lzma_stream strm = LZMA_STREAM_INIT;
lzma_ret ret = lzma_stream_decoder(&strm, UINT64_MAX, LZMA_CONCATENATED);
if (ret != LZMA_OK) {
throw std::runtime_error("LZMA decoder initialization failed: " + getLzmaErrorString(ret));
}
std::vector<uint8_t> output;
size_t chunkSize = std::max(input.size() * 4, static_cast<size_t>(4096));
output.resize(chunkSize);
strm.next_in = input.data();
strm.avail_in = input.size();
strm.next_out = output.data();
strm.avail_out = output.size();
while (true) {
ret = lzma_code(&strm, LZMA_RUN);
if (ret == LZMA_STREAM_END) {
break;
}
if (ret != LZMA_OK) {
lzma_end(&strm);
throw std::runtime_error("LZMA decompression failed: " + getLzmaErrorString(ret));
}
if (strm.avail_out == 0) {
size_t oldSize = output.size();
size_t newSize = oldSize + chunkSize;
if (newSize > 1024 * 1024 * 1024) {
lzma_end(&strm);
throw std::runtime_error("Decompressed data exceeds size limit");
}
output.resize(newSize);
strm.next_out = output.data() + oldSize;
strm.avail_out = chunkSize;
}
if (strm.avail_in == 0) {
ret = lzma_code(&strm, LZMA_FINISH);
if (ret == LZMA_STREAM_END) break;
if (ret != LZMA_OK) {
lzma_end(&strm);
throw std::runtime_error("LZMA finalization failed: " + getLzmaErrorString(ret));
}
}
}
output.resize(strm.total_out);
lzma_end(&strm);
return output;
}
std::vector<uint8_t> Compression::decompress(std::span<const uint8_t> input, size_t expectedSize) {
if (input.empty()) return {};
lzma_stream strm = LZMA_STREAM_INIT;
lzma_ret ret = lzma_stream_decoder(&strm, UINT64_MAX, LZMA_CONCATENATED);
if (ret != LZMA_OK) {
throw std::runtime_error("LZMA decoder initialization failed: " + getLzmaErrorString(ret));
}
std::vector<uint8_t> output(expectedSize);
strm.next_in = input.data();
strm.avail_in = input.size();
strm.next_out = output.data();
strm.avail_out = output.size();
ret = lzma_code(&strm, LZMA_FINISH);
if (ret != LZMA_STREAM_END) {
lzma_end(&strm);
throw std::runtime_error("LZMA decompression failed: " + getLzmaErrorString(ret));
}
if (strm.total_out != expectedSize) {
lzma_end(&strm);
throw std::runtime_error("Decompressed size mismatch");
}
lzma_end(&strm);
return output;
}
size_t Compression::estimateCompressedSize(size_t inputSize) {
return lzma_stream_buffer_bound(inputSize);
}
bool Compression::isCompressed(std::span<const uint8_t> data) {
if (data.size() < 6) return false;
if (data[0] == 0xFD && data[1] == '7' && data[2] == 'z' &&
data[3] == 'X' && data[4] == 'Z' && data[5] == 0x00) {
return true;
}
if ((data[0] & 0xE0) == 0x00 || (data[0] & 0xE0) == 0x40) {
return true;
}
return false;
}
std::string Compression::getLzmaErrorString(int errorCode) {
switch (static_cast<lzma_ret>(errorCode)) {
case LZMA_OK: return "OK";
case LZMA_STREAM_END: return "Stream end";
case LZMA_NO_CHECK: return "No integrity check";
case LZMA_UNSUPPORTED_CHECK: return "Unsupported integrity check";
case LZMA_GET_CHECK: return "Get integrity check";
case LZMA_MEM_ERROR: return "Memory allocation failed";
case LZMA_MEMLIMIT_ERROR: return "Memory usage limit exceeded";
case LZMA_FORMAT_ERROR: return "File format not recognized";
case LZMA_OPTIONS_ERROR: return "Invalid options";
case LZMA_DATA_ERROR: return "Data is corrupt";
case LZMA_BUF_ERROR: return "No progress possible";
case LZMA_PROG_ERROR: return "Programming error";
default: return "Unknown error: " + std::to_string(errorCode);
}
}
CompressionInfo Compression::getInfo(std::span<const uint8_t> compressedData) {
CompressionInfo info{};
info.compressedSize = compressedData.size();
info.isValid = isCompressed(compressedData);
if (info.isValid) {
info.originalSize = compressedData.size() * 3;
info.algorithm = "LZMA2";
}
return info;
}
std::string Compression::getLibraryVersion() {
return lzma_version_string();
}
struct Compression::CompressStream::Impl {
lzma_stream strm = LZMA_STREAM_INIT;
int level = 6;
bool initialized = false;
~Impl() {
if (initialized) {
lzma_end(&strm);
}
}
};
Compression::CompressStream::CompressStream(int level) : pImpl_(std::make_unique<Impl>()) {
pImpl_->level = level;
lzma_ret ret = lzma_easy_encoder(&pImpl_->strm, static_cast<uint32_t>(level), LZMA_CHECK_CRC64);
pImpl_->initialized = (ret == LZMA_OK);
}
Compression::CompressStream::~CompressStream() = default;
std::vector<uint8_t> Compression::CompressStream::process(std::span<const uint8_t> input) {
if (!pImpl_->initialized || input.empty()) return {};
std::vector<uint8_t> output(estimateCompressedSize(input.size()));
pImpl_->strm.next_in = input.data();
pImpl_->strm.avail_in = input.size();
pImpl_->strm.next_out = output.data();
pImpl_->strm.avail_out = output.size();
lzma_code(&pImpl_->strm, LZMA_RUN);
output.resize(output.size() - pImpl_->strm.avail_out);
return output;
}
std::vector<uint8_t> Compression::CompressStream::finish() {
if (!pImpl_->initialized) return {};
std::vector<uint8_t> output(4096);
pImpl_->strm.next_in = nullptr;
pImpl_->strm.avail_in = 0;
pImpl_->strm.next_out = output.data();
pImpl_->strm.avail_out = output.size();
lzma_ret ret = lzma_code(&pImpl_->strm, LZMA_FINISH);
if (ret == LZMA_STREAM_END || ret == LZMA_OK) {
output.resize(output.size() - pImpl_->strm.avail_out);
return output;
}
return {};
}
void Compression::CompressStream::reset() {
if (pImpl_->initialized) {
lzma_end(&pImpl_->strm);
}
pImpl_->strm = LZMA_STREAM_INIT;
lzma_ret ret = lzma_easy_encoder(&pImpl_->strm, static_cast<uint32_t>(pImpl_->level), LZMA_CHECK_CRC64);
pImpl_->initialized = (ret == LZMA_OK);
}
struct Compression::DecompressStream::Impl {
lzma_stream strm = LZMA_STREAM_INIT;
bool initialized = false;
~Impl() {
if (initialized) {
lzma_end(&strm);
}
}
};
Compression::DecompressStream::DecompressStream() : pImpl_(std::make_unique<Impl>()) {
lzma_ret ret = lzma_stream_decoder(&pImpl_->strm, UINT64_MAX, LZMA_CONCATENATED);
pImpl_->initialized = (ret == LZMA_OK);
}
Compression::DecompressStream::~DecompressStream() = default;
std::vector<uint8_t> Compression::DecompressStream::process(std::span<const uint8_t> input) {
if (!pImpl_->initialized || input.empty()) return {};
std::vector<uint8_t> output(input.size() * 4);
pImpl_->strm.next_in = input.data();
pImpl_->strm.avail_in = input.size();
pImpl_->strm.next_out = output.data();
pImpl_->strm.avail_out = output.size();
lzma_code(&pImpl_->strm, LZMA_RUN);
output.resize(output.size() - pImpl_->strm.avail_out);
return output;
}
std::vector<uint8_t> Compression::DecompressStream::finish() {
if (!pImpl_->initialized) return {};
std::vector<uint8_t> output(4096);
pImpl_->strm.next_in = nullptr;
pImpl_->strm.avail_in = 0;
pImpl_->strm.next_out = output.data();
pImpl_->strm.avail_out = output.size();
lzma_ret ret = lzma_code(&pImpl_->strm, LZMA_FINISH);
if (ret == LZMA_STREAM_END || ret == LZMA_OK) {
output.resize(output.size() - pImpl_->strm.avail_out);
return output;
}
return {};
}
void Compression::DecompressStream::reset() {
if (pImpl_->initialized) {
lzma_end(&pImpl_->strm);
}
pImpl_->strm = LZMA_STREAM_INIT;
lzma_ret ret = lzma_stream_decoder(&pImpl_->strm, UINT64_MAX, LZMA_CONCATENATED);
pImpl_->initialized = (ret == LZMA_OK);
}
}
```
## File: CAdmin/Backend/Compression.hpp
```
#pragma once
#include <vector>
#include <span>
#include <cstdint>
#include <string>
#include <memory>
namespace Cognitive::Utilities {
enum class CompressionLevel {
Fast = 1,
Default = 6,
Best = 9
};
struct CompressionResult {
std::vector<uint8_t> data;
size_t originalSize = 0;
size_t compressedSize = 0;
bool success = false;
std::string error;
[[nodiscard]] double ratio() const {
return originalSize > 0 ? static_cast<double>(compressedSize) / originalSize : 0.0;
}
[[nodiscard]] double savings() const {
return originalSize > 0 ? (1.0 - ratio()) * 100.0 : 0.0;
}
};
struct CompressionInfo {
size_t originalSize = 0;
size_t compressedSize = 0;
std::string algorithm;
bool isValid = false;
};
class Compression {
public:
static std::vector<uint8_t> compress(std::span<const uint8_t> input, int level = 6);
static CompressionResult compressSafe(std::span<const uint8_t> input, int level = 6);
static std::vector<uint8_t> compressString(const std::string& input, int level = 6);
static std::vector<uint8_t> decompress(std::span<const uint8_t> input);
static std::vector<uint8_t> decompress(std::span<const uint8_t> input, size_t expectedSize);
static CompressionResult decompressSafe(std::span<const uint8_t> input);
static std::string decompressString(std::span<const uint8_t> input);
static bool compressFile(const std::string& inputPath, const std::string& outputPath,
int level = 6);
static bool decompressFile(const std::string& inputPath, const std::string& outputPath);
static bool compressFileInPlace(const std::string& filePath, int level = 6);
static bool decompressFileInPlace(const std::string& filePath);
class CompressStream {
public:
explicit CompressStream(int level = 6);
~CompressStream();
CompressStream(const CompressStream&) = delete;
CompressStream& operator=(const CompressStream&) = delete;
std::vector<uint8_t> process(std::span<const uint8_t> input);
std::vector<uint8_t> finish();
void reset();
private:
struct Impl;
std::unique_ptr<Impl> pImpl_;
};
class DecompressStream {
public:
DecompressStream();
~DecompressStream();
DecompressStream(const DecompressStream&) = delete;
DecompressStream& operator=(const DecompressStream&) = delete;
std::vector<uint8_t> process(std::span<const uint8_t> input);
std::vector<uint8_t> finish();
void reset();
private:
struct Impl;
std::unique_ptr<Impl> pImpl_;
};
static CompressionInfo getInfo(std::span<const uint8_t> compressedData);
static size_t estimateCompressedSize(size_t inputSize);
static bool isCompressed(std::span<const uint8_t> data);
static std::string getLibraryVersion();
static std::string getLzmaErrorString(int errorCode);
};
}
```
## File: CAdmin/Backend/Configurator.cpp
```cpp
#include "Configurator.hpp"
#include <fstream>
#include <sstream>
#include <filesystem>
#include <boost/json.hpp>
namespace json = boost::json;
namespace fs = std::filesystem;
namespace Cognitive::Business {
std::string PrinterProfile::toJson() const {
json::object obj;
obj["name"] = name;
obj["modelNumber"] = modelNumber;
obj["connectionType"] = connectionType;
obj["connectionPath"] = connectionPath;
json::object settingsObj;
for (const auto& [key, value] : settings) {
settingsObj[key] = value;
}
obj["settings"] = settingsObj;
return json::serialize(obj);
}
bool PrinterProfile::fromJson(const std::string& jsonStr) {
try {
auto val = json::parse(jsonStr);
auto& obj = val.as_object();
name = obj.at("name").as_string().c_str();
modelNumber = obj.at("modelNumber").as_string().c_str();
connectionType = obj.at("connectionType").as_string().c_str();
connectionPath = obj.at("connectionPath").as_string().c_str();
if (obj.contains("settings")) {
auto& settingsObj = obj.at("settings").as_object();
for (const auto& [key, value] : settingsObj) {
settings[std::string(key)] = value.as_string().c_str();
}
}
return true;
} catch (...) {
return false;
}
}
Configurator::Configurator() = default;
Configurator::~Configurator() = default;
bool Configurator::load(const std::string& path) {
std::ifstream file(path);
if (!file) return false;
filePath_ = path;
std::stringstream buffer;
buffer << file.rdbuf();
return importFromJson(buffer.str());
}
bool Configurator::save(const std::string& path) {
std::string tmpPath = path + ".tmp";
{
std::ofstream file(tmpPath);
if (!file) return false;
file << exportToJson();
file.flush();
if (!file.good()) {
std::error_code ec;
fs::remove(tmpPath, ec);
return false;
}
}
std::error_code ec;
fs::rename(tmpPath, path, ec);
if (ec) {
fs::remove(tmpPath, ec);
return false;
}
filePath_ = path;
return true;
}
bool Configurator::save() {
if (filePath_.empty()) return false;
return save(filePath_);
}
bool Configurator::reload() {
if (filePath_.empty()) return false;
return load(filePath_);
}
std::string Configurator::get(const std::string& key, const std::string& defaultValue) const {
auto it = config_.find(key);
return it != config_.end() ? it->second : defaultValue;
}
int Configurator::getInt(const std::string& key, int defaultValue) const {
auto it = config_.find(key);
if (it == config_.end()) return defaultValue;
try {
return std::stoi(it->second);
} catch (...) {
return defaultValue;
}
}
bool Configurator::getBool(const std::string& key, bool defaultValue) const {
auto it = config_.find(key);
if (it == config_.end()) return defaultValue;
return it->second == "true" || it->second == "1" || it->second == "yes";
}
double Configurator::getDouble(const std::string& key, double defaultValue) const {
auto it = config_.find(key);
if (it == config_.end()) return defaultValue;
try {
return std::stod(it->second);
} catch (...) {
return defaultValue;
}
}
void Configurator::set(const std::string& key, const std::string& value) {
config_[key] = value;
notifyChange(key, value);
}
void Configurator::setInt(const std::string& key, int value) {
set(key, std::to_string(value));
}
void Configurator::setBool(const std::string& key, bool value) {
set(key, value ? "true" : "false");
}
void Configurator::setDouble(const std::string& key, double value) {
set(key, std::to_string(value));
}
bool Configurator::has(const std::string& key) const {
return config_.find(key) != config_.end();
}
void Configurator::remove(const std::string& key) {
config_.erase(key);
}
void Configurator::clear() {
config_.clear();
profiles_.clear();
}
std::vector<std::string> Configurator::getKeys() const {
std::vector<std::string> keys;
keys.reserve(config_.size());
for (const auto& [key, _] : config_) {
keys.push_back(key);
}
return keys;
}
std::vector<std::string> Configurator::getKeysWithPrefix(const std::string& prefix) const {
std::vector<std::string> keys;
for (const auto& [key, _] : config_) {
if (key.substr(0, prefix.size()) == prefix) {
keys.push_back(key);
}
}
return keys;
}
void Configurator::saveProfile(const PrinterProfile& profile) {
profiles_[profile.name] = profile;
}
PrinterProfile Configurator::getProfile(const std::string& name) const {
auto it = profiles_.find(name);
return it != profiles_.end() ? it->second : PrinterProfile{};
}
std::vector<std::string> Configurator::listProfiles() const {
std::vector<std::string> names;
names.reserve(profiles_.size());
for (const auto& [name, _] : profiles_) {
names.push_back(name);
}
return names;
}
void Configurator::deleteProfile(const std::string& name) {
profiles_.erase(name);
}
std::string Configurator::getDefaultProfile() const {
return get("defaultProfile", "");
}
void Configurator::setDefaultProfile(const std::string& name) {
set("defaultProfile", name);
}
size_t Configurator::registerChangeCallback(ConfigChangeCallback callback) {
size_t id = nextCallbackId_++;
changeCallbacks_[id] = std::move(callback);
return id;
}
void Configurator::unregisterChangeCallback(size_t callbackId) {
changeCallbacks_.erase(callbackId);
}
void Configurator::notifyChange(const std::string& key, const std::string& value) {
for (const auto& [_, callback] : changeCallbacks_) {
callback(key, value);
}
}
std::string Configurator::exportToJson() const {
json::object root;
json::object configObj;
for (const auto& [key, value] : config_) {
configObj[key] = value;
}
root["config"] = configObj;
json::object profilesObj;
for (const auto& [name, profile] : profiles_) {
profilesObj[name] = json::parse(profile.toJson());
}
root["profiles"] = profilesObj;
return json::serialize(root);
}
bool Configurator::importFromJson(const std::string& jsonStr) {
try {
auto val = json::parse(jsonStr);
auto& root = val.as_object();
config_.clear();
if (root.contains("config")) {
auto& configObj = root.at("config").as_object();
for (const auto& [key, value] : configObj) {
if (value.is_string()) {
config_[std::string(key)] = value.as_string().c_str();
} else {
config_[std::string(key)] = json::serialize(value);
}
}
}
profiles_.clear();
if (root.contains("profiles")) {
auto& profilesObj = root.at("profiles").as_object();
for (const auto& [name, value] : profilesObj) {
PrinterProfile profile;
if (profile.fromJson(json::serialize(value))) {
profiles_[std::string(name)] = profile;
}
}
}
return true;
} catch (...) {
return false;
}
}
Configurator& Configurator::global() {
static Configurator instance;
return instance;
}
}
```
## File: CAdmin/Backend/Configurator.hpp
```
#pragma once
#include <string>
#include <map>
#include <vector>
#include <functional>
namespace Cognitive::Business {
struct PrinterProfile {
std::string name;
std::string modelNumber;
std::string connectionType;
std::string connectionPath;
std::map<std::string, std::string> settings;
[[nodiscard]] std::string toJson() const;
bool fromJson(const std::string& json);
};
using ConfigChangeCallback = std::function<void(const std::string& key, const std::string& value)>;
class Configurator {
public:
Configurator();
~Configurator();
bool load(const std::string& path);
bool save(const std::string& path);
bool save();
bool reload();
[[nodiscard]] std::string getFilePath() const { return filePath_; }
[[nodiscard]] std::string get(const std::string& key, const std::string& defaultValue = "") const;
[[nodiscard]] int getInt(const std::string& key, int defaultValue = 0) const;
[[nodiscard]] bool getBool(const std::string& key, bool defaultValue = false) const;
[[nodiscard]] double getDouble(const std::string& key, double defaultValue = 0.0) const;
void set(const std::string& key, const std::string& value);
void setInt(const std::string& key, int value);
void setBool(const std::string& key, bool value);
void setDouble(const std::string& key, double value);
[[nodiscard]] bool has(const std::string& key) const;
void remove(const std::string& key);
void clear();
[[nodiscard]] std::vector<std::string> getKeys() const;
[[nodiscard]] std::vector<std::string> getKeysWithPrefix(const std::string& prefix) const;
void saveProfile(const PrinterProfile& profile);
[[nodiscard]] PrinterProfile getProfile(const std::string& name) const;
[[nodiscard]] std::vector<std::string> listProfiles() const;
void deleteProfile(const std::string& name);
[[nodiscard]] std::string getDefaultProfile() const;
void setDefaultProfile(const std::string& name);
size_t registerChangeCallback(ConfigChangeCallback callback);
void unregisterChangeCallback(size_t callbackId);
[[nodiscard]] std::string exportToJson() const;
bool importFromJson(const std::string& json);
static Configurator& global();
private:
std::map<std::string, std::string> config_;
std::map<std::string, PrinterProfile> profiles_;
std::map<size_t, ConfigChangeCallback> changeCallbacks_;
std::string filePath_;
size_t nextCallbackId_ = 0;
void notifyChange(const std::string& key, const std::string& value);
};
}
```
## File: CAdmin/Backend/CPLParser.cpp
```cpp
#include "CPLParser.hpp"
#include "Obfuscation.hpp"
#include <sstream>
#include <algorithm>
#include <cctype>
namespace Cognitive::Business {
std::string CPLParser::clean(const std::string& str) {
std::string result = str;
std::replace(result.begin(), result.end(), '\n', ' ');
std::replace(result.begin(), result.end(), '\r', ' ');
auto start = result.find_first_not_of(" \t");
if (start == std::string::npos) return "";
auto end = result.find_last_not_of(" \t");
return result.substr(start, end - start + 1);
}
std::string CPLParser::getMatch(const std::string& str, const std::string& pattern) {
try {
std::regex re(pattern);
std::smatch match;
if (std::regex_search(str, match, re)) {
return match[0].str();
}
} catch (...) {
}
return "";
}
// ==================== Command Parsing ====================
CPLCommandType CPLParser::getCommandType(const std::string& command) {
std::string upper = command;
std::transform(upper.begin(), upper.end(), upper.begin(), ::toupper);
upper = clean(upper);
if (upper.find("VARIABLE") != std::string::npos ||
(upper.length() > 1 && upper[0] == 'V' && upper[1] == ' ')) {
return CPLCommandType::Variable;
}
if (upper.find("!SHOW") != std::string::npos || upper.find("SHOW ") != std::string::npos) {
return CPLCommandType::Show;
}
if (upper.find("!QR") != std::string::npos || upper.find("!QS") != std::string::npos) {
return CPLCommandType::Query;
}
if (upper.find("!CAL") != std::string::npos || upper.find("INDEX") != std::string::npos) {
return CPLCommandType::Calibrate;
}
if (upper.find("!SET") != std::string::npos) {
return CPLCommandType::Set;
}
if (upper.find("!LOAD") != std::string::npos) {
return CPLCommandType::Load;
}
if (upper.find("!0 ") != std::string::npos || upper.find("TEXT") != std::string::npos ||
upper.find("BARCODE") != std::string::npos) {
return CPLCommandType::Label;
}
return CPLCommandType::Other;
}
std::string CPLParser::getVariableName(const std::string& command) {
std::string upper = command;
std::transform(upper.begin(), upper.end(), upper.begin(), ::toupper);
if (upper.find("VARIABLE") != std::string::npos ||
(upper.length() > 1 && upper[0] == 'V' && upper[1] == ' ')) {
size_t start = upper.find("VARIABLE");
if (start != std::string::npos) {
start = upper.find('E', start) + 1;
} else {
start = upper.find('V') + 1;
}
size_t end = upper.find('?');
if (end == std::string::npos) {
end = upper.length();
}
if (start < end) {
std::string name = upper.substr(start, end - start);
return clean(name);
}
}
return "";
}
CPLCommand CPLParser::parseCommand(const std::string& command) const {
CPLCommand cmd;
cmd.rawCommand = command;
cmd.type = getCommandType(command);
switch (cmd.type) {
case CPLCommandType::Variable:
cmd.name = getVariableName(command);
break;
case CPLCommandType::Show:
// Extract what's being shown
{
auto pos = command.find("SHOW");
if (pos != std::string::npos) {
cmd.name = clean(command.substr(pos + 4));
}
}
break;
default:
break;
}
return cmd;
}
std::vector<CPLCommand> CPLParser::parseCommands(const std::string& cpl) const {
std::vector<CPLCommand> commands;
std::istringstream stream(cpl);
std::string line;
while (std::getline(stream, line)) {
line = clean(line);
if (line.empty()) continue;
if (line[0] == ';' || line[0] == '#') continue;
CPLCommand cmd = parseCommand(line);
cmd.command = line;
commands.push_back(cmd);
}
return commands;
}
ValidationResult CPLParser::validate(const std::string& cpl) const {
ValidationResult result;
result.isValid = true;
std::istringstream stream(cpl);
std::string line;
int lineNumber = 0;
bool inLabel = false;
while (std::getline(stream, line)) {
lineNumber++;
std::string trimmed = clean(line);
if (trimmed.empty()) continue;
if (trimmed[0] == '!' && trimmed.length() > 1 && std::isdigit(trimmed[1])) {
if (inLabel) {
result.warnings.push_back("Line " + std::to_string(lineNumber) + ": Nested label start detected");
}
inLabel = true;
}
std::string upper = trimmed;
std::transform(upper.begin(), upper.end(), upper.begin(), ::toupper);
if (upper == "END") {
if (!inLabel) {
result.warnings.push_back("Line " + std::to_string(lineNumber) + ": END without label start");
}
inLabel = false;
}
if (upper.find("VARIABLE") != std::string::npos) {
if (upper.find("=") == std::string::npos && upper.find("?") == std::string::npos) {
size_t varPos = upper.find("VARIABLE");
size_t spaceAfter = upper.find(' ', varPos + 8);
if (spaceAfter == std::string::npos) {
result.errors.push_back("Line " + std::to_string(lineNumber) + ": VARIABLE command missing name/value");
result.isValid = false;
}
}
}
int quoteCount = std::count(trimmed.begin(), trimmed.end(), '"');
if (quoteCount % 2 != 0) {
result.errors.push_back("Line " + std::to_string(lineNumber) + ": Mismatched quotes");
result.isValid = false;
}
}
if (inLabel) {
result.errors.push_back("Unclosed label - missing END statement");
result.isValid = false;
}
return result;
}
std::string CPLParser::getResponseValue(const std::string& response, const std::string& command) {
std::string cleaned = clean(response);
std::string cmd = command;
std::transform(cmd.begin(), cmd.end(), cmd.begin(), ::toupper);
cmd = clean(cmd);
if (cleaned.find('=') != std::string::npos) {
if (cmd.find("VARIABLE") != std::string::npos || cmd.find("V ") != std::string::npos) {
std::string varName = getVariableName(cmd);
auto pos = cleaned.find(varName);
if (pos != std::string::npos) {
cleaned = cleaned.substr(pos);
}
}
auto eqPos = cleaned.find('=');
auto nlPos = cleaned.find('\n');
if (nlPos == std::string::npos) {
return clean(cleaned.substr(eqPos + 1));
} else {
return clean(cleaned.substr(eqPos + 1, nlPos - eqPos - 1));
}
}
if (cmd.find("INDEX") != std::string::npos || cmd.find("!CAL") != std::string::npos) {
auto pos = response.find('C');
if (pos != std::string::npos) {
return response.substr(pos);
}
}
return cleaned;
}
ResponsePattern CPLParser::getResponsePattern(const std::string& command) {
ResponsePattern pattern;
std::string cmd = command;
std::transform(cmd.begin(), cmd.end(), cmd.begin(), ::toupper);
cmd = clean(cmd);
if (cmd.find("VARIABLE") != std::string::npos || cmd.find("V ") != std::string::npos) {
if (cmd.find("TIME") != std::string::npos) {
pattern.startPattern = "(Sunday|Monday|Tuesday|Wednesday|Thursday|Friday|Saturday).*";
} else if (cmd.find("AUX_POWER") != std::string::npos) {
pattern.startPattern = ".*AUXPOWER.*";
} else if (cmd.find("BLUETOOTH DEVICENAME") != std::string::npos) {
pattern.startPattern = ".*BLUETOOTH DEVICENAME=.*";
} else if (cmd.find("BLUETOOTH BDADDR") != std::string::npos) {
pattern.startPattern = ".*BLUETOOTH BDADDR=.*";
} else if (cmd.find("INDEX") != std::string::npos) {
pattern.startPattern = ".*INDEX.*";
} else {
std::string varName = getVariableName(cmd);
pattern.startPattern = ".*" + varName + ".*";
}
}
else if (cmd.find("INDEX") != std::string::npos && cmd.find("CALIBRATE") != std::string::npos) {
pattern.startPattern = ".*C3[FP]";
}
else if (cmd.find("!CAL") != std::string::npos) {
pattern.startPattern = ".*C[012]3*[FP]";
}
else if (cmd.find("SHOW MODELNUMBER") != std::string::npos) {
pattern.startPattern = "Model Number.*";
}
else if (cmd.find("SHOW SERIALNUMBER") != std::string::npos) {
pattern.startPattern = ".*Serial Number.*";
}
else if (cmd.find("SHOW INCHCOUNT") != std::string::npos) {
pattern.startPattern = ".*Inches Printed.*";
}
else if (cmd.find("SHOW MAC") != std::string::npos) {
pattern.startPattern = ".*MAC.*";
}
else if (cmd.find("!QR") != std::string::npos) {
pattern.startPattern = ".*195-...-....*";
}
else if (cmd.find("!QS") != std::string::npos) {
pattern.startPattern = ".*[a-zA-Z]\\d{5}.*";
}
else if (cmd.find("!LS") != std::string::npos) {
pattern.startPattern = ".*,.*,.*,.*,.*,.*";
pattern.endPattern = ".*END-OF-LIST.*";
}
else if (cmd.find("!D") != std::string::npos) {
pattern.startPattern = "Success";
}
else if (cmd.find("SHOW") != std::string::npos && cmd.find("AD") != std::string::npos) {
pattern.startPattern = "(\\d=\\d{3}\\s*){8}.*";
}
else {
pattern.startPattern = ".*";
}
return pattern;
}
bool CPLParser::matchesPattern(const std::string& response, const std::string& pattern) {
try {
std::regex re(pattern, std::regex::icase);
return std::regex_search(response, re);
} catch (...) {
return false;
}
}
std::string CPLParser::parse(const std::string& cpl) const {
return substituteVariables(cpl);
}
std::string CPLParser::substituteVariables(const std::string& text) const {
std::string result = text;
for (const auto& [name, value] : variables_) {
std::string placeholder = "${" + name + "}";
size_t pos = 0;
while ((pos = result.find(placeholder, pos)) != std::string::npos) {
result.replace(pos, placeholder.length(), value);
pos += value.length();
}
}
return result;
}
void CPLParser::setVariable(const std::string& name, const std::string& value) {
variables_[name] = value;
}
std::string CPLParser::getVariable(const std::string& name) const {
auto it = variables_.find(name);
return it != variables_.end() ? it->second : "";
}
bool CPLParser::hasVariable(const std::string& name) const {
return variables_.find(name) != variables_.end();
}
void CPLParser::clearVariables() {
variables_.clear();
}
std::vector<std::string> CPLParser::getVariableNames() const {
std::vector<std::string> names;
names.reserve(variables_.size());
for (const auto& [name, _] : variables_) {
names.push_back(name);
}
return names;
}
// ==================== Label Generation ====================
std::string CPLParser::labelStart(int x, int y, int height, int quantity) {
std::ostringstream oss;
oss << OBF("!") << x << " " << y << " " << height << " " << quantity << "\n";
return oss.str();
}
std::string CPLParser::textElement(int font, int x, int y, const std::string& text, int rotation) {
std::ostringstream oss;
oss << OBF("TEXT ") << font << " " << rotation << " " << x << " " << y << " " << text << "\n";
return oss.str();
}
std::string CPLParser::barcodeElement(const std::string& type, int x, int y,
const std::string& data, int height) {
std::ostringstream oss;
oss << OBF("BARCODE ") << type << " 1 1 " << height << " " << x << " " << y << " " << data << "\n";
return oss.str();
}
std::string CPLParser::drawBox(int x, int y, int width, int height, int thickness) {
std::ostringstream oss;
oss << OBF("DRAW_BOX ") << x << " " << y << " " << width << " " << height << " " << thickness << "\n";
return oss.str();
}
std::string CPLParser::labelEnd() {
return OBF("END\n");
}
}
```
## File: CAdmin/Backend/CPLParser.hpp
```
#pragma once
#include <string>
#include <map>
#include <vector>
#include <regex>
namespace Cognitive::Business {
enum class CPLCommandType {
Variable,
Show,
Query,
Label,
Calibrate,
Set,
Load,
Other
};
struct CPLCommand {
CPLCommandType type;
std::string rawCommand;
std::string command;
std::string name;
std::string value;
std::vector<std::string> parameters;
};
struct ResponsePattern {
std::string startPattern;
std::string endPattern;
};
struct ValidationResult {
bool isValid = true;
std::vector<std::string> errors;
std::vector<std::string> warnings;
};
class CPLParser {
public:
CPLParser() = default;
static std::string clean(const std::string& str);
static std::string getMatch(const std::string& str, const std::string& pattern);
CPLCommand parseCommand(const std::string& command) const;
std::vector<CPLCommand> parseCommands(const std::string& cpl) const;
ValidationResult validate(const std::string& cpl) const;
static CPLCommandType getCommandType(const std::string& command);
static std::string getVariableName(const std::string& command);
static std::string getResponseValue(const std::string& response, const std::string& command);
static ResponsePattern getResponsePattern(const std::string& command);
static bool matchesPattern(const std::string& response, const std::string& pattern);
std::string parse(const std::string& cpl) const;
std::string substituteVariables(const std::string& text) const;
void setVariable(const std::string& name, const std::string& value);
[[nodiscard]] std::string getVariable(const std::string& name) const;
[[nodiscard]] bool hasVariable(const std::string& name) const;
void clearVariables();
[[nodiscard]] std::vector<std::string> getVariableNames() const;
static std::string labelStart(int x, int y, int height, int quantity = 1);
static std::string textElement(int font, int x, int y, const std::string& text, int rotation = 0);
static std::string barcodeElement(const std::string& type, int x, int y,
const std::string& data, int height = 50);
static std::string drawBox(int x, int y, int width, int height, int thickness = 1);
static std::string labelEnd();
private:
std::map<std::string, std::string> variables_;
};
}
```
## File: CAdmin/Backend/Debug.hpp
```
#pragma once
#include <iostream>
#include <sstream>
namespace Cognitive {
#ifndef CADMIN_DEBUG_LEVEL
#ifdef NDEBUG
#define CADMIN_DEBUG_LEVEL 0
#else
#define CADMIN_DEBUG_LEVEL 4
#endif
#endif
#define CADMIN_DEBUG_LOCATION __FILE__ << ":" << __LINE__
#if CADMIN_DEBUG_LEVEL >= 1
#define CADMIN_LOG_ERROR(msg) \
do { \
std::cerr << "[ERROR] " << msg << std::endl; \
} while (0)
#else
#define CADMIN_LOG_ERROR(msg) ((void)0)
#endif
#if CADMIN_DEBUG_LEVEL >= 2
#define CADMIN_LOG_WARN(msg) \
do { \
std::cerr << "[WARN] " << msg << std::endl; \
} while (0)
#else
#define CADMIN_LOG_WARN(msg) ((void)0)
#endif
#if CADMIN_DEBUG_LEVEL >= 3
#define CADMIN_LOG_INFO(msg) \
do { \
std::cerr << "[INFO] " << msg << std::endl; \
} while (0)
#else
#define CADMIN_LOG_INFO(msg) ((void)0)
#endif
#if CADMIN_DEBUG_LEVEL >= 4
#define CADMIN_LOG_DEBUG(msg) \
do { \
std::cerr << "[DEBUG] " << msg << std::endl; \
} while (0)
#define CADMIN_LOG_TRACE(msg) \
do { \
std::cerr << "[TRACE] " << CADMIN_DEBUG_LOCATION << " " << msg << std::endl; \
} while (0)
#else
#define CADMIN_LOG_DEBUG(msg) ((void)0)
#define CADMIN_LOG_TRACE(msg) ((void)0)
#endif
#if CADMIN_DEBUG_LEVEL >= 1
#define CADMIN_ASSERT(condition, msg) \
do { \
if (!(condition)) { \
std::cerr << "[ASSERT FAILED] " << CADMIN_DEBUG_LOCATION << ": " \
<< #condition << " - " << msg << std::endl; \
} \
} while (0)
#else
#define CADMIN_ASSERT(condition, msg) ((void)0)
#endif
}
```
## File: CAdmin/Backend/Device.cpp
```cpp
#include "Device.hpp"
#include <boost/json.hpp>
namespace json = boost::json;
namespace Cognitive::HAL {
std::string DeviceInfo::toJson() const {
json::object obj;
obj["id"] = id;
obj["path"] = path;
obj["description"] = description;
obj["manufacturer"] = manufacturer;
obj["serialNumber"] = serialNumber;
obj["type"] = deviceTypeToString(type);
obj["state"] = deviceStateToString(state);
return json::serialize(obj);
}
static DeviceInfo createDeviceInfo(const std::string& id, const std::string& path,
DeviceType type, const std::string& description) {
DeviceInfo info;
info.id = id;
info.path = path;
info.description = description;
info.type = type;
info.state = DeviceState::Disconnected;
return info;
}
}
```
## File: CAdmin/Backend/Device.hpp
```
#pragma once
#include <string>
#include <vector>
#include <span>
#include <chrono>
#include <cstdint>
#include <functional>
namespace Cognitive::HAL {
constexpr auto DEFAULT_READ_TIMEOUT = std::chrono::milliseconds(5000);
constexpr auto DEFAULT_WRITE_TIMEOUT = std::chrono::milliseconds(5000);
constexpr auto NETWORK_DISCOVERY_TIMEOUT = std::chrono::milliseconds(3000);
constexpr auto USB_DEFAULT_TIMEOUT = std::chrono::milliseconds(5000);
constexpr size_t DEVICE_READ_BUFFER_SIZE = 4096;
constexpr size_t MAX_FIRMWARE_SIZE = 64 * 1024 * 1024;
constexpr size_t MAX_OBJECT_SIZE = 10 * 1024 * 1024;
constexpr size_t MAX_CONFIG_SIZE = 1 * 1024 * 1024;
constexpr uint16_t PRINTER_PORT_RAW = 9100;
constexpr uint16_t PRINTER_PORT_RAW_ALT = 9101;
constexpr uint16_t PRINTER_PORT_LPR = 515;
constexpr uint16_t PRINTER_PORT_IPP = 631;
constexpr uint16_t PRINTER_PORT_SNMP = 161;
constexpr uint16_t PRINTER_PORT_MDNS = 5353;
constexpr uint16_t PRINTER_PORT_HTTP = 80;
constexpr uint16_t PRINTER_PORT_HTTPS = 443;
constexpr uint16_t CADMIN_WEBSOCKET_PORT = 3001;
enum class DeviceType {
USB,
Bluetooth,
Network,
Serial
};
enum class DeviceState {
Disconnected,
Connecting,
Connected,
Error
};
struct DeviceInfo {
std::string id;
std::string path;
std::string description;
std::string manufacturer;
std::string serialNumber;
DeviceType type;
DeviceState state;
DeviceInfo() : type(DeviceType::USB), state(DeviceState::Disconnected) {}
[[nodiscard]] std::string toJson() const;
};
using ReadCallback = std::function<void(const std::vector<uint8_t>&, bool success)>;
using StateCallback = std::function<void(DeviceState newState, const std::string& message)>;
class Device {
public:
virtual ~Device() = default;
virtual bool open(const std::string& path) = 0;
virtual void close() = 0;
[[nodiscard]] virtual bool isOpen() const = 0;
[[nodiscard]] virtual DeviceState getState() const { return isOpen() ? DeviceState::Connected : DeviceState::Disconnected; }
virtual bool write(std::span<const uint8_t> data) = 0;
virtual bool writeString(const std::string& str) {
return write(std::span<const uint8_t>(
reinterpret_cast<const uint8_t*>(str.data()), str.size()));
}
virtual std::vector<uint8_t> read(size_t maxBytes, std::chrono::milliseconds timeout) = 0;
virtual std::string readString(size_t maxBytes, std::chrono::milliseconds timeout) {
auto data = read(maxBytes, timeout);
return std::string(data.begin(), data.end());
}
virtual std::string sendCommand(const std::string& command, std::chrono::milliseconds timeout = std::chrono::milliseconds(5000)) {
if (!writeString(command)) return "";
return readString(4096, timeout);
}
/**
* @brief Sends command and waits for response (out parameter version)
* @param command Command string to send
* @param response Output response string
* @param timeout Response timeout
* @return true if command succeeded
*/
virtual bool sendCommand(const std::string& command, std::string& response, std::chrono::milliseconds timeout) {
if (!writeString(command)) return false;
response = readString(4096, timeout);
return !response.empty();
}
// ==================== Device Properties ====================
/**
* @brief Gets the device connection type
* @return DeviceType enumeration value
*/
[[nodiscard]] virtual DeviceType getType() const = 0;
/**
* @brief Gets the device path/address
* @return Device path string
*/
[[nodiscard]] virtual std::string getPath() const = 0;
/**
* @brief Gets a human-readable device description
* @return Description string
*/
[[nodiscard]] virtual std::string getDescription() const = 0;
/**
* @brief Gets complete device information
* @return DeviceInfo structure
*/
[[nodiscard]] virtual DeviceInfo getInfo() const {
DeviceInfo info;
info.path = getPath();
info.description = getDescription();
info.type = getType();
info.state = getState();
return info;
}
/**
* @brief Sets callback for state changes
* @param callback Function to call on state change
*/
virtual void setStateCallback(StateCallback callback) { stateCallback_ = std::move(callback); }
/**
* @brief Gets the last error message
* @return Last error string (empty if no error)
*/
[[nodiscard]] virtual std::string getLastError() const { return lastError_; }
protected:
std::string path_;
std::string lastError_;
bool isOpen_ = false;
StateCallback stateCallback_;
/**
* @brief Notifies listeners of state change
* @param state New state
* @param message Optional message
*/
void notifyStateChange(DeviceState state, const std::string& message = "") {
if (stateCallback_) {
stateCallback_(state, message);
}
}
};
/**
* @brief Converts DeviceType to string
*/
inline std::string deviceTypeToString(DeviceType type) {
switch (type) {
case DeviceType::USB: return "USB";
case DeviceType::Bluetooth: return "Bluetooth";
case DeviceType::Network: return "Network";
case DeviceType::Serial: return "Serial";
default: return "Unknown";
}
}
inline std::string deviceStateToString(DeviceState state) {
switch (state) {
case DeviceState::Disconnected: return "Disconnected";
case DeviceState::Connecting: return "Connecting";
case DeviceState::Connected: return "Connected";
case DeviceState::Error: return "Error";
default: return "Unknown";
}
}
}
```
## File: CAdmin/Backend/DeviceManager.cpp
```cpp
#include "DeviceManager.hpp"
#include "USBDevice.hpp"
#include "BTDevice.hpp"
#include "LANDevice.hpp"
#include "SerialDevice.hpp"
#include <algorithm>
#include <thread>
#include <mutex>
namespace Cognitive::HAL {
DeviceManager::DeviceManager() = default;
DeviceManager::~DeviceManager() {
stopDiscovery();
disconnectAll();
}
DeviceManager& DeviceManager::instance() {
static DeviceManager inst;
return inst;
}
std::shared_ptr<Device> DeviceManager::getDevice(const std::string& id) {
std::lock_guard<std::mutex> lock(mutex_);
auto it = devices_.find(id);
return it != devices_.end() ? it->second : nullptr;
}
void DeviceManager::addDevice(const std::string& id, std::shared_ptr<Device> device) {
std::lock_guard<std::mutex> lock(mutex_);
devices_[id] = device;
for (const auto& [cbId, callback] : deviceCallbacks_) {
callback(id, DeviceEvent::Added);
}
}
void DeviceManager::removeDevice(const std::string& id) {
std::shared_ptr<Device> device;
{
std::lock_guard<std::mutex> lock(mutex_);
auto it = devices_.find(id);
if (it != devices_.end()) {
device = it->second;
devices_.erase(it);
}
}
if (device) {
device->close();
for (const auto& [cbId, callback] : deviceCallbacks_) {
callback(id, DeviceEvent::Removed);
}
}
}
std::vector<std::string> DeviceManager::listDevices() const {
std::lock_guard<std::mutex> lock(mutex_);
std::vector<std::string> list;
list.reserve(devices_.size());
for (const auto& [id, _] : devices_) {
list.push_back(id);
}
return list;
}
std::vector<std::string> DeviceManager::listDevicesByType(DeviceType type) const {
std::lock_guard<std::mutex> lock(mutex_);
std::vector<std::string> list;
for (const auto& [id, device] : devices_) {
if (device->getType() == type) {
list.push_back(id);
}
}
return list;
}
size_t DeviceManager::getDeviceCount() const {
std::lock_guard<std::mutex> lock(mutex_);
return devices_.size();
}
bool DeviceManager::hasDevice(const std::string& id) const {
std::lock_guard<std::mutex> lock(mutex_);
return devices_.find(id) != devices_.end();
}
std::vector<DeviceInfo> DeviceManager::getAllDeviceInfo() const {
std::lock_guard<std::mutex> lock(mutex_);
std::vector<DeviceInfo> infos;
infos.reserve(devices_.size());
for (const auto& [id, device] : devices_) {
DeviceInfo info;
info.id = id;
info.path = device->getPath();
info.description = device->getDescription();
info.type = device->getType();
info.state = device->isOpen() ? DeviceState::Connected : DeviceState::Disconnected;
infos.push_back(info);
}
return infos;
}
void DeviceManager::clearAll() {
std::lock_guard<std::mutex> lock(mutex_);
for (auto& [id, device] : devices_) {
device->close();
}
devices_.clear();
}
bool DeviceManager::openDevice(const std::string& id) {
return connect(id);
}
void DeviceManager::closeDevice(const std::string& id) {
disconnect(id);
}
void DeviceManager::closeAllDevices() {
disconnectAll();
}
std::shared_ptr<Device> DeviceManager::getFirstAvailable(DeviceType type) {
std::lock_guard<std::mutex> lock(mutex_);
for (const auto& [id, device] : devices_) {
if (device->getType() == type && !device->isOpen()) {
return device;
}
}
return nullptr;
}
void DeviceManager::discoverAll(const DeviceFilter& filter, std::chrono::seconds timeout) {
auto deadline = std::chrono::steady_clock::now() + timeout;
if (filter.includeUSB && std::chrono::steady_clock::now() < deadline) {
discoverUSB();
}
if (filter.includeBluetooth && std::chrono::steady_clock::now() < deadline) {
discoverBluetooth();
}
if (filter.includeNetwork && std::chrono::steady_clock::now() < deadline) {
discoverNetwork();
}
if (filter.includeSerial && std::chrono::steady_clock::now() < deadline) {
discoverSerial();
}
}
void DeviceManager::discoverUSB() {
auto devices = USBDevice::enumerate();
for (const auto& path : devices) {
std::string id = "USB:" + path;
if (!hasDevice(id)) {
auto dev = std::make_shared<USBDevice>();
addDevice(id, dev);
}
}
}
void DeviceManager::discoverBluetooth() {
auto devices = BTDevice::enumerate();
for (const auto& path : devices) {
std::string id = "BT:" + path;
if (!hasDevice(id)) {
auto dev = std::make_shared<BTDevice>();
addDevice(id, dev);
}
}
}
void DeviceManager::discoverNetwork(uint16_t port) {
auto devices = LANDevice::discover();
for (const auto& path : devices) {
std::string id = "NET:" + path;
if (!hasDevice(id)) {
auto dev = std::make_shared<LANDevice>();
addDevice(id, dev);
}
}
}
void DeviceManager::discoverSerial() {
auto devices = SerialDevice::enumerate();
for (const auto& path : devices) {
std::string id = "SERIAL:" + path;
if (!hasDevice(id)) {
auto dev = std::make_shared<SerialDevice>();
addDevice(id, dev);
}
}
}
void DeviceManager::discoverAllAsync(DiscoveryCallback callback, std::chrono::seconds timeout) {
std::thread([this, callback, timeout]() {
discoverAll(DeviceFilter{}, timeout);
std::vector<DeviceInfo> allDevices;
{
std::lock_guard<std::mutex> lock(mutex_);
for (const auto& [id, device] : devices_) {
allDevices.push_back(device->getInfo());
}
}
if (callback) {
callback(allDevices);
}
}).detach();
}
void DeviceManager::startContinuousDiscovery(std::chrono::milliseconds interval) {
stopDiscovery();
discoveryRunning_ = true;
discoveryThread_ = std::make_unique<std::thread>([this, interval]() {
while (discoveryRunning_) {
discoverAll();
auto deadline = std::chrono::steady_clock::now() + interval;
while (discoveryRunning_ && std::chrono::steady_clock::now() < deadline) {
std::this_thread::sleep_for(std::chrono::milliseconds(100));
}
}
});
}
void DeviceManager::stopDiscovery() {
discoveryRunning_ = false;
if (discoveryThread_ && discoveryThread_->joinable()) {
discoveryThread_->join();
}
discoveryThread_.reset();
}
bool DeviceManager::isDiscovering() const {
return discoveryRunning_;
}
bool DeviceManager::connect(const std::string& id) {
auto device = getDevice(id);
if (!device) {
return false;
}
auto colonPos = id.find(':');
if (colonPos == std::string::npos) {
return false;
}
std::string path = id.substr(colonPos + 1);
bool result = device->open(path);
if (result) {
for (const auto& [cbId, callback] : deviceCallbacks_) {
callback(id, DeviceEvent::Changed);
}
}
return result;
}
void DeviceManager::disconnect(const std::string& id) {
auto device = getDevice(id);
if (device) {
device->close();
for (const auto& [cbId, callback] : deviceCallbacks_) {
callback(id, DeviceEvent::Changed);
}
}
}
void DeviceManager::disconnectAll() {
std::lock_guard<std::mutex> lock(mutex_);
for (auto& [id, device] : devices_) {
device->close();
}
}
size_t DeviceManager::registerCallback(DeviceEventCallback callback) {
std::lock_guard<std::mutex> lock(mutex_);
size_t id = nextCallbackId_++;
deviceCallbacks_[id] = std::move(callback);
return id;
}
void DeviceManager::unregisterCallback(size_t callbackId) {
std::lock_guard<std::mutex> lock(mutex_);
deviceCallbacks_.erase(callbackId);
}
std::shared_ptr<Device> DeviceManager::createDevice(DeviceType type) {
switch (type) {
case DeviceType::USB:
return std::make_shared<USBDevice>();
case DeviceType::Bluetooth:
return std::make_shared<BTDevice>();
case DeviceType::Network:
return std::make_shared<LANDevice>();
case DeviceType::Serial:
return std::make_shared<SerialDevice>();
default:
return nullptr;
}
}
std::shared_ptr<Device> DeviceManager::createAndConnect(DeviceType type, const std::string& path) {
auto device = createDevice(type);
if (device && device->open(path)) {
std::string id;
switch (type) {
case DeviceType::USB: id = "USB:"; break;
case DeviceType::Bluetooth: id = "BT:"; break;
case DeviceType::Network: id = "NET:"; break;
case DeviceType::Serial: id = "SERIAL:"; break;
default: id = "UNKNOWN:"; break;
}
id += path;
addDevice(id, device);
return device;
}
return nullptr;
}
void DeviceManager::setPreferredDevice(const std::string& id) {
std::lock_guard<std::mutex> lock(mutex_);
preferredDeviceId_ = id;
}
std::string DeviceManager::getPreferredDevice() const {
std::lock_guard<std::mutex> lock(mutex_);
return preferredDeviceId_;
}
std::shared_ptr<Device> DeviceManager::getPreferredDevicePtr() {
std::lock_guard<std::mutex> lock(mutex_);
if (!preferredDeviceId_.empty()) {
auto it = devices_.find(preferredDeviceId_);
if (it != devices_.end()) {
return it->second;
}
}
return nullptr;
}
std::string DeviceManager::toJson() const {
std::lock_guard<std::mutex> lock(mutex_);
std::string json = "{\"devices\":[";
bool first = true;
for (const auto& [id, device] : devices_) {
if (!first) json += ",";
first = false;
json += "{";
json += "\"id\":\"" + id + "\",";
json += "\"info\":" + device->getInfo().toJson() + ",";
json += "\"isOpen\":" + std::string(device->isOpen() ? "true" : "false");
json += "}";
}
json += "],";
json += "\"preferredDevice\":\"" + preferredDeviceId_ + "\"";
json += "}";
return json;
}
}
```
## File: CAdmin/Backend/DeviceManager.hpp
```
#pragma once
#include "Device.hpp"
#include <map>
#include <memory>
#include <mutex>
#include <thread>
#include <functional>
namespace Cognitive::HAL {
enum class DeviceEvent {
Added,
Removed,
Changed
};
using DeviceEventCallback = std::function<void(const std::string& deviceId, DeviceEvent event)>;
using DiscoveryCallback = std::function<void(const std::vector<DeviceInfo>& devices)>;
struct DeviceFilter {
bool includeUSB = true;
bool includeBluetooth = true;
bool includeNetwork = true;
bool includeSerial = true;
std::string manufacturerFilter;
std::string modelFilter;
};
class DeviceManager {
public:
static DeviceManager& instance();
DeviceManager(const DeviceManager&) = delete;
DeviceManager& operator=(const DeviceManager&) = delete;
DeviceManager(DeviceManager&&) = delete;
DeviceManager& operator=(DeviceManager&&) = delete;
std::shared_ptr<Device> getDevice(const std::string& id);
void addDevice(const std::string& id, std::shared_ptr<Device> device);
void removeDevice(const std::string& id);
[[nodiscard]] bool hasDevice(const std::string& id) const;
[[nodiscard]] std::vector<std::string> listDevices() const;
[[nodiscard]] std::vector<std::string> listDevicesByType(DeviceType type) const;
[[nodiscard]] std::vector<DeviceInfo> getAllDeviceInfo() const;
[[nodiscard]] size_t getDeviceCount() const;
void clearAll();
static constexpr auto DEFAULT_DISCOVERY_TIMEOUT = std::chrono::seconds(30);
void discoverAll(const DeviceFilter& filter = DeviceFilter{},
std::chrono::seconds timeout = DEFAULT_DISCOVERY_TIMEOUT);
void discoverAllAsync(DiscoveryCallback callback,
std::chrono::seconds timeout = DEFAULT_DISCOVERY_TIMEOUT);
void discoverUSB();
void discoverBluetooth();
void discoverNetwork(uint16_t port = 9100);
void discoverSerial();
void startContinuousDiscovery(std::chrono::milliseconds interval = std::chrono::milliseconds(30000));
void stopDiscovery();
[[nodiscard]] bool isDiscovering() const;
size_t registerCallback(DeviceEventCallback callback);
void unregisterCallback(size_t callbackId);
bool connect(const std::string& id);
void disconnect(const std::string& id);
bool openDevice(const std::string& id);
void closeDevice(const std::string& id);
void closeAllDevices();
void disconnectAll();
std::shared_ptr<Device> getFirstAvailable(DeviceType type);
std::shared_ptr<Device> createDevice(DeviceType type);
std::shared_ptr<Device> createAndConnect(DeviceType type, const std::string& path);
void setPreferredDevice(const std::string& id);
[[nodiscard]] std::string getPreferredDevice() const;
std::shared_ptr<Device> getPreferredDevicePtr();
[[nodiscard]] std::string toJson() const;
private:
DeviceManager();
~DeviceManager();
mutable std::mutex mutex_;
std::map<std::string, std::shared_ptr<Device>> devices_;
std::map<size_t, DeviceEventCallback> deviceCallbacks_;
size_t nextCallbackId_ = 0;
bool discoveryRunning_ = false;
std::unique_ptr<std::thread> discoveryThread_;
std::string preferredDeviceId_;
void notifyEvent(DeviceEvent event, const std::string& deviceId);
};
}
```
## File: CAdmin/Backend/HttpClient.cpp
```cpp
#include "HttpClient.hpp"
#include "Compression.hpp"
#include <boost/beast/core.hpp>
#include <boost/beast/http.hpp>
#include <boost/beast/ssl.hpp>
#include <boost/asio/connect.hpp>
#include <boost/asio/ip/tcp.hpp>
#include <boost/asio/ssl/stream.hpp>
#include <regex>
#include <thread>
#include <fstream>
#include <iomanip>
#include <sstream>
#include <algorithm>
namespace beast = boost::beast;
namespace http = beast::http;
namespace net = boost::asio;
namespace ssl = net::ssl;
using tcp = net::ip::tcp;
namespace Cognitive::Network {
struct HttpClient::Impl {
};
std::string ClientResponse::getHeader(const std::string& name) const {
std::string lowerName = name;
std::transform(lowerName.begin(), lowerName.end(), lowerName.begin(), ::tolower);
for (const auto& [key, value] : headers) {
std::string lowerKey = key;
std::transform(lowerKey.begin(), lowerKey.end(), lowerKey.begin(), ::tolower);
if (lowerKey == lowerName) {
return value;
}
}
return "";
}
// ==================== Constructor/Destructor ====================
HttpClient::HttpClient() : pImpl_(std::make_unique<Impl>()) {}
HttpClient::HttpClient(const RequestOptions& options)
: pImpl_(std::make_unique<Impl>()), defaultOptions_(options) {}
HttpClient::~HttpClient() = default;
// ==================== Configuration ====================
void HttpClient::setDefaultOptions(const RequestOptions& options) {
defaultOptions_ = options;
}
void HttpClient::setTimeout(std::chrono::milliseconds timeout) {
defaultOptions_.timeout = timeout;
}
void HttpClient::setDefaultHeaders(const std::map<std::string, std::string>& headers) {
defaultOptions_.headers = headers;
}
// ==================== URL Utilities ====================
std::string HttpClient::urlEncode(const std::string& str) {
std::ostringstream encoded;
encoded << std::hex << std::uppercase;
for (char c : str) {
if (std::isalnum(static_cast<unsigned char>(c)) || c == '-' || c == '_' || c == '.' || c == '~') {
encoded << c;
} else {
encoded << '%' << std::setw(2) << std::setfill('0') << static_cast<int>(static_cast<unsigned char>(c));
}
}
return encoded.str();
}
std::string HttpClient::urlDecode(const std::string& str) {
std::string decoded;
for (size_t i = 0; i < str.size(); ++i) {
if (str[i] == '%' && i + 2 < str.size()) {
int value = 0;
std::istringstream iss(str.substr(i + 1, 2));
iss >> std::hex >> value;
decoded += static_cast<char>(value);
i += 2;
} else if (str[i] == '+') {
decoded += ' ';
} else {
decoded += str[i];
}
}
return decoded;
}
std::string HttpClient::buildQueryString(const std::map<std::string, std::string>& params) {
std::string query;
bool first = true;
for (const auto& [key, value] : params) {
if (!first) query += '&';
query += urlEncode(key) + '=' + urlEncode(value);
first = false;
}
return query;
}
bool HttpClient::parseUrl(const std::string& url, std::string& scheme, std::string& host,
uint16_t& port, std::string& path, std::string& query) {
std::regex urlRegex(R"(^(https?):
std::smatch match;
if (!std::regex_match(url, match, urlRegex)) {
return false;
}
scheme = match[1].str();
host = match[2].str();
port = match[3].matched ? static_cast<uint16_t>(std::stoi(match[3].str())) :
(scheme == "https" ? 443 : 80);
path = match[4].matched ? match[4].str() : "/";
query = match[5].matched ? match[5].str() : "";
return true;
}
// ==================== Internal Request Function ====================
static ClientResponse doRequest(const std::string& method, const std::string& url,
const std::vector<uint8_t>& body,
const RequestOptions& options) {
ClientResponse response;
auto startTime = std::chrono::steady_clock::now();
try {
std::string scheme, host, path, query;
uint16_t port;
if (!HttpClient::parseUrl(url, scheme, host, port, path, query)) {
response.error = "Invalid URL";
return response;
}
if (!query.empty()) {
path += '?' + query;
}
net::io_context io;
tcp::resolver resolver(io);
auto endpoints = resolver.resolve(host, std::to_string(port));
http::verb verb = http::verb::get;
if (method == "POST") verb = http::verb::post;
else if (method == "PUT") verb = http::verb::put;
else if (method == "DELETE") verb = http::verb::delete_;
else if (method == "PATCH") verb = http::verb::patch;
if (scheme == "https") {
ssl::context ctx(ssl::context::tlsv12_client);
ctx.set_default_verify_paths();
if (options.verifySSL) {
ctx.set_verify_mode(ssl::verify_peer);
} else {
ctx.set_verify_mode(ssl::verify_none);
}
beast::ssl_stream<beast::tcp_stream> stream(io, ctx);
if (!SSL_set_tlsext_host_name(stream.native_handle(), host.c_str())) {
response.error = "SSL SNI error";
return response;
}
beast::get_lowest_layer(stream).connect(endpoints);
stream.handshake(ssl::stream_base::client);
http::request<http::string_body> req{verb, path, 11};
req.set(http::field::host, host);
req.set(http::field::user_agent, options.userAgent);
req.set(http::field::accept, options.accept);
for (const auto& [key, value] : options.headers) {
req.set(key, value);
}
if (!options.contentType.empty()) {
req.set(http::field::content_type, options.contentType);
}
if (!body.empty()) {
req.body() = std::string(body.begin(), body.end());
req.prepare_payload();
}
http::write(stream, req);
beast::flat_buffer buffer;
http::response<http::string_body> res;
http::read(stream, buffer, res);
response.statusCode = res.result_int();
response.statusMessage = std::string(res.reason());
response.body = std::vector<uint8_t>(res.body().begin(), res.body().end());
for (const auto& field : res) {
response.headers[std::string(field.name_string())] = std::string(field.value());
}
beast::error_code ec;
stream.shutdown(ec);
} else {
beast::tcp_stream stream(io);
stream.connect(endpoints);
http::request<http::string_body> req{verb, path, 11};
req.set(http::field::host, host);
req.set(http::field::user_agent, options.userAgent);
req.set(http::field::accept, options.accept);
for (const auto& [key, value] : options.headers) {
req.set(key, value);
}
if (!options.contentType.empty()) {
req.set(http::field::content_type, options.contentType);
}
if (!body.empty()) {
req.body() = std::string(body.begin(), body.end());
req.prepare_payload();
}
http::write(stream, req);
beast::flat_buffer buffer;
http::response<http::string_body> res;
http::read(stream, buffer, res);
response.statusCode = res.result_int();
response.statusMessage = std::string(res.reason());
response.body = std::vector<uint8_t>(res.body().begin(), res.body().end());
for (const auto& field : res) {
response.headers[std::string(field.name_string())] = std::string(field.value());
}
beast::error_code ec;
stream.socket().shutdown(tcp::socket::shutdown_both, ec);
}
} catch (const std::exception& e) {
response.error = e.what();
}
auto endTime = std::chrono::steady_clock::now();
response.responseTime = std::chrono::duration_cast<std::chrono::milliseconds>(endTime - startTime);
return response;
}
ClientResponse HttpClient::get(const std::string& url) {
return doRequest("GET", url, {}, RequestOptions{});
}
ClientResponse HttpClient::get(const std::string& url, const RequestOptions& options) {
return doRequest("GET", url, {}, options);
}
ClientResponse HttpClient::post(const std::string& url, const std::vector<uint8_t>& data) {
return doRequest("POST", url, data, RequestOptions{});
}
ClientResponse HttpClient::post(const std::string& url, const std::string& body,
const std::string& contentType) {
RequestOptions opts;
opts.contentType = contentType;
return doRequest("POST", url, std::vector<uint8_t>(body.begin(), body.end()), opts);
}
ClientResponse HttpClient::post(const std::string& url, const std::vector<uint8_t>& data,
const RequestOptions& options) {
return doRequest("POST", url, data, options);
}
ClientResponse HttpClient::put(const std::string& url, const std::vector<uint8_t>& data) {
return doRequest("PUT", url, data, RequestOptions{});
}
ClientResponse HttpClient::del(const std::string& url) {
return doRequest("DELETE", url, {}, RequestOptions{});
}
void HttpClient::getAsync(const std::string& url, CompletionCallback callback) {
std::thread([url, callback, opts = defaultOptions_]() {
auto response = doRequest("GET", url, {}, opts);
if (callback) callback(response);
}).detach();
}
void HttpClient::postAsync(const std::string& url, const std::vector<uint8_t>& data,
CompletionCallback callback) {
std::thread([url, data, callback, opts = defaultOptions_]() {
auto response = doRequest("POST", url, data, opts);
if (callback) callback(response);
}).detach();
}
bool HttpClient::downloadFile(const std::string& url, const std::string& filePath,
ProgressCallback progress) {
auto response = get(url);
if (!response.isSuccess()) {
return false;
}
std::ofstream file(filePath, std::ios::binary);
if (!file) {
return false;
}
file.write(reinterpret_cast<const char*>(response.body.data()), response.body.size());
if (progress) {
progress(response.body.size(), response.body.size());
}
return true;
}
ClientResponse HttpClient::uploadFile(const std::string& url, const std::string& filePath,
const std::string& fieldName, ProgressCallback progress) {
std::ifstream file(filePath, std::ios::binary);
if (!file) {
ClientResponse response;
response.error = "Could not open file";
return response;
}
std::vector<uint8_t> fileData((std::istreambuf_iterator<char>(file)),
std::istreambuf_iterator<char>());
std::string filename = filePath;
auto pos = filePath.find_last_of("/\\");
if (pos != std::string::npos) {
filename = filePath.substr(pos + 1);
}
std::string boundary = "----CognitiveUploadBoundary" +
std::to_string(std::chrono::system_clock::now().time_since_epoch().count());
std::string bodyStr;
bodyStr += "--" + boundary + "\r\n";
bodyStr += "Content-Disposition: form-data; name=\"" + fieldName + "\"; filename=\"" + filename + "\"\r\n";
bodyStr += "Content-Type: application/octet-stream\r\n\r\n";
bodyStr += std::string(fileData.begin(), fileData.end());
bodyStr += "\r\n--" + boundary + "--\r\n";
RequestOptions opts;
opts.contentType = "multipart/form-data; boundary=" + boundary;
if (progress) {
progress(fileData.size(), fileData.size());
}
return doRequest("POST", url, std::vector<uint8_t>(bodyStr.begin(), bodyStr.end()), opts);
}
ClientResponse HttpClient::postJson(const std::string& url, const std::string& json) {
return post(url, json, "application/json");
}
std::string HttpClient::getJson(const std::string& url) {
auto response = get(url);
return response.bodyString();
}
}
```
## File: CAdmin/Backend/HttpClient.hpp
```
#pragma once
#include <string>
#include <vector>
#include <map>
#include <cstdint>
#include <chrono>
#include <functional>
namespace Cognitive::Network {
struct ClientResponse {
int statusCode = 0;
std::string statusMessage;
std::map<std::string, std::string> headers;
std::vector<uint8_t> body;
std::string error;
std::chrono::milliseconds responseTime{0};
[[nodiscard]] bool isSuccess() const { return statusCode >= 200 && statusCode < 300; }
[[nodiscard]] std::string bodyString() const {
return std::string(body.begin(), body.end());
}
[[nodiscard]] std::string getHeader(const std::string& name) const;
};
struct RequestOptions {
std::chrono::milliseconds timeout{30000};
std::map<std::string, std::string> headers;
bool followRedirects = true;
int maxRedirects = 5;
bool verifySSL = true;
std::string userAgent = "CAdmin/1.0";
std::string contentType;
std::string accept = "*/*";
};
using ProgressCallback = std::function<void(size_t current, size_t total)>;
using CompletionCallback = std::function<void(const ClientResponse&)>;
class HttpClient {
public:
HttpClient();
explicit HttpClient(const RequestOptions& defaultOptions);
~HttpClient();
static ClientResponse get(const std::string& url);
static ClientResponse get(const std::string& url, const RequestOptions& options);
static ClientResponse post(const std::string& url, const std::vector<uint8_t>& data);
static ClientResponse post(const std::string& url, const std::string& body,
const std::string& contentType = "application/json");
static ClientResponse post(const std::string& url, const std::vector<uint8_t>& data,
const RequestOptions& options);
static ClientResponse put(const std::string& url, const std::vector<uint8_t>& data);
static ClientResponse del(const std::string& url);
void getAsync(const std::string& url, CompletionCallback callback);
void postAsync(const std::string& url, const std::vector<uint8_t>& data,
CompletionCallback callback);
static bool downloadFile(const std::string& url, const std::string& filePath,
ProgressCallback progress = nullptr);
static ClientResponse uploadFile(const std::string& url, const std::string& filePath,
const std::string& fieldName = "file",
ProgressCallback progress = nullptr);
static ClientResponse postJson(const std::string& url, const std::string& json);
static std::string getJson(const std::string& url);
void setDefaultOptions(const RequestOptions& options);
[[nodiscard]] const RequestOptions& getDefaultOptions() const { return defaultOptions_; }
void setTimeout(std::chrono::milliseconds timeout);
void setDefaultHeaders(const std::map<std::string, std::string>& headers);
static std::string urlEncode(const std::string& str);
static std::string urlDecode(const std::string& str);
static std::string buildQueryString(const std::map<std::string, std::string>& params);
static bool parseUrl(const std::string& url, std::string& scheme, std::string& host,
uint16_t& port, std::string& path, std::string& query);
private:
struct Impl;
std::unique_ptr<Impl> pImpl_;
RequestOptions defaultOptions_;
};
}
```
## File: CAdmin/Backend/HttpServer.cpp
```cpp
#include "HttpServer.hpp"
#include "Compression.hpp"
#include "Device.hpp"
#include <boost/beast/core.hpp>
#include <boost/beast/http.hpp>
#include <boost/beast/websocket.hpp>
#include <thread>
#include <filesystem>
#include <fstream>
namespace beast = boost::beast;
namespace http = beast::http;
namespace websocket = beast::websocket;
namespace net = boost::asio;
using tcp = net::ip::tcp;
namespace Cognitive::Network {
class HttpSession : public std::enable_shared_from_this<HttpSession> {
public:
HttpSession(tcp::socket socket, HttpServer* server)
: socket_(std::move(socket))
, server_(server) {}
void run() {
doRead();
}
private:
void doRead() {
request_ = {};
http::async_read(socket_, buffer_, request_,
[self = shared_from_this()](beast::error_code ec, size_t bytes) {
self->onRead(ec, bytes);
});
}
void onRead(beast::error_code ec, size_t ) {
if (ec == http::error::end_of_stream) {
return doClose();
}
if (ec) return;
handleRequest();
}
void handleRequest() {
auto response = std::make_shared<http::response<http::string_body>>();
response->version(request_.version());
response->keep_alive(request_.keep_alive());
HttpRequest req;
req.method = std::string(request_.method_string());
req.path = std::string(request_.target());
req.body = request_.body();
for (const auto& field : request_) {
req.headers[std::string(field.name_string())] = std::string(field.value());
}
try {
req.headers["X-Remote-Address"] = socket_.remote_endpoint().address().to_string();
} catch (...) {}
HttpResponse res;
res.statusCode = 404;
res.body = "Not Found";
bool handled = false;
for (const auto& [pathPrefix, handler] : server_->getHandlers()) {
if (req.path.find(pathPrefix) == 0) {
res = handler(req);
handled = true;
break;
}
}
if (!handled && server_->getDefaultHandler()) {
res = server_->getDefaultHandler()(req);
}
response->result(static_cast<http::status>(res.statusCode));
response->body() = res.body;
for (const auto& [key, value] : res.headers) {
response->set(key, value);
}
response->set(http::field::content_length, std::to_string(response->body().size()));
response->prepare_payload();
http::async_write(socket_, *response,
[self = shared_from_this(), response](beast::error_code ec, size_t ) {
self->onWrite(ec, response->need_eof());
});
}
void onWrite(beast::error_code ec, bool close) {
if (ec || close) {
return doClose();
}
doRead();
}
void doClose() {
beast::error_code ec;
socket_.shutdown(tcp::socket::shutdown_send, ec);
}
tcp::socket socket_;
beast::flat_buffer buffer_;
http::request<http::string_body> request_;
HttpServer* server_;
};
class WebSocketSession : public std::enable_shared_from_this<WebSocketSession> {
public:
WebSocketSession(tcp::socket socket, HttpServer* server)
: ws_(std::move(socket))
, server_(server) {}
void run(http::request<http::string_body> req) {
ws_.async_accept(req,
[self = shared_from_this()](beast::error_code ec) {
if (!ec) self->doRead();
});
}
void send(const std::string& message) {
ws_.text(true);
ws_.async_write(net::buffer(message),
[self = shared_from_this()](beast::error_code ec, size_t ) {
if (ec) {
}
});
}
private:
void doRead() {
ws_.async_read(buffer_,
[self = shared_from_this()](beast::error_code ec, size_t bytes) {
self->onRead(ec, bytes);
});
}
void onRead(beast::error_code ec, size_t ) {
if (ec == websocket::error::closed) return;
if (ec) return;
std::string message = beast::buffers_to_string(buffer_.data());
buffer_.consume(buffer_.size());
if (server_->getWebSocketHandler()) {
server_->getWebSocketHandler()(message);
}
doRead();
}
websocket::stream<tcp::socket> ws_;
beast::flat_buffer buffer_;
HttpServer* server_;
};
HttpServer::HttpServer(uint16_t port)
: port_(port)
, acceptor_(io_) {}
HttpServer::~HttpServer() {
stop();
}
void HttpServer::addHandler(const std::string& path, RequestHandler handler) {
std::lock_guard<std::mutex> lock(mutex_);
handlers_[path] = std::move(handler);
}
void HttpServer::removeHandler(const std::string& path) {
std::lock_guard<std::mutex> lock(mutex_);
handlers_.erase(path);
}
void HttpServer::setDefaultHandler(RequestHandler handler) {
std::lock_guard<std::mutex> lock(mutex_);
defaultHandler_ = std::move(handler);
}
void HttpServer::setWebSocketHandler(WebSocketHandler handler) {
std::lock_guard<std::mutex> lock(mutex_);
wsHandler_ = std::move(handler);
}
const std::map<std::string, RequestHandler>& HttpServer::getHandlers() const {
return handlers_;
}
RequestHandler HttpServer::getDefaultHandler() const {
return defaultHandler_;
}
WebSocketHandler HttpServer::getWebSocketHandler() const {
return wsHandler_;
}
bool HttpServer::start() {
try {
tcp::endpoint endpoint{tcp::v4(), port_};
acceptor_.open(endpoint.protocol());
acceptor_.set_option(net::socket_base::reuse_address(true));
acceptor_.bind(endpoint);
acceptor_.listen(net::socket_base::max_listen_connections);
running_ = true;
doAccept();
serverThread_ = std::make_unique<std::thread>([this]() {
io_.run();
});
return true;
} catch (const std::exception& e) {
lastError_ = e.what();
return false;
}
}
void HttpServer::stop() {
running_ = false;
boost::system::error_code ec;
acceptor_.close(ec);
io_.stop();
if (serverThread_ && serverThread_->joinable()) {
serverThread_->join();
}
serverThread_.reset();
}
bool HttpServer::isRunning() const {
return running_;
}
uint16_t HttpServer::getPort() const {
return port_;
}
std::string HttpServer::getLastError() const {
return lastError_;
}
void HttpServer::doAccept() {
acceptor_.async_accept(
[this](beast::error_code ec, tcp::socket socket) {
if (!ec && running_) {
std::make_shared<HttpSession>(std::move(socket), this)->run();
}
if (running_) {
doAccept();
}
});
}
HttpResponse HttpServer::handleLogUpload(const HttpRequest& request) {
HttpResponse response;
if (request.method != "POST") {
response.statusCode = 405;
response.body = "Method Not Allowed";
return response;
}
auto contentEncodingIt = request.headers.find("Content-Encoding");
std::string bodyData = request.body;
if (contentEncodingIt != request.headers.end() && contentEncodingIt->second == "lzma") {
std::vector<uint8_t> compressed(request.body.begin(), request.body.end());
auto decompressed = Utilities::Compression::decompress(compressed);
bodyData = std::string(decompressed.begin(), decompressed.end());
}
std::string timestamp = std::to_string(std::chrono::system_clock::now().time_since_epoch().count());
std::string filename = "logs/log_" + timestamp + ".txt";
std::filesystem::create_directories("logs");
std::ofstream file(filename);
if (file) {
file << bodyData;
response.statusCode = 200;
response.body = "{\"status\":\"ok\",\"file\":\"" + filename + "\"}";
} else {
response.statusCode = 500;
response.body = "{\"status\":\"error\",\"message\":\"Failed to save log\"}";
}
response.headers["Content-Type"] = "application/json";
return response;
}
HttpResponse HttpServer::handleFirmwareRequest(const HttpRequest& request) {
HttpResponse response;
std::string model;
auto queryPos = request.path.find('?');
if (queryPos != std::string::npos) {
std::string query = request.path.substr(queryPos + 1);
auto modelPos = query.find("model=");
if (modelPos != std::string::npos) {
auto endPos = query.find('&', modelPos);
model = query.substr(modelPos + 6, endPos - modelPos - 6);
}
}
std::string firmwarePath = "firmware/" + model + ".cpr";
if (!std::filesystem::exists(firmwarePath)) {
response.statusCode = 404;
response.body = "{\"status\":\"error\",\"message\":\"Firmware not found\"}";
response.headers["Content-Type"] = "application/json";
return response;
}
auto fileSize = std::filesystem::file_size(firmwarePath);
if (fileSize > HAL::MAX_FIRMWARE_SIZE) {
response.statusCode = 413;
response.body = "{\"status\":\"error\",\"message\":\"Firmware file exceeds maximum allowed size\"}";
response.headers["Content-Type"] = "application/json";
return response;
}
std::ifstream file(firmwarePath, std::ios::binary);
std::vector<uint8_t> firmware((std::istreambuf_iterator<char>(file)),
std::istreambuf_iterator<char>());
auto compressed = Utilities::Compression::compress(firmware);
response.statusCode = 200;
response.body = std::string(compressed.begin(), compressed.end());
response.headers["Content-Type"] = "application/octet-stream";
response.headers["Content-Encoding"] = "lzma";
response.headers["X-Firmware-Size"] = std::to_string(firmware.size());
return response;
}
HttpResponse HttpServer::handleStaticFile(const HttpRequest& request, const std::string& basePath) {
HttpResponse response;
std::string requestPath = request.path;
if (requestPath == "/") requestPath = "/index.html";
auto queryPos = requestPath.find('?');
if (queryPos != std::string::npos) {
requestPath = requestPath.substr(0, queryPos);
}
if (requestPath.find("..") != std::string::npos) {
response.statusCode = 403;
response.body = "Forbidden";
return response;
}
std::string fullPath = basePath + requestPath;
if (!std::filesystem::exists(fullPath)) {
response.statusCode = 404;
response.body = "Not Found";
return response;
}
auto fileSize = std::filesystem::file_size(fullPath);
if (fileSize > HAL::MAX_OBJECT_SIZE) {
response.statusCode = 413;
response.body = "File too large";
return response;
}
std::ifstream file(fullPath, std::ios::binary);
std::string content((std::istreambuf_iterator<char>(file)),
std::istreambuf_iterator<char>());
response.statusCode = 200;
response.body = content;
std::string ext = std::filesystem::path(fullPath).extension().string();
if (ext == ".html") response.headers["Content-Type"] = "text/html";
else if (ext == ".css") response.headers["Content-Type"] = "text/css";
else if (ext == ".js") response.headers["Content-Type"] = "application/javascript";
else if (ext == ".json") response.headers["Content-Type"] = "application/json";
else if (ext == ".png") response.headers["Content-Type"] = "image/png";
else if (ext == ".jpg" || ext == ".jpeg") response.headers["Content-Type"] = "image/jpeg";
else if (ext == ".svg") response.headers["Content-Type"] = "image/svg+xml";
else response.headers["Content-Type"] = "application/octet-stream";
return response;
}
}
```
## File: CAdmin/Backend/HttpServer.hpp
```
#pragma once
#include <boost/beast.hpp>
#include <boost/asio.hpp>
#include <string>
#include <functional>
#include <memory>
#include <map>
#include <mutex>
#include <thread>
namespace Cognitive::Network {
namespace beast = boost::beast;
namespace http = beast::http;
namespace net = boost::asio;
using tcp = net::ip::tcp;
struct HttpRequest {
std::string method;
std::string path;
std::string query;
std::map<std::string, std::string> headers;
std::string body;
std::string remoteAddress;
uint16_t remotePort = 0;
};
struct HttpResponse {
int statusCode = 200;
std::string contentType = "application/json";
std::map<std::string, std::string> headers;
std::string body;
void setBody(const std::string& str) {
body = str;
}
void setJson(const std::string& json) {
contentType = "application/json";
body = json;
}
void setHtml(const std::string& html) {
contentType = "text/html";
body = html;
}
};
using RequestHandler = std::function<HttpResponse(const HttpRequest&)>;
using WebSocketHandler = std::function<void(const std::string& message)>;
class HttpServer {
public:
explicit HttpServer(uint16_t port);
~HttpServer();
HttpServer(const HttpServer&) = delete;
HttpServer& operator=(const HttpServer&) = delete;
bool start();
void stop();
[[nodiscard]] bool isRunning() const;
[[nodiscard]] uint16_t getPort() const;
[[nodiscard]] std::string getLastError() const;
void addHandler(const std::string& path, RequestHandler handler);
void removeHandler(const std::string& path);
void setDefaultHandler(RequestHandler handler);
void setWebSocketHandler(WebSocketHandler handler);
[[nodiscard]] const std::map<std::string, RequestHandler>& getHandlers() const;
[[nodiscard]] RequestHandler getDefaultHandler() const;
[[nodiscard]] WebSocketHandler getWebSocketHandler() const;
static HttpResponse handleLogUpload(const HttpRequest& request);
static HttpResponse handleFirmwareRequest(const HttpRequest& request);
static HttpResponse handleStaticFile(const HttpRequest& request, const std::string& basePath);
private:
void doAccept();
uint16_t port_;
boost::asio::io_context io_;
tcp::acceptor acceptor_;
std::map<std::string, RequestHandler> handlers_;
RequestHandler defaultHandler_;
WebSocketHandler wsHandler_;
std::mutex mutex_;
bool running_ = false;
std::unique_ptr<std::thread> serverThread_;
std::string lastError_;
};
}
```
## File: CAdmin/Backend/LANDevice.cpp
```cpp
#include "LANDevice.hpp"
#include <span>
#include <thread>
#include <array>
namespace Cognitive::HAL {
struct LANDevice::Impl {
boost::asio::io_context ownedIo;
boost::asio::io_context* io;
boost::asio::ip::tcp::socket socket;
boost::asio::ip::udp::socket udpSocket;
std::string host;
uint16_t port = 9100;
bool isOpen = false;
std::string lastError;
Impl() : io(&ownedIo), socket(ownedIo), udpSocket(ownedIo) {}
explicit Impl(boost::asio::io_context& externalIo) : io(&externalIo), socket(externalIo), udpSocket(externalIo) {}
};
LANDevice::LANDevice() : pImpl_(std::make_unique<Impl>()) {
}
LANDevice::LANDevice(boost::asio::io_context& io) : pImpl_(std::make_unique<Impl>(io)) {
}
LANDevice::~LANDevice() {
close();
}
LANDevice::LANDevice(LANDevice&&) noexcept = default;
LANDevice& LANDevice::operator=(LANDevice&&) noexcept = default;
bool LANDevice::open(const std::string& path) {
path_ = path;
try {
auto colonPos = path.rfind(':');
std::string host = path;
std::string portStr = "9100";
if (colonPos != std::string::npos && colonPos > 0) {
auto firstColon = path.find(':');
if (firstColon == colonPos) {
host = path.substr(0, colonPos);
portStr = path.substr(colonPos + 1);
}
}
pImpl_->host = host;
pImpl_->port = static_cast<uint16_t>(std::stoi(portStr));
config_.host = host;
config_.port = pImpl_->port;
boost::asio::ip::tcp::resolver resolver(*pImpl_->io);
auto endpoints = resolver.resolve(pImpl_->host, portStr);
boost::asio::connect(pImpl_->socket, endpoints);
pImpl_->socket.set_option(boost::asio::ip::tcp::no_delay(config_.noDelay));
pImpl_->socket.set_option(boost::asio::socket_base::keep_alive(config_.keepAlive));
pImpl_->isOpen = true;
isOpen_ = true;
return true;
} catch (const boost::system::system_error& e) {
pImpl_->lastError = "Connection failed: " + std::string(e.what());
return false;
} catch (const std::exception& e) {
pImpl_->lastError = "Error: " + std::string(e.what());
return false;
}
}
bool LANDevice::openWithConfig(const LANConfig& config) {
config_ = config;
return open(config.host + ":" + std::to_string(config.port));
}
void LANDevice::close() {
if (!pImpl_->isOpen) return;
boost::system::error_code ec;
if (pImpl_->socket.is_open()) {
pImpl_->socket.shutdown(boost::asio::ip::tcp::socket::shutdown_both, ec);
pImpl_->socket.close(ec);
}
if (pImpl_->udpSocket.is_open()) {
pImpl_->udpSocket.close(ec);
}
pImpl_->isOpen = false;
isOpen_ = false;
}
bool LANDevice::isOpen() const {
return pImpl_->socket.is_open();
}
bool LANDevice::write(std::span<const uint8_t> data) {
if (!pImpl_->isOpen) {
pImpl_->lastError = "Device not open";
return false;
}
try {
size_t written = boost::asio::write(pImpl_->socket,
boost::asio::buffer(data.data(), data.size()));
return written == data.size();
} catch (const boost::system::system_error& e) {
pImpl_->lastError = "Write failed: " + std::string(e.what());
return false;
}
}
std::vector<uint8_t> LANDevice::read(size_t maxBytes, std::chrono::milliseconds timeout) {
std::vector<uint8_t> buffer(maxBytes);
if (!pImpl_->isOpen) {
pImpl_->lastError = "Device not open";
return {};
}
try {
size_t bytesRead = 0;
boost::system::error_code readError;
bool readComplete = false;
pImpl_->socket.async_read_some(
boost::asio::buffer(buffer),
[&](const boost::system::error_code& ec, size_t bytes) {
readError = ec;
bytesRead = bytes;
readComplete = true;
}
);
pImpl_->io->restart();
auto deadline = std::chrono::steady_clock::now() + timeout;
while (!readComplete && std::chrono::steady_clock::now() < deadline) {
pImpl_->io->run_for(std::chrono::milliseconds(10));
}
if (!readComplete) {
pImpl_->socket.cancel();
pImpl_->io->run();
return {};
}
if (!readError) {
buffer.resize(bytesRead);
return buffer;
}
if (readError == boost::asio::error::eof) {
return {};
}
pImpl_->lastError = "Read failed: " + readError.message();
return {};
} catch (const boost::system::system_error& e) {
pImpl_->lastError = "Read error: " + std::string(e.what());
return {};
}
}
std::string LANDevice::readUntil(char delimiter, std::chrono::milliseconds timeout) {
if (!pImpl_->isOpen) {
pImpl_->lastError = "Device not open";
return "";
}
std::string result;
auto deadline = std::chrono::steady_clock::now() + timeout;
try {
while (std::chrono::steady_clock::now() < deadline) {
// Read one chunk at a time
auto remaining = std::chrono::duration_cast<std::chrono::milliseconds>(
deadline - std::chrono::steady_clock::now());
if (remaining.count() <= 0) break;
auto chunk = read(256, remaining);
if (chunk.empty()) {
// Timeout or error on this chunk, but we may have partial data
continue;
}
// Append to result and look for delimiter
for (uint8_t byte : chunk) {
result += static_cast<char>(byte);
if (byte == static_cast<uint8_t>(delimiter)) {
return result;  // Found delimiter, return complete message
}
}
}
// Timeout - return whatever we have (may be partial)
return result;
} catch (const std::exception& e) {
pImpl_->lastError = "readUntil error: " + std::string(e.what());
return result;  // Return partial data on error
}
}
std::vector<uint8_t> LANDevice::readExactly(size_t numBytes, std::chrono::milliseconds timeout) {
if (!pImpl_->isOpen) {
pImpl_->lastError = "Device not open";
return {};
}
std::vector<uint8_t> result;
result.reserve(numBytes);
auto deadline = std::chrono::steady_clock::now() + timeout;
try {
while (result.size() < numBytes && std::chrono::steady_clock::now() < deadline) {
auto remaining = std::chrono::duration_cast<std::chrono::milliseconds>(
deadline - std::chrono::steady_clock::now());
if (remaining.count() <= 0) break;
size_t needed = numBytes - result.size();
auto chunk = read(needed, remaining);
if (!chunk.empty()) {
result.insert(result.end(), chunk.begin(), chunk.end());
}
}
if (result.size() < numBytes) {
pImpl_->lastError = "Timeout: received " + std::to_string(result.size()) +
" of " + std::to_string(numBytes) + " bytes";
return {};
}
return result;
} catch (const std::exception& e) {
pImpl_->lastError = "readExactly error: " + std::string(e.what());
return {};
}
}
std::string LANDevice::getDescription() const {
std::string desc = "Network Device";
if (!pImpl_->host.empty()) {
desc += " [" + pImpl_->host + ":" + std::to_string(pImpl_->port) + "]";
}
return desc;
}
DeviceInfo LANDevice::getInfo() const {
DeviceInfo info;
info.id = pImpl_->host + ":" + std::to_string(pImpl_->port);
info.path = path_;
info.description = getDescription();
info.manufacturer = "Unknown";
info.serialNumber = "";
info.type = DeviceType::Network;
info.state = pImpl_->isOpen ? DeviceState::Connected : DeviceState::Disconnected;
return info;
}
LANConfig LANDevice::getConfig() const {
return config_;
}
void LANDevice::setConfig(const LANConfig& config) {
config_ = config;
}
std::string LANDevice::getRemoteAddress() const {
return pImpl_->host;
}
uint16_t LANDevice::getRemotePort() const {
return pImpl_->port;
}
uint16_t LANDevice::getLocalPort() const {
if (pImpl_->socket.is_open()) {
boost::system::error_code ec;
auto endpoint = pImpl_->socket.local_endpoint(ec);
if (!ec) {
return endpoint.port();
}
}
return 0;
}
bool LANDevice::hasData() const {
if (!pImpl_->socket.is_open()) return false;
boost::system::error_code ec;
return pImpl_->socket.available(ec) > 0;
}
size_t LANDevice::available() const {
if (!pImpl_->socket.is_open()) return 0;
boost::system::error_code ec;
return pImpl_->socket.available(ec);
}
// ==================== Async Methods ====================
void LANDevice::writeAsync(std::span<const uint8_t> data,
std::function<void(bool success, size_t bytesWritten)> callback) {
if (!pImpl_->isOpen) {
if (callback) callback(false, 0);
return;
}
auto buffer = std::make_shared<std::vector<uint8_t>>(data.begin(), data.end());
boost::asio::async_write(pImpl_->socket, boost::asio::buffer(*buffer),
[buffer, callback](const boost::system::error_code& ec, size_t bytesWritten) {
if (callback) {
callback(!ec, bytesWritten);
}
});
}
void LANDevice::readAsync(size_t maxBytes,
std::function<void(const std::vector<uint8_t>&, bool success)> callback) {
if (!pImpl_->isOpen) {
if (callback) callback({}, false);
return;
}
auto buffer = std::make_shared<std::vector<uint8_t>>(maxBytes);
pImpl_->socket.async_read_some(boost::asio::buffer(*buffer),
[buffer, callback](const boost::system::error_code& ec, size_t bytesRead) {
if (!ec && bytesRead > 0) {
buffer->resize(bytesRead);
if (callback) callback(*buffer, true);
} else {
if (callback) callback({}, false);
}
});
}
// ==================== Diagnostics ====================
int LANDevice::ping(std::chrono::milliseconds timeout) {
// Simple connectivity test - attempt to read with short timeout
auto start = std::chrono::steady_clock::now();
if (!pImpl_->socket.is_open()) {
return -1;
}
// For TCP sockets, we can check if the connection is still alive
boost::system::error_code ec;
pImpl_->socket.remote_endpoint(ec);
if (ec) {
return -1;
}
auto end = std::chrono::steady_clock::now();
return static_cast<int>(std::chrono::duration_cast<std::chrono::milliseconds>(end - start).count());
}
std::string LANDevice::getLastError() const {
return pImpl_->lastError;
}
int LANDevice::getLastErrorCode() const {
return 0; // Would return platform-specific error code
}
std::string LANDevice::getLastErrorMessage() const {
return pImpl_->lastError;
}
// ==================== Static Discovery Methods ====================
std::vector<std::string> LANDevice::discover() {
std::vector<std::string> devices;
try {
boost::asio::io_context io;
boost::asio::ip::udp::socket socket(io, boost::asio::ip::udp::endpoint(boost::asio::ip::udp::v4(), 0));
socket.set_option(boost::asio::socket_base::broadcast(true));
socket.set_option(boost::asio::socket_base::reuse_address(true));
// Discovery message (CPL-style discovery)
std::string discoveryMsg = "\x1B" "DISCOVER\x03";
std::array<uint16_t, 3> ports = {9100, 3001, 515};
for (uint16_t port : ports) {
boost::asio::ip::udp::endpoint broadcastEndpoint(
boost::asio::ip::address_v4::broadcast(), port
);
socket.send_to(boost::asio::buffer(discoveryMsg), broadcastEndpoint);
}
socket.non_blocking(true);
std::array<char, 1024> recvBuffer;
boost::asio::ip::udp::endpoint senderEndpoint;
boost::system::error_code ec;
auto deadline = std::chrono::steady_clock::now() + std::chrono::seconds(3);
while (std::chrono::steady_clock::now() < deadline) {
size_t len = socket.receive_from(
boost::asio::buffer(recvBuffer), senderEndpoint, 0, ec
);
if (!ec && len > 0) {
std::string path = senderEndpoint.address().to_string() + ":9100";
bool found = false;
for (const auto& d : devices) {
if (d == path) {
found = true;
break;
}
}
if (!found) {
devices.push_back(path);
}
} else if (ec && ec != boost::asio::error::would_block) {
break;
}
std::this_thread::sleep_for(std::chrono::milliseconds(50));
}
} catch (const std::exception&) {
}
return devices;
}
std::vector<LANDeviceInfo> LANDevice::discoverDetailed(std::chrono::milliseconds timeout) {
std::vector<LANDeviceInfo> devices;
try {
boost::asio::io_context io;
boost::asio::ip::udp::socket socket(io, boost::asio::ip::udp::endpoint(boost::asio::ip::udp::v4(), 0));
socket.set_option(boost::asio::socket_base::broadcast(true));
socket.set_option(boost::asio::socket_base::reuse_address(true));
std::string discoveryMsg = "\x1B" "DISCOVER\x03";
std::array<uint16_t, 3> ports = {9100, 3001, 515};
for (uint16_t port : ports) {
boost::asio::ip::udp::endpoint broadcastEndpoint(
boost::asio::ip::address_v4::broadcast(), port
);
socket.send_to(boost::asio::buffer(discoveryMsg), broadcastEndpoint);
}
socket.non_blocking(true);
std::array<char, 1024> recvBuffer;
boost::asio::ip::udp::endpoint senderEndpoint;
boost::system::error_code ec;
auto deadline = std::chrono::steady_clock::now() + timeout;
while (std::chrono::steady_clock::now() < deadline) {
size_t len = socket.receive_from(
boost::asio::buffer(recvBuffer), senderEndpoint, 0, ec
);
if (!ec && len > 0) {
LANDeviceInfo info;
info.ipAddress = senderEndpoint.address().to_string();
info.port = 9100;
info.hostname = "printer-" + senderEndpoint.address().to_string();
std::string response(recvBuffer.data(), len);
auto modelPos = response.find("MODEL=");
if (modelPos != std::string::npos) {
auto endPos = response.find('\n', modelPos);
info.modelNumber = response.substr(modelPos + 6, endPos - modelPos - 6);
}
bool found = false;
for (const auto& d : devices) {
if (d.ipAddress == info.ipAddress) {
found = true;
break;
}
}
if (!found) {
devices.push_back(info);
}
} else if (ec && ec != boost::asio::error::would_block) {
break;
}
std::this_thread::sleep_for(std::chrono::milliseconds(50));
}
} catch (const std::exception&) {
}
return devices;
}
void LANDevice::discoverAsync(LANDiscoveryCallback callback, std::chrono::milliseconds timeout) {
std::thread([callback, timeout]() {
auto devices = discoverDetailed(timeout);
for (const auto& device : devices) {
if (callback) {
callback(device);
}
}
}).detach();
}
}
```
## File: CAdmin/Backend/LANDevice.hpp
```
#pragma once
#include "Device.hpp"
#include <boost/asio.hpp>
#include <memory>
namespace Cognitive::HAL {
struct LANDeviceInfo {
std::string ipAddress;
uint16_t port;
std::string hostname;
std::string modelNumber;
std::string serialNumber;
std::string macAddress;
LANDeviceInfo() : port(9100) {}
std::string getAddress() const {
return ipAddress + ":" + std::to_string(port);
}
};
struct LANConfig {
std::string host;
uint16_t port = 9100;
std::chrono::milliseconds connectTimeout{5000};
std::chrono::milliseconds readTimeout{5000};
bool keepAlive = true;
bool noDelay = true;
};
using LANDiscoveryCallback = std::function<void(const LANDeviceInfo&)>;
class LANDevice : public Device {
public:
LANDevice();
explicit LANDevice(boost::asio::io_context& io);
~LANDevice() override;
LANDevice(const LANDevice&) = delete;
LANDevice& operator=(const LANDevice&) = delete;
LANDevice(LANDevice&&) noexcept;
LANDevice& operator=(LANDevice&&) noexcept;
bool open(const std::string& path) override;
void close() override;
[[nodiscard]] bool isOpen() const override;
bool write(std::span<const uint8_t> data) override;
std::vector<uint8_t> read(size_t maxBytes, std::chrono::milliseconds timeout) override;
[[nodiscard]] DeviceType getType() const override { return DeviceType::Network; }
[[nodiscard]] std::string getPath() const override { return path_; }
[[nodiscard]] std::string getDescription() const override;
[[nodiscard]] DeviceInfo getInfo() const override;
static std::vector<std::string> discover();
static std::vector<LANDeviceInfo> discoverDetailed(
std::chrono::milliseconds timeout = std::chrono::milliseconds(3000));
static void discoverAsync(LANDiscoveryCallback callback,
std::chrono::milliseconds timeout = std::chrono::milliseconds(3000));
bool openWithConfig(const LANConfig& config);
[[nodiscard]] LANConfig getConfig() const;
void setConfig(const LANConfig& config);
[[nodiscard]] std::string getRemoteAddress() const;
[[nodiscard]] uint16_t getRemotePort() const;
[[nodiscard]] uint16_t getLocalPort() const;
[[nodiscard]] bool hasData() const;
[[nodiscard]] size_t available() const;
std::string readUntil(char delimiter, std::chrono::milliseconds timeout = std::chrono::milliseconds(5000));
std::vector<uint8_t> readExactly(size_t numBytes, std::chrono::milliseconds timeout = std::chrono::milliseconds(5000));
void writeAsync(std::span<const uint8_t> data,
std::function<void(bool success, size_t bytesWritten)> callback);
void readAsync(size_t maxBytes,
std::function<void(const std::vector<uint8_t>&, bool success)> callback);
int ping(std::chrono::milliseconds timeout = std::chrono::milliseconds(1000));
[[nodiscard]] std::string getLastError() const override;
[[nodiscard]] int getLastErrorCode() const;
[[nodiscard]] std::string getLastErrorMessage() const;
private:
struct Impl;
std::unique_ptr<Impl> pImpl_;
LANConfig config_;
};
}
```
## File: CAdmin/Backend/main.cpp
```cpp
#include "Application.hpp"
#include <wx/app.h>
wxIMPLEMENT_APP(Cognitive::App::Application);
```
## File: CAdmin/Backend/MainFrame.cpp
```cpp
#include "MainFrame.hpp"
#include "Application.hpp"
#include "ShowcaseResource.hpp"
#include "WebBridge.hpp"
#include "DeviceManager.hpp"
#include "Configurator.hpp"
#include "Debug.hpp"
#include <wx/artprov.h>
#include <wx/config.h>
#include <wx/filedlg.h>
#include <wx/msgdlg.h>
#include <wx/aboutdlg.h>
#include <iostream>
#ifdef _WIN32
#include <windows.h>
#include <dwmapi.h>
#include <windowsx.h>
#ifdef IsMaximized
#undef IsMaximized
#endif
#ifdef IsMinimized
#undef IsMinimized
#endif
#pragma comment(lib, "dwmapi.lib")
constexpr int BORDERLESS_RESIZE_BORDER = 8;
constexpr int BORDERLESS_CAPTION_HEIGHT = 32;
constexpr int TITLEBAR_BUTTON_WIDTH = 46;
constexpr int TITLEBAR_BUTTON_COUNT = 3;
#endif
namespace Cognitive::App {
wxBEGIN_EVENT_TABLE(MainFrame, wxFrame)
EVT_CLOSE(MainFrame::OnClose)
EVT_SIZE(MainFrame::OnSize)
EVT_MOVE(MainFrame::OnMove)
EVT_MENU(wxID_EXIT, MainFrame::OnMenuExit)
EVT_MENU(wxID_PREFERENCES, MainFrame::OnMenuPreferences)
EVT_MENU(wxID_ABOUT, MainFrame::OnMenuAbout)
EVT_MENU(ID_VIEW_DEVTOOLS, MainFrame::OnMenuDevTools)
EVT_MENU(ID_VIEW_REFRESH, MainFrame::OnMenuReload)
wxEND_EVENT_TABLE()
MainFrame::MainFrame()
: wxFrame(nullptr, wxID_ANY, "Cognitive LLC Printer Administrator",
wxDefaultPosition, wxSize(1280, 900),
wxDEFAULT_FRAME_STYLE)
{
CADMIN_LOG_DEBUG("MainFrame::MainFrame() - Creating controls...");
normalPos_ = GetPosition();
normalSize_ = GetSize();
CreateControls();
CADMIN_LOG_DEBUG("MainFrame::MainFrame() - Binding events...");
BindEvents();
Centre();
#ifdef _WIN32
SetupDWMExtensions();
#endif
CADMIN_LOG_DEBUG("MainFrame::MainFrame() - Constructor complete");
}
MainFrame::MainFrame(const wxString& title, const wxPoint& pos, const wxSize& size)
: wxFrame(nullptr, wxID_ANY, title, pos, size, wxDEFAULT_FRAME_STYLE)
{
normalPos_ = pos;
normalSize_ = size;
CreateControls();
BindEvents();
#ifdef _WIN32
SetupDWMExtensions();
#endif
}
MainFrame::~MainFrame() {
CADMIN_LOG_DEBUG("MainFrame::~MainFrame() - Destructor called");
}
void MainFrame::CreateControls() {
CADMIN_LOG_DEBUG("MainFrame::CreateControls() - SetupMenuBar...");
SetupMenuBar();
CADMIN_LOG_DEBUG("MainFrame::CreateControls() - SetupStatusBar...");
SetupStatusBar();
CADMIN_LOG_DEBUG("MainFrame::CreateControls() - SetupWebView...");
SetupWebView();
CADMIN_LOG_DEBUG("MainFrame::CreateControls() - Complete");
}
void MainFrame::SetupMenuBar() {
menuBar_ = new wxMenuBar();
wxMenu* fileMenu = new wxMenu();
fileMenu->Append(wxID_OPEN, "&Open Configuration...\tCtrl+O");
fileMenu->Append(wxID_SAVE, "&Save Configuration\tCtrl+S");
fileMenu->AppendSeparator();
fileMenu->Append(wxID_EXIT, "E&xit\tAlt+F4");
menuBar_->Append(fileMenu, "&File");
wxMenu* editMenu = new wxMenu();
editMenu->Append(wxID_PREFERENCES, "&Preferences...\tCtrl+,");
menuBar_->Append(editMenu, "&Edit");
wxMenu* viewMenu = new wxMenu();
viewMenu->AppendCheckItem(ID_VIEW_TOOLBAR, "Show &Toolbar");
viewMenu->AppendCheckItem(ID_VIEW_STATUSBAR, "Show &Status Bar");
viewMenu->AppendSeparator();
viewMenu->Append(ID_VIEW_REFRESH, "&Refresh\tF5");
viewMenu->Append(ID_VIEW_DEVTOOLS, "Developer &Tools\tF12");
menuBar_->Append(viewMenu, "&View");
wxMenu* devicesMenu = new wxMenu();
devicesMenu->Append(ID_DEVICES_SCAN, "&Scan for Devices\tCtrl+F");
devicesMenu->Append(ID_DEVICES_CONNECT, "&Connect...");
devicesMenu->Append(ID_DEVICES_DISCONNECT, "&Disconnect");
menuBar_->Append(devicesMenu, "&Devices");
wxMenu* helpMenu = new wxMenu();
helpMenu->Append(wxID_HELP, "&Help Contents\tF1");
helpMenu->AppendSeparator();
helpMenu->Append(wxID_ABOUT, "&About...");
menuBar_->Append(helpMenu, "&Help");
wxFrame::SetMenuBar(menuBar_);
}
void MainFrame::SetupStatusBar() {
statusBar_ = wxFrame::CreateStatusBar(3);
int widths[] = {-3, -1, -1};
statusBar_->SetStatusWidths(3, widths);
statusBar_->SetStatusText("Ready", 0);
}
void MainFrame::SetupWebView() {
CADMIN_LOG_DEBUG("SetupWebView() - Checking WebView backend availability...");
#ifdef __WXMSW__
if (!wxWebView::IsBackendAvailable(wxWebViewBackendEdge)) {
CADMIN_LOG_ERROR("WebView2 runtime not available!");
wxMessageBox("Microsoft Edge WebView2 Runtime is not installed.\n\n"
"Please download and install it from:\n"
"https://developer.microsoft.com/en-us/microsoft-edge/webview2/",
"WebView2 Required", wxOK | wxICON_ERROR);
Close(true);
return;
}
CADMIN_LOG_DEBUG("SetupWebView() - WebView2 backend is available");
#endif
CADMIN_LOG_DEBUG("SetupWebView() - Creating wxWebView...");
webView_ = wxWebView::New(this, wxID_ANY, wxWebViewDefaultURLStr,
wxDefaultPosition, wxDefaultSize,
wxWebViewBackendDefault);
if (!webView_) {
CADMIN_LOG_ERROR("Failed to create wxWebView!");
wxMessageBox("Failed to create web view!\n\n"
"This may be due to missing WebView2 runtime.",
"Error", wxOK | wxICON_ERROR);
Close(true);
return;
}
CADMIN_LOG_DEBUG("SetupWebView() - wxWebView created successfully");
webView_->EnableAccessToDevTools(true);
CADMIN_LOG_DEBUG("SetupWebView() - Binding WebView events...");
webView_->Bind(wxEVT_WEBVIEW_NAVIGATING, &MainFrame::OnWebViewNavigating, this);
webView_->Bind(wxEVT_WEBVIEW_NAVIGATED, &MainFrame::OnWebViewNavigated, this);
webView_->Bind(wxEVT_WEBVIEW_LOADED, &MainFrame::OnWebViewLoaded, this);
webView_->Bind(wxEVT_WEBVIEW_ERROR, &MainFrame::OnWebViewError, this);
webView_->Bind(wxEVT_WEBVIEW_TITLE_CHANGED, &MainFrame::OnWebViewTitleChanged, this);
webView_->Bind(wxEVT_WEBVIEW_NEWWINDOW, &MainFrame::OnWebViewNewWindow, this);
webView_->Bind(wxEVT_WEBVIEW_SCRIPT_MESSAGE_RECEIVED, &MainFrame::OnWebViewScriptMessage, this);
if (!webView_->AddScriptMessageHandler("bridge")) {
CADMIN_LOG_WARN("Failed to add script message handler 'bridge'");
}
CADMIN_LOG_DEBUG("SetupWebView() - Loading Showcase HTML...");
LoadShowcase();
CADMIN_LOG_DEBUG("SetupWebView() - Complete");
}
void MainFrame::LoadShowcase() {
CADMIN_LOG_DEBUG("LoadShowcase() - Starting...");
if (!webView_) {
CADMIN_LOG_ERROR("LoadShowcase() - webView_ is null!");
return;
}
CADMIN_LOG_DEBUG("LoadShowcase() - Getting HTML content...");
std::string html = Resource::getShowcaseHTML();
CADMIN_LOG_DEBUG("LoadShowcase() - HTML size: " << html.size() << " bytes");
if (html.size() < 100) {
CADMIN_LOG_WARN("LoadShowcase() - HTML content seems too small, using fallback");
html = "<!DOCTYPE html><html><head><title>CAdmin</title></head>"
"<body style='background:#1e1e1e;color:#fff;font-family:sans-serif;'>"
"<h1>Cognitive LLC Printer Administrator</h1>"
"<p>Loading error - Showcase.html not found or invalid.</p>"
"</body></html>";
}
if (html.substr(0, 15) != "<!DOCTYPE html>" && html.substr(0, 6) != "<html>" && html[0] != '<') {
CADMIN_LOG_WARN("LoadShowcase() - HTML doesn't start with expected tag");
CADMIN_LOG_DEBUG("First 50 chars: " << html.substr(0, 50));
}
std::string cssInjection = R"CSS(
<style id="cadmin-webview-fixes">
body {
height: 100vh !important;
width: 100vw !important;
margin: 0 !important;
padding: 0 !important;
overflow: hidden !important;
}
.app-wrapper {
width: 100% !important;
height: 100% !important;
max-width: none !important;
max-height: none !important;
box-sizing: border-box !important;
display: flex !important;
flex-direction: column !important;
}
.app-container {
width: 100% !important;
height: 100% !important;
display: flex !important;
flex-direction: column !important;
flex: 1 !important;
overflow: hidden !important;
}
.tab-folder {
display: flex !important;
min-height: 26px !important;
flex-shrink: 0 !important;
background: var(--bg-face, #d4d0c8) !important;
border-bottom: 1px solid var(--border-shadow, #808080) !important;
padding: 2px 4px 0 4px !important;
overflow-x: auto !important;
overflow-y: hidden !important;
}
.tab-item {
display: inline-flex !important;
align-items: center !important;
padding: 3px 8px !important;
margin-right: 2px !important;
border: 1px solid var(--border-shadow, #808080) !important;
border-bottom: none !important;
border-top-left-radius: 3px !important;
border-top-right-radius: 3px !important;
background: var(--bg-face, #d4d0c8) !important;
cursor: pointer !important;
font-size: 10px !important;
white-space: nowrap !important;
position: relative !important;
top: 1px !important;
}
.tab-item:hover {
background: var(--border-light, #c0c0c0) !important;
}
.tab-item.active {
background: var(--bg-window, #ffffff) !important;
border-bottom: 1px solid var(--bg-window, #ffffff) !important;
z-index: 1 !important;
}
.workspace {
display: none !important;
width: 100% !important;
flex: 1 !important;
overflow: hidden !important;
}
.workspace.visible {
display: flex !important;
}
</style>
)CSS";
size_t headEnd = html.find("</head>");
if (headEnd != std::string::npos) {
html.insert(headEnd, cssInjection);
}
CADMIN_LOG_DEBUG("LoadShowcase() - Creating WebBridge...");
bridge_ = std::make_unique<UI::WebBridge>(webView_);
CADMIN_LOG_DEBUG("LoadShowcase() - Setting page content via SetPage...");
wxString wxHtml = wxString::FromUTF8(html.c_str(), html.length());
CADMIN_LOG_DEBUG("LoadShowcase() - wxString length: " << wxHtml.length());
webView_->SetPage(wxHtml, "file:
CADMIN_LOG_DEBUG("LoadShowcase() - Complete");
}
void MainFrame::BindEvents() {
}
void MainFrame::LoadURL(const wxString& url) {
if (webView_) {
webView_->LoadURL(url);
}
}
void MainFrame::LoadHTML(const wxString& html, const wxString& baseUrl) {
if (webView_) {
webView_->SetPage(html, baseUrl);
}
}
void MainFrame::Reload() {
if (webView_) {
webView_->Reload();
}
}
bool MainFrame::CanGoBack() const {
return webView_ && webView_->CanGoBack();
}
bool MainFrame::CanGoForward() const {
return webView_ && webView_->CanGoForward();
}
void MainFrame::GoBack() {
if (webView_) {
webView_->GoBack();
}
}
void MainFrame::GoForward() {
if (webView_) {
webView_->GoForward();
}
}
void MainFrame::ExecuteScript(const wxString& script) {
if (webView_) {
webView_->RunScript(script);
}
}
void MainFrame::SendToJS(const std::string& event, const std::string& data) {
if (bridge_) {
bridge_->sendEvent(event, data);
}
}
void MainFrame::OpenDevTools() {
}
bool MainFrame::SupportsDevTools() const {
return true;
}
void MainFrame::UpdateStatus(const wxString& text) {
if (statusBar_) {
statusBar_->SetStatusText(text, 0);
}
}
void MainFrame::ShowStatusBar(bool show) {
if (statusBar_) {
statusBar_->Show(show);
Layout();
}
}
void MainFrame::UpdateConnectionStatus(bool connected, const wxString& deviceName) {
if (statusBar_) {
if (connected) {
statusBar_->SetStatusText("Connected: " + deviceName, 1);
} else {
statusBar_->SetStatusText("Disconnected", 1);
}
}
}
void MainFrame::OnWebViewNavigating(wxWebViewEvent& evt) {
wxString url = evt.GetURL();
CADMIN_LOG_DEBUG("OnWebViewNavigating: " << url.ToStdString());
if (url.StartsWith("file:
evt.Skip();
return;
}
CADMIN_LOG_DEBUG("OnWebViewNavigating: Vetoing external URL");
evt.Veto();
wxLaunchDefaultBrowser(url);
}
void MainFrame::OnWebViewNavigated(wxWebViewEvent& evt) {
CADMIN_LOG_DEBUG("OnWebViewNavigated: " << evt.GetURL().ToStdString());
UpdateStatus("Navigating...");
}
void MainFrame::OnWebViewLoaded(wxWebViewEvent& evt) {
CADMIN_LOG_DEBUG("OnWebViewLoaded: " << evt.GetURL().ToStdString());
if (bridge_ && webView_) {
CADMIN_LOG_DEBUG("Injecting JavaScript API...");
std::string apiScript = bridge_->getJavaScriptAPI();
apiScript += R"JS(
(function() {
console.log('[CAdmin C++] Starting UI initialization...');
function ensureTabsVisible() {
var tabBar = document.getElementById('tab-bar');
if (tabBar) {
console.log('[CAdmin C++] tab-bar found, children:', tabBar.children.length);
if (tabBar.children.length === 0) {
console.log('[CAdmin C++] tab-bar is empty, calling renderTabs...');
if (window.CAdmin && window.CAdmin.renderTabs) {
window.CAdmin.renderTabs();
console.log('[CAdmin C++] renderTabs called, new children:', tabBar.children.length);
}
}
var firstWorkspace = document.querySelector('.workspace');
if (firstWorkspace && !document.querySelector('.workspace.visible')) {
firstWorkspace.classList.add('visible');
console.log('[CAdmin C++] Made first workspace visible');
}
} else {
console.error('[CAdmin C++] tab-bar element not found!');
}
}
function tryInit(attempt) {
console.log('[CAdmin C++] tryInit attempt', attempt);
if (window.CAdmin && typeof window.CAdmin.init === 'function') {
console.log('[CAdmin C++] Calling CAdmin.init()...');
try {
window.CAdmin.init();
console.log('[CAdmin C++] init() completed successfully');
} catch (e) {
console.error('[CAdmin C++] init() error:', e);
}
setTimeout(ensureTabsVisible, 100);
} else if (attempt < 30) {
console.log('[CAdmin C++] CAdmin not ready, retrying...');
setTimeout(function() { tryInit(attempt + 1); }, 100);
} else {
console.error('[CAdmin C++] CAdmin.init not found after 3 seconds, trying direct renderTabs');
ensureTabsVisible();
}
}
setTimeout(function() { tryInit(1); }, 50);
})();
)JS";
wxTheApp->CallAfter([this, apiScript]() {
if (webView_) {
CADMIN_LOG_DEBUG("Running API script injection...");
webView_->RunScript(apiScript);
CADMIN_LOG_DEBUG("API script injected");
if (borderlessEnabled_) {
CADMIN_LOG_DEBUG("Applying initial borderless mode...");
SetWindowMode(WindowMode::Borderless);
InjectFullWindowCSS();
}
}
});
}
UpdateStatus("Ready");
}
void MainFrame::OnWebViewError(wxWebViewEvent& evt) {
wxString errorMsg = evt.GetString();
wxString url = evt.GetURL();
int errorType = evt.GetInt();
CADMIN_LOG_ERROR("OnWebViewError: URL=" << url.ToStdString()
<< ", Error=" << errorMsg.ToStdString()
<< ", Type=" << errorType);
if (errorType == wxWEBVIEW_NAV_ERR_USER_CANCELLED) {
CADMIN_LOG_DEBUG("Navigation cancelled by user - ignoring");
return;
}
if (errorMsg.IsEmpty()) {
CADMIN_LOG_DEBUG("Empty error message - this may be a false positive, ignoring");
return;
}
wxLogError("WebView error loading '%s': %s", url, errorMsg);
UpdateStatus("Error: " + errorMsg);
}
void MainFrame::OnWebViewTitleChanged(wxWebViewEvent& evt) {
wxString title = evt.GetString();
if (!title.IsEmpty()) {
wxFrame::SetTitle(title + " - Cognitive LLC Admin");
}
}
void MainFrame::OnWebViewNewWindow(wxWebViewEvent& evt) {
wxLaunchDefaultBrowser(evt.GetURL());
evt.Veto();
}
void MainFrame::OnWebViewScriptMessage(wxWebViewEvent& evt) {
if (bridge_) {
std::string message = std::string(evt.GetString().ToUTF8());
bridge_->handleMessage(message);
}
}
void MainFrame::OnMenuExit(wxCommandEvent& evt) {
Close(true);
}
void MainFrame::OnMenuAbout(wxCommandEvent& evt) {
wxAboutDialogInfo info;
info.SetName("Cognitive LLC Printer Administrator");
info.SetVersion("1.0.0");
info.SetDescription("Cross-platform printer configuration and testing utility");
info.SetCopyright("(C) 2024 Cognitive LLC");
info.SetWebSite("https://www.cognitivetpg.com");
wxAboutBox(info, this);
}
void MainFrame::OnMenuPreferences(wxCommandEvent& evt) {
if (webView_) {
webView_->RunScript("window.location.hash = '#/settings';");
}
}
void MainFrame::OnMenuDevTools(wxCommandEvent& evt) {
OpenDevTools();
}
void MainFrame::OnMenuReload(wxCommandEvent& evt) {
Reload();
}
void MainFrame::OnClose(wxCloseEvent& evt) {
CADMIN_LOG_DEBUG("OnClose() - Window is closing. CanVeto=" << evt.CanVeto());
evt.Skip();
}
void MainFrame::OnSize(wxSizeEvent& evt) {
if (webView_) {
webView_->SetSize(GetClientSize());
}
if (!IsMaximized() && windowMode_ == WindowMode::Normal) {
normalSize_ = GetSize();
}
evt.Skip();
}
void MainFrame::OnMove(wxMoveEvent& evt) {
if (!IsMaximized() && windowMode_ == WindowMode::Normal) {
normalPos_ = GetPosition();
}
evt.Skip();
}
void MainFrame::SetWindowMode(WindowMode mode) {
if (mode == windowMode_) {
return;
}
CADMIN_LOG_DEBUG("SetWindowMode() - Changing to " << (mode == WindowMode::Borderless ? "Borderless" : "Normal"));
windowMode_ = mode;
if (mode == WindowMode::Borderless) {
ApplyBorderlessStyle();
} else {
ApplyNormalStyle();
}
}
void MainFrame::ApplyThemeWindowStyle(const std::string& themeName) {
CADMIN_LOG_DEBUG("ApplyThemeWindowStyle() - Theme: " << themeName);
if (webView_) {
std::string refreshScript = R"JS(
(function() {
window.dispatchEvent(new CustomEvent('theme-changed', {detail: {theme: 'THEME_NAME'}}));
void document.body.offsetHeight;
console.log('[CAdmin] Theme CSS refresh triggered');
})();
)JS";
size_t pos = refreshScript.find("THEME_NAME");
if (pos != std::string::npos) {
refreshScript.replace(pos, 10, themeName);
}
webView_->RunScript(refreshScript);
}
}
void MainFrame::SetBorderlessEnabled(bool enabled) {
CADMIN_LOG_DEBUG("SetBorderlessEnabled() - enabled: " << (enabled ? "true" : "false"));
borderlessEnabled_ = enabled;
if (enabled) {
SetWindowMode(WindowMode::Borderless);
InjectFullWindowCSS();
} else {
SetWindowMode(WindowMode::Normal);
}
}
void MainFrame::ApplyBorderlessStyle() {
CADMIN_LOG_DEBUG("ApplyBorderlessStyle() - Applying...");
isMaximized_ = IsMaximized();
if (!isMaximized_) {
normalPos_ = GetPosition();
normalSize_ = GetSize();
}
if (menuBar_) {
wxFrame::SetMenuBar(nullptr);
}
if (statusBar_) {
statusBar_->Hide();
}
#ifdef _WIN32
HWND hwnd = (HWND)GetHandle();
LONG style = GetWindowLong(hwnd, GWL_STYLE);
style &= ~WS_CAPTION;
style |= WS_THICKFRAME | WS_MINIMIZEBOX | WS_MAXIMIZEBOX | WS_SYSMENU;
SetWindowLong(hwnd, GWL_STYLE, style);
MARGINS margins = {1, 1, 1, 1};
DwmExtendFrameIntoClientArea(hwnd, &margins);
DWORD cornerPref = 2;
DwmSetWindowAttribute(hwnd, 33 , &cornerPref, sizeof(cornerPref));
SetWindowPos(hwnd, nullptr, 0, 0, 0, 0,
SWP_FRAMECHANGED | SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER | SWP_NOOWNERZORDER);
CADMIN_LOG_DEBUG("ApplyBorderlessStyle() - Window style applied");
#endif
Layout();
if (webView_) {
webView_->SetSize(GetClientSize());
}
Refresh();
}
void MainFrame::ApplyNormalStyle() {
CADMIN_LOG_DEBUG("ApplyNormalStyle() - Applying...");
RemoveCustomTitleBar();
if (menuBar_) {
wxFrame::SetMenuBar(menuBar_);
}
if (statusBar_) {
statusBar_->Show();
}
#ifdef _WIN32
HWND hwnd = (HWND)GetHandle();
LONG style = GetWindowLong(hwnd, GWL_STYLE);
style |= WS_CAPTION | WS_THICKFRAME | WS_MINIMIZEBOX | WS_MAXIMIZEBOX | WS_SYSMENU | WS_OVERLAPPEDWINDOW;
SetWindowLong(hwnd, GWL_STYLE, style);
LONG exStyle = GetWindowLong(hwnd, GWL_EXSTYLE);
exStyle |= WS_EX_WINDOWEDGE;
SetWindowLong(hwnd, GWL_EXSTYLE, exStyle);
wxSize currentSize = GetSize();
SetWindowPos(hwnd, nullptr, 0, 0, currentSize.GetWidth(), currentSize.GetHeight(),
SWP_FRAMECHANGED | SWP_NOMOVE | SWP_NOZORDER | SWP_NOOWNERZORDER);
CADMIN_LOG_DEBUG("ApplyNormalStyle() - Window style restored");
#endif
Layout();
if (webView_) {
webView_->SetSize(GetClientSize());
}
Refresh();
}
void MainFrame::InjectFullWindowCSS() {
if (!webView_) return;
const wxString cssAndTitleBarScript = R"JS(
(function() {
var style = document.createElement('style');
style.id = 'cadmin-fullwindow-style';
style.textContent = `
:root {
--container-size: 100% !important;
--titlebar-height: 32px;
--titlebar-button-width: 46px;
}
body {
background-color: var(--bg-face) !important;
}
.app-wrapper {
width: 100% !important;
height: 100% !important;
border: none !important;
box-shadow: none !important;
border-radius: 0 !important;
}
/* Custom title bar for borderless mode */
.cadmin-titlebar {
position: fixed;
top: 0;
left: 0;
right: 0;
height: var(--titlebar-height);
background: var(--bg-face);
display: flex;
align-items: center;
justify-content: flex-end;
z-index: 10000;
-webkit-app-region: drag;
app-region: drag;
}
/* Title bar buttons container */
.cadmin-titlebar-buttons {
display: flex;
height: 100%;
-webkit-app-region: no-drag;
app-region: no-drag;
}
/* Window control buttons */
.cadmin-titlebar-btn {
width: var(--titlebar-button-width);
height: 100%;
border: none;
background: transparent;
color: var(--text-main);
display: flex;
align-items: center;
justify-content: center;
cursor: pointer;
transition: background-color 0.1s ease;
font-family: 'Segoe MDL2 Assets', 'Segoe Fluent Icons', system-ui;
font-size: 10px;
padding: 0;
margin: 0;
min-width: auto;
pointer-events: auto;
-webkit-app-region: no-drag;
app-region: no-drag;
}
.cadmin-titlebar-btn:hover {
background: rgba(0, 0, 0, 0.1);
}
.cadmin-titlebar-btn:active {
background: rgba(0, 0, 0, 0.15);
}
.cadmin-titlebar-btn.close:hover {
background: #e81123;
color: white;
}
.cadmin-titlebar-btn.close:active {
background: #bf0f1d;
color: white;
}
.cadmin-titlebar-btn.disabled {
color: var(--text-secondary);
opacity: 0.4;
cursor: default;
}
.cadmin-titlebar-btn.disabled:hover {
background: transparent;
}
/* Dark mode overrides */
[data-theme="dark_mode"] .cadmin-titlebar-btn:hover,
[data-theme="retro_terminal"] .cadmin-titlebar-btn:hover {
background: rgba(255, 255, 255, 0.1);
}
[data-theme="dark_mode"] .cadmin-titlebar-btn:active,
[data-theme="retro_terminal"] .cadmin-titlebar-btn:active {
background: rgba(255, 255, 255, 0.15);
}
[data-theme="high_contrast"] .cadmin-titlebar-btn {
border: 1px solid var(--border-light);
}
[data-theme="high_contrast"] .cadmin-titlebar-btn:hover {
background: var(--accent-primary);
}
/* SVG icons for buttons */
.cadmin-titlebar-btn svg {
width: 10px;
height: 10px;
fill: currentColor;
}
/* Offset app content to account for title bar */
.app-wrapper {
margin-top: var(--titlebar-height) !important;
height: calc(100% - var(--titlebar-height)) !important;
}
`;
var existing = document.getElementById('cadmin-fullwindow-style');
if (existing) existing.remove();
document.head.appendChild(style);
var existingTitlebar = document.getElementById('cadmin-titlebar');
if (existingTitlebar) existingTitlebar.remove();
var titlebar = document.createElement('div');
titlebar.id = 'cadmin-titlebar';
titlebar.className = 'cadmin-titlebar';
titlebar.innerHTML = `
<div class="cadmin-titlebar-buttons">
<button class="cadmin-titlebar-btn minimize" id="cadmin-btn-minimize" title="Minimize">
<svg viewBox="0 0 10 10"><path d="M0,5 L10,5" stroke="currentColor" stroke-width="1" fill="none"/></svg>
</button>
<button class="cadmin-titlebar-btn maximize disabled" id="cadmin-btn-maximize" title="Maximize (disabled)" disabled>
<svg viewBox="0 0 10 10"><rect x="0.5" y="0.5" width="9" height="9" stroke="currentColor" stroke-width="1" fill="none"/></svg>
</button>
<button class="cadmin-titlebar-btn close" id="cadmin-btn-close" title="Close">
<svg viewBox="0 0 10 10"><path d="M0,0 L10,10 M10,0 L0,10" stroke="currentColor" stroke-width="1" fill="none"/></svg>
</button>
</div>
`;
document.body.insertBefore(titlebar, document.body.firstChild);
function setupTitlebarButton(buttonId, action) {
var btn = document.getElementById(buttonId);
if (btn) {
btn.addEventListener('click', function(e) {
e.preventDefault();
e.stopPropagation();
console.log('[CAdmin] ' + action + ' button clicked');
if (window.Backend && window.Backend._call) {
window.Backend._call('Backend_WindowControl', {action: action})
.then(function() {
console.log('[CAdmin] ' + action + ' command sent successfully');
})
.catch(function(err) {
console.error('[CAdmin] ' + action + ' error:', err);
});
} else {
console.warn('[CAdmin] Backend not available for ' + action);
}
}, true);
btn.addEventListener('pointerdown', function(e) {
e.preventDefault();
e.stopPropagation();
}, true);
}
}
setupTitlebarButton('cadmin-btn-minimize', 'minimize');
setupTitlebarButton('cadmin-btn-close', 'close');
var maxBtn = document.getElementById('cadmin-btn-maximize');
if (maxBtn) {
maxBtn.addEventListener('click', function(e) {
e.preventDefault();
e.stopPropagation();
}, true);
}
console.log('[CAdmin] Custom title bar injected for borderless mode');
})();
)JS";
webView_->RunScript(cssAndTitleBarScript);
CADMIN_LOG_DEBUG("InjectFullWindowCSS() - CSS and title bar injected");
}
void MainFrame::RemoveCustomTitleBar() {
if (!webView_) return;
const wxString removeScript = R"JS(
(function() {
var titlebar = document.getElementById('cadmin-titlebar');
if (titlebar) titlebar.remove();
var style = document.getElementById('cadmin-fullwindow-style');
if (style) style.remove();
console.log('[CAdmin] Custom title bar removed');
})();
)JS";
webView_->RunScript(removeScript);
CADMIN_LOG_DEBUG("RemoveCustomTitleBar() - Title bar removed");
}
#ifdef _WIN32
void MainFrame::SetupDWMExtensions() {
HWND hwnd = (HWND)GetHandle();
BOOL enabled = TRUE;
DwmSetWindowAttribute(hwnd, 2 , &enabled, sizeof(enabled));
}
WXLRESULT MainFrame::MSWWindowProc(WXUINT message, WXWPARAM wParam, WXLPARAM lParam) {
if (windowMode_ == WindowMode::Borderless) {
switch (message) {
case WM_NCCALCSIZE: {
if (wParam == TRUE) {
NCCALCSIZE_PARAMS* params = (NCCALCSIZE_PARAMS*)lParam;
params->rgrc[0].top += 1;
return 0;
}
break;
}
case WM_NCHITTEST: {
int x = GET_X_LPARAM(lParam);
int y = GET_Y_LPARAM(lParam);
LRESULT hitResult = HTCLIENT;
if (hitTestNonClientArea(x, y, hitResult)) {
return hitResult;
}
return HTCLIENT;
}
case WM_NCACTIVATE: {
return TRUE;
}
case WM_GETMINMAXINFO: {
MINMAXINFO* mmi = (MINMAXINFO*)lParam;
HMONITOR monitor = MonitorFromWindow((HWND)GetHandle(), MONITOR_DEFAULTTONEAREST);
if (monitor) {
MONITORINFO mi;
mi.cbSize = sizeof(mi);
if (GetMonitorInfo(monitor, &mi)) {
mmi->ptMaxPosition.x = mi.rcWork.left - mi.rcMonitor.left;
mmi->ptMaxPosition.y = mi.rcWork.top - mi.rcMonitor.top;
mmi->ptMaxSize.x = mi.rcWork.right - mi.rcWork.left;
mmi->ptMaxSize.y = mi.rcWork.bottom - mi.rcWork.top;
}
}
return 0;
}
}
}
return wxFrame::MSWWindowProc(message, wParam, lParam);
}
bool MainFrame::hitTestNonClientArea(int screenX, int screenY, LRESULT& result) {
POINT pt = {screenX, screenY};
::ScreenToClient((HWND)GetHandle(), &pt);
wxSize size = GetClientSize();
int width = size.GetWidth();
int height = size.GetHeight();
const int RESIZE_BORDER = 8;
bool left = (pt.x < RESIZE_BORDER);
bool right = (pt.x >= width - RESIZE_BORDER);
bool top = (pt.y < RESIZE_BORDER);
bool bottom = (pt.y >= height - RESIZE_BORDER);
if (top && left) {
result = HTTOPLEFT;
return true;
}
if (top && right) {
result = HTTOPRIGHT;
return true;
}
if (bottom && left) {
result = HTBOTTOMLEFT;
return true;
}
if (bottom && right) {
result = HTBOTTOMRIGHT;
return true;
}
if (!top) {
if (left) {
result = HTLEFT;
return true;
}
if (right) {
result = HTRIGHT;
return true;
}
}
if (top) {
result = HTTOP;
return true;
}
if (bottom) {
result = HTBOTTOM;
return true;
}
if (pt.y < BORDERLESS_CAPTION_HEIGHT) {
int buttonAreaStart = width - (TITLEBAR_BUTTON_WIDTH * TITLEBAR_BUTTON_COUNT);
if (pt.x < buttonAreaStart) {
result = HTCAPTION;
return true;
}
}
result = HTCLIENT;
return false;
}
#endif
void MainFrame::onDeviceEvent(const std::string& deviceId, UIDeviceEvent event) {
wxTheApp->CallAfter([this, deviceId, event]() {
std::string eventName;
switch (event) {
case UIDeviceEvent::Connected:
eventName = "connected";
UpdateStatus("Device connected");
UpdateConnectionStatus(true, wxString::FromUTF8(deviceId));
break;
case UIDeviceEvent::Disconnected:
eventName = "disconnected";
UpdateStatus("Device disconnected");
UpdateConnectionStatus(false);
break;
case UIDeviceEvent::DataReceived:
eventName = "dataReceived";
break;
case UIDeviceEvent::Error:
eventName = "error";
UpdateStatus("Device error");
break;
}
if (bridge_) {
std::string json = "{\"deviceId\":\"" + deviceId + "\",\"event\":\"" + eventName + "\"}";
bridge_->sendEvent("deviceEvent", json);
}
});
}
}
```
## File: CAdmin/Backend/MainFrame.hpp
```
#pragma once
#include <wx/wx.h>
#include <wx/webview.h>
#include "WebBridge.hpp"
#include <memory>
#ifdef _WIN32
#include <dwmapi.h>
#endif
namespace Cognitive::App {
enum MainFrameIds {
ID_VIEW_TOOLBAR = wxID_HIGHEST + 1,
ID_VIEW_STATUSBAR,
ID_VIEW_REFRESH,
ID_VIEW_DEVTOOLS,
ID_DEVICES_SCAN,
ID_DEVICES_CONNECT,
ID_DEVICES_DISCONNECT,
ID_PRINT_TEST,
ID_PRINT_LABEL,
ID_NETWORK_SERVER,
ID_NETWORK_CLIENT
};
enum class UIDeviceEvent {
Connected,
Disconnected,
DataReceived,
Error
};
enum class WindowMode {
Normal,
Borderless
};
class MainFrame : public wxFrame {
public:
MainFrame();
MainFrame(const wxString& title, const wxPoint& pos, const wxSize& size);
~MainFrame() override;
wxWebView* GetWebView() const { return webView_; }
UI::WebBridge* GetBridge() const { return bridge_.get(); }
void LoadURL(const wxString& url);
void LoadHTML(const wxString& html, const wxString& baseUrl = "");
/**
* @brief Reloads current page
*/
void Reload();
/**
* @brief Checks if WebView can go back
* @return true if can go back
*/
bool CanGoBack() const;
/**
* @brief Checks if WebView can go forward
* @return true if can go forward
*/
bool CanGoForward() const;
/**
* @brief Navigates back
*/
void GoBack();
/**
* @brief Navigates forward
*/
void GoForward();
// ==================== JavaScript ====================
/**
* @brief Executes JavaScript in WebView
* @param script JavaScript code
*/
void ExecuteScript(const wxString& script);
/**
* @brief Sends event to JavaScript
* @param event Event name
* @param data Event data (JSON)
*/
void SendToJS(const std::string& event, const std::string& data);
// ==================== DevTools ====================
/**
* @brief Opens developer tools (if supported)
*/
void OpenDevTools();
/**
* @brief Checks if dev tools are supported
* @return true if supported
*/
bool SupportsDevTools() const;
// ==================== Status ====================
/**
* @brief Sets status bar text
* @param text Status text
*/
void UpdateStatus(const wxString& text);
/**
* @brief Shows/hides status bar
* @param show true to show
*/
void ShowStatusBar(bool show);
/**
* @brief Updates connection status indicator
* @param connected true if connected
* @param deviceName Connected device name
*/
void UpdateConnectionStatus(bool connected, const wxString& deviceName = "");
void SetWindowMode(WindowMode mode);
WindowMode GetWindowMode() const { return windowMode_; }
void SetBorderlessEnabled(bool enabled);
bool IsBorderlessEnabled() const { return borderlessEnabled_; }
void ApplyThemeWindowStyle(const std::string& themeName);
private:
wxWebView* webView_ = nullptr;
std::unique_ptr<UI::WebBridge> bridge_;
wxStatusBar* statusBar_ = nullptr;
wxMenuBar* menuBar_ = nullptr;
WindowMode windowMode_ = WindowMode::Borderless;
bool borderlessEnabled_ = true;
bool isMaximized_ = false;
wxPoint normalPos_;
wxSize normalSize_;
void CreateControls();
void SetupWebView();
void LoadShowcase();
void SetupMenuBar();
void SetupStatusBar();
void BindEvents();
void ApplyBorderlessStyle();
void ApplyNormalStyle();
void InjectFullWindowCSS();
void RemoveCustomTitleBar();
#ifdef _WIN32
void SetupDWMExtensions();
WXLRESULT MSWWindowProc(WXUINT message, WXWPARAM wParam, WXLPARAM lParam) override;
bool hitTestNonClientArea(int x, int y, LRESULT& result);
#endif
void OnClose(wxCloseEvent& evt);
void OnSize(wxSizeEvent& evt);
void OnMove(wxMoveEvent& evt);
void OnWebViewNavigating(wxWebViewEvent& evt);
void OnWebViewNavigated(wxWebViewEvent& evt);
void OnWebViewLoaded(wxWebViewEvent& evt);
void OnWebViewError(wxWebViewEvent& evt);
void OnWebViewTitleChanged(wxWebViewEvent& evt);
void OnWebViewNewWindow(wxWebViewEvent& evt);
void OnWebViewScriptMessage(wxWebViewEvent& evt);
void OnMenuExit(wxCommandEvent& evt);
void OnMenuAbout(wxCommandEvent& evt);
void OnMenuPreferences(wxCommandEvent& evt);
void OnMenuDevTools(wxCommandEvent& evt);
void OnMenuReload(wxCommandEvent& evt);
void onDeviceEvent(const std::string& deviceId, UIDeviceEvent event);
wxDECLARE_EVENT_TABLE();
};
}
```
## File: CAdmin/Backend/Obfuscation.cpp
```cpp
#include "Obfuscation.hpp"
namespace Cognitive::Security {
}
```
## File: CAdmin/Backend/Obfuscation.hpp
```
#pragma once
#include <array>
#include <cstddef>
#include <cstdint>
#include <string>
#include <string_view>
namespace Cognitive::Security {
constexpr uint8_t generateKey(size_t seed) noexcept {
constexpr uint8_t baseKey = 0x5A;
constexpr uint8_t prime1 = 31;
constexpr uint8_t prime2 = 17;
constexpr uint8_t prime3 = 13;
uint8_t k = static_cast<uint8_t>(
(baseKey ^ (seed * prime1)) +
((seed * seed) % prime2) +
((seed >> 1) ^ prime3)
);
return k;
}
template<size_t N>
class ObfuscatedString {
std::array<char, N> data_;
public:
consteval ObfuscatedString(const char(&str)[N]) noexcept : data_{} {
for (size_t i = 0; i < N; ++i) {
data_[i] = static_cast<char>(str[i] ^ generateKey(i));
}
}
[[nodiscard]] std::string decrypt() const {
std::string result;
result.reserve(N - 1);
for (size_t i = 0; i < N - 1; ++i) {
result += static_cast<char>(data_[i] ^ generateKey(i));
}
return result;
}
[[nodiscard]] constexpr size_t size() const noexcept { return N - 1; }
[[nodiscard]] constexpr bool empty() const noexcept { return N <= 1; }
};
template<size_t N>
ObfuscatedString(const char(&)[N]) -> ObfuscatedString<N>;
}
#define OBF(str) (::Cognitive::Security::ObfuscatedString(str).decrypt())
```
## File: CAdmin/Backend/PrinterHelper.cpp
```cpp
#include "PrinterHelper.hpp"
#include "CPLParser.hpp"
#include <sstream>
#include <regex>
#include <thread>
#include <mutex>
namespace Cognitive::Business {
static std::mutex printer_mutex_;
std::shared_ptr<HAL::Device> PrinterHelper::printer_ = nullptr;
bool PrinterStatus::parseFromResponse(const std::string& response) {
rawStatus = response;
std::regex statusRegex("[RoOUP](\\d{5})");
std::smatch match;
if (std::regex_search(response, match, statusRegex)) {
std::string flags = match[1].str();
char statusChar = response[match.position()];
ready = (statusChar == 'R' || statusChar == 'o' || statusChar == 'O');
paused = (statusChar == 'P');
if (flags.length() >= 5) {
paperOut = (flags[0] != '0');
headUp = (flags[1] != '0');
ribbonOut = (flags[2] != '0');
error = (flags[4] != '0');
}
return true;
}
return false;
}
std::string PrinterStatus::toString() const {
std::ostringstream oss;
if (ready) oss << "Ready";
else if (paused) oss << "Paused";
else oss << "Not Ready";
if (paperOut) oss << ", Paper Out";
if (headUp) oss << ", Head Up";
if (ribbonOut) oss << ", Ribbon Out";
if (error) oss << ", Error";
return oss.str();
}
void PrinterHelper::setDevice(std::shared_ptr<HAL::Device> device) {
std::lock_guard<std::mutex> lock(printer_mutex_);
printer_ = device;
}
std::shared_ptr<HAL::Device> PrinterHelper::getDevice() {
std::lock_guard<std::mutex> lock(printer_mutex_);
return printer_;
}
bool PrinterHelper::isConnected() {
std::lock_guard<std::mutex> lock(printer_mutex_);
return printer_ && printer_->isOpen();
}
std::string PrinterHelper::queryStatus() {
return OBF("!QS\r\n");
}
std::string PrinterHelper::queryRevision() {
return OBF("!QR\r\n");
}
std::string PrinterHelper::setDarkness(int value) {
value = std::max(0, std::min(30, value));
return OBF("!D") + std::to_string(value) + "\r\n";
}
std::string PrinterHelper::setSpeed(int value) {
value = std::max(1, std::min(6, value));
std::ostringstream oss;
oss << OBF("!0 0 0 0\nVARIABLE SPEED ") << value << OBF("\nEND\n");
return oss.str();
}
std::string PrinterHelper::calibrate(int type) {
std::ostringstream oss;
oss << OBF("!CAL ") << type << "\r\n";
return oss.str();
}
std::string PrinterHelper::printTestLabel() {
std::ostringstream oss;
oss << OBF("! 0 100 100 1\n");
oss << OBF("TEXT 3 0 10 10 TEST LABEL\n");
oss << OBF("END\n");
return oss.str();
}
std::string PrinterHelper::printSelfTest() {
return OBF("!PRINT TESTLABEL\n!L\n");
}
std::string PrinterHelper::feed(int lines) {
std::ostringstream oss;
oss << OBF("!F") << lines << "\r\n";
return oss.str();
}
std::string PrinterHelper::formFeed() {
return OBF("!FF\r\n");
}
std::string PrinterHelper::variableReset() {
return OBF("!!0 0 0 0\n!0 0 0 0\nVARIABLE RESET\nEND\n");
}
std::string PrinterHelper::factoryRestore() {
return OBF("!!0 0 0 0\n!0 0 0 0\nVARIABLE FACTORY_RESTORE\nEND\n");
}
std::string PrinterHelper::getVariableCommand(const std::string& name) {
return OBF("!0 0 0 0\nVARIABLE ") + name + OBF(" ?\nEND\n");
}
std::string PrinterHelper::setVariableCommand(const std::string& name, const std::string& value) {
return OBF("!0 0 0 0\nVARIABLE ") + name + " " + value + OBF("\nEND\n");
}
std::string PrinterHelper::showCommand(const std::string& what) {
return OBF("!SHOW ") + what + "\r\n";
}
std::string PrinterHelper::loadCommand(const std::string& what, const std::string& value) {
return OBF("!LOAD ") + what + " " + value + "\r\n";
}
bool PrinterHelper::send(const std::string& command) {
std::shared_ptr<HAL::Device> device;
{
std::lock_guard<std::mutex> lock(printer_mutex_);
device = printer_;
}
if (!device || !device->isOpen()) return false;
return device->writeString(command);
}
bool PrinterHelper::send(const std::vector<uint8_t>& data) {
std::shared_ptr<HAL::Device> device;
{
std::lock_guard<std::mutex> lock(printer_mutex_);
device = printer_;
}
if (!device || !device->isOpen()) return false;
return device->write(data);
}
std::string PrinterHelper::commandWaitResponse(const std::string& command,
std::chrono::milliseconds timeout) {
std::shared_ptr<HAL::Device> device;
{
std::lock_guard<std::mutex> lock(printer_mutex_);
device = printer_;
}
if (!device || !device->isOpen()) return "";
if (!device->writeString(command)) return "";
return device->readString(4096, timeout);
}
std::string PrinterHelper::getVariable(const std::string& name) {
std::string cmd = getVariableCommand(name);
std::string response = commandWaitResponse(cmd);
if (response.empty()) return "";
return CPLParser::getResponseValue(response, cmd);
}
bool PrinterHelper::setVariable(const std::string& name, const std::string& value) {
std::string cmd = setVariableCommand(name, value);
return send(cmd);
}
std::string PrinterHelper::setAndGetVariable(const std::string& name, const std::string& value) {
if (!setVariable(name, value)) return "";
// Small delay for variable to be set
std::this_thread::sleep_for(std::chrono::milliseconds(100));
return getVariable(name);
}
bool PrinterHelper::waitFor(const std::string& pattern, int seconds) {
std::shared_ptr<HAL::Device> device;
{
std::lock_guard<std::mutex> lock(printer_mutex_);
device = printer_;
}
if (!device || !device->isOpen()) return false;
auto timeout = std::chrono::seconds(seconds);
auto start = std::chrono::steady_clock::now();
std::regex re(pattern, std::regex::icase);
std::string accumulated;
while (std::chrono::steady_clock::now() - start < timeout) {
std::string data = device->readString(1024, std::chrono::milliseconds(100));
accumulated += data;
if (std::regex_search(accumulated, re)) {
return true;
}
}
return false;
}
// ==================== Status ====================
PrinterStatus PrinterHelper::getStatus() {
PrinterStatus status;
std::string response = commandWaitResponse(queryStatus());
status.parseFromResponse(response);
return status;
}
std::map<std::string, std::string> PrinterHelper::parseStatusResponse(const std::string& response) {
std::map<std::string, std::string> result;
// Parse status format: X00000 where X is status char and 00000 are flags
std::regex statusRegex("([RoOUP])(\\d{5})");
std::smatch match;
if (std::regex_search(response, match, statusRegex)) {
std::string statusChar = match[1].str();
std::string flags = match[2].str();
result["statusChar"] = statusChar;
result["ready"] = (statusChar == "R" || statusChar == "o" || statusChar == "O") ? "true" : "false";
result["paused"] = (statusChar == "P") ? "true" : "false";
if (flags.length() >= 5) {
result["paperOut"] = (flags[0] != '0') ? "true" : "false";
result["headUp"] = (flags[1] != '0') ? "true" : "false";
result["ribbonOut"] = (flags[2] != '0') ? "true" : "false";
result["error"] = (flags[4] != '0') ? "true" : "false";
}
result["rawFlags"] = flags;
}
result["rawResponse"] = response;
return result;
}
std::string PrinterHelper::queryVariable(const std::string& name) {
if (name == "all") {
return OBF("!0 0 0 0\nVARIABLE ?\nEND\n");
}
return getVariableCommand(name);
}
bool PrinterHelper::isReady() {
return getStatus().ready;
}
std::string PrinterHelper::getModelNumber() {
std::string response = commandWaitResponse(showCommand("MODELNUMBER"));
return CPLParser::clean(CPLParser::getResponseValue(response, "SHOW MODELNUMBER"));
}
std::string PrinterHelper::getSerialNumber() {
std::string response = commandWaitResponse(showCommand("SERIALNUMBER"));
return CPLParser::clean(CPLParser::getResponseValue(response, "SHOW SERIALNUMBER"));
}
std::string PrinterHelper::getFirmwareVersion() {
std::string response = commandWaitResponse(queryRevision());
std::regex versionRegex("(\\d{3}-\\d{3}-\\d{3})");
std::smatch match;
if (std::regex_search(response, match, versionRegex)) {
return match[1].str();
}
return CPLParser::clean(response);
}
std::string PrinterHelper::getMACAddress() {
std::string response = commandWaitResponse(showCommand("MAC"));
return CPLParser::clean(CPLParser::getResponseValue(response, "SHOW MAC"));
}
void PrinterHelper::printTestLabel(const std::string& tof, const std::string& shiftLeft,
const std::string& message) {
std::ostringstream label;
label << OBF("!0 100 200 1\n");
label << OBF("INDEX\n");
label << OBF("END\n");
send(label.str());
label.str("");
// Get width and pitch for label
std::string width = getVariable("WIDTH");
std::string pitch = getVariable("PITCH");
if (width.empty()) width = "220";
if (pitch.empty()) pitch = "200";
std::string widthMatch = CPLParser::getMatch(width, "\\d+");
float fWidth = std::stof(widthMatch.empty() ? "220" : widthMatch);
int iPitch = std::stoi(pitch);
int iDots = static_cast<int>(fWidth / 100.0f * iPitch);
std::string widthDots = std::to_string(iDots);
std::string companyName = OBF("COGNITIVE TPG");
label << OBF("!0 100 250 1\n");
label << OBF("DRAW_BOX 0 0 ") << widthDots << OBF(" 2 3\n");
label << OBF("DRAW_BOX 0 0 2 200 3\n");
label << OBF("U B24 (3,0,0) 20 20 ") << companyName << "\n";
label << OBF("U B24 (3,0,0) 20 60 Test Page\n");
if (!tof.empty()) {
label << OBF("U B24 (3,0,0) 20 100 TOF: ") << tof << "\n";
}
if (!shiftLeft.empty()) {
label << OBF("U B24 (3,0,0) 20 140 Shift: ") << shiftLeft << "\n";
}
if (!message.empty()) {
label << OBF("U B24 (3,0,0) 20 180 ") << message << "\n";
}
label << OBF("END\n");
send(label.str());
}
}
```
## File: CAdmin/Backend/PrinterHelper.hpp
```
#pragma once
#include "Obfuscation.hpp"
#include "Device.hpp"
#include <string>
#include <memory>
#include <chrono>
#include <functional>
#include <map>
namespace Cognitive::Business {
struct PrinterStatus {
bool ready = false;
bool paperOut = false;
bool headUp = false;
bool ribbonOut = false;
bool paused = false;
bool error = false;
std::string rawStatus;
bool parseFromResponse(const std::string& response);
[[nodiscard]] std::string toString() const;
};
struct PrinterVariable {
std::string name;
std::string value;
std::string description;
};
using PrinterCallback = std::function<void(bool success, const std::string& result)>;
class PrinterHelper {
public:
static void setDevice(std::shared_ptr<HAL::Device> device);
static std::shared_ptr<HAL::Device> getDevice();
static bool isConnected();
static std::string queryStatus();
static std::string queryRevision();
static std::string setDarkness(int value);
static std::string setSpeed(int value);
static std::string calibrate(int type = 0);
static std::string printTestLabel();
static std::string printSelfTest();
static std::string feed(int lines = 1);
static std::string formFeed();
static std::string variableReset();
static std::string factoryRestore();
static std::string getVariableCommand(const std::string& name);
static std::string setVariableCommand(const std::string& name, const std::string& value);
static std::string showCommand(const std::string& what);
static std::string loadCommand(const std::string& what, const std::string& value);
static bool send(const std::string& command);
static bool send(const std::vector<uint8_t>& data);
static std::string commandWaitResponse(const std::string& command,
std::chrono::milliseconds timeout = std::chrono::milliseconds(5000));
static std::string getVariable(const std::string& name);
static bool setVariable(const std::string& name, const std::string& value);
static std::string setAndGetVariable(const std::string& name, const std::string& value);
static bool waitFor(const std::string& pattern, int seconds);
static PrinterStatus getStatus();
static std::map<std::string, std::string> parseStatusResponse(const std::string& response);
static std::string queryVariable(const std::string& name);
static bool isReady();
static std::string getModelNumber();
static std::string getSerialNumber();
static std::string getFirmwareVersion();
static std::string getMACAddress();
static void printTestLabel(const std::string& tof, const std::string& shiftLeft,
const std::string& message = "");
// ==================== Response Patterns ====================
static constexpr const char* GENERAL_PRINTER_READY = ".*[RoOU]00000.*";
static constexpr const char* PEELER_PRINTER_READY = ".*[RoOUP]0000.*";
private:
static std::shared_ptr<HAL::Device> printer_;
};
}
```
## File: CAdmin/Backend/SerialDevice.cpp
```cpp
#include "SerialDevice.hpp"
#include <span>
#include <thread>
#ifdef _WIN32
#include <windows.h>
#else
#include <dirent.h>
#include <sys/stat.h>
#include <sys/ioctl.h>
#include <termios.h>
#include <fcntl.h>
#include <unistd.h>
#endif
namespace Cognitive::HAL {
bool SerialConfig::fromString(const std::string& str) {
try {
size_t pos = 0;
size_t nextPos = str.find(',');
if (nextPos != std::string::npos) {
baudRate = std::stoul(str.substr(pos, nextPos));
pos = nextPos + 1;
}
nextPos = str.find(',', pos);
if (nextPos != std::string::npos) {
dataBits = static_cast<uint8_t>(std::stoul(str.substr(pos, nextPos - pos)));
pos = nextPos + 1;
}
nextPos = str.find(',', pos);
if (nextPos != std::string::npos) {
char p = str[pos];
switch (p) {
case 'N': case 'n': parity = SerialParity::None; break;
case 'O': case 'o': parity = SerialParity::Odd; break;
case 'E': case 'e': parity = SerialParity::Even; break;
default: parity = SerialParity::None;
}
pos = nextPos + 1;
}
if (pos < str.length()) {
int sb = std::stoi(str.substr(pos));
stopBits = (sb == 2) ? SerialStopBits::Two : SerialStopBits::One;
}
return true;
} catch (...) {
return false;
}
}
std::string SerialConfig::toString() const {
char parityChar = 'N';
switch (parity) {
case SerialParity::Odd: parityChar = 'O'; break;
case SerialParity::Even: parityChar = 'E'; break;
case SerialParity::Mark: parityChar = 'M'; break;
case SerialParity::Space: parityChar = 'S'; break;
default: parityChar = 'N';
}
int stopBitsValue = (stopBits == SerialStopBits::Two) ? 2 : 1;
return std::to_string(baudRate) + "," +
std::to_string(dataBits) + "," +
parityChar + "," +
std::to_string(stopBitsValue);
}
struct SerialDevice::Impl {
boost::asio::io_context ownedIo;
boost::asio::io_context* io;
boost::asio::serial_port port;
bool isOpen = false;
std::string lastError;
Impl() : io(&ownedIo), port(ownedIo) {}
explicit Impl(boost::asio::io_context& externalIo) : io(&externalIo), port(externalIo) {}
};
SerialDevice::SerialDevice() : pImpl_(std::make_unique<Impl>()) {
}
SerialDevice::SerialDevice(boost::asio::io_context& io) : pImpl_(std::make_unique<Impl>(io)) {
}
SerialDevice::~SerialDevice() {
close();
}
SerialDevice::SerialDevice(SerialDevice&&) noexcept = default;
SerialDevice& SerialDevice::operator=(SerialDevice&&) noexcept = default;
bool SerialDevice::open(const std::string& path) {
path_ = path;
try {
pImpl_->port.open(path);
if (!applySettings()) {
pImpl_->port.close();
pImpl_->lastError = "Failed to apply serial port settings";
return false;
}
pImpl_->isOpen = true;
isOpen_ = true;
return true;
} catch (const boost::system::system_error& e) {
pImpl_->lastError = "Failed to open port: " + std::string(e.what());
return false;
}
}
bool SerialDevice::openWithConfig(const std::string& portName, const SerialConfig& config) {
config_ = config;
if (open(portName)) {
return setConfig(config);
}
return false;
}
void SerialDevice::close() {
if (!pImpl_->port.is_open()) return;
boost::system::error_code ec;
pImpl_->port.close(ec);
pImpl_->isOpen = false;
isOpen_ = false;
}
bool SerialDevice::isOpen() const {
return pImpl_->port.is_open();
}
bool SerialDevice::write(std::span<const uint8_t> data) {
if (!pImpl_->isOpen) {
pImpl_->lastError = "Device not open";
return false;
}
try {
size_t written = boost::asio::write(pImpl_->port,
boost::asio::buffer(data.data(), data.size()));
return written == data.size();
} catch (const boost::system::system_error& e) {
pImpl_->lastError = "Write failed: " + std::string(e.what());
return false;
}
}
std::vector<uint8_t> SerialDevice::read(size_t maxBytes, std::chrono::milliseconds timeout) {
std::vector<uint8_t> buffer(maxBytes);
if (!pImpl_->isOpen) {
pImpl_->lastError = "Device not open";
return {};
}
try {
size_t bytesRead = 0;
boost::system::error_code readError;
bool readComplete = false;
pImpl_->port.async_read_some(
boost::asio::buffer(buffer),
[&](const boost::system::error_code& ec, size_t bytes) {
readError = ec;
bytesRead = bytes;
readComplete = true;
}
);
pImpl_->io->restart();
auto deadline = std::chrono::steady_clock::now() + timeout;
while (!readComplete && std::chrono::steady_clock::now() < deadline) {
pImpl_->io->run_for(std::chrono::milliseconds(10));
}
if (!readComplete) {
pImpl_->port.cancel();
pImpl_->io->run();
return {};
}
if (!readError && bytesRead > 0) {
buffer.resize(bytesRead);
return buffer;
}
return {};
} catch (const boost::system::system_error& e) {
pImpl_->lastError = "Read error: " + std::string(e.what());
return {};
}
}
std::string SerialDevice::readUntil(char delimiter, std::chrono::milliseconds timeout) {
if (!pImpl_->isOpen) {
pImpl_->lastError = "Device not open";
return "";
}
std::string result;
auto deadline = std::chrono::steady_clock::now() + timeout;
try {
while (std::chrono::steady_clock::now() < deadline) {
auto remaining = std::chrono::duration_cast<std::chrono::milliseconds>(
deadline - std::chrono::steady_clock::now());
if (remaining.count() <= 0) break;
auto chunk = read(256, remaining);
if (chunk.empty()) {
continue;
}
for (uint8_t byte : chunk) {
result += static_cast<char>(byte);
if (byte == static_cast<uint8_t>(delimiter)) {
return result;
}
}
}
return result;
} catch (const std::exception& e) {
pImpl_->lastError = "readUntil error: " + std::string(e.what());
return result;
}
}
std::vector<uint8_t> SerialDevice::readExactly(size_t numBytes, std::chrono::milliseconds timeout) {
if (!pImpl_->isOpen) {
pImpl_->lastError = "Device not open";
return {};
}
std::vector<uint8_t> result;
result.reserve(numBytes);
auto deadline = std::chrono::steady_clock::now() + timeout;
try {
while (result.size() < numBytes && std::chrono::steady_clock::now() < deadline) {
auto remaining = std::chrono::duration_cast<std::chrono::milliseconds>(
deadline - std::chrono::steady_clock::now());
if (remaining.count() <= 0) break;
size_t needed = numBytes - result.size();
auto chunk = read(needed, remaining);
if (!chunk.empty()) {
result.insert(result.end(), chunk.begin(), chunk.end());
}
}
if (result.size() < numBytes) {
pImpl_->lastError = "Timeout: received " + std::to_string(result.size()) +
" of " + std::to_string(numBytes) + " bytes";
return {};
}
return result;
} catch (const std::exception& e) {
pImpl_->lastError = "readExactly error: " + std::string(e.what());
return {};
}
}
std::string SerialDevice::getDescription() const {
std::string desc = "Serial Port";
if (!path_.empty()) {
desc += " [" + path_ + "]";
}
desc += " @ " + std::to_string(config_.baudRate) + " baud";
return desc;
}
SerialConfig SerialDevice::getConfig() const {
return config_;
}
bool SerialDevice::setConfig(const SerialConfig& config) {
config_ = config;
return applySettings();
}
bool SerialDevice::setBaudRate(uint32_t baudRate) {
config_.baudRate = baudRate;
if (pImpl_->port.is_open()) {
try {
pImpl_->port.set_option(boost::asio::serial_port_base::baud_rate(baudRate));
return true;
} catch (...) {
return false;
}
}
return true;
}
uint32_t SerialDevice::getBaudRate() const {
return config_.baudRate;
}
bool SerialDevice::applySettings() {
if (!pImpl_->port.is_open()) return false;
try {
pImpl_->port.set_option(boost::asio::serial_port_base::baud_rate(config_.baudRate));
pImpl_->port.set_option(boost::asio::serial_port_base::character_size(config_.dataBits));
boost::asio::serial_port_base::parity::type parityType =
boost::asio::serial_port_base::parity::none;
switch (config_.parity) {
case SerialParity::Odd: parityType = boost::asio::serial_port_base::parity::odd; break;
case SerialParity::Even: parityType = boost::asio::serial_port_base::parity::even; break;
default: parityType = boost::asio::serial_port_base::parity::none; break;
}
pImpl_->port.set_option(boost::asio::serial_port_base::parity(parityType));
boost::asio::serial_port_base::stop_bits::type stopBitsType =
boost::asio::serial_port_base::stop_bits::one;
switch (config_.stopBits) {
case SerialStopBits::Two: stopBitsType = boost::asio::serial_port_base::stop_bits::two; break;
case SerialStopBits::OnePointFive: stopBitsType = boost::asio::serial_port_base::stop_bits::onepointfive; break;
default: stopBitsType = boost::asio::serial_port_base::stop_bits::one; break;
}
pImpl_->port.set_option(boost::asio::serial_port_base::stop_bits(stopBitsType));
boost::asio::serial_port_base::flow_control::type flowType =
boost::asio::serial_port_base::flow_control::none;
switch (config_.flowControl) {
case SerialFlowControl::Software: flowType = boost::asio::serial_port_base::flow_control::software; break;
case SerialFlowControl::Hardware: flowType = boost::asio::serial_port_base::flow_control::hardware; break;
default: flowType = boost::asio::serial_port_base::flow_control::none; break;
}
pImpl_->port.set_option(boost::asio::serial_port_base::flow_control(flowType));
return true;
} catch (const boost::system::system_error& e) {
pImpl_->lastError = "Failed to apply settings: " + std::string(e.what());
return false;
}
}
void SerialDevice::setDTR(bool state) {
if (!pImpl_->port.is_open()) return;
#ifdef _WIN32
auto handle = pImpl_->port.native_handle();
EscapeCommFunction(handle, state ? SETDTR : CLRDTR);
#else
int fd = pImpl_->port.native_handle();
int flags;
ioctl(fd, TIOCMGET, &flags);
if (state) {
flags |= TIOCM_DTR;
} else {
flags &= ~TIOCM_DTR;
}
ioctl(fd, TIOCMSET, &flags);
#endif
}
void SerialDevice::setRTS(bool state) {
if (!pImpl_->port.is_open()) return;
#ifdef _WIN32
auto handle = pImpl_->port.native_handle();
EscapeCommFunction(handle, state ? SETRTS : CLRRTS);
#else
int fd = pImpl_->port.native_handle();
int flags;
ioctl(fd, TIOCMGET, &flags);
if (state) {
flags |= TIOCM_RTS;
} else {
flags &= ~TIOCM_RTS;
}
ioctl(fd, TIOCMSET, &flags);
#endif
}
bool SerialDevice::getCTS() const {
if (!pImpl_->port.is_open()) return false;
#ifdef _WIN32
auto handle = pImpl_->port.native_handle();
DWORD status = 0;
GetCommModemStatus(handle, &status);
return (status & MS_CTS_ON) != 0;
#else
int fd = pImpl_->port.native_handle();
int flags = 0;
ioctl(fd, TIOCMGET, &flags);
return (flags & TIOCM_CTS) != 0;
#endif
}
bool SerialDevice::getDSR() const {
if (!pImpl_->port.is_open()) return false;
#ifdef _WIN32
auto handle = pImpl_->port.native_handle();
DWORD status = 0;
GetCommModemStatus(handle, &status);
return (status & MS_DSR_ON) != 0;
#else
int fd = pImpl_->port.native_handle();
int flags = 0;
ioctl(fd, TIOCMGET, &flags);
return (flags & TIOCM_DSR) != 0;
#endif
}
void SerialDevice::sendBreak(std::chrono::milliseconds duration) {
if (!pImpl_->port.is_open()) return;
#ifdef _WIN32
auto handle = pImpl_->port.native_handle();
SetCommBreak(handle);
std::this_thread::sleep_for(duration);
ClearCommBreak(handle);
#else
int fd = pImpl_->port.native_handle();
(void)duration;
tcsendbreak(fd, 0);
#endif
}
void SerialDevice::flushInput() {
if (!pImpl_->port.is_open()) return;
#ifdef _WIN32
auto handle = pImpl_->port.native_handle();
PurgeComm(handle, PURGE_RXCLEAR);
#else
int fd = pImpl_->port.native_handle();
tcflush(fd, TCIFLUSH);
#endif
}
void SerialDevice::flushOutput() {
if (!pImpl_->port.is_open()) return;
#ifdef _WIN32
auto handle = pImpl_->port.native_handle();
PurgeComm(handle, PURGE_TXCLEAR);
#else
int fd = pImpl_->port.native_handle();
tcflush(fd, TCOFLUSH);
#endif
}
size_t SerialDevice::available() const {
if (!pImpl_->port.is_open()) return 0;
#ifdef _WIN32
auto handle = pImpl_->port.native_handle();
COMSTAT stat;
DWORD errors;
if (ClearCommError(handle, &errors, &stat)) {
return stat.cbInQue;
}
return 0;
#else
int fd = pImpl_->port.native_handle();
int bytes = 0;
ioctl(fd, FIONREAD, &bytes);
return static_cast<size_t>(bytes);
#endif
}
std::vector<std::string> SerialDevice::enumerate() {
std::vector<std::string> ports;
#ifdef _WIN32
char target[5000];
for (int i = 1; i <= 256; i++) {
std::string portName = "COM" + std::to_string(i);
DWORD result = QueryDosDeviceA(portName.c_str(), target, sizeof(target));
if (result != 0) {
ports.push_back(portName);
}
}
#elif defined(__APPLE__)
DIR* dir = opendir("/dev");
if (dir) {
struct dirent* entry;
while ((entry = readdir(dir)) != nullptr) {
std::string name = entry->d_name;
if (name.find("tty.") == 0 || name.find("cu.") == 0) {
ports.push_back("/dev/" + name);
}
}
closedir(dir);
}
#else
DIR* dir = opendir("/dev");
if (dir) {
struct dirent* entry;
while ((entry = readdir(dir)) != nullptr) {
std::string name = entry->d_name;
if (name.find("ttyUSB") == 0 ||
name.find("ttyACM") == 0 ||
name.find("ttyS") == 0) {
ports.push_back("/dev/" + name);
}
}
closedir(dir);
}
#endif
return ports;
}
std::vector<SerialPortInfo> SerialDevice::enumerateDetailed() {
std::vector<SerialPortInfo> ports;
auto simplePorts = enumerate();
for (const auto& portName : simplePorts) {
SerialPortInfo info;
info.portName = portName;
info.description = "Serial Port " + portName;
info.available = true;
#ifdef _WIN32
info.manufacturer = "Unknown";
#else
info.manufacturer = "Unknown";
#endif
ports.push_back(info);
}
return ports;
}
}
```
## File: CAdmin/Backend/SerialDevice.hpp
```
#pragma once
#include "Device.hpp"
#include <boost/asio.hpp>
#include <memory>
namespace Cognitive::HAL {
enum class SerialParity {
None,
Odd,
Even,
Mark,
Space
};
enum class SerialStopBits {
One,
OnePointFive,
Two
};
enum class SerialFlowControl {
None,
Software,
Hardware
};
struct SerialConfig {
uint32_t baudRate = 115200;
uint8_t dataBits = 8;
SerialParity parity = SerialParity::None;
SerialStopBits stopBits = SerialStopBits::One;
SerialFlowControl flowControl = SerialFlowControl::None;
bool fromString(const std::string& str);
std::string toString() const;
};
struct SerialPortInfo {
std::string portName;
std::string description;
std::string manufacturer;
std::string hardwareId;
bool available = true;
};
class SerialDevice : public Device {
public:
SerialDevice();
explicit SerialDevice(boost::asio::io_context& io);
~SerialDevice() override;
SerialDevice(const SerialDevice&) = delete;
SerialDevice& operator=(const SerialDevice&) = delete;
SerialDevice(SerialDevice&&) noexcept;
SerialDevice& operator=(SerialDevice&&) noexcept;
bool open(const std::string& path) override;
void close() override;
[[nodiscard]] bool isOpen() const override;
bool write(std::span<const uint8_t> data) override;
std::vector<uint8_t> read(size_t maxBytes, std::chrono::milliseconds timeout) override;
[[nodiscard]] DeviceType getType() const override { return DeviceType::Serial; }
[[nodiscard]] std::string getPath() const override { return path_; }
[[nodiscard]] std::string getDescription() const override;
static std::vector<std::string> enumerate();
static std::vector<SerialPortInfo> enumerateDetailed();
bool openWithConfig(const std::string& portName, const SerialConfig& config);
[[nodiscard]] SerialConfig getConfig() const;
bool setConfig(const SerialConfig& config);
bool setBaudRate(uint32_t baudRate);
[[nodiscard]] uint32_t getBaudRate() const;
std::string readUntil(char delimiter, std::chrono::milliseconds timeout = std::chrono::milliseconds(5000));
std::vector<uint8_t> readExactly(size_t numBytes, std::chrono::milliseconds timeout = std::chrono::milliseconds(5000));
void setDTR(bool state);
void setRTS(bool state);
[[nodiscard]] bool getCTS() const;
[[nodiscard]] bool getDSR() const;
void sendBreak(std::chrono::milliseconds duration = std::chrono::milliseconds(250));
void flushInput();
void flushOutput();
[[nodiscard]] size_t available() const;
private:
struct Impl;
std::unique_ptr<Impl> pImpl_;
SerialConfig config_;
bool applySettings();
};
}
```
## File: CAdmin/Backend/ShowcaseResource.cpp
```cpp
#include "ShowcaseResource.hpp"
#include "Compression.hpp"
#include "Debug.hpp"
#include <fstream>
#include <sstream>
#include <cstdint>
#include <vector>
#include <iostream>
#ifdef _WIN32
#include <windows.h>
#endif
namespace Cognitive::Resource {
#ifndef EMBEDDED_SHOWCASE_HTML_SIZE
#define EMBEDDED_SHOWCASE_HTML_SIZE 0
#endif
#ifndef EMBEDDED_SHOWCASE_HTML_DATA
static const uint8_t embeddedShowcaseData[] = { 0 };
#define EMBEDDED_SHOWCASE_HTML_DATA embeddedShowcaseData
#endif
static const char* fallbackHTML = R"HTMLRAW(
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<title>Cognitive LLC Printer Administrator</title>
<style>
:root {
--bg-face: #f0f0f0;
--bg-window: #ffffff;
--text-main: #000000;
--text-secondary: #666666;
--border-light: #ffffff;
--border-shadow: #a0a0a0;
--border-dark: #696969;
--group-text: #0046d5;
--status-red: #ff0000;
--status-green: #008000;
--accent-primary: #0078d7;
--accent-hover: #005a9e;
--font-family: 'Tahoma', 'Segoe UI', sans-serif;
--font-size-base: 11px;
--font-size-small: 9px;
--border-radius: 3px;
--button-height: 20px;
--spacing-xs: 2px;
--spacing-sm: 4px;
--spacing-md: 8px;
--spacing-lg: 12px;
--z-base: 1;
--z-dropdown: 100;
--z-modal: 1000;
--container-size: min(88vh, 88vw);
}
[data-theme="light_mode"] {
--bg-face: #f0f0f0;
--bg-window: #ffffff;
--text-main: #000000;
--text-secondary: #666666;
--border-light: #ffffff;
--border-shadow: #a0a0a0;
--border-dark: #696969;
--group-text: #0046d5;
--accent-primary: #0078d7;
--accent-hover: #005a9e;
--font-family: 'Segoe UI', 'Tahoma', sans-serif;
--border-radius: 3px;
}
[data-theme="dark_mode"] {
--bg-face: #1e1e1e;
--bg-window: #252526;
--text-main: #cccccc;
--text-secondary: #888888;
--border-light: #3e3e42;
--border-shadow: #2b2b2b;
--border-dark: #1e1e1e;
--group-text: #4fc3f7;
--accent-primary: #0e639c;
--accent-hover: #1177bb;
--font-family: 'Segoe UI', sans-serif;
}
[data-theme="glassmorphism"] {
--bg-face: rgba(255, 255, 255, 0.15);
--bg-window: rgba(255, 255, 255, 0.25);
--text-main: #1a1a2e;
--text-secondary: #4a4a6a;
--border-light: rgba(255, 255, 255, 0.4);
--border-shadow: rgba(200, 200, 220, 0.3);
--border-dark: rgba(150, 150, 180, 0.4);
--group-text: #6366f1;
--accent-primary: #8b5cf6;
--accent-hover: #7c3aed;
--font-family: 'Segoe UI', system-ui, sans-serif;
--border-radius: 12px;
--glass-blur: blur(20px);
--glass-saturate: saturate(180%);
}
[data-theme="legacy_style"] {
--bg-face: #d4d0c8;
--bg-window: #ffffff;
--text-main: #000000;
--text-secondary: #505050;
--border-light: #ffffff;
--border-shadow: #808080;
--border-dark: #404040;
--group-text: #000080;
--accent-primary: #0a246a;
--accent-hover: #316ac5;
--font-family: 'MS Sans Serif', 'Tahoma', sans-serif;
--border-radius: 0px;
--button-gradient: linear-gradient(180deg, #ffffff 0%, #d4d0c8 50%, #c0c0c0 100%);
}
[data-theme="space"] {
--bg-face: #0a0a1a;
--bg-window: #12122a;
--text-main: #e0e0ff;
--text-secondary: #8888bb;
--border-light: #2a2a4a;
--border-shadow: #1a1a3a;
--border-dark: #0a0a2a;
--group-text: #00d4ff;
--accent-primary: #6366f1;
--accent-hover: #818cf8;
--status-red: #ff4444;
--status-green: #44ff88;
--font-family: 'Segoe UI', sans-serif;
--border-radius: 6px;
--glow-color: rgba(99, 102, 241, 0.5);
}
[data-theme="nebula"] {
--bg-face: #1a0a2e;
--bg-window: #2a1a3e;
--text-main: #f0e6ff;
--text-secondary: #b8a8d8;
--border-light: #4a2a6e;
--border-shadow: #3a1a5e;
--border-dark: #2a0a4e;
--group-text: #ff6ec7;
--accent-primary: #bf5af2;
--accent-hover: #da8fff;
--status-red: #ff4466;
--status-green: #66ffaa;
--font-family: 'Segoe UI', sans-serif;
--border-radius: 8px;
--nebula-gradient: linear-gradient(135deg, #1a0a2e 0%, #2a1a4e 25%, #3a2a6e 50%, #2a1a4e 75%, #1a0a2e 100%);
--aurora-glow: 0 0 20px rgba(191, 90, 242, 0.3);
}
[data-theme="high_contrast"] {
--bg-face: #000000;
--bg-window: #000000;
--text-main: #ffffff;
--text-secondary: #ffff00;
--border-light: #ffffff;
--border-shadow: #ffffff;
--border-dark: #ffffff;
--group-text: #00ff00;
--accent-primary: #1aebff;
--accent-hover: #00ffff;
--status-red: #ff0000;
--status-green: #00ff00;
--font-family: 'Segoe UI', sans-serif;
--border-radius: 0px;
}
* {
box-sizing: border-box;
}
body {
font-family: var(--font-family);
font-size: var(--font-size-base);
background-color: #2a2a2a;
color: var(--text-main);
margin: 0;
padding: 0;
height: 100vh;
width: 100vw;
overflow: hidden;
user-select: none;
-webkit-user-select: none;
-moz-user-select: none;
display: flex;
align-items: center;
justify-content: center;
}
.app-wrapper {
width: var(--container-size);
height: var(--container-size);
background: var(--bg-face);
box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
border: 2px solid var(--border-dark);
display: flex;
flex-direction: column;
transition: all 0.3s ease;
position: relative;
overflow: hidden;
}
[data-theme="glassmorphism"] .app-wrapper {
background: linear-gradient(135deg, #a8c0ff 0%, #c8b6ff 50%, #e8d5ff 100%);
}
[data-theme="glassmorphism"] .app-container {
background: rgba(255, 255, 255, 0.25);
backdrop-filter: blur(20px);
-webkit-backdrop-filter: blur(20px);
}
[data-theme="glassmorphism"] .app-header {
background: rgba(255, 255, 255, 0.3);
backdrop-filter: blur(20px);
-webkit-backdrop-filter: blur(20px);
border-bottom: 1px solid rgba(255, 255, 255, 0.4);
}
[data-theme="glassmorphism"] .sidebar-panel,
[data-theme="glassmorphism"] .main-panel {
background: rgba(255, 255, 255, 0.2);
backdrop-filter: blur(20px);
-webkit-backdrop-filter: blur(20px);
}
[data-theme="glassmorphism"] .group-box {
background: rgba(255, 255, 255, 0.15);
border: 1px solid rgba(255, 255, 255, 0.3);
box-shadow: 0 4px 16px rgba(0, 0, 0, 0.1);
}
[data-theme="glassmorphism"] .tab-item {
background: rgba(255, 255, 255, 0.2);
backdrop-filter: blur(10px);
-webkit-backdrop-filter: blur(10px);
}
[data-theme="glassmorphism"] .tab-item.active {
background: rgba(139, 92, 246, 0.4);
color: white;
}
[data-theme="glassmorphism"] button {
background: rgba(255, 255, 255, 0.3);
backdrop-filter: blur(10px);
-webkit-backdrop-filter: blur(10px);
border: 1px solid rgba(255, 255, 255, 0.4);
}
[data-theme="glassmorphism"] button:hover {
background: rgba(139, 92, 246, 0.3);
}
[data-theme="space"] .app-wrapper {
background: radial-gradient(ellipse at center, #1a1a3a 0%, #0a0a1a 100%);
}
[data-theme="space"] .app-wrapper::before {
content: '';
position: absolute;
top: 0;
left: 0;
right: 0;
bottom: 0;
background-image:
radial-gradient(2px 2px at 20px 30px, rgba(255,255,255,0.8), transparent),
radial-gradient(2px 2px at 40px 70px, rgba(255,255,255,0.6), transparent),
radial-gradient(1px 1px at 90px 40px, rgba(255,255,255,0.9), transparent),
radial-gradient(2px 2px at 130px 80px, rgba(255,255,255,0.5), transparent),
radial-gradient(1px 1px at 160px 120px, rgba(255,255,255,0.7), transparent),
radial-gradient(2px 2px at 200px 50px, rgba(99,102,241,0.8), transparent),
radial-gradient(1px 1px at 250px 150px, rgba(255,255,255,0.6), transparent),
radial-gradient(2px 2px at 300px 100px, rgba(255,255,255,0.8), transparent),
radial-gradient(1px 1px at 350px 200px, rgba(129,140,248,0.7), transparent),
radial-gradient(2px 2px at 400px 80px, rgba(255,255,255,0.5), transparent);
background-size: 450px 250px;
animation: space-twinkle 4s ease-in-out infinite alternate, space-drift 60s linear infinite;
pointer-events: none;
z-index: 0;
}
[data-theme="space"] .app-container {
position: relative;
z-index: 1;
background: rgba(18, 18, 42, 0.9);
}
[data-theme="space"] .group-box {
box-shadow: 0 0 15px var(--glow-color);
border: 1px solid rgba(99, 102, 241, 0.3);
}
[data-theme="space"] .tab-item.active {
box-shadow: 0 0 10px var(--glow-color);
}
[data-theme="space"] .status-box {
box-shadow: 0 0 8px rgba(255, 68, 68, 0.5);
}
[data-theme="space"] .status-box.connected {
box-shadow: 0 0 8px rgba(68, 255, 136, 0.5);
}
@keyframes space-twinkle {
0% { opacity: 0.7; }
50% { opacity: 1; }
100% { opacity: 0.8; }
}
@keyframes space-drift {
0% { background-position: 0 0; }
100% { background-position: 450px 250px; }
}
@keyframes space-particle-float {
0%, 100% { transform: translateY(0) translateX(0); opacity: 0.5; }
25% { transform: translateY(-10px) translateX(5px); opacity: 1; }
50% { transform: translateY(-5px) translateX(-3px); opacity: 0.8; }
75% { transform: translateY(-15px) translateX(8px); opacity: 0.6; }
}
/* Nebula Theme - Cosmic Gradients with Aurora Effects */
[data-theme="nebula"] .app-wrapper {
background: var(--nebula-gradient);
position: relative;
}
[data-theme="nebula"] .app-wrapper::before {
content: '';
position: absolute;
top: 0;
left: 0;
right: 0;
bottom: 0;
background:
radial-gradient(ellipse at 20% 20%, rgba(191, 90, 242, 0.3) 0%, transparent 50%),
radial-gradient(ellipse at 80% 30%, rgba(255, 110, 199, 0.2) 0%, transparent 40%),
radial-gradient(ellipse at 40% 80%, rgba(99, 102, 241, 0.25) 0%, transparent 45%),
radial-gradient(ellipse at 70% 70%, rgba(168, 85, 247, 0.2) 0%, transparent 35%);
animation: nebula-pulse 8s ease-in-out infinite alternate;
pointer-events: none;
z-index: 0;
}
[data-theme="nebula"] .app-wrapper::after {
content: '';
position: absolute;
top: 0;
left: 0;
right: 0;
bottom: 0;
background: linear-gradient(45deg,
transparent 0%,
rgba(191, 90, 242, 0.1) 25%,
transparent 50%,
rgba(255, 110, 199, 0.1) 75%,
transparent 100%);
background-size: 200% 200%;
animation: nebula-aurora 12s ease-in-out infinite;
pointer-events: none;
z-index: 0;
}
[data-theme="nebula"] .app-container {
position: relative;
z-index: 1;
background: rgba(42, 26, 62, 0.85);
}
[data-theme="nebula"] .app-header {
background: rgba(42, 26, 62, 0.9);
box-shadow: var(--aurora-glow);
}
[data-theme="nebula"] .group-box {
background: rgba(58, 26, 94, 0.5);
box-shadow: var(--aurora-glow);
border: 1px solid rgba(191, 90, 242, 0.3);
}
[data-theme="nebula"] .tab-item.active {
background: linear-gradient(135deg, rgba(191, 90, 242, 0.6), rgba(255, 110, 199, 0.4));
box-shadow: var(--aurora-glow);
}
[data-theme="nebula"] button {
background: linear-gradient(135deg, rgba(74, 42, 110, 0.8), rgba(58, 26, 94, 0.9));
border: 1px solid rgba(191, 90, 242, 0.4);
}
[data-theme="nebula"] button:hover {
background: linear-gradient(135deg, rgba(191, 90, 242, 0.5), rgba(168, 85, 247, 0.5));
box-shadow: var(--aurora-glow);
}
@keyframes nebula-pulse {
0% { opacity: 0.6; transform: scale(1); }
50% { opacity: 0.9; transform: scale(1.02); }
100% { opacity: 0.7; transform: scale(1); }
}
@keyframes nebula-aurora {
0% { background-position: 0% 50%; }
50% { background-position: 100% 50%; }
100% { background-position: 0% 50%; }
}
/* Legacy Style Special Effects - Windows XP/2000 Chiseled Look */
[data-theme="legacy_style"] button {
background: var(--button-gradient);
border-width: 2px;
border-style: solid;
border-color: #ffffff #404040 #404040 #ffffff;
}
[data-theme="legacy_style"] button:active:not(:disabled) {
border-color: #404040 #ffffff #ffffff #404040;
}
[data-theme="legacy_style"] .group-box {
border-width: 2px;
border-style: groove;
border-color: #808080;
}
[data-theme="legacy_style"] input[type="text"],
[data-theme="legacy_style"] input[type="number"],
[data-theme="legacy_style"] select,
[data-theme="legacy_style"] textarea {
border-width: 2px;
border-style: inset;
border-color: #808080;
}
[data-theme="legacy_style"] .app-header {
background: linear-gradient(180deg, #0a246a 0%, #a6caf0 100%);
color: white;
}
[data-theme="legacy_style"] .header-logo,
[data-theme="legacy_style"] .header-logo span {
color: white !important;
text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
}
[data-theme="legacy_style"] .tab-item.active {
border-width: 2px;
border-style: solid;
border-color: #ffffff #404040 #d4d0c8 #ffffff;
}
.app-container {
width: 100%;
height: 100%;
display: flex;
flex-direction: column;
background: var(--bg-face);
transition: background-color 0.3s, color 0.3s;
}
/* Cognitive Layout (Default) - Standard sidebar-left layout similar to JAdmin */
[data-layout="cognitive"] .workspace-content {
flex-direction: row;
}
[data-layout="cognitive"] .sidebar-panel {
order: 1;
width: 300px;
min-width: 300px;
height: auto;
border-right: 1px solid var(--border-shadow);
border-bottom: none;
}
[data-layout="cognitive"] .main-panel {
order: 2;
flex: 1;
width: auto;
height: auto;
}
/* Minimal Layout - Ultra-clean, content-focused with vertical tabs on left edge */
[data-layout="minimal"] .app-header {
padding: var(--spacing-sm) var(--spacing-md);
min-height: 40px;
}
[data-layout="minimal"] .header-branding {
gap: var(--spacing-sm);
}
[data-layout="minimal"] .header-logo {
font-size: 14px;
}
[data-layout="minimal"] .header-logo span:first-child {
font-size: 16px !important;
}
[data-layout="minimal"] .header-controls {
gap: var(--spacing-sm);
}
[data-layout="minimal"] .header-controls .control-group label {
font-size: 9px;
}
[data-layout="minimal"] .tab-folder {
flex-direction: column;
position: absolute;
left: 0;
top: 100px;
width: 32px;
padding: var(--spacing-xs);
background: var(--bg-face);
border-right: 1px solid var(--border-shadow);
border-bottom: none;
z-index: 10;
opacity: 0.3;
transition: opacity 0.3s, width 0.3s;
}
[data-layout="minimal"] .tab-folder:hover {
opacity: 1;
width: auto;
min-width: 100px;
}
[data-layout="minimal"] .tab-item {
writing-mode: horizontal-tb;
padding: 4px 6px;
margin: 1px 0;
font-size: 9px;
border-radius: var(--border-radius);
border: 1px solid transparent;
white-space: nowrap;
overflow: hidden;
text-overflow: ellipsis;
max-width: 24px;
transition: max-width 0.3s;
}
[data-layout="minimal"] .tab-folder:hover .tab-item {
max-width: 200px;
}
[data-layout="minimal"] .tab-item.active {
background: var(--accent-primary);
color: white;
border-color: var(--accent-primary);
}
[data-layout="minimal"] .workspace-content {
flex-direction: row;
margin-left: 32px;
}
[data-layout="minimal"] .sidebar-panel {
order: 1;
width: 240px;
min-width: 200px;
height: auto;
border-right: 1px solid var(--border-shadow);
border-bottom: none;
padding: var(--spacing-sm);
}
[data-layout="minimal"] .main-panel {
order: 2;
flex: 1;
width: auto;
height: auto;
padding: var(--spacing-sm);
}
[data-layout="minimal"] .group-box {
margin: var(--spacing-sm) 0;
padding: var(--spacing-sm);
}
[data-layout="minimal"] .section-title {
font-size: 10px;
}
[data-layout="minimal"] button {
height: 18px;
font-size: 9px;
padding: 1px 6px;
}
/* Border Options - No borders is default (Windows Store/Update style) */
.app-wrapper {
border: none;
}
[data-borders="true"] .app-wrapper {
border: 2px solid var(--border-dark);
}
/* Legacy Layout Compatibility */
[data-layout="sidebar_left"] .workspace-content {
flex-direction: row;
}
[data-layout="sidebar_left"] .sidebar-panel {
order: 1;
width: 300px;
min-width: 300px;
height: auto;
border-right: 1px solid var(--border-shadow);
border-bottom: none;
}
[data-layout="sidebar_left"] .main-panel {
order: 2;
flex: 1;
width: auto;
height: auto;
}
.app-header {
background: var(--bg-face);
padding: var(--spacing-md);
display: flex;
align-items: center;
justify-content: space-between;
border-bottom: 1px solid var(--border-shadow);
flex-shrink: 0;
min-height: 60px;
gap: var(--spacing-md);
flex-wrap: wrap;
}
.header-logo {
font-size: 18px;
font-weight: bold;
color: var(--text-main);
font-family: 'Arial Black', sans-serif;
display: flex;
flex-direction: column;
line-height: 1.2;
}
.header-logo .logo-tpg {
color: #cc0000;
display: inline;
}
.header-logo .logo-subtitle {
font-size: var(--font-size-small);
font-family: var(--font-family);
font-weight: normal;
color: var(--text-secondary);
}
.header-controls {
display: flex;
align-items: center;
gap: var(--spacing-md);
flex-wrap: wrap;
}
.control-group {
display: flex;
align-items: center;
gap: var(--spacing-sm);
}
.control-group label {
display: flex;
align-items: center;
gap: var(--spacing-sm);
white-space: nowrap;
margin: 0;
}
.header-center-spacer {
flex: 1;
}
.header-right-spacer {
flex: 0;
margin-left: auto;
}
.heartbeat-centered {
justify-content: center;
flex: 0;
}
.status-box {
min-width: 150px;
height: 32px;
background-color: var(--status-red);
color: white !important;
display: flex;
align-items: center;
padding: 0 10px;
font-weight: bold;
font-size: var(--font-size-base);
border: 2px solid var(--border-dark);
border-top-color: var(--border-shadow);
border-left-color: var(--border-shadow);
cursor: pointer;
position: relative;
user-select: none;
}
.status-box.connected {
background-color: var(--status-green);
}
.status-box:hover {
opacity: 0.9;
}
.status-menu {
position: absolute;
top: 100%;
right: 0;
background: var(--bg-window);
border: 1px solid var(--border-dark);
box-shadow: 2px 2px 4px rgba(0,0,0,0.2);
min-width: 200px;
z-index: var(--z-dropdown);
display: none;
}
.status-menu.visible {
display: block;
}
.status-menu-item {
padding: 5px 10px;
cursor: pointer;
border-bottom: 1px solid var(--border-light);
font-size: 10px;
background: var(--bg-window);
color: var(--text-main);
}
.status-menu-item:hover {
background: var(--accent-primary);
color: white;
}
[data-theme="dark_mode"] .status-menu-item:hover,
[data-theme="high_contrast"] .status-menu-item:hover,
[data-theme="space"] .status-menu-item:hover,
[data-theme="nebula"] .status-menu-item:hover {
color: var(--bg-window);
}
.tab-folder {
display: flex;
padding: var(--spacing-xs) var(--spacing-xs) 0 var(--spacing-xs);
background: var(--bg-face);
border-bottom: 1px solid var(--border-shadow);
flex-shrink: 0;
overflow-x: auto;
overflow-y: hidden;
scroll-behavior: smooth;
scrollbar-width: thin;
scrollbar-color: var(--border-shadow) var(--bg-face);
}
.tab-folder::-webkit-scrollbar {
height: 6px;
}
.tab-folder::-webkit-scrollbar-track {
background: var(--bg-face);
}
.tab-folder::-webkit-scrollbar-thumb {
background: var(--border-shadow);
border-radius: 3px;
}
.tab-folder::-webkit-scrollbar-thumb:hover {
background: var(--border-dark);
}
.tab-item {
padding: 3px 8px;
margin-right: var(--spacing-xs);
background: var(--bg-face);
border: 1px solid var(--border-shadow);
border-bottom: none;
border-top-left-radius: var(--border-radius);
border-top-right-radius: var(--border-radius);
cursor: pointer;
position: relative;
top: 1px;
color: var(--text-main);
font-size: 10px;
white-space: nowrap;
transition: background-color 0.2s;
}
.tab-item:hover {
background: var(--border-light);
}
.tab-item.active {
background: var(--bg-window);
border-left: 1px solid var(--border-light);
border-top: 1px solid var(--border-light);
border-right: 1px solid var(--border-dark);
z-index: var(--z-base);
font-weight: bold;
}
.tab-item.dragging {
opacity: 0.5;
}
.workspace {
flex: 1;
background: var(--bg-window);
display: none;
overflow: hidden;
}
.workspace.visible {
display: flex;
flex-direction: column;
}
.workspace-content {
flex: 1;
display: flex;
overflow: hidden;
transition: all 0.3s ease;
}
.sidebar-panel {
display: flex;
flex-direction: column;
padding: var(--spacing-md);
overflow-y: auto;
background: var(--bg-window);
transition: all 0.3s ease;
}
.main-panel {
display: flex;
flex-direction: column;
padding: var(--spacing-md);
overflow-y: auto;
background: var(--bg-window);
gap: var(--spacing-md);
transition: all 0.3s ease;
}
.group-box {
border: 1px solid var(--border-shadow);
border-radius: var(--border-radius);
margin-top: var(--spacing-md);
margin-bottom: var(--spacing-md);
padding: var(--spacing-md);
position: relative;
}
.group-title {
position: absolute;
top: -7px;
left: 8px;
background: var(--bg-window);
padding: 0 3px;
color: var(--group-text);
font-size: var(--font-size-base);
}
button {
font-family: var(--font-family);
font-size: 10px;
background: var(--bg-face);
border: 1px solid var(--border-dark);
border-top-color: var(--border-light);
border-left-color: var(--border-light);
border-right-color: var(--border-dark);
border-bottom-color: var(--border-dark);
border-radius: var(--border-radius);
padding: 2px 8px;
min-width: 60px;
height: var(--button-height);
color: var(--text-main);
cursor: pointer;
transition: transform 0.1s, background-color 0.2s;
}
button:hover:not(:disabled) {
background: var(--border-light);
}
button:active:not(:disabled) {
border: 1px solid var(--border-shadow);
border-right-color: var(--border-light);
border-bottom-color: var(--border-light);
transform: translate(1px, 1px);
}
button:disabled {
color: var(--text-secondary);
opacity: 0.6;
cursor: not-allowed;
}
button:focus {
outline: 2px solid var(--accent-primary);
outline-offset: 2px;
}
input[type="text"],
input[type="number"],
input[type="password"],
select,
textarea {
border: 1px solid #7f9db9;
padding: 2px 4px;
font-family: var(--font-family);
font-size: 10px;
background: var(--bg-window);
color: var(--text-main);
border-radius: var(--border-radius);
}
input:focus,
select:focus,
textarea:focus {
outline: 2px solid var(--accent-primary);
outline-offset: 1px;
}
input[readonly] {
background: var(--bg-face);
color: var(--text-secondary);
}
input:disabled,
select:disabled {
background: var(--bg-face);
color: var(--text-secondary);
opacity: 0.6;
}
label {
display: inline-flex;
align-items: center;
margin-right: var(--spacing-md);
white-space: nowrap;
cursor: pointer;
}
input[type="checkbox"],
input[type="radio"] {
margin: 0 var(--spacing-sm) 0 0;
cursor: pointer;
}
.row {
display: flex;
align-items: center;
margin-bottom: var(--spacing-sm);
gap: var(--spacing-sm);
flex-wrap: wrap;
}
.fill {
flex: 1;
min-width: 0;
}
.grid-2 {
display: grid;
grid-template-columns: auto 1fr;
gap: var(--spacing-sm);
align-items: center;
}
textarea {
font-size: 10px;
resize: vertical;
}
table {
width: 100%;
border-collapse: collapse;
border: 1px solid var(--border-dark);
background: var(--bg-window);
table-layout: fixed;
font-size: 10px;
}
th {
background: var(--bg-face);
text-align: left;
padding: var(--spacing-sm);
border-bottom: 1px solid var(--border-dark);
font-weight: normal;
border-right: 1px solid var(--border-shadow);
}
td {
padding: var(--spacing-sm);
border-bottom: 1px solid var(--border-light);
white-space: nowrap;
overflow: hidden;
text-overflow: ellipsis;
}
tr:hover {
background: var(--border-light);
}
tr.selected {
background: var(--accent-primary);
color: white;
}
.progress-container {
border: 1px solid var(--border-dark);
height: 16px;
background: var(--bg-window);
position: relative;
border-radius: var(--border-radius);
overflow: hidden;
}
.progress-bar {
height: 100%;
background: var(--accent-primary);
width: 0%;
transition: width 0.3s;
}
.printer-list {
border: 1px solid var(--border-dark);
background: var(--bg-window);
flex: 1;
overflow-y: auto;
border-radius: var(--border-radius);
}
.printer-item {
padding: 5px;
border-bottom: 1px solid var(--border-light);
display: flex;
justify-content: space-between;
align-items: center;
cursor: pointer;
transition: background-color 0.2s;
}
.printer-item:hover {
background: var(--border-light);
}
.printer-item.selected {
background: var(--accent-primary);
color: white;
}
.printer-item-left {
display: flex;
align-items: center;
gap: 5px;
}
.printer-status {
width: 10px;
height: 10px;
border-radius: 50%;
background: var(--status-red);
flex-shrink: 0;
}
.printer-status.connected {
background: var(--status-green);
}
.printer-item-port {
font-size: var(--font-size-small);
color: var(--text-secondary);
}
.printer-item.selected .printer-item-port {
color: rgba(255, 255, 255, 0.8);
}
.multi-select-dropdown {
border: 1px solid #7f9db9;
background: var(--bg-window);
min-height: 24px;
padding: var(--spacing-xs);
cursor: pointer;
position: relative;
display: flex;
flex-wrap: wrap;
gap: var(--spacing-xs);
border-radius: var(--border-radius);
}
.multi-select-tag {
background: var(--accent-primary);
color: white;
padding: 1px 5px;
border-radius: var(--border-radius);
font-size: var(--font-size-small);
display: flex;
align-items: center;
gap: 3px;
}
.multi-select-tag-remove {
cursor: pointer;
font-weight: bold;
padding: 0 2px;
}
.multi-select-tag-remove:hover {
background: rgba(255, 255, 255, 0.3);
border-radius: 2px;
}
.multi-select-options {
position: absolute;
top: 100%;
left: 0;
right: 0;
background: var(--bg-window);
border: 1px solid #7f9db9;
max-height: 200px;
overflow-y: auto;
z-index: var(--z-dropdown);
display: none;
border-radius: var(--border-radius);
box-shadow: 2px 2px 8px rgba(0,0,0,0.2);
}
.multi-select-options.visible {
display: block;
}
.multi-select-option {
padding: 3px 5px;
cursor: pointer;
font-size: 10px;
}
.multi-select-option:hover {
background: var(--border-light);
}
.multi-select-option.selected {
background: var(--accent-primary);
color: white;
}
#cpl a[data-category] {
cursor: pointer;
color: var(--accent-primary);
padding: 2px 4px;
border-radius: var(--border-radius);
text-decoration: none;
}
#cpl a[data-category]:hover {
background: var(--accent-primary);
color: #fff;
}
#cpl a[data-category].active {
background: var(--accent-secondary);
color: #000;
font-weight: bold;
}
[data-theme="dark_mode"] #cpl a[data-category].active,
[data-theme="high_contrast"] #cpl a[data-category].active,
[data-theme="space"] #cpl a[data-category].active,
[data-theme="nebula"] #cpl a[data-category].active {
color: #fff;
}
.cpl-command-card {
background: var(--bg-face);
border: 1px solid var(--border-shadow);
padding: var(--spacing-md);
margin-bottom: var(--spacing-md);
border-radius: var(--border-radius);
}
.cpl-command-title {
font-weight: bold;
color: var(--group-text);
margin-bottom: 3px;
}
.cpl-command-syntax {
font-family: 'Courier New', monospace;
font-size: var(--font-size-small);
background: var(--bg-window);
padding: 3px;
border: 1px solid var(--border-light);
margin: 3px 0;
border-radius: var(--border-radius);
}
.cpl-command-desc {
font-size: var(--font-size-small);
color: var(--text-secondary);
line-height: 1.3;
}
.cpl-response {
font-size: var(--font-size-small);
color: var(--text-secondary);
margin-top: 3px;
padding: 2px 0;
}
.cpl-response .response-bytes {
color: var(--accent-primary);
font-weight: 500;
}
.cpl-example-response {
font-size: var(--font-size-small);
margin-top: 2px;
padding: 2px 0;
}
.cpl-example-response code {
font-family: 'Courier New', monospace;
background: var(--bg-face);
padding: 2px 6px;
border-radius: 3px;
color: var(--accent-secondary);
font-weight: 500;
}
.autotest-suite {
border-bottom: 1px solid var(--border-light);
}
.autotest-suite:last-child {
border-bottom: none;
}
.autotest-suite-header {
display: flex;
align-items: center;
padding: 8px var(--spacing-md);
background: var(--bg-face);
cursor: pointer;
user-select: none;
transition: background-color 0.2s;
}
.autotest-suite-header:hover {
background: var(--border-light);
}
.autotest-suite-toggle {
width: 16px;
font-size: 10px;
color: var(--text-secondary);
transition: transform 0.2s;
}
.autotest-suite.expanded .autotest-suite-toggle {
transform: rotate(90deg);
}
.autotest-suite-title {
flex: 1;
font-weight: bold;
font-size: 11px;
}
.autotest-suite-status {
font-size: 10px;
padding: 2px 8px;
border-radius: 10px;
background: var(--bg-window);
}
.autotest-suite-status.passed {
background: rgba(0, 128, 0, 0.2);
color: var(--status-green);
}
.autotest-suite-status.failed {
background: rgba(255, 0, 0, 0.2);
color: var(--status-red);
}
.autotest-suite-status.running {
background: rgba(0, 120, 215, 0.2);
color: var(--accent-primary);
}
.autotest-suite-content {
padding: 0;
background: var(--bg-window);
}
.autotest-item {
display: flex;
align-items: center;
justify-content: space-between;
padding: 4px var(--spacing-md) 4px 28px;
font-size: 10px;
border-bottom: 1px solid var(--border-light);
}
.autotest-item:last-child {
border-bottom: none;
}
.autotest-item:hover {
background: var(--border-light);
}
.autotest-item label {
display: flex;
align-items: center;
gap: var(--spacing-sm);
cursor: pointer;
flex: 1;
}
.autotest-status {
font-size: 9px;
padding: 1px 6px;
border-radius: 8px;
min-width: 50px;
text-align: center;
}
.autotest-status.passed {
background: rgba(0, 128, 0, 0.15);
color: var(--status-green);
}
.autotest-status.failed {
background: rgba(255, 0, 0, 0.15);
color: var(--status-red);
}
.autotest-status.running {
background: rgba(0, 120, 215, 0.15);
color: var(--accent-primary);
animation: pulse 1s ease-in-out infinite;
}
.autotest-status.skipped {
background: rgba(128, 128, 128, 0.15);
color: var(--text-secondary);
}
@keyframes pulse {
0%, 100% { opacity: 1; }
50% { opacity: 0.5; }
}
[data-theme="dark_mode"] .cpl-example-response code,
[data-theme="high_contrast"] .cpl-example-response code,
[data-theme="space"] .cpl-example-response code,
[data-theme="nebula"] .cpl-example-response code {
background: #333;
color: #7df;
}
.cpl-example {
font-family: 'Courier New', monospace;
font-size: var(--font-size-small);
background: #fffbf0;
padding: 3px;
border-left: 3px solid #ffcc00;
margin-top: 3px;
border-radius: var(--border-radius);
}
[data-theme="dark_mode"] .cpl-example,
[data-theme="high_contrast"] .cpl-example,
[data-theme="space"] .cpl-example,
[data-theme="nebula"] .cpl-example {
background: var(--bg-face);
border-left-color: var(--accent-primary);
}
.debug-console {
border: 1px solid var(--border-dark);
background: #000;
color: #0f0;
font-family: 'Courier New', monospace;
font-size: var(--font-size-small);
padding: 5px;
overflow-y: auto;
height: 300px;
white-space: pre-wrap;
border-radius: var(--border-radius);
}
.log-trace { color: #888; }
.log-info { color: #0f0; }
.log-warning { color: #ff0; }
.log-error { color: #f00; }
.log-exception { color: #f0f; font-weight: bold; }
a {
color: var(--accent-primary);
text-decoration: underline;
cursor: pointer;
}
a:hover {
color: var(--accent-hover);
}
.canvas-wrapper {
flex: 1;
border: 2px solid var(--border-dark);
background: #f9f9f9;
position: relative;
overflow: auto;
border-radius: var(--border-radius);
}
[data-theme="dark_mode"] .canvas-wrapper,
[data-theme="high_contrast"] .canvas-wrapper,
[data-theme="space"] .canvas-wrapper,
[data-theme="nebula"] .canvas-wrapper {
background: var(--bg-face);
}
#canvas_el {
background: white;
cursor: crosshair;
display: block;
}
.designer-sidebar {
width: 180px;
min-width: 180px;
border-right: 1px solid var(--border-shadow);
padding: var(--spacing-md);
overflow-y: auto;
display: flex;
flex-direction: column;
gap: var(--spacing-md);
}
.designer-main {
flex: 1;
display: flex;
flex-direction: column;
padding: var(--spacing-md);
overflow: hidden;
gap: var(--spacing-sm);
}
.designer-controls {
display: flex;
justify-content: space-between;
align-items: center;
margin-bottom: 5px;
flex-wrap: wrap;
gap: var(--spacing-sm);
}
.compact-header-row {
display: flex;
align-items: center;
gap: var(--spacing-sm);
padding: var(--spacing-sm) 0;
margin-bottom: var(--spacing-sm);
flex-wrap: wrap;
}
.element-dialog {
padding: var(--spacing-md);
border: 1px solid var(--border-dark);
border-radius: var(--border-radius);
background: var(--bg-face);
color: var(--text-main);
box-shadow: 0 4px 12px rgba(0,0,0,0.3);
}
.element-dialog::backdrop {
background: rgba(0,0,0,0.5);
}
.element-dialog input, .element-dialog select {
background: var(--bg-field);
color: var(--text-main);
border: 1px solid var(--border-shadow);
padding: 4px;
}
.designer-button-row {
display: flex;
gap: var(--spacing-sm);
flex-wrap: wrap;
}
.designer-button-row button {
flex: 1;
min-width: 80px;
}
.sr-only {
position: absolute;
width: 1px;
height: 1px;
padding: 0;
margin: -1px;
overflow: hidden;
clip: rect(0, 0, 0, 0);
white-space: nowrap;
border-width: 0;
}
@media (max-width: 768px) {
.app-wrapper {
width: 100vw;
height: 100vh;
}
.app-header {
flex-direction: column;
align-items: stretch;
}
.header-controls {
flex-direction: column;
align-items: stretch;
}
[data-layout="cognitive"] .workspace-content,
[data-layout="sidebar_left"] .workspace-content {
flex-direction: column;
}
[data-layout="cognitive"] .sidebar-panel,
[data-layout="sidebar_left"] .sidebar-panel {
width: 100%;
height: 250px;
border: none;
border-bottom: 1px solid var(--border-shadow);
}
[data-layout="minimal"] .tab-folder {
position: relative;
left: 0;
top: 0;
width: 100%;
flex-direction: row;
opacity: 1;
}
[data-layout="minimal"] .workspace-content {
margin-left: 0;
flex-direction: column;
}
[data-layout="minimal"] .sidebar-panel {
width: 100%;
height: 200px;
}
.designer-sidebar {
width: 100%;
height: 200px;
border-right: none;
border-bottom: 1px solid var(--border-shadow);
}
}
.loading-spinner {
display: inline-block;
width: 14px;
height: 14px;
border: 2px solid var(--border-shadow);
border-top-color: var(--accent-primary);
border-radius: 50%;
animation: spin 0.8s linear infinite;
}
@keyframes spin {
to { transform: rotate(360deg); }
}
.section-title {
font-weight: bold;
margin-bottom: 5px;
color: var(--text-main);
}
.button-row {
display: flex;
gap: var(--spacing-sm);
margin-top: var(--spacing-md);
flex-wrap: wrap;
}
.button-row button {
flex: 1;
min-width: 80px;
}
select.compact {
height: 18px;
font-size: var(--font-size-small);
padding: 0 2px;
}
.server-dashboard {
display: grid;
grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
gap: var(--spacing-md);
padding: var(--spacing-md);
overflow-y: auto;
height: 100%;
}
.dashboard-card {
background: var(--bg-window);
border: 1px solid var(--border-shadow);
border-radius: var(--border-radius);
padding: var(--spacing-md);
display: flex;
flex-direction: column;
}
.dashboard-card-title {
font-weight: bold;
color: var(--group-text);
margin-bottom: var(--spacing-sm);
padding-bottom: var(--spacing-sm);
border-bottom: 1px solid var(--border-light);
font-size: 12px;
}
.dashboard-card-content {
flex: 1;
overflow: hidden;
}
.stat-grid {
display: grid;
grid-template-columns: repeat(2, 1fr);
gap: var(--spacing-sm);
}
.stat-item {
text-align: center;
padding: var(--spacing-sm);
background: var(--bg-face);
border-radius: var(--border-radius);
}
.stat-value {
font-size: 20px;
font-weight: bold;
color: var(--accent-primary);
}
.stat-label {
font-size: var(--font-size-small);
color: var(--text-secondary);
}
.chart-area {
height: 120px;
background: var(--bg-face);
border-radius: var(--border-radius);
position: relative;
overflow: hidden;
}
.chart-bar {
position: absolute;
bottom: 0;
width: 8px;
background: var(--accent-primary);
transition: height 0.3s ease;
border-radius: 2px 2px 0 0;
}
.chart-line {
position: absolute;
bottom: 0;
width: 100%;
height: 100%;
}
.chart-line svg {
width: 100%;
height: 100%;
}
.gauge-container {
display: flex;
justify-content: space-around;
padding: var(--spacing-sm);
}
.gauge {
width: 60px;
height: 60px;
position: relative;
}
.gauge-bg {
fill: none;
stroke: var(--border-shadow);
stroke-width: 6;
}
.gauge-fill {
fill: none;
stroke: var(--accent-primary);
stroke-width: 6;
stroke-linecap: round;
transition: stroke-dasharray 0.5s ease;
}
.gauge-text {
position: absolute;
top: 50%;
left: 50%;
transform: translate(-50%, -50%);
font-size: 11px;
font-weight: bold;
}
.gauge-label {
text-align: center;
font-size: var(--font-size-small);
color: var(--text-secondary);
margin-top: 2px;
}
.status-indicator {
display: inline-block;
width: 10px;
height: 10px;
border-radius: 50%;
margin-right: 5px;
}
.status-healthy { background: var(--status-green); }
.status-warning { background: #f0ad4e; }
.status-critical { background: var(--status-red); }
.log-feed {
height: 150px;
overflow-y: auto;
font-family: monospace;
font-size: var(--font-size-small);
background: #1a1a1a;
color: #0f0;
padding: var(--spacing-sm);
border-radius: var(--border-radius);
}
.log-entry {
padding: 2px 0;
border-bottom: 1px solid #333;
}
.ticket-list {
max-height: 120px;
overflow-y: auto;
}
.ticket-item {
padding: var(--spacing-sm);
border-bottom: 1px solid var(--border-light);
font-size: var(--font-size-small);
display: flex;
justify-content: space-between;
align-items: center;
}
.ticket-priority-high { border-left: 3px solid var(--status-red); }
.ticket-priority-medium { border-left: 3px solid #f0ad4e; }
.ticket-priority-low { border-left: 3px solid var(--status-green); }
.printer-grid {
display: grid;
grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
gap: var(--spacing-xs);
}
.printer-tile {
text-align: center;
padding: var(--spacing-sm);
background: var(--bg-face);
border-radius: var(--border-radius);
font-size: var(--font-size-small);
}
.printer-tile-icon {
font-size: 20px;
margin-bottom: 2px;
}
[data-role="customer"] .role-factory,
[data-role="customer"] .role-technician,
[data-role="customer"] .role-admin { display: none !important; }
[data-role="factory"] .role-technician,
[data-role="factory"] .role-admin { display: none !important; }
[data-role="technician"] .role-admin { display: none !important; }
[data-role="server"] .client-interface { display: none !important; }
[data-role]:not([data-role="server"]) .server-interface { display: none !important; }
.wifi-config-panel {
transition: opacity 0.3s, max-height 0.3s;
overflow: hidden;
}
.wifi-config-panel.hidden {
max-height: 0;
opacity: 0;
padding: 0;
margin: 0;
border: none;
}
.header-branding {
display: flex;
align-items: center;
gap: var(--spacing-md);
}
.role-selector {
display: flex;
flex-direction: column;
gap: 2px;
}
.role-selector label {
font-size: var(--font-size-small);
color: var(--text-secondary);
margin: 0;
}
</style>
</head>
<body data-theme="light_mode" data-layout="cognitive" data-borders="false">
<div class="app-wrapper">
<div class="app-container">
<div class="app-header">
<div class="header-branding">
<div class="header-logo">
<span style="font-size:22px;">COGNITIVE <span class="logo-tpg">LLC</span></span>
<span class="logo-subtitle" id="app_subtitle">Printer Administrator</span>
</div>
<div class="role-selector">
<label for="role_selector">Role:</label>
<select id="role_selector" class="compact" style="width:130px;">
<option value="admin">Administrator</option>
<option value="technician">Repair Technician</option>
<option value="factory">Factory Worker</option>
<option value="customer">Customer</option>
<option value="server">Server Backend</option>
</select>
</div>
</div>
<div class="header-controls">
<div class="control-group">
<label for="theme_selector">Theme:</label>
<select id="theme_selector" class="compact">
<option value="light_mode">Light Mode</option>
<option value="dark_mode">Dark Mode</option>
<option value="glassmorphism">Glassmorphism</option>
<option value="legacy_style">Legacy Style</option>
<option value="space">Space</option>
<option value="nebula">Nebula</option>
<option value="high_contrast">High Contrast</option>
</select>
</div>
<div class="control-group">
<label for="layout_selector">Layout:</label>
<select id="layout_selector" class="compact">
<option value="cognitive">Cognitive</option>
<option value="minimal">Minimal</option>
</select>
</div>
<div class="control-group">
<label><input type="checkbox" id="chk_borders"> Borders</label>
</div>
<div class="control-group header-center-spacer"></div>
<div class="control-group heartbeat-centered">
<label><input type="checkbox" id="chk_heart"> Heartbeat</label>
</div>
<div class="control-group header-right-spacer"></div>
<div id="status_box" class="status-box" tabindex="0" role="button" aria-label="Connection Status">
0 Connected
<div class="status-menu" id="status_menu" role="menu">
<div class="status-menu-item" role="menuitem" tabindex="0">Connect All</div>
<div class="status-menu-item" role="menuitem" tabindex="0">Disconnect All</div>
<div class="status-menu-item" role="menuitem" tabindex="0">Connect Selected</div>
<div class="status-menu-item" role="menuitem" tabindex="0">Disconnect Selected</div>
</div>
</div>
</div>
</div>
<div class="tab-folder" id="tab-bar" role="tablist"></div>
<div id="conn" class="workspace visible" role="tabpanel">
<div class="workspace-content">
<div class="sidebar-panel">
<div class="section-title">Printer Manager</div>
<div class="printer-list" id="printer_list" role="listbox" aria-label="Printer List"></div>
<div class="button-row">
<button id="btn_add_printer">Add Printer</button>
<button id="btn_remove_printer">Remove</button>
</div>
<div class="row">
<button id="btn_scan_devices" class="fill">Auto-Scan Devices</button>
</div>
<div class="row">
<button id="btn_connect_selected" class="fill">Connect Selected</button>
</div>
<div class="group-box">
<span class="group-title">Quick Actions</span>
<button id="btn_connect_all" style="width:100%; margin-bottom:3px;">Connect All</button>
<button id="btn_disconnect_all" style="width:100%;">Disconnect All</button>
</div>
</div>
<div class="main-panel">
<div class="group-box">
<span class="group-title">Connection Parameters</span>
<div style="padding:var(--spacing-md);">
<div style="font-weight:bold; color:var(--text-secondary); margin-bottom:var(--spacing-md);">Connection Type</div>
<div style="display:flex; flex-direction:column; gap:6px; margin-bottom:15px;">
<label><input type="radio" name="ct" value="ser" checked> Serial Connection</label>
<label><input type="radio" name="ct" value="usb"> USB Direct Connection</label>
<label><input type="radio" name="ct" value="net"> Network Connection (Ethernet/WiFi)</label>
<label><input type="radio" name="ct" value="bt"> Bluetooth Connection</label>
<label><input type="radio" name="ct" value="par"> Parallel Port Connection</label>
</div>
<div id="p_ser">
<div class="grid-2" style="max-width:350px; margin-bottom:15px;">
<span style="text-align:right;">Com Port:</span>
<select id="com_list" class="fill">
<option>COM1</option>
<option>COM2</option>
<option>COM3</option>
<option>COM4</option>
<option>COM5</option>
</select>
<span style="text-align:right;">Baud Rate:</span>
<select id="baud">
<option>9600</option>
<option>19200</option>
<option>38400</option>
<option>57600</option>
<option selected>115200</option>
</select>
<span style="text-align:right;">Stop Bits:</span>
<select id="stop_bits">
<option selected>1</option>
<option>2</option>
</select>
<span style="text-align:right;">Buffer Size:</span>
<input type="number" id="ser_buffer" value="4096" min="512" max="65536">
</div>
<div style="margin-left:85px;">
<label><input type="checkbox" id="xon_xoff"> XON/XOFF Flow Control</label><br>
<label><input type="checkbox" id="dumb_terminal"> Dumb Terminal Mode</label>
</div>
</div>
<div id="p_net" style="display:none;">
<div class="grid-2" style="max-width:350px;">
<span style="text-align:right;">IP Address:</span>
<input type="text" id="net_ip" value="192.168.1.10">
<span style="text-align:right;">Port:</span>
<input type="text" id="net_port" value="9100">
<span style="text-align:right;">Net Mask:</span>
<input type="text" id="net_mask" value="255.255.255.0">
<span style="text-align:right;">Gateway:</span>
<input type="text" id="net_gateway" value="192.168.1.1">
<span style="text-align:right;">RTEL Port:</span>
<input type="text" id="rtel_port" value="9100">
<span style="text-align:right;">Buffer Size:</span>
<input type="number" id="net_buffer" value="4096" min="512" max="65536">
</div>
<div style="margin-top:var(--spacing-sm);">
<label><input type="checkbox" id="net_dhcp" checked> Use DHCP</label>
<label style="margin-left:15px;"><input type="checkbox" id="net_lpd"> Enable LPD</label>
</div>
</div>
<div id="p_bt" style="display:none;">
<div class="grid-2" style="max-width:350px;">
<span style="text-align:right;">Bluetooth Device:</span>
<select id="bt_device" class="fill">
<option>Device 1</option>
<option>Device 2</option>
</select>
<span style="text-align:right;">Bluetooth COM:</span>
<input type="text" id="bt_com" value="COM5">
</div>
<button id="btn_scan_bluetooth" style="margin-top:var(--spacing-md);">Scan Bluetooth Devices</button>
</div>
<div id="p_par" style="display:none;">
<div class="grid-2" style="max-width:350px;">
<span style="text-align:right;">Parallel Port:</span>
<select id="par_port" class="fill">
<option>LPT1</option>
<option>LPT2</option>
</select>
</div>
</div>
<div id="p_usb" style="display:none;">
<div style="padding:var(--spacing-md); color:var(--text-secondary); font-size:var(--font-size-small);">
USB connections are automatically detected. No additional configuration required.
</div>
</div>
</div>
</div>
<div class="group-box" id="wifi_panel" style="display:none;">
<span class="group-title">WiFi Configuration</span>
<div class="grid-2" style="margin-bottom:var(--spacing-md);">
<span style="text-align:right;">SSID:</span>
<input type="text" id="wifi_ssid" class="fill" placeholder="Network Name">
<span style="text-align:right;">Password:</span>
<input type="password" id="wifi_pass" class="fill">
<span style="text-align:right;">Security:</span>
<select id="wifi_sec" class="fill">
<option>WPA2-PSK</option>
<option>WPA3</option>
<option>WEP</option>
<option>Open</option>
</select>
</div>
<div>
<label><input type="checkbox" id="wifi_dhcp" checked> Use DHCP</label>
</div>
<div class="grid-2" id="wifi_static" style="display:none; margin-top:var(--spacing-md);">
<span style="text-align:right;">IP Address:</span>
<input type="text" class="fill" value="192.168.1.100">
<span style="text-align:right;">Subnet Mask:</span>
<input type="text" class="fill" value="255.255.255.0">
<span style="text-align:right;">Gateway:</span>
<input type="text" class="fill" value="192.168.1.1">
<span style="text-align:right;">DNS Server:</span>
<input type="text" class="fill" value="8.8.8.8">
</div>
<div class="button-row">
<button id="btn_scan_wifi">Scan Networks</button>
<button id="btn_apply_wifi">Apply WiFi Config</button>
</div>
<div class="group-box" style="margin-top:var(--spacing-md);">
<span class="group-title">Available Networks</span>
<div style="height:120px; overflow-y:auto; border:1px solid var(--border-dark); background:var(--bg-window); padding:5px;" id="wifi_list">
<div style="color:var(--text-secondary); font-size:10px;">Click "Scan Networks" to discover</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="print" class="workspace" role="tabpanel">
<div class="workspace-content">
<div class="main-panel">
<div class="compact-header-row">
<span style="font-size:var(--font-size-small);">Target:</span>
<div id="print_target" class="multi-select-dropdown" style="flex:1; max-width:200px;" tabindex="0">
<span style="color:var(--text-secondary); font-size:var(--font-size-small);">Select...</span>
</div>
</div>
<div style="display:flex; gap:20px; flex-wrap:wrap;">
<div style="flex:1; min-width:350px;">
<div class="grid-2" style="margin-top:var(--spacing-sm);">
<span style="text-align:right;">Print Speed:</span>
<div class="row" style="margin:0;">
<select class="fill" id="print_speed">
<option>High</option>
<option selected>Normal</option>
<option>Low</option>
</select>
<button id="btn_apply_print_speed">Apply</button>
</div>
<span style="text-align:right;">No-Media-Out (In):</span>
<div class="row" style="margin:0;">
<input type="number" class="fill" id="no_media" value="12" min="1" max="100">
<button id="btn_apply_no_media">Apply</button>
</div>
<span style="text-align:right;">Debug Report Level:</span>
<div class="row" style="margin:0;">
<select class="fill" id="debug_level">
<option>0 - Silent</option>
<option selected>1 - Standard</option>
<option>2 - Verbose</option>
</select>
<button id="btn_apply_debug_level">Apply</button>
</div>
</div>
<div style="margin-top:var(--spacing-lg);" class="grid-2">
<label style="text-align:right;"><input type="checkbox" id="auto_reprint"> Enable Automatic Reprint</label>
<button id="btn_apply_auto_reprint">Apply</button>
<label style="text-align:right;"><input type="checkbox" id="aux_power"> Auxiliary Power On</label>
<button id="btn_apply_aux_power">Apply</button>
</div>
<div class="grid-2" style="margin-top:var(--spacing-md);">
<span style="text-align:right;">Media Adjust:</span>
<div class="row" style="margin:0;">
<input type="number" class="fill" id="media_adjust" value="0" min="-100" max="100">
<button id="btn_apply_media_adjust">Apply</button>
</div>
<span style="text-align:right;">Pitch (DPI):</span>
<div class="row" style="margin:0;">
<select class="fill" id="pitch">
<option selected>203</option>
<option>300</option>
</select>
<button id="btn_apply_pitch">Apply</button>
</div>
</div>
<div class="group-box" style="margin-top:var(--spacing-md);">
<span class="group-title">Real-Time Clock</span>
<div class="grid-2">
<span style="text-align:right;">Time (HH:MM:SS):</span>
<div class="row" style="margin:0;">
<input type="text" id="rtc_time" class="fill" placeholder="12:00:00">
<button id="btn_refresh_time"></button>
</div>
<span style="text-align:right;">Date:</span>
<div class="row" style="margin:0;">
<input type="date" id="rtc_date" class="fill">
<button id="btn_apply_datetime">Apply</button>
</div>
</div>
</div>
</div>
<div style="flex:1; min-width:250px; display:flex; flex-direction:column; gap:var(--spacing-md);">
<div class="group-box">
<span class="group-title">Darkness</span>
<div class="row">
<input type="number" id="darkness_val" style="width:60px" value="0" min="-200" max="200">
<button id="btn_apply_darkness">Apply</button>
</div>
<div style="display:flex; align-items:center; gap:5px;">
<button id="btn_darkness_down"></button>
<input type="range" id="darkness_slider" min="-200" max="200" value="0" style="flex:1;">
<button id="btn_darkness_up"></button>
</div>
</div>
<div class="group-box">
<span class="group-title">Primary Language</span>
<label><input type="radio" name="lang" value="auto" checked> Auto (CPL/ZPL)</label><br>
<label><input type="radio" name="lang" value="cpl"> CPL</label><br>
<label><input type="radio" name="lang" value="zpl"> ZPL</label><br>
<label><input type="radio" name="lang" value="epl"> EPL</label>
<div style="text-align:right; margin-top:var(--spacing-md);">
<button id="btn_apply_language">Apply</button>
</div>
</div>
<div class="group-box">
<span class="group-title">Thermal Mode</span>
<label><input type="radio" name="tm" value="dt" checked> Direct Thermal</label><br>
<label><input type="radio" name="tm" value="tt"> Thermal Transfer</label>
<div style="text-align:right; margin-top:var(--spacing-md);">
<button id="btn_apply_thermal_mode">Apply</button>
</div>
</div>
</div>
</div>
<div style="text-align:center; margin-top:var(--spacing-lg);">
<button id="btn_refresh_printer_settings">Refresh Settings</button>
<button id="btn_print_test_label">Print Test Label</button>
</div>
</div>
</div>
</div>
<div id="pos" class="workspace" role="tabpanel">
<div class="workspace-content">
<div class="main-panel" style="overflow:hidden;">
<div style="display:flex; gap:var(--spacing-md); height:100%;">
<div style="flex:1; overflow-y:auto; padding-right:var(--spacing-md);">
<div class="compact-header-row" style="margin-bottom:var(--spacing-md);">
<span style="font-size:var(--font-size-small);">Target:</span>
<div id="pos_target" class="multi-select-dropdown" style="flex:1; max-width:200px;" tabindex="0">
<span style="color:var(--text-secondary); font-size:var(--font-size-small);">Select...</span>
</div>
</div>
<div class="grid-2" style="max-width:400px;">
<span style="text-align:right;">Print Width (Inches):</span>
<div class="row" style="margin:0;">
<input type="text" class="fill" value="4.09">
<button>Apply</button>
</div>
<span style="text-align:right;">Label Length (Dots):</span>
<div class="row" style="margin:0;">
<input type="text" class="fill" value="">
<button>Apply</button>
</div>
</div>
<div class="grid-2" style="max-width:400px; margin-top:var(--spacing-md);">
<label style="text-align:right;"><input type="checkbox"> Enable Auto-Recalibration</label>
<button>Apply</button>
<label style="text-align:right;"><input type="checkbox"> Enable Automatic TOF</label>
<button>Apply</button>
</div>
<div class="group-box" style="max-width:400px;">
<span class="group-title">Indexing</span>
<label><input type="checkbox" checked> Indexing On</label>
<div class="row" style="margin-top:var(--spacing-md);">
<label><input type="radio" name="idx"> Bar</label>
<button>Apply</button>
</div>
<div class="row">
<label><input type="radio" name="idx" checked> Gap</label>
<button id="btn_calibrate_sensor">Calibrate</button>
</div>
<div class="row">
<label><input type="radio" name="idx"> Notch</label>
</div>
</div>
<div class="group-box" style="max-width:400px;">
<span class="group-title">TOF Adjustment (Motor Steps)</span>
<div class="row">
<input type="text" class="fill" value="0">
<button>Apply</button>
</div>
<p style="font-size:var(--font-size-small); color:var(--text-secondary); margin-top:4px; line-height:1.3;">
Moves label top margin down the page.
</p>
</div>
<div class="group-box" style="max-width:400px;">
<span class="group-title">Shift-Left (Hundredths of Inch)</span>
<div class="row">
<input type="text" class="fill" value="0">
<button>Apply</button>
</div>
<p style="font-size:var(--font-size-small); color:var(--text-secondary); margin-top:4px; line-height:1.3;">
Moves image leftward across label.
</p>
</div>
<div class="group-box" style="max-width:400px;">
<span class="group-title">Label Presentation</span>
<label><input type="checkbox" id="enable_presentation"> Enable Label Presentation</label>
<div class="grid-2" style="margin-top:var(--spacing-sm);">
<span style="text-align:right;">Advance (dots):</span>
<div class="row" style="margin:0;">
<input type="number" id="present_advance" class="fill" value="0" min="0" max="999">
<button id="btn_apply_advance">Apply</button>
</div>
<span style="text-align:right;">Retract (dots):</span>
<div class="row" style="margin:0;">
<input type="number" id="present_retract" class="fill" value="0" min="0" max="999">
<button id="btn_apply_retract">Apply</button>
</div>
<span style="text-align:right;">Time (ms):</span>
<div class="row" style="margin:0;">
<input type="number" id="present_time" class="fill" value="0" min="0" max="9999">
<button id="btn_apply_present_time">Apply</button>
</div>
</div>
</div>
<div style="text-align:center; margin-top:var(--spacing-lg);">
<button id="btn_refresh_positioning">Refresh</button>
<button id="btn_pos_test_label">Print Test Label</button>
</div>
</div>
<div style="flex:1; display:flex; flex-direction:column; align-items:center; justify-content:center; padding:var(--spacing-sm); border-left:1px solid var(--border-shadow);">
<span style="font-size:var(--font-size-small); font-weight:bold; margin-bottom:var(--spacing-xs);">Reference</span>
<img src="data:image/png;base64,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
</div>
</div>
</div>
</div>
</div>
<div id="fonts" class="workspace" role="tabpanel">
<div class="workspace-content">
<div class="main-panel">
<div class="compact-header-row">
<span style="font-size:var(--font-size-small);">Target:</span>
<div id="fonts_target" class="multi-select-dropdown" style="flex:1; max-width:200px;" tabindex="0">
<span style="color:var(--text-secondary); font-size:var(--font-size-small);">Select...</span>
</div>
</div>
<div style="flex:1; border:1px solid var(--border-dark); overflow:auto; background:var(--bg-window);">
<table id="obj_table">
<thead>
<tr>
<th style="width:100px">Name</th>
<th style="width:100px">Type</th>
<th style="width:80px">Storage</th>
<th style="width:80px">Size</th>
<th>Description</th>
</tr>
</thead>
<tbody></tbody>
</table>
</div>
<div class="button-row">
<button id="btn_send_objects">Send Objects</button>
<button id="btn_delete_objects">Delete Selected</button>
<button id="btn_load_objects">Refresh</button>
</div>
</div>
</div>
</div>
<div id="prof" class="workspace" role="tabpanel">
<div class="workspace-content">
<div class="main-panel">
<div class="compact-header-row">
<span style="font-size:var(--font-size-small);">Target:</span>
<div id="prof_target" class="multi-select-dropdown" style="flex:1; max-width:200px;" tabindex="0">
<span style="color:var(--text-secondary); font-size:var(--font-size-small);">Select...</span>
</div>
</div>
<textarea id="prof_txt" style="flex:1; font-family:monospace; white-space:pre;"></textarea>
<div class="button-row">
<button id="btn_get_profile">Get Printer Profile</button>
<button id="btn_apply_profile">Apply Profile to Printer(s)</button>
<button id="btn_save_profile">Save to File</button>
<button id="btn_load_profile_file">Load from File</button>
</div>
</div>
</div>
</div>
<div id="firm" class="workspace" role="tabpanel">
<div class="workspace-content">
<div class="main-panel">
<div class="compact-header-row">
<span style="font-size:var(--font-size-small);">Target:</span>
<div id="firm_target" class="multi-select-dropdown" style="flex:1; max-width:200px;" tabindex="0">
<span style="color:var(--text-secondary); font-size:var(--font-size-small);">Select...</span>
</div>
</div>
<div class="group-box">
<span class="group-title">Firmware Info</span>
<div class="grid-2" style="max-width:400px;">
<span style="text-align:right;">Part Number:</span>
<strong id="fw_part">-</strong>
<span style="text-align:right;">Version:</span>
<strong id="fw_ver">-</strong>
<span style="text-align:right;">Release Date:</span>
<span id="fw_date">-</span>
</div>
<div style="text-align:right; margin-top:var(--spacing-md);">
<button id="btn_refresh_firmware">Refresh</button>
</div>
</div>
<div class="group-box">
<span class="group-title">Upgrade Firmware</span>
<div class="row" style="margin-bottom:var(--spacing-md);">
<span style="width:100px;">Firmware File:</span>
<input type="text" id="fw_file" readonly class="fill">
<button id="btn_browse_firmware">Browse</button>
</div>
<div id="fw_comparison" style="display:none; margin-bottom:var(--spacing-md); padding:var(--spacing-sm); border:1px solid var(--border-dark); border-radius:var(--border-radius); background:var(--bg-face);">
<div class="grid-2" style="max-width:300px; font-size:var(--font-size-small);">
<span style="text-align:right;">New Version:</span>
<strong id="fw_new_ver">-</strong>
<span style="text-align:right;">New Release Date:</span>
<span id="fw_new_date">-</span>
</div>
</div>
<div id="fw_downgrade_warning" style="display:none; margin-bottom:var(--spacing-md); padding:var(--spacing-sm); border:1px solid var(--status-red); border-radius:var(--border-radius); background:#fff0f0; color:var(--status-red); font-size:var(--font-size-small);">
 <strong>Warning:</strong> You are about to downgrade the firmware. This may cause loss of functionality or data. Only proceed if instructed by technical support.
</div>
<button id="btn_update_firmware">Update Firmware</button>
<div class="row" style="margin-top:var(--spacing-md);">
<span style="width:100px">Progress:</span>
<div class="progress-container" style="flex:1;">
<div class="progress-bar" id="fw_prog"></div>
</div>
</div>
<div id="fw_restart_msg" style="display:none; margin-top:var(--spacing-md); padding:var(--spacing-sm); border:1px solid var(--status-green); border-radius:var(--border-radius); background:#f0fff0; color:var(--status-green); font-size:var(--font-size-small);">
 Firmware update complete. Please restart the printer for changes to take effect.
</div>
</div>
<div class="group-box">
<span class="group-title">CPR (Configuration Parameter Record)</span>
<button id="btn_load_cpr">Load CPR File</button>
<button id="btn_save_cpr">Save CPR</button>
</div>
</div>
</div>
</div>
<div id="mfg" class="workspace" role="tabpanel">
<div class="workspace-content">
<div class="main-panel">
<div style="display:flex; gap:var(--spacing-md); flex-wrap:wrap;">
<div style="width:340px; display:flex; flex-direction:column; gap:var(--spacing-md);">
<div class="section-title">Unit Under Test:</div>
<div style="display:flex; gap:15px;">
<label><input type="checkbox" id="mfg_board_test"> Board Test Mode</label>
<label><input type="checkbox" id="mfg_disable_licenses"> Disable Licenses</label>
</div>
<div class="grid-2">
<span style="text-align:right;">Model Number:</span>
<div class="row" style="margin:0;">
<button id="btn_scan_barcode">Scan</button>
<input type="text" id="mfg_model" class="fill">
</div>
<span style="text-align:right;">Serial Number:</span>
<input type="text" id="mfg_serial" class="fill">
<span style="text-align:right;">MAC Address:</span>
<input type="text" id="mfg_mac" class="fill">
</div>
<label><input type="checkbox" id="mfg_specify_sn_mac"> Specify S/N & MAC manually</label>
<div style="display:flex; flex-direction:column; gap:5px;">
<label><input type="checkbox" id="mfg_prompt_fw"> Prompt for firmware download</label>
<div class="grid-2">
<label style="text-align:right; justify-content:flex-end;"><input type="checkbox" id="mfg_serial_port" checked> Serial Port:</label>
<input type="text" id="mfg_serial_val" value="COM3">
<label style="text-align:right; justify-content:flex-end;"><input type="checkbox" id="mfg_bt_port"> Bluetooth COM:</label>
<input type="text" id="mfg_bt_val">
<label style="text-align:right; justify-content:flex-end;"><input type="checkbox" id="mfg_parallel"> Parallel Port:</label>
<input type="text" id="mfg_parallel_val">
<label style="text-align:right; justify-content:flex-end;"><input type="checkbox" id="mfg_network"> IP Address:</label>
<input type="text" id="mfg_ip_val">
</div>
<label><input type="checkbox" id="mfg_usb_b" checked> USB Direct Connect (USB-B)</label>
<label><input type="checkbox" id="mfg_usb_a"> USB-A</label>
</div>
<div class="grid-2">
<span style="text-align:right;">Print-head:</span>
<select id="mfg_printhead" class="fill">
<option value="auto">Automatic</option>
<option value="203">203 DPI</option>
<option value="300">300 DPI</option>
</select>
</div>
<div class="group-box">
<span class="group-title">Peripherals:</span>
<div class="grid-2">
<label style="text-align:right;"><input type="checkbox" id="mfg_scanner" checked> Scanner:</label>
<input type="text" id="mfg_scanner_val">
<label style="text-align:right;"><input type="checkbox" id="mfg_sn_printer" checked> S/N Label Printer:</label>
<input type="text" id="mfg_sn_printer_val" value="USB">
<label style="text-align:right;"><input type="checkbox" id="mfg_box_printer"> Box Label Printer:</label>
<input type="text" id="mfg_box_printer_val">
</div>
<div class="button-row">
<button id="btn_print_serial_label">Print S/N Label</button>
<button id="btn_print_box_label">Print Box Label</button>
</div>
</div>
<div class="group-box">
<span class="group-title">Test Options:</span>
<div style="display:flex; flex-direction:column; gap:3px;">
<label><input type="checkbox" id="mfg_autorun"> Auto-run after scan</label>
<label><input type="checkbox" id="mfg_tg_mode"> TG (Test Group) Mode</label>
</div>
</div>
</div>
<div style="flex:1; display:flex; flex-direction:column;">
<div class="section-title">Test Sequence</div>
<div style="flex:1; border:1px solid var(--border-dark); background:var(--bg-window); overflow-y:auto; padding:5px; font-size:var(--font-size-small);" id="test_sequence">
<div class="row"><span style="flex:1">1. Initial Setup</span><span id="test_1" style="color:var(--text-secondary);">Pending</span></div>
<div class="row"><span style="flex:1">2. Firmware Load</span><label style="font-size:10px;"><input type="checkbox" id="skip_test_2"> Skip</label><span id="test_2" style="color:var(--text-secondary);">Pending</span></div>
<div class="row"><span style="flex:1">3. Printer Identification</span><span id="test_3" style="color:var(--text-secondary);">Pending</span></div>
<div class="row"><span style="flex:1">4. Font Loading</span><label style="font-size:10px;"><input type="checkbox" id="skip_test_4"> Skip</label><span id="test_4" style="color:var(--text-secondary);">Pending</span></div>
<div class="row"><span style="flex:1">5. CPR Download</span><label style="font-size:10px;"><input type="checkbox" id="skip_test_5"> Skip</label><span id="test_5" style="color:var(--text-secondary);">Pending</span></div>
<div class="row"><span style="flex:1">6. Control Panel Test</span><span id="test_6" style="color:var(--text-secondary);">Pending</span></div>
<div class="row"><span style="flex:1">7. Connection Interfaces</span><span id="test_7" style="color:var(--text-secondary);">Pending</span></div>
<div class="row"><span style="flex:1">8. Print-Head Up/Down</span><span id="test_8" style="color:var(--text-secondary);">Pending</span></div>
<div class="row"><span style="flex:1">9. Feed Button Test</span><span id="test_9" style="color:var(--text-secondary);">Pending</span></div>
<div class="row"><span style="flex:1">10. Peeler Test</span><span id="test_10" style="color:var(--text-secondary);">Pending</span></div>
<div class="row"><span style="flex:1">11. Tone Check</span><span id="test_11" style="color:var(--text-secondary);">Pending</span></div>
<div class="row"><span style="flex:1">12. RTC Setup</span><span id="test_12" style="color:var(--text-secondary);">Pending</span></div>
<div class="row"><span style="flex:1">13. Calibration & Indexing</span><span id="test_13" style="color:var(--text-secondary);">Pending</span></div>
<div class="row"><span style="flex:1">14. Backup Memory</span><span id="test_14" style="color:var(--text-secondary);">Pending</span></div>
<div class="row"><span style="flex:1">15. Print Quality</span><span id="test_15" style="color:var(--text-secondary);">Pending</span></div>
<div class="row"><span style="flex:1">16. Print Head Test</span><span id="test_16" style="color:var(--text-secondary);">Pending</span></div>
<div class="row"><span style="flex:1">17. Ribbon Wrinkle</span><span id="test_17" style="color:var(--text-secondary);">Pending</span></div>
<div class="row"><span style="flex:1">18. Self-Test</span><span id="test_18" style="color:var(--text-secondary);">Pending</span></div>
<div class="row"><span style="flex:1">19. Final Settings</span><span id="test_19" style="color:var(--text-secondary);">Pending</span></div>
<div class="row"><span style="flex:1">20. Shipping Label</span><span id="test_20" style="color:var(--text-secondary);">Pending</span></div>
</div>
<div class="button-row">
<button id="btn_start_test">Start</button>
<button id="btn_run_next">Run Next</button>
<button id="btn_rerun_test">Re-run</button>
<button id="btn_stop_test">Abort</button>
</div>
<div class="button-row">
<button id="btn_enable_pcl">Enable PCL</button>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="edit" class="workspace" role="tabpanel">
<div class="workspace-content">
<div class="main-panel">
<div style="display:flex; height:100%; gap:var(--spacing-md); flex-wrap:wrap;">
<div style="flex:1; min-width:300px; display:flex; flex-direction:column;">
<div style="display:flex; justify-content:space-between; margin-bottom:5px;">
<span>CPL Script Input</span>
<button id="btn_insert_template" style="height:18px; min-width:60px;">Templates</button>
</div>
<textarea id="cpl_in" style="flex:1;">! 0 100 100 1
TEXT 3 0 10 10 Hello World
END</textarea>
<div class="row" style="margin-top:var(--spacing-sm); align-items:center;">
<span style="font-size:var(--font-size-small);">Target:</span>
<div id="script_target" class="multi-select-dropdown" style="flex:1; max-width:180px;" tabindex="0">
<span style="color:var(--text-secondary); font-size:var(--font-size-small);">Select...</span>
</div>
</div>
<div class="button-row">
<button id="btn_send_script">Send</button>
<button id="btn_save_script">Save Script</button>
<button id="btn_load_script">Load Script</button>
<button id="btn_clear_script">Clear</button>
</div>
<div class="group-box" style="margin-top:var(--spacing-md);">
<span class="group-title">Timer Settings</span>
<div class="grid-2" style="max-width:250px; margin-bottom:var(--spacing-sm);">
<span style="text-align:right;">Interval (secs):</span>
<input type="number" id="timer_interval" value="5" min="1" max="3600" style="width:60px;">
<span style="text-align:right;">Repeat:</span>
<input type="number" id="timer_repeat" value="1" min="1" max="9999" style="width:60px;">
<span style="text-align:right;">Current:</span>
<span id="timer_current" style="font-weight:bold;">0 / 0</span>
</div>
<div class="button-row">
<button id="btn_timer_start">Start</button>
<button id="btn_timer_pause" disabled>Pause</button>
<button id="btn_timer_resume" disabled>Resume</button>
<button id="btn_timer_stop" disabled>Stop</button>
</div>
</div>
</div>
<div style="flex:1; min-width:300px; display:flex; flex-direction:column;">
<span style="margin-bottom:5px;">Printer Output</span>
<textarea id="cpl_out" readonly style="flex:1; background:var(--bg-face);"></textarea>
<div class="button-row" style="justify-content:flex-end;">
<button id="btn_view_variables">View Variables</button>
<button id="btn_view_status">View Status</button>
<button id="btn_clear_output">Clear Output</button>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="pcl" class="workspace" role="tabpanel">
<div class="workspace-content">
<div class="main-panel" style="overflow:hidden;">
<div style="display:flex; gap:var(--spacing-md); height:100%;">
<div style="flex:0 0 auto; display:flex; flex-direction:column; padding:var(--spacing-sm); border-right:1px solid var(--border-shadow);">
<div class="group-box" style="margin:0; flex:1; display:flex; flex-direction:column;">
<span class="group-title">Label Window Within Standard Page</span>
<span style="font-size:var(--font-size-small); font-style:italic; color:var(--text-secondary);">(0,0)</span>
<div style="flex:1; display:flex; align-items:center; justify-content:center; padding:var(--spacing-sm);">
<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAATYAAAGQCAIAAACrm9sNAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAACxMAAAsTAQCanBgAAAAYdEVYdFNvZnR3YXJlAFBhaW50Lk5FVCA1LjEuM4y7MyAAAAC2ZVhJZklJKgAIAAAABQAaAQUAAQAAAEoAAAAbAQUAAQAAAFIAAAAoAQMAAQAAAAIAAAAxAQIAEAAAAFoAAABphwQAAQAAAGoAAAAAAAAASRkBAOgDAABJGQEA6AMAAFBhaW50Lk5FVCA1LjEuMwADAACQBwAEAAAAMDIzMAGgAwABAAAAAQAAAAWgBAABAAAAlAAAAAAAAAACAAEAAgAEAAAAUjk4AAIABwAEAAAAMDEwMAAAAADInY6tb+sRQQAAK+FJREFUeF7t3Ad8jdfjx/HEVqP2VtQsLa3atH61R6uoqlIUNcofbc2irdWi1PjVKrFXVBG7tWrv0ahdYksIYiYx8//knsdtKvgpwkl836++0nPOc55zn9x7v885J7nhGRYW5iEitorl/F9ErKSIilhNERWxmiIqYjVFNLoKDQ1t0aKFU5GYSxGNrm7cuLF69WqnIjGXIipiNUVUxGqKqIjVFFERqymiIlZTREWspoiKWO1fR3TNmjVZsmTJlClT5syZKRw5csQ5cA+3bt26efOmU/HwCAsLu3HjBoVBgwZNnTrVNN7V9evXndLDYoQSJUrwiBEv4A7dunX77bffnIqIff51REuVKkUsmzRp0qtXLwqk1DlwDyNHjhwwYIBT8fA4fPhw+fLlKVy+fDk4ONg03lWOHDmc0sMinIGBgcuXL2/atKnTFMnFixevXr3qVETs83gWuhcuXCAJOH78ONVNmzYxVRJCX19fqgcPHjx16pSrY7igoKDdu3eb8h9//MFZzLSUTZxAgSqNGzZscPUKxynnz5+nsG7dOr4yIMNS4CE4ZdWqVZTPnDmzf//+AwcO0EL2YsWKVbx4cdr9/f0PHTpEwbh27Roddu7c6dRdF7xy5UpTPnHiRPhFLF/ON0XVPFxAQICfnx8FLvjKlSvh/USeiMcQUSbDCRMmTHahcOzYMWYt8kkqunbtSoft27czeZrOIF3mfb927dqJEydylre3N9WjR4+6Bzl79iwhnzdvnuuMcH379t2xYweFDz/8kK/Lli3z8vJav379pEmTzFlz585l2JYtW5oxx48fz0KXMp0JsznXMB34unnzZqoMZQbx8fHhFuP+XhiB76JevXr0WbJkydixYyl07tyZ6wwfReSJeAwRZXLr378/K16QE+aZFi1aDBkyZNasWXXr1qVDrVq1ihYtajojT548n3zyCQVy2KpVK976X375JdXnnnvODEILkY4XL963337rOuNvDNuoUaNx48aZKjErU6YM/fv16/fNN9/QcunSpUqVKtHCRtfMumBx/u6775oymFTZozZs2JD5nOrp06e5lQwcOJB9KUnmFsPpmDFjxrlz5+jAep4pNE6cONu2bXMNIPLkPJ6Fbvz48TO7NG/e/NVXX/30008HDx48c+ZME9F7qVatWvbs2U2ZTBI8M0jChAlNY2QM27hx4zFjxjj1SLgXED+ncg/t27dnscrauEKFClSZltOlS2cO3RURZR6OGzfu1q1bnSaRJ+XxRDRNmjQkB7z12csRVBaKzI3MS06P/4VtJDOVGYSJ1GmNoFOnTqw8f/jhBx6LhfTGjRubNGniHPuXmMM//vjjmzdvjho1ymm6B09PTx6Rx+XRud3s27fvvffee+GFF5zDIlHvMUSUzJDGXC5sIF955ZUNGzaULFny5ZdfZtHLXu7ChQvz5883nTNlytS6dWve8abqRue3337bDMLGj5Zff/21cuXK5ijy5cvHVFawYMEECRLkyJGDSPO1R48e3As4pWzZsnPmzHG6/lPx4sULFSr0448/OnUPj7Zt2xYuXJgdcs2aNZ2m20qXLs063FxGhw4d0qdPzyPyuDx6tmzZLl68SD4TJUrk9LbbyJEj+S7MD9KMpUuX9u7d26k8DTyTd72xsjxp166dU5E7hD0UoginEhZ269atUBfTePXqVdN47do1CtevX2fKCu/nQpmWiCOY/rSbQcC57nY3RjPtZgR3I/3dI0RsN50R8bFgrtb0jHhtZhB6ui4h1LS7vwtE7PzUsevOmzevU7kbvhHWC4sWLaLMZa9cuZIVivv5efJ4JtetW1enTh2nfhvXyUWyOXLq8k/6Rzqjq8uXL7Px3rVrl1O/m759+7LN/uCDDzZv3uzl5WV+vm1wIrsSliRZs2bdu3dvRhfafX19uVUlTpyY/FNlH25+Yfb666/Hjh37/Pnz+/fvz5w5M+uL3bt3s5CJFy8eN4vAwECGOn78eO7cuZ9//vktW7YQyBQpUphfbv/1119BQUHc9Vq0aOH+fRv27NnDuYzfr1+/NWvW+Pv7Hzt2jHYWYuz8uSrWVhxlKPfDsS4z57ovOOYzSZVo53/OokalSpUGDRrE7t2p31akSJEqVarw1h86dCgbgdq1ax86dGjFihXs0tlxsDsw3Qh2rVq1SN3p06dnzJgxZMiQ1157jc3L0aNHS5QoQaLo8/vvvzdo0KBnz57EmAixQ+GmwNaDfTtHafnss88YJH78+C+99JJr1HAbN25k5qSdNyHbIu4FjECVe8rOnTvPnTv36quvnjhxgpm/f//+69evb968OXHl3kEfLvj999/ngp2xYrTH8+OiyLgTR7xn38vMmTPNLzbub+3atRHvvsamTZvMRyPuZfTo0U7p2cazRA6disu8efPKlCkzYcIEZrY4ceIwuTEBsqtnYWy236Ybcy/TZrFixdh+s1TmrMWLFzMUKeLcN998M0mSJBcuXCA/bNGZ64YNG3bgwAHiSoyZCRmBTeasWbOIGfFmUiX/ZmReUEZr37497UmTJmUo3i0knKr70bkpjBs3zvxGfeDAgY0aNWKorl270qdly5ZcsPmIS4wXVRH19PRkXeRUIiFdCxcupDBq1KgHeaLZq0T+hcfy5ct5cziVu3m6PxqxR4cOHViOOhUX8lCjRg0Cljp1amYnWipWrHjw4EGmXOKXMmVK5r3t27fPnz+fBSfowDqWnJQqVYqZbcCAAayT33nnHWZX7rDkNmfOnGSYhTcvKDN2woQJs2XLRjJXrVqVPHlyE1fG6dixY/jDu17QXLlyvfjii5STJUtWtWpVFr3M6uYovv/++48++oj3SfXq1efMmcOMmiVLlj59+nTu3Nl04IILFy5syjFbVEWU94T5XM5dsc2I+OE+sUTNmjXbtGlDrqZNm0Z0Q0JCqLLpZdcaHBzcq1cvwtapUydmM9OfmdMkPKL69es3bNiQ1W/Ej1gyYV68eNGpRMDprOWciuun0ASVvS5RP3PmTJcuXWhkm8ot4P6/u47JzHr3wRGtHj16mHKzZs3YjXAzY2GDwYMHm3awU2J7w4vNnc9sYNiTOMfCwlgm8YzzSleoUIG4spQiz+YQGw8zWlBQkGkByxtu/BS43XKINQ9lRua1NJ15G9HCVspUua9TZfXF15jqQfairCN4qkmaU3dhMiQApK5y5cpMhryg5NDf359VKEng2WN9u23bNp7etGnTUmWq9Pb2Pnv2LHNj9uzZ2QQGBATUqVOHaZCjGTNmJM+tWrU6efIkg/OCclWlS5dmBD8/Px4rU6ZMdHvuuecIrbkA8IIyK9LOrXzHjh2EkMmWKv1ZOdOBYZlXKfz3v/9lSmeuZv3M68sKm9jWrVubh3sW/OuILlmypEmTJqb81ltvsffgNeCGh759+3p5eZlDPNHccVkpsZpiXcTRcuXKuZ9W3jft2rVjI8QrmiFDBtZOPPvceocPH84744gLp5vOcEeUHQiHWPlwd6AneTYPnT9//j
</div>
</div>
</div>
<div style="flex:1; overflow-y:auto; padding-left:var(--spacing-md);">
<div class="compact-header-row">
<span style="font-size:var(--font-size-small);">Target:</span>
<div id="pcl_target" class="multi-select-dropdown" style="flex:1; max-width:200px;" tabindex="0">
<span style="color:var(--text-secondary); font-size:var(--font-size-small);">Select...</span>
</div>
</div>
<div class="group-box">
<span class="group-title">Label Window Parameters</span>
<p style="font-size:var(--font-size-small); color:var(--text-secondary); margin-bottom:var(--spacing-md); line-height:1.4;">
These parameters define the label area within a PCL page. Use PJL commands to configure the windowing area for label printing.
</p>
<div class="grid-2" style="max-width:400px;">
<span style="text-align:right;">Label Origin X (dots):</span>
<input type="number" id="pcl_origin_x" value="0" min="0" class="fill">
<span style="text-align:right;">Label Origin Y (dots):</span>
<input type="number" id="pcl_origin_y" value="0" min="0" class="fill">
<span style="text-align:right;">Label Width (dots):</span>
<input type="number" id="pcl_width" value="812" min="1" class="fill">
<span style="text-align:right;">Label Length (dots):</span>
<input type="number" id="pcl_length" value="1218" min="1" class="fill">
</div>
<div class="button-row" style="margin-top:var(--spacing-md);">
<button id="btn_apply_pcl_window">Apply Window</button>
<button id="btn_refresh_pcl_window">Refresh</button>
</div>
</div>
<div class="group-box">
<span class="group-title">PJL Commands</span>
<textarea id="pjl_commands" style="width:100%; height:150px; font-family:monospace; font-size:var(--font-size-small);">@PJL SET LPARM:CPL LABEL ORIGIN X = 0
@PJL SET LPARM:CPL LABEL ORIGIN Y = 0
@PJL SET LPARM:CPL LABEL WIDTH = 812
@PJL SET LPARM:CPL LABEL LENGTH = 1218</textarea>
<div class="button-row" style="margin-top:var(--spacing-md);">
<button id="btn_load_pjl">Load PJL File</button>
<button id="btn_save_pjl">Save PJL File</button>
<button id="btn_send_pjl">Send PJL to Printer</button>
</div>
</div>
<div class="group-box">
<span class="group-title">Print PCL File</span>
<div class="row">
<span style="width:100px;">PCL File:</span>
<input type="text" id="pcl_file" readonly class="fill" placeholder="No file selected">
<button id="btn_browse_pcl">Browse</button>
</div>
<div class="button-row" style="margin-top:var(--spacing-md);">
<button id="btn_send_pcl">Send PCL to Printer</button>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="autotest" class="workspace" role="tabpanel">
<div class="workspace-content">
<div class="main-panel" style="overflow:hidden;">
<div style="display:flex; gap:var(--spacing-md); height:100%;">
<div style="width:280px; min-width:280px; border-right:1px solid var(--border-shadow); padding:var(--spacing-md); overflow-y:auto; display:flex; flex-direction:column;">
<div class="section-title">Test Configuration</div>
<div class="group-box" style="margin-top:var(--spacing-sm);">
<span class="group-title">Test Target</span>
<div style="display:flex; flex-direction:column; gap:var(--spacing-sm);">
<label><input type="radio" name="autotest_target" value="printer" checked> External Printer(s)</label>
<label><input type="radio" name="autotest_target" value="cadmin"> CAdmin Application</label>
<label><input type="radio" name="autotest_target" value="both"> Both</label>
</div>
</div>
<div class="group-box">
<span class="group-title">Printer Selection</span>
<select id="autotest_printer_select" multiple style="width:100%; height:80px; font-size:var(--font-size-small);">
</select>
<label style="margin-top:var(--spacing-sm);"><input type="checkbox" id="autotest_all_printers"> Select All Connected</label>
</div>
<div class="group-box">
<span class="group-title">Test Options</span>
<div style="display:flex; flex-direction:column; gap:var(--spacing-xs);">
<label><input type="checkbox" id="autotest_verbose" checked> Verbose Logging</label>
<label><input type="checkbox" id="autotest_stop_on_fail"> Stop on First Failure</label>
<label><input type="checkbox" id="autotest_generate_report" checked> Generate Report</label>
<label><input type="checkbox" id="autotest_continuous"> Continuous Mode</label>
</div>
<div class="grid-2" style="margin-top:var(--spacing-sm);">
<span>Timeout (sec):</span>
<input type="number" id="autotest_timeout" value="30" min="5" max="300" style="width:60px;">
<span>Retry Count:</span>
<input type="number" id="autotest_retries" value="3" min="0" max="10" style="width:60px;">
</div>
</div>
<div class="button-row" style="margin-top:auto;">
<button id="btn_autotest_run_all" style="flex:2;">Run All Tests</button>
<button id="btn_autotest_run_selected">Run Selected</button>
</div>
<div class="button-row">
<button id="btn_autotest_stop" disabled>Stop</button>
<button id="btn_autotest_reset">Reset</button>
<button id="btn_autotest_export">Export Results</button>
</div>
</div>
<div style="flex:1; display:flex; flex-direction:column; min-width:0; padding:var(--spacing-md);">
<div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:var(--spacing-sm);">
<span class="section-title" style="margin:0;">Test Suites</span>
<div style="display:flex; gap:var(--spacing-sm); align-items:center;">
<span id="autotest_progress_text" style="font-size:var(--font-size-small); color:var(--text-secondary);">0 / 0 tests</span>
<div class="progress-container" style="width:150px; height:12px;">
<div class="progress-bar" id="autotest_progress" style="width:0%;"></div>
</div>
</div>
</div>
<div style="flex:1; overflow-y:auto; border:1px solid var(--border-shadow); background:var(--bg-window); border-radius:var(--border-radius);">
<div class="autotest-suite" data-suite="printer">
<div class="autotest-suite-header" onclick="toggleAutoTestSuite('printer')">
<span class="autotest-suite-toggle"></span>
<span class="autotest-suite-title">Printer Hardware Tests</span>
<span class="autotest-suite-status" id="suite_printer_status"></span>
</div>
<div class="autotest-suite-content" id="suite_printer_content" style="display:none;">
<div class="autotest-item" data-test="printer_connect"><label><input type="checkbox" checked> Connection Test</label><span class="autotest-status"></span></div>
<div class="autotest-item" data-test="printer_identify"><label><input type="checkbox" checked> Printer Identification</label><span class="autotest-status"></span></div>
<div class="autotest-item" data-test="printer_status"><label><input type="checkbox" checked> Status Query</label><span class="autotest-status"></span></div>
<div class="autotest-item" data-test="printer_sensors"><label><input type="checkbox" checked> Sensor Check</label><span class="autotest-status"></span></div>
<div class="autotest-item" data-test="printer_head"><label><input type="checkbox" checked> Print Head Test</label><span class="autotest-status"></span></div>
<div class="autotest-item" data-test="printer_motor"><label><input type="checkbox" checked> Motor Function</label><span class="autotest-status"></span></div>
<div class="autotest-item" data-test="printer_feed"><label><input type="checkbox" checked> Media Feed Test</label><span class="autotest-status"></span></div>
<div class="autotest-item" data-test="printer_calibration"><label><input type="checkbox" checked> Calibration Check</label><span class="autotest-status"></span></div>
</div>
</div>
<div class="autotest-suite" data-suite="communication">
<div class="autotest-suite-header" onclick="toggleAutoTestSuite('communication')">
<span class="autotest-suite-toggle"></span>
<span class="autotest-suite-title">Communication Tests</span>
<span class="autotest-suite-status" id="suite_communication_status"></span>
</div>
<div class="autotest-suite-content" id="suite_communication_content" style="display:none;">
<div class="autotest-item" data-test="comm_serial"><label><input type="checkbox" checked> Serial Port</label><span class="autotest-status"></span></div>
<div class="autotest-item" data-test="comm_usb"><label><input type="checkbox" checked> USB Interface</label><span class="autotest-status"></span></div>
<div class="autotest-item" data-test="comm_ethernet"><label><input type="checkbox" checked> Ethernet/Network</label><span class="autotest-status"></span></div>
<div class="autotest-item" data-test="comm_bluetooth"><label><input type="checkbox" checked> Bluetooth</label><span class="autotest-status"></span></div>
<div class="autotest-item" data-test="comm_wifi"><label><input type="checkbox" checked> WiFi</label><span class="autotest-status"></span></div>
<div class="autotest-item" data-test="comm_latency"><label><input type="checkbox" checked> Latency Test</label><span class="autotest-status"></span></div>
<div class="autotest-item" data-test="comm_throughput"><label><input type="checkbox" checked> Throughput Test</label><span class="autotest-status"></span></div>
</div>
</div>
<div class="autotest-suite" data-suite="printing">
<div class="autotest-suite-header" onclick="toggleAutoTestSuite('printing')">
<span class="autotest-suite-toggle"></span>
<span class="autotest-suite-title">Print Quality Tests</span>
<span class="autotest-suite-status" id="suite_printing_status"></span>
</div>
<div class="autotest-suite-content" id="suite_printing_content" style="display:none;">
<div class="autotest-item" data-test="print_text"><label><input type="checkbox" checked> Text Rendering</label><span class="autotest-status"></span></div>
<div class="autotest-item" data-test="print_barcode"><label><input type="checkbox" checked> Barcode Generation</label><span class="autotest-status"></span></div>
<div class="autotest-item" data-test="print_graphics"><label><input type="checkbox" checked> Graphics Printing</label><span class="autotest-status"></span></div>
<div class="autotest-item" data-test="print_alignment"><label><input type="checkbox" checked> Alignment Test</label><span class="autotest-status"></span></div>
<div class="autotest-item" data-test="print_density"><label><input type="checkbox" checked> Density Test</label><span class="autotest-status"></span></div>
<div class="autotest-item" data-test="print_speed"><label><input type="checkbox" checked> Speed Test</label><span class="autotest-status"></span></div>
</div>
</div>
<div class="autotest-suite" data-suite="firmware">
<div class="autotest-suite-header" onclick="toggleAutoTestSuite('firmware')">
<span class="autotest-suite-toggle"></span>
<span class="autotest-suite-title">Firmware & Memory Tests</span>
<span class="autotest-suite-status" id="suite_firmware_status"></span>
</div>
<div class="autotest-suite-content" id="suite_firmware_content" style="display:none;">
<div class="autotest-item" data-test="fw_version"><label><input type="checkbox" checked> Firmware Version</label><span class="autotest-status"></span></div>
<div class="autotest-item" data-test="fw_checksum"><label><input type="checkbox" checked> Firmware Checksum</label><span class="autotest-status"></span></div>
<div class="autotest-item" data-test="fw_flash"><label><input type="checkbox" checked> Flash Memory</label><span class="autotest-status"></span></div>
<div class="autotest-item" data-test="fw_ram"><label><input type="checkbox" checked> RAM Test</label><span class="autotest-status"></span></div>
<div class="autotest-item" data-test="fw_eeprom"><label><input type="checkbox" checked> EEPROM Test</label><span class="autotest-status"></span></div>
<div class="autotest-item" data-test="fw_config"><label><input type="checkbox" checked> Configuration Integrity</label><span class="autotest-status"></span></div>
</div>
</div>
<div class="autotest-suite" data-suite="cadmin">
<div class="autotest-suite-header" onclick="toggleAutoTestSuite('cadmin')">
<span class="autotest-suite-toggle"></span>
<span class="autotest-suite-title">CAdmin Application Tests</span>
<span class="autotest-suite-status" id="suite_cadmin_status"></span>
</div>
<div class="autotest-suite-content" id="suite_cadmin_content" style="display:none;">
<div class="autotest-item" data-test="cadmin_ui"><label><input type="checkbox" checked> UI Rendering</label><span class="autotest-status"></span></div>
<div class="autotest-item" data-test="cadmin_tabs"><label><input type="checkbox" checked> Tab Navigation</label><span class="autotest-status"></span></div>
<div class="autotest-item" data-test="cadmin_themes"><label><input type="checkbox" checked> Theme Switching</label><span class="autotest-status"></span></div>
<div class="autotest-item" data-test="cadmin_layouts"><label><input type="checkbox" checked> Layout Changes</label><span class="autotest-status"></span></div>
<div class="autotest-item" data-test="cadmin_roles"><label><input type="checkbox" checked> Role Permissions</label><span class="autotest-status"></span></div>
<div class="autotest-item" data-test="cadmin_state"><label><input type="checkbox" checked> State Persistence</label><span class="autotest-status"></span></div>
<div class="autotest-item" data-test="cadmin_cpl"><label><input type="checkbox" checked> CPL Parsing</label><span class="autotest-status"></span></div>
<div class="autotest-item" data-test="cadmin_designer"><label><input type="checkbox" checked> Label Designer</label><span class="autotest-status"></span></div>
<div class="autotest-item" data-test="cadmin_multiselect"><label><input type="checkbox" checked> Multi-Select Controls</label><span class="autotest-status"></span></div>
<div class="autotest-item" data-test="cadmin_logging"><label><input type="checkbox" checked> Logging System</label><span class="autotest-status"></span></div>
</div>
</div>
<div class="autotest-suite" data-suite="integration">
<div class="autotest-suite-header" onclick="toggleAutoTestSuite('integration')">
<span class="autotest-suite-toggle"></span>
<span class="autotest-suite-title">Integration Tests</span>
<span class="autotest-suite-status" id="suite_integration_status"></span>
</div>
<div class="autotest-suite-content" id="suite_integration_content" style="display:none;">
<div class="autotest-item" data-test="int_connect_cycle"><label><input type="checkbox" checked> Connect/Disconnect Cycle</label><span class="autotest-status"></span></div>
<div class="autotest-item" data-test="int_multi_printer"><label><input type="checkbox" checked> Multi-Printer Operations</label><span class="autotest-status"></span></div>
<div class="autotest-item" data-test="int_profile_load"><label><input type="checkbox" checked> Profile Load/Save</label><span class="autotest-status"></span></div>
<div class="autotest-item" data-test="int_firmware_check"><label><input type="checkbox" checked> Firmware Version Check</label><span class="autotest-status"></span></div>
<div class="autotest-item" data-test="int_batch_print"><label><input type="checkbox" checked> Batch Print Job</label><span class="autotest-status"></span></div>
<div class="autotest-item" data-test="int_stress"><label><input type="checkbox" checked> Stress Test</label><span class="autotest-status"></span></div>
<div class="autotest-item" data-test="int_error_recovery"><label><input type="checkbox" checked> Error Recovery</label><span class="autotest-status"></span></div>
</div>
</div>
<div class="autotest-suite" data-suite="stress">
<div class="autotest-suite-header" onclick="toggleAutoTestSuite('stress')">
<span class="autotest-suite-toggle"></span>
<span class="autotest-suite-title">Stress & Performance Tests</span>
<span class="autotest-suite-status" id="suite_stress_status"></span>
</div>
<div class="autotest-suite-content" id="suite_stress_content" style="display:none;">
<div class="autotest-item" data-test="stress_rapid_commands"><label><input type="checkbox" checked> Rapid Command Sequence</label><span class="autotest-status"></span></div>
<div class="autotest-item" data-test="stress_large_labels"><label><input type="checkbox" checked> Large Label Processing</label><span class="autotest-status"></span></div>
<div class="autotest-item" data-test="stress_memory_leak"><label><input type="checkbox" checked> Memory Leak Detection</label><span class="autotest-status"></span></div>
<div class="autotest-item" data-test="stress_concurrent"><label><input type="checkbox" checked> Concurrent Operations</label><span class="autotest-status"></span></div>
<div class="autotest-item" data-test="stress_long_run"><label><input type="checkbox" checked> Long Duration Test</label><span class="autotest-status"></span></div>
</div>
</div>
</div>
<div style="margin-top:var(--spacing-md); display:flex; flex-direction:column; gap:var(--spacing-sm);">
<div style="display:flex; justify-content:space-between; align-items:center;">
<span style="font-weight:bold;">Test Output</span>
<div style="display:flex; gap:var(--spacing-sm);">
<span id="autotest_summary" style="font-size:var(--font-size-small);">
<span style="color:var(--status-green);">Passed: 0</span> |
<span style="color:var(--status-red);">Failed: 0</span> |
<span style="color:var(--text-secondary);">Skipped: 0</span>
</span>
<button id="btn_autotest_clear_log" style="height:18px; min-width:40px;">Clear</button>
</div>
</div>
<div class="debug-console" id="autotest_log" style="height:150px; font-size:9px;"></div>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="about" class="workspace" role="tabpanel">
<div class="workspace-content">
<div class="main-panel" style="overflow:hidden;">
<div style="display:flex; flex-direction:column; gap:var(--spacing-md); padding:var(--spacing-sm); height:100%;">
<div style="text-align:center; padding:var(--spacing-md); border-bottom:1px solid var(--border-shadow);">
<span class="logo" style="font-size:16px;">Cognitive<span>LLC</span></span>
<h1 style="color: #cc0000; font-family:sans-serif; margin:var(--spacing-sm) 0 0 0; font-size:24px;">COGNITIVE <span style="color:var(--text-main)">LLC</span></h1>
<p style="font-size:14px; font-weight:bold; margin:var(--spacing-xs) 0;">Printer Administrator</p>
<p style="font-size:11px; margin:2px 0;">Version 2.1.0</p>
<p style="font-size:10px; color:var(--text-secondary); margin:var(--spacing-sm) 0 2px 0;">Lincolnshire, IL 60069</p>
<p style="font-size:10px; color:var(--text-secondary); margin:2px 0;">1-800-732-8950</p>
<p style="font-size:9px; color:var(--text-secondary); margin-top:var(--spacing-sm);"> 2025 Cognitive LLC</p>
</div>
<div style="flex:1; display:flex; flex-direction:column; min-width:0; min-height:0;">
<div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;">
<span style="font-weight:bold;">Debug Console</span>
<div style="display:flex; gap:5px; align-items:center;">
<span style="font-size:var(--font-size-small);">Log Level:</span>
<select id="log_level" class="compact">
<option value="0">All</option>
<option value="1">Trace</option>
<option value="2">Info</option>
<option value="3">Warning</option>
<option value="4">Error</option>
<option value="5">Exception</option>
</select>
<input type="text" id="log_search" placeholder="Search..." style="width:100px; font-size:var(--font-size-small); height:18px;">
<button id="btn_clear_logs" style="height:18px; min-width:40px;">Clear</button>
<button id="btn_export_logs" style="height:18px; min-width:40px;">Export</button>
</div>
</div>
<div class="debug-console" id="debug_console" style="flex:1; min-height:150px;"></div>
</div>
</div>
</div>
</div>
</div>
<div id="cpl" class="workspace" role="tabpanel">
<div class="workspace-content">
<div style="width:200px; border-right:1px solid var(--border-shadow); padding:var(--spacing-md); overflow-y:auto;">
<input type="text" id="cpl_search" placeholder="Search..." style="width:100%; margin-bottom:5px;">
<div style="font-weight:bold; margin:5px 0;">Categories</div>
<div style="display:flex; flex-direction:column; gap:var(--spacing-xs); font-size:10px;">
<a tabindex="0" data-category="all">All Commands</a>
<a tabindex="0" data-category="header">Header & Format</a>
<a tabindex="0" data-category="control">Control & Layout</a>
<a tabindex="0" data-category="text">Text & Fonts</a>
<a tabindex="0" data-category="graphics">Graphics & Drawing</a>
<a tabindex="0" data-category="barcode">Barcodes</a>
<a tabindex="0" data-category="system">System Commands</a>
<a tabindex="0" data-category="variable">Variables</a>
<a tabindex="0" data-category="network">Network</a>
<a tabindex="0" data-category="bluetooth">Bluetooth</a>
<a tabindex="0" data-category="object">Object Management</a>
<a tabindex="0" data-category="menu">Menu System</a>
<a tabindex="0" data-category="time">Time & Date</a>
<a tabindex="0" data-category="query">Query Commands</a>
</div>
</div>
<div style="flex:1; overflow-y:auto; padding:var(--spacing-md);" id="cpl_content"></div>
</div>
</div>
<div id="designer" class="workspace" role="tabpanel">
<div class="workspace-content">
<div class="designer-sidebar">
<div style="font-weight:bold; margin-bottom:var(--spacing-md);">Elements</div>
<button id="btn_add_text" style="width:100%; margin-bottom:3px;">Add Text</button>
<button id="btn_add_barcode" style="width:100%; margin-bottom:3px;">Add Barcode</button>
<button id="btn_add_box" style="width:100%; margin-bottom:3px;">Add Box</button>
<button id="btn_add_line" style="width:100%; margin-bottom:3px;">Add Line</button>
<button id="btn_add_circle" style="width:100%; margin-bottom:3px;">Add Circle</button>
<button id="btn_add_ellipse" style="width:100%; margin-bottom:10px;">Add Ellipse</button>
<div style="font-weight:bold; margin:var(--spacing-md) 0 5px 0;">Label Size</div>
<div class="grid-2" style="font-size:var(--font-size-small);">
<span>Width (dots):</span>
<input type="number" id="label_w" value="812" style="width:70px;">
<span>Height (dots):</span>
<input type="number" id="label_h" value="406" style="width:70px;">
</div>
<div id="element_props" style="margin-top:15px; padding-top:var(--spacing-md); border-top:1px solid var(--border-shadow);">
<div style="font-weight:bold; margin-bottom:5px;">Properties</div>
<div style="font-size:var(--font-size-small); color:var(--text-secondary);">Select an element</div>
</div>
</div>
<div class="designer-main">
<div class="designer-controls">
<span style="font-weight:bold;">Canvas</span>
<div style="display:flex; align-items:center; gap:var(--spacing-sm);">
<span style="font-size:var(--font-size-small);">Target:</span>
<select id="designer_target" style="width:120px; font-size:var(--font-size-small);"></select>
</div>
</div>
<div class="designer-button-row">
<button id="btn_clear_canvas">Clear</button>
<button id="btn_generate_cpl">Generate CPL</button>
<button id="btn_send_label">Send to Printer</button>
<button id="btn_save_label">Save Label</button>
<button id="btn_load_label">Load Label</button>
</div>
<div class="canvas-wrapper">
<canvas id="canvas_el" width="812" height="406"></canvas>
</div>
<textarea id="generated_cpl" readonly style="height:100px; margin-top:5px; font-family:monospace; font-size:var(--font-size-small);"></textarea>
</div>
</div>
</div>
<dialog id="dlg_add_text" class="element-dialog">
<form method="dialog">
<div style="font-weight:bold; margin-bottom:var(--spacing-md);">Add Text Element</div>
<div class="grid-2" style="gap:var(--spacing-sm); margin-bottom:var(--spacing-md);">
<label>Text:</label>
<input type="text" id="dlg_text_value" value="Sample Text" style="width:200px;">
<label>Font:</label>
<select id="dlg_text_font">
<option value="TEXT 0">TEXT 0 (5x7)</option>
<option value="TEXT 1">TEXT 1 (8x11)</option>
<option value="TEXT 2">TEXT 2 (12x16)</option>
<option value="TEXT 3" selected>TEXT 3 (18x24)</option>
<option value="TEXT 4">TEXT 4 (24x32)</option>
<option value="TEXT 5">TEXT 5 (30x40)</option>
</select>
<label>X Position:</label>
<input type="number" id="dlg_text_x" value="50" style="width:80px;">
<label>Y Position:</label>
<input type="number" id="dlg_text_y" value="50" style="width:80px;">
</div>
<div class="button-row">
<button type="submit" value="ok">Add</button>
<button type="submit" value="cancel">Cancel</button>
</div>
</form>
</dialog>
<dialog id="dlg_add_barcode" class="element-dialog">
<form method="dialog">
<div style="font-weight:bold; margin-bottom:var(--spacing-md);">Add Barcode Element</div>
<div class="grid-2" style="gap:var(--spacing-sm); margin-bottom:var(--spacing-md);">
<label>Barcode Type:</label>
<select id="dlg_bc_type">
<option value="CODE128">Code 128</option>
<option value="CODE39">Code 39</option>
<option value="EAN13">EAN-13</option>
<option value="EAN8">EAN-8</option>
<option value="UPCA">UPC-A</option>
<option value="UPCE">UPC-E</option>
<option value="ITF">Interleaved 2 of 5</option>
<option value="CODABAR">Codabar</option>
<option value="QR">QR Code</option>
<option value="DATAMATRIX">DataMatrix</option>
<option value="PDF417">PDF417</option>
</select>
<label>Data:</label>
<input type="text" id="dlg_bc_data" value="12345678" style="width:200px;">
<label>Height:</label>
<input type="number" id="dlg_bc_height" value="50" style="width:80px;">
<label>Narrow Bar:</label>
<input type="number" id="dlg_bc_narrow" value="2" min="1" max="10" style="width:80px;">
<label>X Position:</label>
<input type="number" id="dlg_bc_x" value="50" style="width:80px;">
<label>Y Position:</label>
<input type="number" id="dlg_bc_y" value="100" style="width:80px;">
</div>
<div class="button-row">
<button type="submit" value="ok">Add</button>
<button type="submit" value="cancel">Cancel</button>
</div>
</form>
</dialog>
<div id="image" class="workspace" role="tabpanel">
<div class="workspace-content">
<div class="main-panel">
<div class="compact-header-row" style="margin-bottom:var(--spacing-md);">
<span style="font-size:var(--font-size-small);">Source:</span>
<div id="img_src" class="multi-select-dropdown" style="flex:1; max-width:180px;" tabindex="0">
<span style="color:var(--text-secondary); font-size:var(--font-size-small);">Select...</span>
</div>
<span style="margin-left:var(--spacing-md); font-size:var(--font-size-small);">Target:</span>
<div id="img_target" class="multi-select-dropdown" style="flex:1; max-width:180px;" tabindex="0">
<span style="color:var(--text-secondary); font-size:var(--font-size-small);">Select...</span>
</div>
</div>
<div style="display:flex; gap:20px; flex-wrap:wrap;">
<div style="flex:1; min-width:350px; display:flex; flex-direction:column;">
<div class="group-box" style="flex:0;">
<span class="group-title">Image Extraction</span>
<div class="grid-2" style="margin-bottom:var(--spacing-md);">
<span style="text-align:right;">Memory Region:</span>
<select id="img_region" class="fill">
<option value="all">Complete Image</option>
<option value="flash">Flash Only</option>
<option value="config">Config Only</option>
</select>
<span style="text-align:right;">Start Address:</span>
<input type="text" id="img_addr" value="0x00400000" class="fill">
<span style="text-align:right;">Length (bytes):</span>
<input type="text" id="img_len" value="524288" class="fill">
</div>
<div class="button-row">
<button id="btn_extract_image">Extract Image</button>
<button id="btn_save_image">Save to File</button>
</div>
<div class="row" style="margin-top:var(--spacing-md);">
<span style="width:100px;">Progress:</span>
<div class="progress-container" style="flex:1;">
<div class="progress-bar" id="img_prog"></div>
</div>
</div>
</div>
<div class="group-box" style="flex:1; margin-top:var(--spacing-md); display:flex; flex-direction:column;">
<span class="group-title">Extracted Data (Hex Preview)</span>
<textarea id="img_data" readonly style="flex:1; font-family:'Courier New',monospace; font-size:8px; background:var(--bg-face);"></textarea>
</div>
</div>
<div style="flex:1; min-width:350px; display:flex; flex-direction:column;">
<div class="group-box" style="flex:0;">
<span class="group-title">Image Deployment</span>
<div class="grid-2" style="margin-bottom:var(--spacing-md);">
<span style="text-align:right;">Image File:</span>
<div class="row" style="margin:0;">
<input type="text" id="img_file" readonly class="fill">
<button id="btn_load_image_file">Browse</button>
</div>
</div>
<div style="margin:var(--spacing-md) 0; padding:8px; background:#fff3cd; border:1px solid #ffc107; font-size:var(--font-size-small); border-radius:var(--border-radius);">
<strong> Warning:</strong> Deploying overwrites ALL data on target printer(s).
</div>
<div class="button-row">
<button id="btn_deploy_image">Deploy Image</button>
<button id="btn_verify_image">Verify</button>
</div>
<div class="row" style="margin-top:var(--spacing-md);">
<span style="width:100px;">Progress:</span>
<div class="progress-container" style="flex:1;">
<div class="progress-bar" id="deploy_prog"></div>
</div>
</div>
</div>
<div class="group-box" style="margin-top:var(--spacing-md);">
<span class="group-title">Bootloader Recovery</span>
<div style="font-size:var(--font-size-small); margin-bottom:var(--spacing-md); line-height:1.4;">
<strong>Recovery Steps:</strong><br>
1. Power off printer<br>
2. Hold FEED button<br>
3. Power on (hold 5 sec)<br>
4. Release - LED blinks<br>
5. Click Enter Bootloader
</div>
<div class="button-row">
<button id="btn_enter_bootloader">Enter Bootloader</button>
<button id="btn_check_bootloader">Check Status</button>
<button id="btn_send_bootloader_cmd">Send Command</button>
</div>
<div id="bootloader_status" style="margin-top:var(--spacing-md); padding:5px; border:1px solid var(--border-shadow); background:var(--bg-face); min-height:60px; font-size:var(--font-size-small);">
<div style="color:var(--text-secondary);">Bootloader status will appear here...</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="server_dashboard" class="workspace server-interface" role="tabpanel">
<div class="server-dashboard">
<div class="dashboard-card">
<div class="dashboard-card-title">Server Statistics</div>
<div class="dashboard-card-content">
<div class="stat-grid">
<div class="stat-item"><div class="stat-value" id="stat_uptime">0d 0h</div><div class="stat-label">Uptime</div></div>
<div class="stat-item"><div class="stat-value" id="stat_jobs_today">0</div><div class="stat-label">Jobs Today</div></div>
<div class="stat-item"><div class="stat-value" id="stat_response">0ms</div><div class="stat-label">Avg Response</div></div>
<div class="stat-item"><div class="stat-value" id="stat_success">0%</div><div class="stat-label">Success Rate</div></div>
</div>
</div>
</div>
<div class="dashboard-card">
<div class="dashboard-card-title">System Resources</div>
<div class="dashboard-card-content">
<div class="gauge-container">
<div>
<div class="gauge"><svg viewBox="0 0 36 36"><path class="gauge-bg" d="M18 2.0845 a 15.9155 15.9155 0 0 1 0 31.831 a 15.9155 15.9155 0 0 1 0 -31.831"></path><path class="gauge-fill" id="gauge_cpu" stroke-dasharray="0, 100" d="M18 2.0845 a 15.9155 15.9155 0 0 1 0 31.831 a 15.9155 15.9155 0 0 1 0 -31.831"></path></svg><div class="gauge-text" id="gauge_cpu_text">0%</div></div>
<div class="gauge-label">CPU</div>
</div>
<div>
<div class="gauge"><svg viewBox="0 0 36 36"><path class="gauge-bg" d="M18 2.0845 a 15.9155 15.9155 0 0 1 0 31.831 a 15.9155 15.9155 0 0 1 0 -31.831"></path><path class="gauge-fill" id="gauge_mem" stroke-dasharray="0, 100" d="M18 2.0845 a 15.9155 15.9155 0 0 1 0 31.831 a 15.9155 15.9155 0 0 1 0 -31.831"></path></svg><div class="gauge-text" id="gauge_mem_text">0%</div></div>
<div class="gauge-label">Memory</div>
</div>
<div>
<div class="gauge"><svg viewBox="0 0 36 36"><path class="gauge-bg" d="M18 2.0845 a 15.9155 15.9155 0 0 1 0 31.831 a 15.9155 15.9155 0 0 1 0 -31.831"></path><path class="gauge-fill" id="gauge_disk" stroke-dasharray="0, 100" d="M18 2.0845 a 15.9155 15.9155 0 0 1 0 31.831 a 15.9155 15.9155 0 0 1 0 -31.831"></path></svg><div class="gauge-text" id="gauge_disk_text">0%</div></div>
<div class="gauge-label">Disk</div>
</div>
</div>
</div>
</div>
<div class="dashboard-card">
<div class="dashboard-card-title">Network Traffic</div>
<div class="dashboard-card-content">
<div class="chart-area" id="network_chart"></div>
<div style="display:flex;justify-content:space-between;font-size:9px;color:var(--text-secondary);margin-top:4px;">
<span>In: <span id="net_in">0</span> KB/s</span>
<span>Out: <span id="net_out">0</span> KB/s</span>
</div>
</div>
</div>
<div class="dashboard-card">
<div class="dashboard-card-title">Connected Printers (<span id="printer_count">0</span>)</div>
<div class="dashboard-card-content">
<div class="printer-grid" id="server_printer_grid"></div>
</div>
</div>
<div class="dashboard-card">
<div class="dashboard-card-title">Active Print Jobs</div>
<div class="dashboard-card-content">
<div class="chart-area" id="jobs_chart"></div>
<div style="display:flex;justify-content:space-around;font-size:9px;margin-top:4px;">
<span><span class="status-indicator status-healthy"></span>Complete: <span id="jobs_complete">0</span></span>
<span><span class="status-indicator status-warning"></span>Pending: <span id="jobs_pending">0</span></span>
<span><span class="status-indicator status-critical"></span>Failed: <span id="jobs_failed">0</span></span>
</div>
</div>
</div>
<div class="dashboard-card">
<div class="dashboard-card-title">Support Tickets</div>
<div class="dashboard-card-content">
<div style="display:flex;gap:var(--spacing-md);margin-bottom:var(--spacing-sm);">
<div class="stat-item" style="flex:1;"><div class="stat-value" id="tickets_open" style="font-size:16px;">0</div><div class="stat-label">Open</div></div>
<div class="stat-item" style="flex:1;"><div class="stat-value" id="tickets_closed" style="font-size:16px;">0</div><div class="stat-label">Closed</div></div>
</div>
<div class="ticket-list" id="ticket_list"></div>
</div>
</div>
<div class="dashboard-card" style="grid-column: span 2;">
<div class="dashboard-card-title">Live Server Log</div>
<div class="dashboard-card-content">
<div class="log-feed" id="server_log"></div>
</div>
</div>
<div class="dashboard-card">
<div class="dashboard-card-title">Error Rate (24h)</div>
<div class="dashboard-card-content">
<div class="chart-area" id="error_chart"></div>
<div style="text-align:center;margin-top:4px;font-size:10px;">
<span class="status-indicator" id="error_status"></span>
<span id="error_rate_text">0.0% error rate</span>
</div>
</div>
</div>
</div>
</div>
<div id="status-announcer" class="sr-only" role="status" aria-live="polite" aria-atomic="true"></div>
</div>
</div>
<script>
(function() {
'use strict';
const State = {
printers: [],
printerCounter: 0,
selectedPrinterIds: [],
lastSelectedIndex: -1,
multiSelectStates: {},
labelElements: [],
selectedElement: null,
draggedTab: null,
logMessages: [],
logLevel: 0,
activeIntervals: [],
currentRole: 'admin',
serverDashboardInterval: null,
serverUptime: 0,
networkData: [],
heartbeatInterval: null,
scriptTimer: null
};
const MfgTest = {
totalSteps: 20,
currentStep: 0,
running: false,
aborted: false,
testInterval: null,
tests: [
{ name: 'Initial Setup', fn: 'initialSetup' },
{ name: 'Firmware Load', fn: 'firmwareLoad', skippable: true },
{ name: 'Printer Identification', fn: 'printerIdentification' },
{ name: 'Font Loading', fn: 'fontLoading', skippable: true },
{ name: 'CPR Download', fn: 'cprDownload', skippable: true },
{ name: 'Control Panel Test', fn: 'controlPanelTest' },
{ name: 'Connection Interfaces', fn: 'connectionInterfaces' },
{ name: 'Print-Head Up/Down', fn: 'printHeadUpDown' },
{ name: 'Feed Button Test', fn: 'feedButtonTest' },
{ name: 'Peeler Test', fn: 'peelerTest' },
{ name: 'Tone Check', fn: 'toneCheck' },
{ name: 'RTC Setup', fn: 'rtcSetup' },
{ name: 'Calibration & Indexing', fn: 'calibration' },
{ name: 'Backup Memory', fn: 'backupMemory' },
{ name: 'Print Quality', fn: 'printQuality' },
{ name: 'Print Head Test', fn: 'printHeadTest' },
{ name: 'Ribbon Wrinkle', fn: 'ribbonWrinkle' },
{ name: 'Self-Test', fn: 'selfTest' },
{ name: 'Final Settings', fn: 'finalSettings' },
{ name: 'Shipping Label', fn: 'shippingLabel' }
],
setStatus(step, status, color) {
const elem = $(`test_${step}`);
if (elem) {
elem.textContent = status;
elem.style.color = color;
}
},
reset() {
this.currentStep = 0;
this.running = false;
this.aborted = false;
for (let i = 1; i <= this.totalSteps; i++) {
this.setStatus(i, 'Pending', 'var(--text-secondary)');
}
},
start() {
this.reset();
this.running = true;
this.aborted = false;
this.currentStep = 1;
this.runCurrentStep();
},
runNext() {
if (this.currentStep < this.totalSteps && !this.running) {
this.currentStep++;
this.runCurrentStep();
}
},
runCurrentStep() {
if (this.aborted || this.currentStep > this.totalSteps) {
this.running = false;
if (!this.aborted) {
announce('All tests completed');
log(2, 'Manufacturing test sequence completed');
}
return;
}
const stepNum = this.currentStep;
const testDef = this.tests[stepNum - 1];
if (testDef.skippable && $(`skip_test_${stepNum}`)?.checked) {
this.setStatus(stepNum, 'Skipped', '#888888');
log(2, `Test ${stepNum} (${testDef.name}) skipped`);
this.currentStep++;
setTimeout(() => this.runCurrentStep(), 100);
return;
}
this.setStatus(stepNum, 'Running...', '#0000ff');
log(1, `Test ${stepNum} (${testDef.name}) running...`);
this.executeTest(testDef.fn, stepNum).then(result => {
if (this.aborted) return;
if (result.success) {
this.setStatus(stepNum, 'Passed', '#008000');
log(2, `Test ${stepNum} (${testDef.name}) passed`);
} else {
this.setStatus(stepNum, result.status || 'Failed', '#ff0000');
log(4, `Test ${stepNum} (${testDef.name}) failed: ${result.error || 'Unknown error'}`);
}
this.currentStep++;
if (this.running) {
setTimeout(() => this.runCurrentStep(), 300);
}
});
},
abort() {
this.aborted = true;
this.running = false;
clearIntervals();
},
enablePCL() {
log(2, 'Sending PCL enable command...');
return this.backend_enablePCL();
},
async executeTest(testFn, stepNum) {
return new Promise(resolve => {
setTimeout(() => {
const result = this[`backend_${testFn}`]?.() || { success: true };
resolve(result);
}, 500 + Math.random() * 500);
});
},
backend_initialSetup() {
log(1, '[BACKEND] Initial setup - establishing connection to UUT');
return { success: true };
},
backend_firmwareLoad() {
log(1, '[BACKEND] Firmware load - streaming firmware to printer');
return { success: true };
},
backend_printerIdentification() {
const serial = $('mfg_serial')?.value || 'SN000000';
const mac = $('mfg_mac')?.value || '00:00:00:00:00:00';
log(1, `[BACKEND] Printer ID - S/N: ${serial}, MAC: ${mac}`);
return { success: true };
},
backend_fontLoading() {
log(1, '[BACKEND] Font loading - downloading font files');
return { success: true };
},
backend_cprDownload() {
log(1, '[BACKEND] CPR download - loading configuration parameters');
return { success: true };
},
backend_controlPanelTest() {
log(1, '[BACKEND] Control panel test - verifying buttons and LEDs');
return { success: true };
},
backend_connectionInterfaces() {
log(1, '[BACKEND] Interface test - verifying communication ports');
return { success: true };
},
backend_printHeadUpDown() {
log(1, '[BACKEND] Print head up/down test');
return { success: true };
},
backend_feedButtonTest() {
log(1, '[BACKEND] Feed button test');
return { success: true };
},
backend_peelerTest() {
log(1, '[BACKEND] Peeler test');
return { success: true };
},
backend_toneCheck() {
log(1, '[BACKEND] Tone check - testing audible alerts');
return { success: true };
},
backend_rtcSetup() {
log(1, '[BACKEND] RTC setup - setting real-time clock');
return { success: true };
},
backend_calibration() {
log(1, '[BACKEND] Calibration - calibrating media sensors');
return { success: true };
},
backend_backupMemory() {
log(1, '[BACKEND] Backup memory test');
return { success: true };
},
backend_printQuality() {
log(1, '[BACKEND] Print quality test');
return { success: true };
},
backend_printHeadTest() {
log(1, '[BACKEND] Print head element test');
return { success: true };
},
backend_ribbonWrinkle() {
log(1, '[BACKEND] Ribbon wrinkle test');
return { success: true };
},
backend_selfTest() {
log(1, '[BACKEND] Self-test');
return { success: true };
},
backend_finalSettings() {
log(1, '[BACKEND] Final settings');
return { success: true };
},
backend_shippingLabel() {
log(1, '[BACKEND] Shipping label');
return { success: true };
},
backend_enablePCL() {
log(1, '[BACKEND] Enabling PCL mode');
announce('PCL mode enabled');
return { success: true };
}
};
const ROLES = {
admin: { name: 'Administrator', subtitle: 'Printer Administrator', tabs: ['conn', 'print', 'pos', 'fonts', 'prof', 'firm', 'mfg', 'edit', 'pcl', 'cpl', 'designer', 'image', 'autotest', 'about'] },
technician: { name: 'Repair Technician', subtitle: 'Printer Repair Technician', tabs: ['conn', 'print', 'pos', 'fonts', 'prof', 'firm', 'edit', 'pcl', 'cpl', 'designer', 'about'] },
factory: { name: 'Factory Worker', subtitle: 'Factory Production Console', tabs: ['conn', 'print', 'pos', 'mfg', 'edit', 'cpl', 'about'] },
customer: { name: 'Customer', subtitle: 'Printer Status Viewer', tabs: ['conn', 'about'] },
server: { name: 'Server Backend', subtitle: 'Server Monitoring Dashboard', tabs: ['autotest'] }
};
const TAB_ORDER = [
'conn', 'print', 'pos', 'fonts', 'prof', 'firm', 'mfg', 'edit', 'pcl', 'cpl', 'designer', 'image', 'autotest', 'about'
];
const TAB_NAMES = {
conn: 'Connection Settings',
print: 'Printer Settings',
pos: 'Label Positioning',
fonts: 'Fonts and Objects',
prof: 'Profile Management',
firm: 'Firmware Upgrade',
mfg: 'Manufacturing Test',
edit: 'Script Editor',
pcl: 'PCL Windowing',
about: 'About',
cpl: 'CPL Reference',
designer: 'Label Designer',
image: 'Image & Recovery',
autotest: 'Automated Tests'
};
const CPL_DB = {
header: [
{cmd: "!", short: "HEADER", params: "n LAR Length Quantity", desc: "Header line - defines label format parameters", example: "! 0 100 200 1\nSTRING 12x16 10 10 Hello\nEND"},
{cmd: "!!", short: "FORCED HEADER", params: "n LAR Length Quantity", desc: "Forced header variant that overwrites prior header", example: "!! 0 100 200 1"},
{cmd: "!#", short: "BACKGROUND HEADER", params: "n LAR Length Quantity", desc: "Sets background graphics mode for repeated printing", example: "!# 0 100 200 5\nSTRING 12x16 10 10 Background\nEND"},
{cmd: "!*", short: "CLEAR BACKGROUND", params: "", desc: "Clears background graphics buffer", example: "!*"},
{cmd: "@", short: "FOREGROUND GRAPHIC", params: "", desc: "Enter foreground graphics mode", example: "@"},
{cmd: "#", short: "BACKGROUND GRAPHIC", params: "", desc: "Enter background graphics mode", example: "#"},
{cmd: "!A", short: "HEADER AUTO", params: "0 LAR len qty", desc: "Automatic header variant", example: "!A 0 100 200 1"},
{cmd: "!+", short: "HEADER PLUS", params: "0 LAR len qty", desc: "Header with plus options (background image present)", example: "!+ 0 100 200 5"},
{cmd: "!P", short: "PASSWORD HEADER", params: "xx 0 LAR len qty", desc: "Password-protected header variant (xx=password bytes)", example: "!P01 0 100 200 1"},
{cmd: "END", short: "E", params: "", desc: "End of label format - terminates and prints", example: "TEXT 3 0 10 10 Sample\nEND"},
{cmd: "XENH_END", short: "", params: "", desc: "Enhanced end marker for virtual formats", example: "XENH_END"},
{cmd: "ENHEND", short: "ENHANCED END", params: "", desc: "Enhanced end for special label processing", example: "! 0 100 100 1\nSTRING 12x16 10 10 Enhanced\nENHEND"},
{cmd: "NOPRINTEND", short: "END NO PRINT", params: "", desc: "Terminates format without printing", example: "! 0 100 100 1\nSTRING 12x16 10 10 Test\nNOPRINTEND"},
{cmd: "STORE FORMAT", short: "", params: "name", desc: "Store current format to memory", example: "STORE FORMAT LABEL1"},
{cmd: "STORE ENHANCED FORMAT", short: "", params: "name", desc: "Stores enhanced format with variable placeholders", example: "STORE ENHANCED FORMAT LABEL2"},
{cmd: "RECALL FORMAT", short: "", params: "name [data]", desc: "Recalls and executes stored label format", example: "RECALL FORMAT LABEL1"}
],
control: [
{cmd: "ADJUST", short: "A", params: "[ID] nnn", desc: "Increments/decrements a variable for serial numbering", example: "BARCODE CODE39 150 30 30 TEST20\nADJUST -01", response: "none", responseBytes: 0},
{cmd: "ADJUST_DUP", short: "AP", params: "nnn", desc: "Prints non-incremented duplicates of incremented labels", example: "STRING 8X8 0 0 1000\nADJUST 0001\nADJUST_DUP 2", response: "none", responseBytes: 0},
{cmd: "AREA_CLEAR", short: "AR", params: "x y w h", desc: "Clears a rectangular area for replotting", example: "AREA_CLEAR 50 50 200 100", response: "none", responseBytes: 0},
{cmd: "BEEP", short: "", params: "[duration 0-60] [volume 0-3]", desc: "Activates beeper (duration:0-60 sec, volume:0 to BEEPER_ENTRIES-1)", example: "BEEP 2 5", response: "none", responseBytes: 0},
{cmd: "DELIMIT", short: "", params: "char 0x21-0xFF", desc: "Sets field delimiter character (ASCII 0x21-0xFF)", example: "DELIMIT ,", response: "none", responseBytes: 0},
{cmd: "HALT", short: "H", params: "[time 0-255] [count 0-255]", desc: "Pauses printing (time:0-255 sec, count:0-255)", example: "HALT TIME 5", response: "none", responseBytes: 0},
{cmd: "INDEX", short: "I", params: "", desc: "Forces form feed to next gap/mark", example: "INDEX", response: "none", responseBytes: 0},
{cmd: "NOINDEX", short: "N", params: "", desc: "Disables label indexing for this label", example: "NOINDEX", response: "none", responseBytes: 0},
{cmd: "JUSTIFY", short: "J", params: "LEFT|CENTER|RIGHT", desc: "Sets text justification (LEFT, CENTER, RIGHT)", example: "JUSTIFY CENTER", response: "none", responseBytes: 0},
{cmd: "KEYBOARD_MODE", short: "", params: "mode", desc: "Keyboard mode selection (SERIAL, etc.)", example: "KEYBOARD_MODE SERIAL", response: "none", responseBytes: 0},
{cmd: "LINK", short: "", params: "object target", desc: "Links formats/objects together", example: "LINK format target", response: "none", responseBytes: 0},
{cmd: "MULTIPLE", short: "M", params: "1-9", desc: "Prints multiple copies horizontally (1-9)", example: "MULTIPLE 2", response: "none", responseBytes: 0},
{cmd: "OFFSET", short: "", params: "x y", desc: "Sets coordinate offset for subsequent commands", example: "OFFSET 10 20", response: "none", responseBytes: 0},
{cmd: "PITCH", short: "P", params: "0-65535", desc: "Sets resolution (0-65535, typically 100/200/300)", example: "PITCH 200", response: "none", responseBytes: 0},
{cmd: "PRINT_LABEL", short: "", params: "name [options]", desc: "Invoke stored label format for printing", example: "PRINT_LABEL myformat", response: "none", responseBytes: 0},
{cmd: "PROMPTS", short: "", params: "\"text\"", desc: "Display prompt text for menu system", example: "PROMPTS \"Enter value\"", response: "none", responseBytes: 0},
{cmd: "QUANTITY", short: "QY", params: "0-65535", desc: "Sets number of copies to print (0-65535)", example: "QUANTITY 5", response: "none", responseBytes: 0},
{cmd: "R90", short: "R9", params: "", desc: "Rotate output 90 degrees", example: "R90", response: "none", responseBytes: 0},
{cmd: "R180", short: "R1", params: "", desc: "Rotate output 180 degrees", example: "R180", response: "none", responseBytes: 0},
{cmd: "R270", short: "R2", params: "", desc: "Rotate output 270 degrees", example: "R270", response: "none", responseBytes: 0},
{cmd: "SECURITY BARCODE", short: "", params: "data", desc: "Security barcoding when feature is enabled", example: "SECURITY BARCODE ...", response: "none", responseBytes: 0},
{cmd: "TERMINAL", short: "", params: "DEFAULT|RS232|LCD_PANEL|USB|RTEL|DISCOVER", desc: "Select terminal/display port (DEFAULT|RS232|LCD_PANEL|USB|RTEL|DISCOVER)", example: "TERMINAL DEFAULT", response: "none", responseBytes: 0},
{cmd: "TEST_LABEL", short: "", params: "[Y] [H]", desc: "Print diagnostic test label", example: "TEST_LABEL 1 Y H", response: "none", responseBytes: 0},
{cmd: "VARIABLES", short: "", params: "ON|OFF", desc: "Enable/disable processing of variable blocks", example: "VARIABLES ON", response: "none", responseBytes: 0},
{cmd: "WIDTH", short: "W", params: "n|?", desc: "Sets logical print width (0-65535 dots)", example: "WIDTH 400", response: "ASCII + optional CRLF on query", responseBytes: "18-19", exampleResponse: "WIDTH = 400 (812 dots)"},
{cmd: "BARCODER", short: "BR", params: "", desc: "Enable/adjust internal barcode rendering mode", example: "BARCODER ENABLE"}
],
text: [
{cmd: "STRING", short: "S", params: "font (mods) x y data", desc: "Prints text using bitmap fonts (5X7, 8X8, 10X14, 12X16, 18X23, 24X31)", example: "STRING 12x16 10 10 Hello World"},
{cmd: "TEXT", short: "T", params: "font (mods) x y data", desc: "Prints text using CG Triumvirate fonts (0-6)", example: "TEXT 3 0 50 100 Hello World"},
{cmd: "ULTRA_FONT", short: "U", params: "TnnnXmmm IGz(B,E,R) x y data", desc: "Prints using TrueType vector fonts with size/bold/rotation", example: "ULTRA_FONT T10X15 IGz(2,1,0) 10 10 Ultra"},
{cmd: "ROTATE", short: "R", params: "angle (mods) x y data", desc: "Rotates STRING text (90, 180, 270 degrees)", example: "ROTATE 90 0 100 50 Vertical"},
{cmd: "DOUBLE", short: "", params: "font(mods) x y mtid chars", desc: "Renders double-byte characters (Chinese, Japanese)", example: "DOUBLE 3(1,0,2,2) 10 10 1234 "},
{cmd: "THAI", short: "", params: "fontID(mods) x y chars", desc: "Renders Thai text with specified formatting", example: "THAI 3(0,0,1,1) 10 10 "},
{cmd: "COMMENT", short: "C", params: "text", desc: "Adds comments for documentation (not printed)", example: "COMMENT This is a comment"},
{cmd: "DATASKIP", short: "DP", params: "count", desc: "Skips specified number of characters in data stream", example: "DATASKIP 5"},
{cmd: "DATASKIP UNTIL", short: "", params: "char count", desc: "Skip input until character appears count times", example: "DATASKIP UNTIL , 3"},
{cmd: "DATASKIP LOOPUNTIL", short: "", params: "char count", desc: "Loop skipping until character criteria is met", example: "DATASKIP LOOPUNTIL ; 2"},
{cmd: "DEFINE_VAR", short: "DR", params: "name type length", desc: "Define format variable (type: X,A,N,#,F#; length: 1-254)", example: "DEFINE_VAR price # 8"},
{cmd: "MICR", short: "", params: "text params", desc: "MICR text printing for checks/documents", example: "MICR TEXT 123456789"}
],
graphics: [
{cmd: "DRAW_BOX", short: "D", params: "x y w h [thick]", desc: "Draws hollow rectangle outline", example: "DRAW_BOX 50 50 200 100 2"},
{cmd: "DRAW_LINE", short: "DL", params: "x1 y1 x2 y2 [thick] [color]", desc: "Draws line between points (color: B/W)", example: "DRAW_LINE 10 10 200 200 3 B"},
{cmd: "DRAW_CIRCLE", short: "DC", params: "x y dia [thick] [color]", desc: "Draws circle outline", example: "DRAW_CIRCLE 100 100 50 2 B"},
{cmd: "DRAW_ELLIPSE", short: "DE", params: "x y w h [thick] [color]", desc: "Draws ellipse outline", example: "DRAW_ELLIPSE 100 100 80 50 2 B"},
{cmd: "FILL_BOX", short: "F", params: "x y w h", desc: "Draws filled black rectangle", example: "FILL_BOX 50 50 200 100"},
{cmd: "DRAW_SYMBOL", short: "SYMBOL", params: "x y symbol", desc: "Draws predefined symbol (A-E)", example: "DRAW_SYMBOL 10 10 A"},
{cmd: "GRAPHIC", short: "G", params: "[type] x y [w h] data", desc: "Renders PCX/BMP graphic data at coordinates", example: "GRAPHIC PCX 50 50"},
{cmd: "GRAPHIC STORE", short: "", params: "type loc name", desc: "Saves image to printer memory (loc: R/F)", example: "GRAPHIC STORE PCX F LOGO1"},
{cmd: "GRAPHIC RECALL", short: "!R G", params: "name x y", desc: "Places stored image on label", example: "GRAPHIC RECALL LOGO1 50 50"}
],
barcode: [
{cmd: "BARCODE", short: "B", params: "[Rot] type [mods] x y h data", desc: "Standard 1D barcodes (module size 1-10)", example: "BARCODE CODE128 0 50 100 80 12345678"},
{cmd: "BARCODE CODE39", short: "", params: "x y h data", desc: "Code 39 alphanumeric barcode", example: "BARCODE CODE39 10 10 50 ABC123"},
{cmd: "BARCODE CODE128", short: "", params: "x y h data", desc: "Code 128 high-density barcode", example: "BARCODE CODE128 10 10 50 TEST12345"},
{cmd: "BARCODE EAN13", short: "", params: "x y h data", desc: "EAN-13 retail barcode (13 digits)", example: "BARCODE EAN13 10 10 50 5901234123457"},
{cmd: "BARCODE UPCA", short: "", params: "x y h data", desc: "UPC-A retail barcode (12 digits)", example: "BARCODE UPCA 10 10 50 012345678905"},
{cmd: "BARCODE I2OF5", short: "", params: "x y h data", desc: "Interleaved 2 of 5 numeric barcode", example: "BARCODE I2OF5 10 10 50 12345678"},
{cmd: "BARCODE CODABAR", short: "", params: "x y h data", desc: "Codabar for libraries/blood banks", example: "BARCODE CODABAR 10 10 50 A12345B"},
{cmd: "BARCODE QR", short: "", params: "x y cell [model] bytes data", desc: "2D QR Code (cell=1-10, model=1/2)", example: "BARCODE QR 50 50 3 2 20 https://example.com"},
{cmd: "BARCODE DATAMATRIX", short: "DM", params: "(fmt,ecc,rows,cols,cell,bytes) x y data", desc: "2D Data Matrix (fmt: 0=Square, 1=Rect)", example: "BARCODE DATAMATRIX (0,0,0,0,3,10) 50 50 TEST123"},
{cmd: "BARCODE PDF417", short: "", params: "x y aspect ec r:c bytes T M data", desc: "2D PDF417 stacked barcode", example: "BARCODE PDF417 50 50 3 2 0:0 20 0 0 DATA"},
{cmd: "BARCODE MICROPDF", short: "", params: "x y params data", desc: "2D MicroPDF417 compact version", example: "BARCODE MICROPDF 10 10 \"DATA\""},
{cmd: "BARCODE AZTEC", short: "", params: "(ECP,Size,Lay,ID,E,M) x y bytes data", desc: "2D Aztec Code", example: "BARCODE AZTEC (0,0,0,0,0,0) 50 50 15 AZTEC123"},
{cmd: "BARCODE RSS", short: "", params: "x y params data", desc: "RSS/GS1 DataBar symbology", example: "BARCODE RSS 10 10 \"DATA\""},
{cmd: "BARCODE UPS", short: "", params: "x y w h data", desc: "UPS MaxiCode for shipping", example: "BARCODE UPS 10 10 100 50 1Z12345678"},
{cmd: "BARCODE_FONT", short: "", params: "font", desc: "Select font for barcode human-readable text", example: "BARCODE_FONT TEXT"},
{cmd: "BSTRING", short: "BARCODE_FONT_STRING", params: "fontID(spacing,rotation,xmult,ymult) x y data", desc: "Barcode using string font", example: "BSTRING 3(0,0,1,1) 10 10 CODE128DATA"},
{cmd: "BTEXT", short: "BARCODE_FONT_TEXT", params: "fontID(spacing,rotation,xmult,ymult) x y data", desc: "Barcode using text font", example: "BTEXT 3(0,0,1,1) 10 10 CODE128DATA"},
{cmd: "BULTRA", short: "BARCODE_FONT_ULTRA", params: "fontID(mods) x y data", desc: "Barcode using ultra font", example: "BULTRA 3(0,0,1,1) 10 10 CODE128DATA"}
],
system: [
{cmd: "!RESET", short: "", params: "", desc: "Soft reboots the printer", example: "!RESET", response: "none", responseBytes: 0},
{cmd: "!STATUS", short: "", params: "", desc: "Returns printer status (Ready, Paper Out, Head Open)", example: "!STATUS", response: "Variable ASCII + optional CRLF", responseBytes: "variable", exampleResponse: "Ready"},
{cmd: "!CAL", short: "", params: "[mode]", desc: "Runs media sensor calibration (0=Normal, 3=Mesh)", example: "!CAL 0", response: "none", responseBytes: 0},
{cmd: "!DUMP DATAFLASH", short: "", params: "len addr", desc: "Hex dump of Flash memory", example: "!DUMP DATAFLASH 256 0x400000", response: "Hex ASCII data", responseBytes: "variable"},
{cmd: "!DUMP IMAGE", short: "", params: "", desc: "Hex dump of print buffer (raster data)", example: "!DUMP IMAGE", response: "Binary/ASCII data", responseBytes: "variable"},
{cmd: "!DUMP USERVARS", short: "", params: "", desc: "Lists all user-configurable variable settings", example: "!DUMP USERVARS", response: "ASCII variable list", responseBytes: "variable"},
{cmd: "!DUMP FACTORYAVARS", short: "", params: "", desc: "Displays factory variable memory area", example: "!DUMP FACTORYAVARS", response: "ASCII variable list", responseBytes: "variable"},
{cmd: "!DUMP FACTORYBVARS", short: "", params: "", desc: "Displays factory backup variable memory", example: "!DUMP FACTORYBVARS", response: "ASCII variable list", responseBytes: "variable"},
{cmd: "!DUMP MEMORY", short: "", params: "size addr", desc: "Displays RAM memory contents for debugging", example: "!DUMP MEMORY 20 0x20123456", response: "Hex ASCII data", responseBytes: "variable"},
{cmd: "!GET INDEX", short: "!QI", params: "", desc: "Returns current Gap Sensor voltage/value", example: "!GET INDEX", response: "ASCII config + optional CRLF", responseBytes: "variable", exampleResponse: "INDEX: GAP DT 50 50 100 200"},
{cmd: "!GET STATUS", short: "", params: "", desc: "Returns printer status byte", example: "!GET STATUS", response: "1-2 bytes", responseBytes: "1-2", exampleResponse: "00"},
{cmd: "!GET TOF", short: "", params: "", desc: "Retrieves current Top of Form setting", example: "!GET TOF", response: "ASCII value", responseBytes: "variable", exampleResponse: "TOF = 120"},
{cmd: "!GET SHIFT", short: "", params: "", desc: "Retrieves current print shift/offset settings", example: "!GET SHIFT", response: "ASCII value", responseBytes: "variable", exampleResponse: "SHIFT = 10"},
{cmd: "!LOAD C_BIN", short: "", params: "", desc: "Enters firmware update mode", example: "!LOAD C_BIN"},
{cmd: "!TEST", short: "", params: "[type]", desc: "Runs printer self-test", example: "!TEST", response: "none", responseBytes: 0},
{cmd: "!IDENTIFY", short: "", params: "", desc: "Returns printer model and firmware version", example: "!IDENTIFY", response: "Variable ASCII + optional CRLF", responseBytes: "variable", exampleResponse: "BT200 V1.2.3"},
{cmd: "!!", short: "DOUBLE BANG", params: "x dottime maxY numlbls", desc: "Executes internal test patterns for manufacturing", example: "!! 1 10 100 5"},
{cmd: "!ERASE EVENTLOG", short: "", params: "", desc: "Clears the printer's event log", example: "!ERASE EVENTLOG"},
{cmd: "!ERASE SECTOR", short: "", params: "[A|B]", desc: "Erases specified flash memory sector", example: "!ERASE SECTORA"},
{cmd: "!HISTORY DISABLE", short: "", params: "", desc: "Disables all history tracking", example: "!HISTORY DISABLE"},
{cmd: "!HISTORY ENABLE", short: "", params: "hexvalue", desc: "Enables specific history tracking with bitmask", example: "!HISTORY ENABLE 0xFF"},
{cmd: "!HISTORY INIT", short: "", params: "hexvalue", desc: "Initializes history system with parameters", example: "!HISTORY INIT 0x00"},
{cmd: "!HISTORY OUTPUT", short: "", params: "enable/disable", desc: "Enables/disables history output logging", example: "!HISTORY OUTPUT ENABLE"},
{cmd: "!LOAD INCHCOUNT", short: "", params: "nnn", desc: "Loads inch count value for factory tracking", example: "!LOAD INCHCOUNT 1000", response: "none", responseBytes: 0},
{cmd: "!LOAD LICENSE", short: "", params: "\"key\"", desc: "Loads software license key (manufacturing)", example: "!LOAD LICENSE \"ABC123-DEF456\"", response: "none", responseBytes: 0},
{cmd: "!LOAD MAC", short: "", params: "addr", desc: "Sets the network interface MAC address", example: "!LOAD MAC 00:11:22:33:44:55", response: "none", responseBytes: 0},
{cmd: "!LOAD MODELNUMBER", short: "", params: "model", desc: "Sets the printer's model number", example: "!LOAD MODELNUMBER BT200", response: "none", responseBytes: 0},
{cmd: "!LOAD SERIALNUMBER", short: "", params: "serial", desc: "Sets the printer's serial number", example: "!LOAD SERIALNUMBER ABC123456", response: "none", responseBytes: 0},
{cmd: "!LOAD OOBVARS", short: "", params: "", desc: "Loads out-of-box variables to factory defaults", example: "!LOAD OOBVARS", response: "none", responseBytes: 0},
{cmd: "!PRINT TESTLABEL", short: "", params: "", desc: "Prints comprehensive test label with config", example: "!PRINT TESTLABEL", response: "none", responseBytes: 0},
{cmd: "!SET HOST_NAME", short: "", params: "\"hostname\"", desc: "Sets network host name for printer", example: "!SET HOST_NAME \"PRINTER001\"", response: "none", responseBytes: 0},
{cmd: "!SET INDEX", short: "", params: "FeedType PrintMode R% T% Gain WhiteLevel", desc: "Sets comprehensive index sensor parameters", example: "!SET INDEX GAP DIRECT 50 50 100 200", response: "none", responseBytes: 0},
{cmd: "!SET PEELER", short: "", params: "power 0-100 gain 0-3 time 0-65535", desc: "Configures label peeler operation mode", example: "!SET PEELER 80 2 500", response: "none", responseBytes: 0},
{cmd: "!SET PRINTHEAD", short: "", params: "parameters", desc: "Configures print head specifications (mfg)", example: "!SET PRINTHEAD 203,832", response: "none", responseBytes: 0},
{cmd: "!SET SHIFT", short: "", params: "value", desc: "Sets global print position shift/offset", example: "!SET SHIFT 10", response: "none", responseBytes: 0},
{cmd: "!SET TIME", short: "", params: "YYYY MM DD hh mm ss", desc: "Sets the printer's internal clock", example: "!SET TIME 2024 12 25 14 30 00", response: "none", responseBytes: 0},
{cmd: "!SET TOF", short: "", params: "nnn", desc: "Sets the Top of Form value", example: "!SET TOF 100", response: "none", responseBytes: 0},
{cmd: "!SHOW AD", short: "", params: "", desc: "Displays A/D converter readings for diagnostics", example: "!SHOW AD", response: "Variable ASCII + optional CRLF", responseBytes: "variable", exampleResponse: "AD0: 512 AD1: 384 AD2: 256"},
{cmd: "!SHOW EVENTLOG", short: "", params: "", desc: "Displays printer's event log for troubleshooting", example: "!SHOW EVENTLOG", response: "Variable ASCII lines", responseBytes: "variable"},
{cmd: "!SHOW HEAP", short: "", params: "", desc: "Shows heap memory allocation statistics", example: "!SHOW HEAP", response: "Variable ASCII + optional CRLF", responseBytes: "variable", exampleResponse: "Heap Free: 32768 Used: 16384"},
{cmd: "!SHOW HISTORY", short: "!QH", params: "", desc: "Displays command history buffer for debugging", example: "!SHOW HISTORY", response: "Variable ASCII + optional CRLF", responseBytes: "variable"},
{cmd: "!SHOW HOST_NAME", short: "", params: "", desc: "Displays the printer's network hostname", example: "!SHOW HOST_NAME", response: "ASCII + optional CRLF", responseBytes: "variable", exampleResponse: "PRINTER001"},
{cmd: "!SHOW INCHCOUNT", short: "", params: "", desc: "Shows cumulative count of inches printed", example: "!SHOW INCHCOUNT", response: "Variable ASCII + optional CRLF", responseBytes: "variable", exampleResponse: "123456"},
{cmd: "!SHOW MAC", short: "", params: "", desc: "Displays the Ethernet MAC address", example: "!SHOW MAC", response: "17 ASCII bytes XX:XX:XX:XX:XX:XX", responseBytes: 17, exampleResponse: "00:11:22:33:44:55"},
{cmd: "!SHOW MEMORY", short: "", params: "", desc: "Displays current memory usage statistics", example: "!SHOW MEMORY", response: "Variable ASCII + optional CRLF", responseBytes: "variable", exampleResponse: "Total: 65536 Free: 32768"},
{cmd: "!SHOW MODELNUMBER", short: "", params: "", desc: "Displays the printer model number", example: "!SHOW MODELNUMBER", response: "4-29 ASCII bytes + optional CRLF", responseBytes: "4-29", exampleResponse: "BT200"},
{cmd: "!SHOW PRINTHEAD", short: "", params: "", desc: "Displays print head type, resolution, width", example: "!SHOW PRINTHEAD", response: "Variable ASCII + optional CRLF", responseBytes: "variable", exampleResponse: "DPI: 203 Width: 832"},
{cmd: "!SHOW SERIALNUMBER", short: "", params: "", desc: "Displays the printer serial number", example: "!SHOW SERIALNUMBER", response: "6-20 ASCII bytes + optional CRLF", responseBytes: "6-20", exampleResponse: "ABC123456789"},
{cmd: "!SHOW STACK", short: "", params: "", desc: "Displays current stack status and usage", example: "!SHOW STACK", response: "Variable ASCII + optional CRLF", responseBytes: "variable", exampleResponse: "Stack: 2048/8192"},
{cmd: "!SHOW SECTORADDR", short: "!QSA", params: "", desc: "Displays flash memory sector architecture", example: "!SHOW SECTORADDR", response: "Variable ASCII + optional CRLF", responseBytes: "variable"},
{cmd: "DATA_TRACE_OPEN", short: "", params: "", desc: "Opens data trace for debugging", example: "DATA_TRACE_OPEN", response: "none", responseBytes: 0},
{cmd: "DATA_TRACE_CLOSE", short: "", params: "", desc: "Closes data trace", example: "DATA_TRACE_CLOSE", response: "none", responseBytes: 0},
{cmd: "TRACE_MARK", short: "", params: "", desc: "Adds a marker to trace buffer", example: "TRACE_MARK", response: "none", responseBytes: 0},
{cmd: "TRACE_FLUSH", short: "", params: "", desc: "Flushes trace buffer", example: "TRACE_FLUSH", response: "none", responseBytes: 0},
{cmd: "!DEV", short: "", params: "", desc: "Device diagnostics query", example: "!DEV", response: "Variable ASCII + optional CRLF", responseBytes: "variable", exampleResponse: "DEV: OK"},
{cmd: "!ERASE WARRANTYLOGS", short: "", params: "", desc: "Erases warranty logs from memory", example: "!ERASE WARRANTYLOGS", response: "none", responseBytes: 0},
{cmd: "!SET OEMIDENTIFIER", short: "", params: "oem", desc: "Sets OEM brand identifier (COGNITIVE,TALLYGENICOM,NONBRANDED,TALLYDASCOM)", example: "!SET OEMIDENTIFIER TALLYDASCOM", response: "none", responseBytes: 0},
{cmd: "!SET OEMMODELID", short: "", params: "id", desc: "Sets OEM model identifier string", example: "!SET OEMMODELID 7008-TT2", response: "none", responseBytes: 0},
{cmd: "!SET TRACEFLUSH", short: "", params: "", desc: "Flushes diagnostic trace buffers to storage", example: "!SET TRACEFLUSH", response: "none", responseBytes: 0},
{cmd: "!SET DATATRACEOPEN", short: "", params: "filename", desc: "Opens data trace file on USB storage", example: "!SET DATATRACEOPEN msg1.txt", response: "none", responseBytes: 0},
{cmd: "!SET DATATRACECLOSE", short: "", params: "", desc: "Closes data trace file", example: "!SET DATATRACECLOSE", response: "none", responseBytes: 0},
{cmd: "!SET MESSAGETRACEOPEN", short: "", params: "filename", desc: "Opens message trace file for diagnostics", example: "!SET MESSAGETRACEOPEN msg1.txt", response: "none", responseBytes: 0},
{cmd: "!SET MESSAGETRACECLOSE", short: "", params: "", desc: "Closes message trace file", example: "!SET MESSAGETRACECLOSE", response: "none", responseBytes: 0},
{cmd: "!SET OOBVARS", short: "", params: "", desc: "Applies out-of-box variables block to restore factory defaults", example: "!SET OOBVARS", response: "none", responseBytes: 0},
{cmd: "!PRINT", short: "", params: "item", desc: "Print diagnostic items (VERSION, CONFIG, etc.)", example: "!PRINT VERSION"},
{cmd: "!SHOW", short: "", params: "item", desc: "Show internal data (MAC, MEMORY, CONFIG, etc.)", example: "!SHOW MAC", response: "ASCII + optional CRLF", responseBytes: "variable"},
{cmd: "!HISTORY", short: "", params: "", desc: "Print history information to host", example: "!HISTORY", response: "Variable ASCII + optional CRLF", responseBytes: "variable"},
{cmd: "EVENTLOG", short: "", params: "ENABLE|DISABLE|INIT|OUTPUT", desc: "Control and output event logs for diagnostics", example: "EVENTLOG OUTPUT", response: "Variable ASCII lines", responseBytes: "variable"},
{cmd: "LAST_RESULT", short: "", params: "", desc: "Returns last function result code", example: "LAST_RESULT", response: "ASCII code + optional CRLF", responseBytes: "variable", exampleResponse: "0"},
{cmd: "STATUS", short: "", params: "", desc: "Status operations for menu/variables", example: "STATUS READ", response: "ASCII", responseBytes: "variable"},
{cmd: "CONFIG", short: "", params: "read/write fields", desc: "General configuration read/write commands", example: "CONFIG READ", response: "ASCII", responseBytes: "variable"},
{cmd: "XCONFIG", short: "", params: "extended config", desc: "Extended configuration commands", example: "XCONFIG WRITE field value", response: "none", responseBytes: 0},
{cmd: "I2C", short: "", params: "device addr data", desc: "Direct I2C bus access (platform dependent)", example: "I2C READ 0x50 2", response: "Binary/ASCII", responseBytes: "variable"},
{cmd: "RFCARD", short: "", params: "operation", desc: "RF card reader operations", example: "RFCARD READ", response: "Variable", responseBytes: "variable"}
],
variable: [
{cmd: "VARIABLE ALLOCATE", short: "V ALLOCATE", params: "0-65535", desc: "Allocates memory for printer operations (0-65535)", example: "VARIABLE ALLOCATE 1024"},
{cmd: "VARIABLE AUDIO_FREQ", short: "", params: "n|?", desc: "Sets beeper audio frequency (Hz)", example: "VARIABLE AUDIO_FREQ 2000", response: "ASCII + CRLF on query", responseBytes: "variable", exampleResponse: "AUDIO_FREQ = 2000"},
{cmd: "VARIABLE AUTOCUT", short: "", params: "ON|OFF|?", desc: "Enable/disable automatic label cutting", example: "VARIABLE AUTOCUT ON"},
{cmd: "VARIABLE AUTO_TOF", short: "", params: "ON|OFF|?", desc: "Automatic top-of-form detection", example: "VARIABLE AUTO_TOF ON"},
{cmd: "VARIABLE AUX_POWER", short: "", params: "ON|OFF|?", desc: "Auxiliary power output control", example: "VARIABLE AUX_POWER ON"},
{cmd: "VARIABLE AUXPOWER", short: "", params: "ON|OFF|?", desc: "Alias for AUX_POWER", example: "VARIABLE AUXPOWER ON"},
{cmd: "VARIABLE BACKLIGHT", short: "", params: "ON|OFF|?", desc: "Adjusts LCD display backlight", example: "VARIABLE BACKLIGHT ON"},
{cmd: "VARIABLE BEEPER", short: "V BEEPER", params: "vol dur", desc: "Beeper settings (vol:0 to BEEPER_ENTRIES-1, dur:0-255)", example: "VARIABLE BEEPER 2 50"},
{cmd: "VARIABLE BEEPER VOLUME", short: "", params: "0-3|?", desc: "Beeper volume level", example: "VARIABLE BEEPER VOLUME 2", response: "ASCII + CRLF on query", responseBytes: "17", exampleResponse: "BEEPER VOLUME = 2"},
{cmd: "VARIABLE BEEPER DURATION", short: "", params: "0-255|?", desc: "Beeper duration in milliseconds", example: "VARIABLE BEEPER DURATION 100", response: "ASCII + CRLF on query", responseBytes: "19-21", exampleResponse: "BEEPER DURATION = 100"},
{cmd: "VARIABLE BUFFER_TIMED_RESET", short: "", params: "n", desc: "Buffer reset timeout (2-65535 seconds)", example: "VARIABLE BUFFER_TIMED_RESET 30"},
{cmd: "VARIABLE CENTRONICS_MODE", short: "", params: "mode", desc: "Centronics parallel port mode", example: "VARIABLE CENTRONICS_MODE 1"},
{cmd: "VARIABLE CODE_PAGE", short: "", params: "n", desc: "Character code page (0-65536)", example: "VARIABLE CODE_PAGE 850"},
{cmd: "VARIABLE COMM", short: "", params: "DSR|DTR settings", desc: "Serial port settings", example: "VARIABLE COMM DSR ON"},
{cmd: "VARIABLE COMPATIBLE", short: "", params: "type ON|OFF|?", desc: "Compatibility mode (ZPL, EPL)", example: "VARIABLE COMPATIBLE ZPL ON"},
{cmd: "VARIABLE CONTRAST", short: "", params: "level 0-255|?", desc: "LCD display contrast level", example: "VARIABLE CONTRAST 50", response: "ASCII + CRLF on query", responseBytes: "16-18", exampleResponse: "LCD CONTRAST = 128"},
{cmd: "VARIABLE CPL_COMMAND_MASK", short: "", params: "hex|?", desc: "32-bit hex mask for CPL commands", example: "VARIABLE CPL_COMMAND_MASK 0xFFFFFFFF", response: "ASCII + CRLF on query", responseBytes: "23", exampleResponse: "CPL_CMD_MASK = ffffffff"},
{cmd: "VARIABLE DARKNESS", short: "V D", params: "-200 to 813|?", desc: "Print head heat energy (-200 to 813)", example: "VARIABLE DARKNESS 100", response: "ASCII + CRLF on query", responseBytes: "variable", exampleResponse: "DARKNESS = 100"},
{cmd: "VARIABLE DIAGNOSTIC", short: "", params: "", desc: "Run diagnostic output", example: "VARIABLE DIAGNOSTIC"},
{cmd: "VARIABLE DEVICENAME", short: "", params: "name", desc: "Sets device name for Bluetooth/network", example: "VARIABLE DEVICENAME MyPrinter"},
{cmd: "VARIABLE DEVICEPIN", short: "", params: "pin", desc: "Sets device PIN", example: "VARIABLE DEVICEPIN 1234"},
{cmd: "VARIABLE DISCOVERABLE", short: "", params: "ON|OFF|?", desc: "Set discoverability mode", example: "VARIABLE DISCOVERABLE ON"},
{cmd: "VARIABLE ENCRYPTION", short: "", params: "ON|OFF|?", desc: "Enable/disable encryption", example: "VARIABLE ENCRYPTION ON"},
{cmd: "VARIABLE ENERGY", short: "", params: "n|?", desc: "Print energy level", example: "VARIABLE ENERGY 100", response: "ASCII + CRLF on query", responseBytes: "variable", exampleResponse: "ENERGY = 100"},
{cmd: "VARIABLE EPL_COMMAND_MASK", short: "", params: "hex|?", desc: "32-bit hex mask for EPL commands", example: "VARIABLE EPL_COMMAND_MASK 0x00000000", response: "ASCII + CRLF on query", responseBytes: "23", exampleResponse: "EPL_CMD_MASK = ffffffff"},
{cmd: "VARIABLE EPL_PREFIX", short: "", params: "prefix|?", desc: "EPL command prefix mode", example: "VARIABLE EPL_PREFIX STANDARD", response: "ASCII + CRLF on query", responseBytes: "variable", exampleResponse: "EPL_PREFIX = PREFIX"},
{cmd: "VARIABLE ERROR_LEVEL", short: "", params: "level|?", desc: "Error reporting level", example: "VARIABLE ERROR_LEVEL 1"},
{cmd: "VARIABLE FACTORY_RESTORE", short: "", params: "", desc: "Restores factory default settings", example: "VARIABLE FACTORY_RESTORE"},
{cmd: "VARIABLE FEED", short: "", params: "0-65535|?", desc: "Default feed distance (0-65535 dots)", example: "VARIABLE FEED 100", response: "ASCII + CRLF on query", responseBytes: "variable", exampleResponse: "FEED = 100"},
{cmd: "VARIABLE FEED_BUTTON", short: "", params: "mode", desc: "Manual feed button behavior", example: "VARIABLE FEED_BUTTON ENABLE"},
{cmd: "VARIABLE FEED_CONFIG", short: "", params: "F|C|L|N", desc: "Feed type and print mode config", example: "VARIABLE FEED_CONFIG F"},
{cmd: "VARIABLE FEED_SPEED", short: "", params: "speed", desc: "Media feed speed in milli-IPS", example: "VARIABLE FEED_SPEED 6000"},
{cmd: "VARIABLE FEED_TYPE", short: "", params: "type", desc: "Sensor type (GAP, BAR, NOTCH, CONTINUOUS)", example: "VARIABLE FEED_TYPE GAP"},
{cmd: "VARIABLE FORGET", short: "", params: "", desc: "Forget paired devices", example: "VARIABLE FORGET"},
{cmd: "VARIABLE GAP_SIZE", short: "", params: "0-100|?", desc: "Gap size between labels (0-100)", example: "VARIABLE GAP_SIZE 50", response: "ASCII + CRLF on query", responseBytes: "variable", exampleResponse: "GAP_SIZE = 50"},
{cmd: "VARIABLE HIGHSPEED", short: "", params: "", desc: "Enable high-speed mode", example: "VARIABLE HIGHSPEED"},
{cmd: "VARIABLE INDEX", short: "V I", params: "ON|OFF", desc: "Master gap/mark sensor enable", example: "VARIABLE INDEX ON"},
{cmd: "VARIABLE IRDA", short: "", params: "ON|OFF|?", desc: "IrDA interface enable", example: "VARIABLE IRDA ON"},
{cmd: "VARIABLE IRDA PROTOCOL", short: "", params: "p", desc: "IrDA protocol setting", example: "VARIABLE IRDA PROTOCOL 1"},
{cmd: "VARIABLE IRDA COMM", short: "", params: "baud", desc: "IrDA baud rate", example: "VARIABLE IRDA COMM 115200"},
{cmd: "VARIABLE KBLAYOUT", short: "", params: "mode", desc: "Keyboard layout (0-65535)", example: "VARIABLE KBLAYOUT 4"},
{cmd: "VARIABLE LABEL_LENGTH", short: "", params: "0-10000|?", desc: "Fixed label length (0-10000 dots)", example: "VARIABLE LABEL_LENGTH 800", response: "ASCII + CRLF on query", responseBytes: "variable", exampleResponse: "LABEL_LENGTH = 800"},
{cmd: "VARIABLE LANGUAGE", short: "", params: "type", desc: "Firmware language for status messages", example: "VARIABLE LANGUAGE EN"},
{cmd: "VARIABLE LCD CONTRAST", short: "", params: "0-255|?", desc: "LCD display contrast level", example: "VARIABLE LCD CONTRAST 128", response: "ASCII + CRLF on query", responseBytes: "16-18", exampleResponse: "LCD CONTRAST = 128"},
{cmd: "VARIABLE LOWSPEED", short: "", params: "", desc: "Enable low-speed mode", example: "VARIABLE LOWSPEED"},
{cmd: "VARIABLE LOW_BATTERY_IGNORE", short: "", params: "ON|OFF|?", desc: "Ignore low battery warnings", example: "VARIABLE LOW_BATTERY_IGNORE ON"},
{cmd: "VARIABLE MAX_WIDTH", short: "", params: "0-65535|?", desc: "Maximum printable width (0-65535 dots)", example: "VARIABLE MAX_WIDTH 832", response: "ASCII + CRLF on query", responseBytes: "variable", exampleResponse: "MAX_WIDTH = 832"},
{cmd: "VARIABLE MEASURE_LABEL", short: "", params: "ON|OFF|?", desc: "Auto-measure label length", example: "VARIABLE MEASURE_LABEL ON"},
{cmd: "VARIABLE MEDIA_ADJUST", short: "", params: "-3000 to 3000|?", desc: "Media sensor adjustment (-3000 to 3000)", example: "VARIABLE MEDIA_ADJUST 10", response: "ASCII + CRLF on query", responseBytes: "variable", exampleResponse: "MEDIA_ADJUST = 10"},
{cmd: "VARIABLE MENU_LANGUAGE", short: "", params: "lang|?", desc: "Menu language (ENGLISH|FRENCH|SPANISH|ITALIAN|PORTUGUESE|GERMAN)", example: "VARIABLE MENU_LANGUAGE ENGLISH"},
{cmd: "VARIABLE MIRROR_LABEL", short: "", params: "ON|OFF|?", desc: "Mirror the entire label horizontally", example: "VARIABLE MIRROR_LABEL ON"},
{cmd: "VARIABLE MODE", short: "V MODE", params: "n", desc: "Printer operating mode (0-3)", example: "VARIABLE MODE 1"},
{cmd: "VARIABLE NO_MEDIA", short: "", params: "ON|OFF|?", desc: "No media condition handling", example: "VARIABLE NO_MEDIA ON"},
{cmd: "VARIABLE NORMAL", short: "", params: "", desc: "Reset to normal/default values", example: "VARIABLE NORMAL"},
{cmd: "VARIABLE OEMIDENTIFIER", short: "", params: "oem", desc: "OEM identifier (COGNITIVE|TALLYGENICOM|NONBRANDED|TALLYDASCOM)", example: "VARIABLE OEMIDENTIFIER COGNITIVE"},
{cmd: "VARIABLE OEMMODELID", short: "", params: "id", desc: "OEM model identifier string", example: "VARIABLE OEMMODELID 7008-TT2"},
{cmd: "VARIABLE OFF_AFTER", short: "", params: "0-65535|?", desc: "Auto power-off timer (0-65535 sec)", example: "VARIABLE OFF_AFTER 300", response: "ASCII + CRLF on query", responseBytes: "variable", exampleResponse: "OFF_AFTER = 300"},
{cmd: "VARIABLE ON_TIME", short: "", params: "0-65535|?", desc: "Print head energizing time (0-65535)", example: "VARIABLE ON_TIME 2", response: "ASCII + CRLF on query", responseBytes: "variable", exampleResponse: "ON_TIME = 2"},
{cmd: "VARIABLE OOP_TLED", short: "", params: "DT|TT n", desc: "Out-of-paper LED timing (0-255)", example: "VARIABLE OOP_TLED DT 50"},
{cmd: "VARIABLE OVERRIDE", short: "", params: "ON|OFF|?", desc: "Override protected settings", example: "VARIABLE OVERRIDE ON"},
{cmd: "VARIABLE PITCH", short: "", params: "0-65535|?", desc: "Resolution/pitch (0-65535)", example: "VARIABLE PITCH 203", response: "ASCII + CRLF on query", responseBytes: "variable", exampleResponse: "PITCH = 203"},
{cmd: "VARIABLE PORT_WAIT", short: "", params: "n|?", desc: "Port send wait (0-2000 ms)", example: "VARIABLE PORT_WAIT 100", response: "ASCII + CRLF on query", responseBytes: "variable", exampleResponse: "PORT_WAIT = 100"},
{cmd: "VARIABLE POSITION", short: "", params: "pos", desc: "TOF position in motor steps", example: "VARIABLE POSITION 50"},
{cmd: "VARIABLE PRESENTLABEL", short: "", params: "ON|OFF|? adv|rev time", desc: "Label presentation mode for peeler", example: "VARIABLE PRESENTLABEL ON"},
{cmd: "VARIABLE PRINT_MODE", short: "", params: "AUTO|DT|TT|?", desc: "Print mode (TT=Transfer, DT=Direct)", example: "VARIABLE PRINT_MODE TT", response: "ASCII + CRLF on query", responseBytes: "15", exampleResponse: "PRINT_MODE = 1"},
{cmd: "VARIABLE PRINT_SPEED", short: "", params: "n|LOWSPEED|NORMAL|HIGHSPEED|?", desc: "Print speed setting", example: "VARIABLE PRINT_SPEED 4", response: "ASCII + CRLF on query", responseBytes: "15-23", exampleResponse: "PRINT_SPEED = HIGHSPEED"},
{cmd: "VARIABLE QS_DELAY", short: "", params: "n|?", desc: "Delay before !QS response (0-65535 ms)", example: "VARIABLE QS_DELAY 50", response: "ASCII + CRLF on query", responseBytes: "variable", exampleResponse: "QS_DELAY = 50"},
{cmd: "VARIABLE READ", short: "V READ", params: "name", desc: "Read variable value", example: "VARIABLE READ DARKNESS"},
{cmd: "VARIABLE RECALIBRATE", short: "", params: "ON|OFF|?", desc: "Initiate media calibration", example: "VARIABLE RECALIBRATE ON"},
{cmd: "VARIABLE REPORT_LEVEL", short: "", params: "0-2|?", desc: "Status report verbosity level", example: "VARIABLE REPORT_LEVEL 2", response: "ASCII + CRLF on query", responseBytes: "16", exampleResponse: "REPORT_LEVEL = 1"},
{cmd: "VARIABLE REPORT_TYPE", short: "", params: "0-2|?", desc: "Status report type format", example: "VARIABLE REPORT_TYPE STANDARD", response: "ASCII + CRLF on query", responseBytes: "15", exampleResponse: "REPORT_TYPE = 2"},
{cmd: "VARIABLE REPRINT", short: "", params: "ON|OFF|?", desc: "Enable label reprint functionality", example: "VARIABLE REPRINT ON"},
{cmd: "VARIABLE RESET", short: "", params: "", desc: "Reset printer variables to defaults", example: "VARIABLE RESET"},
{cmd: "VARIABLE ROTATE_LABEL", short: "", params: "ON|OFF|?", desc: "Rotate entire label", example: "VARIABLE ROTATE_LABEL ON"},
{cmd: "VARIABLE SCRIPT_INPUT_RESET", short: "", params: "n|?", desc: "Script input reset timer", example: "VARIABLE SCRIPT_INPUT_RESET 30"},
{cmd: "VARIABLE SHIFT_LEFT", short: "", params: "n|?", desc: "Horizontal image shift", example: "VARIABLE SHIFT_LEFT 5", response: "ASCII + CRLF on query", responseBytes: "variable", exampleResponse: "SHIFT_LEFT = 5"},
{cmd: "VARIABLE SLEEP_AFTER", short: "", params: "0-255|?", desc: "Auto sleep timer (0-255 sec)", example: "VARIABLE SLEEP_AFTER 15", response: "ASCII + CRLF on query", responseBytes: "variable", exampleResponse: "SLEEP_AFTER = 15"},
{cmd: "VARIABLE STATUS_CRLF", short: "", params: "ON|OFF|?", desc: "Append CRLF to status/query responses", example: "VARIABLE STATUS_CRLF ON", response: "ASCII + CRLF on query", responseBytes: "variable", exampleResponse: "STATUS_CRLF = ON"},
{cmd: "VARIABLE TERMINAL", short: "", params: "DEFAULT|RS232|LCD_PANEL|USB|RTEL|DISCOVER|?", desc: "Set/query terminal device", example: "VARIABLE TERMINAL RS232", response: "ASCII + CRLF on query", responseBytes: "variable", exampleResponse: "TERMINAL = RS232"},
{cmd: "VARIABLE TOF", short: "", params: "n|?", desc: "Top-of-form position offset", example: "VARIABLE TOF 50", response: "ASCII + CRLF on query", responseBytes: "variable", exampleResponse: "TOF = 50"},
{cmd: "VARIABLE TRACEMARK", short: "", params: "string", desc: "Add trace marker string", example: "VARIABLE TRACEMARK \"CHECKPOINT1\""},
{cmd: "VARIABLE TXTBFR", short: "", params: "txt [ovf]|?", desc: "Text buffer size (4096-65535)", example: "VARIABLE TXTBFR 8192", response: "ASCII + CRLF on query", responseBytes: "19-21", exampleResponse: "TXTBFR = 4096, 8192"},
{cmd: "VARIABLE USB_TXTBFR", short: "", params: "txt [ovf]|?", desc: "USB text buffer size (4096-65535)", example: "VARIABLE USB_TXTBFR 4096", response: "ASCII + CRLF on query", responseBytes: "variable", exampleResponse: "USB_TXTBFR = 4096, 0"},
{cmd: "VARIABLE USER_FEEDBACK", short: "", params: "ON|OFF|?", desc: "Enable unsolicited status messages", example: "VARIABLE USER_FEEDBACK ON", response: "ASCII + CRLF on query", responseBytes: "variable", exampleResponse: "USER_FEEDBACK = ON"},
{cmd: "VARIABLE WIDTH", short: "V W", params: "n|?", desc: "Label width (0-65535 dots)", example: "VARIABLE WIDTH 812", response: "ASCII + CRLF on query", responseBytes: "variable", exampleResponse: "WIDTH = 400 (812 dots)"},
{cmd: "VARIABLE WRITE", short: "V WRITE", params: "name value", desc: "Write variable value to storage", example: "VARIABLE WRITE DARKNESS 100"},
{cmd: "VARIABLE ZPL_COMMAND_MASK", short: "", params: "hex|?", desc: "32-bit hex mask for ZPL commands", example: "VARIABLE ZPL_COMMAND_MASK 0x00000000", response: "ASCII + CRLF on query", responseBytes: "23", exampleResponse: "ZPL_CMD_MASK = ffffffff"}
],
network: [
{cmd: "VARIABLE ETHERNET LINK", short: "", params: "?|AUTO|10|100 FULL|HALF", desc: "Query/set link state and parameters", example: "VARIABLE ETHERNET LINK ?", response: "ASCII + CRLF on query", responseBytes: "variable", exampleResponse: "EthernetLink = 100Mb/s, full duplex"},
{cmd: "VARIABLE ETHERNET DHCP", short: "", params: "ON|OFF|?", desc: "Enable/disable DHCP client with timeouts", example: "VARIABLE ETHERNET DHCP ON", response: "ASCII + CRLF on query", responseBytes: "variable", exampleResponse: "ETHERNET DHCP = ON"},
{cmd: "VARIABLE ETHERNET DHCP CRITERIA", short: "", params: "flags 0-3", desc: "DHCP criteria flags", example: "VARIABLE ETHERNET DHCP CRITERIA 1", response: "ASCII + CRLF on query", responseBytes: "variable", exampleResponse: "ETHERNET DHCP CRITERIA = 1"},
{cmd: "VARIABLE ETHERNET DHCP OFFERS", short: "", params: "count 0-30", desc: "DHCP offers limit", example: "VARIABLE ETHERNET DHCP OFFERS 2", response: "ASCII + CRLF on query", responseBytes: "variable", exampleResponse: "ETHERNET DHCP OFFERS = 2"},
{cmd: "VARIABLE ETHERNET DHCP TIMEOUT", short: "", params: "n 0-2147483647", desc: "DHCP timeout interval in ms", example: "VARIABLE ETHERNET DHCP TIMEOUT 120000", response: "ASCII + CRLF on query", responseBytes: "variable", exampleResponse: "ETHERNET DHCP TIMOUT = 120000"},
{cmd: "VARIABLE ETHERNET HTTP", short: "", params: "ON|OFF|?", desc: "HTTP server enable", example: "VARIABLE ETHERNET HTTP ON", response: "ASCII + CRLF on query", responseBytes: "variable", exampleResponse: "ETHERNET HTTP = ON"},
{cmd: "VARIABLE ETHERNET LPD", short: "", params: "ON|OFF|?", desc: "LPD print protocol enable", example: "VARIABLE ETHERNET LPD ON", response: "ASCII + CRLF on query", responseBytes: "variable", exampleResponse: "ETHERNET LPD = ON"},
{cmd: "VARIABLE ETHERNET JOBSOKINERROR", short: "", params: "ON|OFF|?", desc: "Report jobs OK in error mode", example: "VARIABLE ETHERNET JOBSOKINERROR ON", response: "ASCII + CRLF on query", responseBytes: "variable", exampleResponse: "ETHERNET JOBSOKINERROR = ON"},
{cmd: "VARIABLE ETHERNET RTEL", short: "", params: "ON|OFF|?", desc: "Remote telnet enable", example: "VARIABLE ETHERNET RTEL ON", response: "ASCII + CRLF on query", responseBytes: "variable", exampleResponse: "ETHERNET RTEL = ON"},
{cmd: "VARIABLE ETHERNET RTEL PORT", short: "", params: "port 1024-65535", desc: "RTEL port", example: "VARIABLE ETHERNET RTEL PORT 9100", response: "ASCII + CRLF on query", responseBytes: "variable", exampleResponse: "ETHERNET RTEL PORT = 9100"},
{cmd: "VARIABLE ETHERNET RTEL TIME", short: "", params: "time 0-900", desc: "RTEL timeout (0-900 sec)", example: "VARIABLE ETHERNET RTEL TIME 300", response: "ASCII + CRLF on query", responseBytes: "variable", exampleResponse: "ETHERNET RTEL TIMOUT = 300"},
{cmd: "VARIABLE ETHERNET SNMP CHECK", short: "", params: "ON|OFF|?", desc: "SNMP check enable", example: "VARIABLE ETHERNET SNMP CHECK ON", response: "ASCII + CRLF on query", responseBytes: "variable", exampleResponse: "ETHERNET SNMP CHECK ON"},
{cmd: "VARIABLE ETHERNET SNMP PRINT", short: "", params: "ON|OFF|?", desc: "SNMP print enable", example: "VARIABLE ETHERNET SNMP PRINT ON", response: "ASCII + CRLF on query", responseBytes: "variable", exampleResponse: "ETHERNET SNMP PRINT ON"},
{cmd: "VARIABLE ETHERNET SNMP ADDR", short: "", params: "community addr", desc: "SNMP address and community string", example: "VARIABLE ETHERNET SNMP ADDR public 192.168.1.100", response: "ASCII + CRLF on query", responseBytes: "variable", exampleResponse: "ETHERNET SNMP TRAP ADDRESS = 192.168.1.100"},
{cmd: "VARIABLE ETHERNET SNMP ACTIVE", short: "", params: "ON|OFF|?", desc: "SNMP active flag", example: "VARIABLE ETHERNET SNMP ACTIVE ON", response: "ASCII + CRLF on query", responseBytes: "variable", exampleResponse: "ETHERNET SNMP ACTIVE ON"},
{cmd: "VARIABLE ETHERNET TELNET", short: "", params: "ON|OFF|?", desc: "Enable/disable telnet service", example: "VARIABLE ETHERNET TELNET ON", response: "ASCII + CRLF on query", responseBytes: "variable", exampleResponse: "ETHERNET TELNET = ON"},
{cmd: "VARIABLE ETHERNET TELNET TIMEOUT", short: "", params: "seconds 0-900", desc: "Telnet connection idle timeout", example: "VARIABLE ETHERNET TELNET TIMEOUT 180", response: "ASCII + CRLF on query", responseBytes: "variable", exampleResponse: "ETHERNET TELNET TIMOUT = 180"},
{cmd: "VARIABLE ETHERNET IP", short: "V IPADDR", params: "a.b.c.d|?", desc: "Sets/queries static IP address", example: "VARIABLE ETHERNET IP 192.168.1.100", response: "ASCII + CRLF on query", responseBytes: "variable", exampleResponse: "ETHERNET IP ADDRESS = 192.168.1.50"},
{cmd: "VARIABLE ETHERNET NETMASK", short: "", params: "a.b.c.d|?", desc: "Sets/queries subnet mask", example: "VARIABLE ETHERNET NETMASK 255.255.255.0", response: "ASCII + CRLF on query", responseBytes: "variable", exampleResponse: "ETHERNET NETMASK = 255.255.255.0"},
{cmd: "VARIABLE ETHERNET GATEWAY", short: "", params: "a.b.c.d|?", desc: "Sets/queries default gateway", example: "VARIABLE ETHERNET GATEWAY 192.168.1.1", response: "ASCII + CRLF on query", responseBytes: "variable", exampleResponse: "ETHERNET GATEWAY = 192.168.1.1"},
{cmd: "VARIABLE ETHERNET RESET", short: "", params: "", desc: "Resets Ethernet module to defaults", example: "VARIABLE ETHERNET RESET", response: "none", responseBytes: 0},
{cmd: "VARIABLE ETHERNET FIRMWARE", short: "", params: "", desc: "Ethernet firmware operations/version query", example: "VARIABLE ETHERNET FIRMWARE", response: "none", responseBytes: 0},
{cmd: "VARIABLE ETHERNET SERVER", short: "", params: "address|?", desc: "Remote server address", example: "VARIABLE ETHERNET SERVER 192.168.1.200", response: "ASCII + CRLF on query", responseBytes: "variable", exampleResponse: "ETHERNET SERVER ADDRESS = 192.168.1.200"},
{cmd: "VARIABLE ETHERNET GARP", short: "", params: "time 0-10080|?", desc: "GARP interval (0-10080 minutes)", example: "VARIABLE ETHERNET GARP 60", response: "ASCII + CRLF on query", responseBytes: "variable", exampleResponse: "ETHERNET GARP TIME = 60"},
{cmd: "VARIABLE ETHERNET TXTBFR", short: "", params: "txt 4096-500000 [ovf 256-65535]|?", desc: "Ethernet text buffer sizes", example: "VARIABLE ETHERNET TXTBFR 8192 8192", response: "ASCII + CRLF on query", responseBytes: "variable", exampleResponse: "ETHERNET TXTBFR = 8192, 8192"},
{cmd: "!SET HOST_NAME", short: "!SET HOSTNAME", params: "hostname", desc: "Sets network host name for printer", example: "!SET HOST_NAME \"PRINTER001\"", response: "none", responseBytes: 0},
{cmd: "!SHOW HOST_NAME", short: "", params: "", desc: "Displays the printer's network hostname", example: "!SHOW HOST_NAME", response: "ASCII + optional CRLF", responseBytes: "variable", exampleResponse: "PRINTER001"},
{cmd: "!SHOW MAC", short: "", params: "", desc: "Displays the Ethernet MAC address", example: "!SHOW MAC", response: "17 ASCII bytes XX:XX:XX:XX:XX:XX", responseBytes: 17, exampleResponse: "00:11:22:33:44:55"},
{cmd: "!LOAD MAC", short: "", params: "addr", desc: "Sets the network interface MAC address", example: "!LOAD MAC 00:11:22:33:44:55", response: "none", responseBytes: 0}
],
bluetooth: [
{cmd: "VARIABLE BLUETOOTH CONFIGURE", short: "", params: "", desc: "Configure Bluetooth stack", example: "VARIABLE BLUETOOTH CONFIGURE", response: "none", responseBytes: 0},
{cmd: "VARIABLE BLUETOOTH LAST_RESULT", short: "", params: "", desc: "Return last BT operation result", example: "VARIABLE BLUETOOTH LAST_RESULT", response: "6 ASCII bytes [0xNN] + CRLF", responseBytes: 6, exampleResponse: "[0x00]", errorCodes: {0x00: "BLU_SUCCESS", 0x01: "BLU_NOT_ATTACHED", 0x02: "BLU_NO_RESPONSE", 0x03: "BLU_INCORRECT_RESPONSE", 0x04: "BLU_READ_ERROR", 0x05: "BLU_DISABLE_CONNECTIONS", 0x06: "BLU_HOST_EVENTS", 0x07: "BLU_WRITE_ERROR", 0x08: "BLU_ALLOCATION_ERROR", 0x09: "BLU_RECOVER_ERROR", 0x0A: "BLU_RESET_ERROR", 0x0B: "BLU_DEFAULT_ERROR", 0x0C: "BLU_OTHER_ERROR"}},
{cmd: "VARIABLE BLUETOOTH RESET", short: "", params: "", desc: "Reset Bluetooth module", example: "VARIABLE BLUETOOTH RESET", response: "none", responseBytes: 0},
{cmd: "VARIABLE BLUETOOTH DIAGNOSTIC", short: "", params: "", desc: "Bluetooth diagnostic output", example: "VARIABLE BLUETOOTH DIAGNOSTIC", response: "ASCII diagnostic data", responseBytes: "variable", exampleResponse: "BT Module: OK"},
{cmd: "VARIABLE BLUETOOTH DEVICENAME", short: "", params: "name", desc: "Sets Bluetooth discoverable name", example: "VARIABLE BLUETOOTH DEVICENAME MyPrinter", response: "none", responseBytes: 0},
{cmd: "VARIABLE BLUETOOTH DEVICEPIN", short: "", params: "pin", desc: "Sets Bluetooth pairing PIN", example: "VARIABLE BLUETOOTH DEVICEPIN 1234", response: "none", responseBytes: 0},
{cmd: "VARIABLE BLUETOOTH DISCOVERABLE", short: "", params: "ON|OFF|?", desc: "Controls discoverability", example: "VARIABLE BLUETOOTH DISCOVERABLE ON", response: "ASCII + CRLF on query", responseBytes: "variable", exampleResponse: "BLUETOOTH DISCOVERABLE = ON"},
{cmd: "VARIABLE BLUETOOTH SECURITY", short: "", params: "n", desc: "Security level (1-4)", example: "VARIABLE BLUETOOTH SECURITY 3", response: "none", responseBytes: 0},
{cmd: "VARIABLE BLUETOOTH ENCRYPTION", short: "", params: "ON|OFF|?", desc: "Enable/disable connection encryption", example: "VARIABLE BLUETOOTH ENCRYPTION ON", response: "ASCII + CRLF on query", responseBytes: "variable", exampleResponse: "BLUETOOTH ENCRYPTION = ON"},
{cmd: "VARIABLE BLUETOOTH FORGET", short: "", params: "", desc: "Forget paired devices", example: "VARIABLE BLUETOOTH FORGET", response: "none", responseBytes: 0},
{cmd: "VARIABLE BLUETOOTH DEFAULT", short: "", params: "", desc: "Reset BT config to default", example: "VARIABLE BLUETOOTH DEFAULT", response: "none", responseBytes: 0},
{cmd: "VARIABLE BLUETOOTH CLASS", short: "", params: "n", desc: "Device class (1-2)", example: "VARIABLE BLUETOOTH CLASS 2", response: "none", responseBytes: 0},
{cmd: "VARIABLE BLUETOOTH BDADDR", short: "", params: "?|ON|OFF", desc: "Query or enable BDADDR print", example: "VARIABLE BLUETOOTH BDADDR ?", response: "ASCII + CRLF on query", responseBytes: "12-17", exampleResponse: "BLUETOOTH BDADDR = 00A1B2C3D4E5"}
],
object: [
{cmd: "!S", short: "STORE", params: "d loc type name", desc: "Starts recording format (d=delimiter, loc=R/F, type=F)", example: "!S | F F LABEL1", response: "none", responseBytes: 0},
{cmd: "!R", short: "RECALL", params: "id", desc: "Recalls stored object into active buffer (id: 1-8 chars)", example: "!R format1", response: "none", responseBytes: 0},
{cmd: "!D", short: "DELETE", params: "id", desc: "Deletes single object by ID (1-8 chars)", example: "!D LABEL1", response: "none", responseBytes: 0},
{cmd: "!I", short: "INITIALIZE", params: "n", desc: "Delete objects in storage (n: 0-3)", example: "!I 3", response: "none", responseBytes: 0},
{cmd: "!F", short: "", params: "n", desc: "Delete ALL objects in storage (n: 0-3)", example: "!F 3", response: "none", responseBytes: 0},
{cmd: "!L", short: "LIST", params: "", desc: "Prints directory of stored objects", example: "!L", response: "Printed output", responseBytes: 0},
{cmd: "!LS", short: "OBJECT_LIST", params: "[LONG]", desc: "Lists stored objects; LONG adds extended details", example: "!LS LONG", response: "Variable ASCII + optional CRLF", responseBytes: "variable", exampleResponse: "LABEL1 F 256\nLABEL2 F 512"},
{cmd: "!R V", short: "RECALL VAR", params: "ID [HIDE]", desc: "Recalls stored variable value", example: "!R V COUNTER", response: "none", responseBytes: 0},
{cmd: "!R G", short: "RECALL GRAPHIC", params: "ID x y", desc: "Recalls stored graphic for printing", example: "!R G LOGO 10 10", response: "none", responseBytes: 0},
{cmd: "!OBJECT INFO", short: "!OI", params: "id type ver", desc: "Display stored object info (id:1-8, type:enum, ver:CRC)", example: "!OBJECT INFO uffonta 2 0x7DD7", response: "Variable ASCII + optional CRLF", responseBytes: "variable", exampleResponse: "Name: uffonta Type: 2 Size: 1024 CRC: 0x7DD7"},
{cmd: "!OBJECT MARK", short: "!OM", params: "id", desc: "Mark object for deletion (requires PACK)", example: "!OBJECT MARK uffonta", response: "none", responseBytes: 0},
{cmd: "!OBJECT MARK_TYPE", short: "!OMT", params: "type", desc: "Mark all objects of specified type for deletion", example: "!OBJECT MARK_TYPE 38", response: "none", responseBytes: 0},
{cmd: "!OBJECT PACK", short: "!OP", params: "", desc: "Pack storage, deleting marked objects", example: "!OBJECT PACK", response: "none", responseBytes: 0},
{cmd: "!OBJECT UPLOAD", short: "!OU", params: "loc id", desc: "Upload stored object to host", example: "!OBJECT UPLOAD 0 uffontb", response: "Binary object data", responseBytes: "variable"},
{cmd: "!OBJECT MEMORY_REMAINING", short: "", params: "", desc: "Reports available memory for object storage", example: "!OBJECT MEMORY_REMAINING", response: "Variable ASCII + optional CRLF", responseBytes: "variable", exampleResponse: "32768 bytes free"},
{cmd: "STORE FORMAT", short: "", params: "name", desc: "Store current format", example: "STORE FORMAT format1", response: "none", responseBytes: 0},
{cmd: "STORE FONT", short: "", params: "name", desc: "Store a font resource", example: "STORE FONT fontA", response: "none", responseBytes: 0},
{cmd: "RECALL FORMAT", short: "", params: "name", desc: "Recall stored label format", example: "RECALL FORMAT format1", response: "none", responseBytes: 0},
{cmd: "RECALL MENU", short: "", params: "name", desc: "Recall stored menu", example: "RECALL MENU setup", response: "none", responseBytes: 0},
{cmd: "RECALL VARIABLE", short: "", params: "name", desc: "Recall variable definitions", example: "RECALL VARIABLE price", response: "none", responseBytes: 0},
{cmd: "GRAPHIC STORE", short: "!S G", params: "name width height data", desc: "Stores graphic data in printer memory", example: "GRAPHIC STORE LOGO1 200 100 [data]", response: "none", responseBytes: 0},
{cmd: "GRAPHIC RECALL", short: "", params: "name x y", desc: "Recalls stored graphic for printing", example: "GRAPHIC RECALL LOGO1 10 10", response: "none", responseBytes: 0}
],
menu: [
{cmd: "MENU START", short: "", params: "[menuname]", desc: "Initiates menu system for user interaction", example: "MENU START MainMenu"},
{cmd: "MENU END", short: "MU END", params: "", desc: "Terminates menu system definition", example: "MENU END"},
{cmd: "MENU ITEM", short: "MU ITEM", params: "label [action]", desc: "Defines a menu item", example: "MENU ITEM \"Print Label\" PRINT"},
{cmd: "MENU ACTION", short: "MU ACTION", params: "itemname action", desc: "Defines action for menu item", example: "MENU ACTION Option1 PRINT"},
{cmd: "MENU CONTROL", short: "MU CONTROL", params: "can nxt prv sel", desc: "Key mappings for navigation", example: "MENU CONTROL ESC PGDN PGUP ENTER"},
{cmd: "MENU MESSAGE", short: "", params: "\"text\"", desc: "Display message in menu", example: "MENU MESSAGE \"Select option\""},
{cmd: "MENU EXIT", short: "MU EXIT", params: "", desc: "Menu exit point or action", example: "MENU EXIT"},
{cmd: "MENU DELAY", short: "", params: "ms", desc: "Menu delay in milliseconds", example: "MENU DELAY 100"},
{cmd: "MENU FLUSH", short: "", params: "", desc: "Flush menu system", example: "MENU FLUSH"},
{cmd: "RECALL MENU", short: "", params: "name", desc: "Activate stored menu", example: "RECALL MENU MainMenu"}
],
time: [
{cmd: "TIME SET", short: "TE SET", params: "y m d h min s", desc: "Set real-time clock (year:1970-2069, month:1-12, day:1-31, hour:0-23, min:0-59, sec:0-59)", example: "TIME SET 2025 11 24 14 30 00", response: "none", responseBytes: 0},
{cmd: "TIME ADD", short: "TE ADD", params: "y m d h min s", desc: "Add time offsets to current time", example: "TIME ADD 0 1 0 0 0 0", response: "none", responseBytes: 0},
{cmd: "TIME GET", short: "TE GET", params: "", desc: "Retrieves current printer time", example: "TIME GET", response: "Variable ASCII + optional CRLF", responseBytes: "variable", exampleResponse: "2025-01-15 14:30:00"},
{cmd: "TIME ?", short: "TE ?", params: "", desc: "Query current time and date", example: "TIME ?", response: "Variable ASCII + optional CRLF", responseBytes: "variable", exampleResponse: "2025-01-15 14:30:00"},
{cmd: "!SET TIME", short: "", params: "y m d h min s", desc: "Factory-set time via header command", example: "!SET TIME 2025 11 24 14 30 00", response: "none", responseBytes: 0},
{cmd: "VARIABLE DATE", short: "", params: "YYYY-MM-DD|?", desc: "Sets/queries printer's internal date", example: "VARIABLE DATE 2024-12-25", response: "ASCII + CRLF on query", responseBytes: "variable", exampleResponse: "DATE = 2024-12-25"},
{cmd: "VARIABLE TIME", short: "", params: "HH:MM:SS|?", desc: "Sets/queries printer's internal clock time", example: "VARIABLE TIME 14:30:00", response: "ASCII + CRLF on query", responseBytes: "variable", exampleResponse: "TIME = 14:30:00"}
],
query: [
{cmd: "!STATUS", short: "", params: "", desc: "Returns printer status (Ready, Paper Out, Head Open)", example: "!STATUS", response: "Variable ASCII + optional CRLF", responseBytes: "variable", exampleResponse: "Ready"},
{cmd: "!IDENTIFY", short: "", params: "", desc: "Returns printer model and firmware version", example: "!IDENTIFY", response: "Variable ASCII + optional CRLF", responseBytes: "variable", exampleResponse: "BT200 V1.2.3"},
{cmd: "!QS", short: "", params: "", desc: "Query status - returns 6-byte status code (R00000=Ready, H00000=Head open, P00000=Paper out, B00000=Busy)", example: "!QS", response: "6 ASCII bytes + optional CRLF", responseBytes: 6, exampleResponse: "R00000", statusCodes: {R: "Ready", H: "Head open", P: "Paper out", B: "Busy", E: "Error", W: "Waiting"}},
{cmd: "!QT", short: "", params: "", desc: "Query time - returns current date/time string", example: "!QT", response: "80 chars + optional CRLF", responseBytes: "80", exampleResponse: "2025-01-15 14:30:00"},
{cmd: "!QR", short: "", params: "", desc: "Query revision - returns firmware version with build date/time", example: "!QR", response: "80 chars + optional CRLF", responseBytes: "80", exampleResponse: "V1.2.3 Build Jan 15 2025 14:30:00"},
{cmd: "!QD", short: "", params: "", desc: "Query build date - returns firmware build date", example: "!QD", response: "Variable length + optional CRLF", responseBytes: "variable", exampleResponse: "Jan 15 2025"},
{cmd: "!QB", short: "", params: "", desc: "Query MCU/BIOS - returns bootloader/MCU information", example: "!QB", response: "Variable ASCII + optional CRLF", responseBytes: "variable", exampleResponse: "MCU: STM32F4 BIOS: V1.0"},
{cmd: "!QH", short: "", params: "", desc: "Query history - returns history log summary", example: "!QH", response: "Variable ASCII + optional CRLF", responseBytes: "variable", exampleResponse: "History entries: 42"},
{cmd: "!QI", short: "", params: "[gain] [byte1] [byte2]", desc: "Query index sensor - gain:0-7, bytes:0-255 for filtered queries", example: "!QI 3 10 25", response: "Settings string + optional CRLF", responseBytes: "variable", exampleResponse: "GAP: 128 MARK: 64 GAIN: 3"},
{cmd: "!QIB", short: "", params: "[mode]", desc: "Query index buffer - mode: D=display, I=initialize, R=reset, T=temp, O=out-of-paper", example: "!QIB D", response: "Comma-separated sensor values + optional CRLF", responseBytes: "variable", exampleResponse: "128,130,125,132,127,129"},
{cmd: "!QIC", short: "", params: "", desc: "Query inch count - returns cumulative inches printed", example: "!QIC", response: "Integer ASCII + optional CRLF", responseBytes: "variable", exampleResponse: "123456"},
{cmd: "!QSN", short: "", params: "", desc: "Query serial number - returns device serial (6-20 chars)", example: "!QSN", response: "Serial number + optional CRLF", responseBytes: "6-20", exampleResponse: "ABC123456789"},
{cmd: "!QMN", short: "", params: "", desc: "Query model number - returns device model (4-29 chars)", example: "!QMN", response: "Model number + optional CRLF", responseBytes: "4-29", exampleResponse: "BT200"},
{cmd: "!QM", short: "", params: "", desc: "Query memory - returns memory status summary", example: "!QM", response: "Variable ASCII + optional CRLF", responseBytes: "variable", exampleResponse: "Free: 65536 Used: 32768"},
{cmd: "!QSA", short: "", params: "", desc: "Query sector architecture - returns flash sector layout", example: "!QSA", response: "Variable ASCII + optional CRLF", responseBytes: "variable", exampleResponse: "Sector 0: 0x00000-0x0FFFF"},
{cmd: "!QSTACK", short: "", params: "", desc: "Query stack - returns current stack usage and status", example: "!QSTACK", response: "Variable ASCII + optional CRLF", responseBytes: "variable", exampleResponse: "Stack: 2048/8192"},
{cmd: "!GET TOF", short: "", params: "", desc: "Retrieves current Top of Form setting", example: "!GET TOF", response: "ASCII value", responseBytes: "variable", exampleResponse: "TOF = 120"},
{cmd: "!GET SHIFT", short: "", params: "", desc: "Retrieves current print shift/offset settings", example: "!GET SHIFT", response: "ASCII value", responseBytes: "variable", exampleResponse: "SHIFT = 10"},
{cmd: "!GET STATUS", short: "", params: "", desc: "Returns printer status byte", example: "!GET STATUS", response: "1-2 bytes", responseBytes: "1-2", exampleResponse: "00"},
{cmd: "!GET INDEX", short: "", params: "", desc: "Query index sensor configuration", example: "!GET INDEX", response: "ASCII config", responseBytes: "variable", exampleResponse: "INDEX: GAP DT 50 50 100 200"},
{cmd: "!GET PEELER", short: "", params: "", desc: "Get peeler configuration parameters", example: "!GET PEELER", response: "Variable ASCII + optional CRLF", responseBytes: "variable", exampleResponse: "PEELER = ENABLED"},
{cmd: "SET INDEX", short: "", params: "type mode a b c d", desc: "Factory index sensor configuration", example: "SET INDEX MARK DT 3 10 25 40", response: "none", responseBytes: 0},
{cmd: "SET TOF", short: "", params: "n", desc: "Factory TOF setting", example: "SET TOF 120", response: "none", responseBytes: 0},
{cmd: "GET TOF", short: "", params: "", desc: "Query factory TOF setting", example: "GET TOF", response: "ASCII value", responseBytes: "variable", exampleResponse: "TOF = 120"},
{cmd: "GET INDEX", short: "", params: "", desc: "Query index sensor configuration", example: "GET INDEX", response: "ASCII config", responseBytes: "variable", exampleResponse: "INDEX: GAP DT 50 50 100 200"},
{cmd: "WIDTH ?", short: "", params: "", desc: "Query current print width in dots", example: "WIDTH ?", response: "ASCII + optional CRLF", responseBytes: "variable", exampleResponse: "WIDTH = 400 (812 dots)"},
{cmd: "TIME ?", short: "TE ?", params: "", desc: "Query current time and date", example: "TIME ?", response: "Variable ASCII + optional CRLF", responseBytes: "variable", exampleResponse: "2025-01-15 14:30:00"}
]
};
function Backend_EnumerateSerialPorts() {
log(2, 'Backend_EnumerateSerialPorts() called - stub');
return Promise.resolve([
{name: 'COM1', description: 'Communications Port', manufacturer: 'Microsoft'},
{name: 'COM3', description: 'USB Serial Port', manufacturer: 'FTDI'},
{name: 'COM5', description: 'Prolific USB-to-Serial', manufacturer: 'Prolific'}
]);
}
function Backend_OpenSerialPort(portName, baudRate, parity, dataBits, stopBits) {
log(2, `Backend_OpenSerialPort(${portName}, ${baudRate}, ${parity}, ${dataBits}, ${stopBits}) called - stub`);
return Promise.resolve({success: true, handle: 1});
}
function Backend_CloseSerialPort(handle) {
log(2, `Backend_CloseSerialPort(${handle}) called - stub`);
return Promise.resolve({success: true});
}
function Backend_DiscoverNetworkPrinters(broadcastAddr, port, timeoutMs) {
log(2, `Backend_DiscoverNetworkPrinters(${broadcastAddr}, ${port}, ${timeoutMs}) called - stub`);
return Promise.resolve([]);
}
function Backend_OpenTcpConnection(ipAddress, port) {
log(2, `Backend_OpenTcpConnection(${ipAddress}, ${port}) called - stub`);
return Promise.resolve({success: true, handle: 2});
}
function Backend_CloseTcpConnection(handle) {
log(2, `Backend_CloseTcpConnection(${handle}) called - stub`);
return Promise.resolve({success: true});
}
function Backend_DiscoverBluetoothPrinters(timeoutMs) {
log(2, `Backend_DiscoverBluetoothPrinters(${timeoutMs}) called - stub`);
return Promise.resolve([]);
}
function Backend_OpenBluetoothConnection(address, pin) {
log(2, `Backend_OpenBluetoothConnection(${address}, ${pin ? '****' : 'no-pin'}) called - stub`);
return Promise.resolve({success: true, handle: 3});
}
function Backend_CloseBluetoothConnection(handle) {
log(2, `Backend_CloseBluetoothConnection(${handle}) called - stub`);
return Promise.resolve({success: true});
}
function Backend_EnumerateUsbPrinters() {
log(2, 'Backend_EnumerateUsbPrinters() called - stub');
return Promise.resolve([]);
}
function Backend_OpenUsbConnection(devicePath) {
log(2, `Backend_OpenUsbConnection(${devicePath}) called - stub`);
return Promise.resolve({success: true, handle: 4});
}
function Backend_CloseUsbConnection(handle) {
log(2, `Backend_CloseUsbConnection(${handle}) called - stub`);
return Promise.resolve({success: true});
}
function Backend_SendData(handle, data) {
const len = typeof data === 'string' ? data.length : data.byteLength;
log(2, `Backend_SendData(${handle}, ${len} bytes) called - stub`);
return Promise.resolve({success: true, bytesSent: len});
}
function Backend_ReceiveData(handle, maxBytes, timeoutMs) {
log(2, `Backend_ReceiveData(${handle}, ${maxBytes}, ${timeoutMs}) called - stub`);
return Promise.resolve({success: true, data: new Uint8Array(0)});
}
function Backend_SendCommand(handle, command, timeoutMs) {
log(2, `Backend_SendCommand(${handle}, "${command.substring(0, 50)}...", ${timeoutMs}) called - stub`);
return Promise.resolve({success: true, response: ''});
}
function Backend_GetPrinterStatus(handle) {
log(2, `Backend_GetPrinterStatus(${handle}) called - stub`);
return Promise.resolve({success: true, status: 0, statusText: 'Ready'});
}
function Backend_GetPrinterIdentity(handle) {
log(2, `Backend_GetPrinterIdentity(${handle}) called - stub`);
return Promise.resolve({success: true, model: 'Unknown', firmware: '0.0.0', serial: '000000'});
}
function Backend_GetPrinterVariables(handle) {
log(2, `Backend_GetPrinterVariables(${handle}) called - stub`);
return Promise.resolve({success: true, variables: {}});
}
function Backend_GetPrintHeadTemperature(handle) {
log(2, `Backend_GetPrintHeadTemperature(${handle}) called - stub`);
return Promise.resolve({success: true, tempCelsius: 25});
}
function Backend_GetMediaSensors(handle) {
log(2, `Backend_GetMediaSensors(${handle}) called - stub`);
return Promise.resolve({success: true, gapSensor: 128, markSensor: 64});
}
function Backend_GetPrintStatistics(handle) {
log(2, `Backend_GetPrintStatistics(${handle}) called - stub`);
return Promise.resolve({success: true, inchCount: 0, labelCount: 0, headLifePct: 100});
}
function Backend_SetVariable(handle, varName, value, saveToFlash) {
log(2, `Backend_SetVariable(${handle}, ${varName}, ${value}, ${saveToFlash}) called - stub`);
return Promise.resolve({success: true});
}
function Backend_CalibrateMedia(handle, mode) {
log(2, `Backend_CalibrateMedia(${handle}, ${mode}) called - stub`);
return Promise.resolve({success: true, gapThreshold: 128, markThreshold: 64});
}
function Backend_FactoryReset(handle, fullReset) {
log(2, `Backend_FactoryReset(${handle}, ${fullReset}) called - stub`);
return Promise.resolve({success: true});
}
function Backend_ResetPrinter(handle) {
log(2, `Backend_ResetPrinter(${handle}) called - stub`);
return Promise.resolve({success: true});
}
function Backend_GetFirmwareVersions(handle) {
log(2, `Backend_GetFirmwareVersions(${handle}) called - stub`);
return Promise.resolve({success: true, mainVersion: '1.0.0', bootVersion: '1.0.0'});
}
function Backend_UpdateFirmware(handle, firmwareData, progressCallback) {
log(2, `Backend_UpdateFirmware(${handle}, ${firmwareData.byteLength} bytes) called - stub`);
return Promise.resolve({success: false, error: 'Not implemented'});
}
function Backend_VerifyFirmware(firmwareData) {
log(2, `Backend_VerifyFirmware(${firmwareData.byteLength} bytes) called - stub`);
return Promise.resolve({success: true, version: '0.0.0', checksum: '00000000', compatible: false});
}
function Backend_PrintTestLabel(handle, testType) {
log(2, `Backend_PrintTestLabel(${handle}, ${testType}) called - stub`);
return Promise.resolve({success: true});
}
function Backend_PrintLabel(handle, cplData) {
log(2, `Backend_PrintLabel(${handle}, ${cplData.length} chars) called - stub`);
return Promise.resolve({success: true});
}
function Backend_FeedLabel(handle) {
log(2, `Backend_FeedLabel(${handle}) called - stub`);
return Promise.resolve({success: true});
}
function Backend_CancelPrint(handle) {
log(2, `Backend_CancelPrint(${handle}) called - stub`);
return Promise.resolve({success: true});
}
function Backend_ListObjects(handle, location) {
log(2, `Backend_ListObjects(${handle}, ${location}) called - stub`);
return Promise.resolve({success: true, objects: []});
}
function Backend_DownloadObject(handle, name, type, data, location) {
log(2, `Backend_DownloadObject(${handle}, ${name}, ${type}, ${data.byteLength} bytes, ${location}) called - stub`);
return Promise.resolve({success: true});
}
function Backend_DeleteObject(handle, name) {
log(2, `Backend_DeleteObject(${handle}, ${name}) called - stub`);
return Promise.resolve({success: true});
}
function Backend_GetMemoryInfo(handle) {
log(2, `Backend_GetMemoryInfo(${handle}) called - stub`);
return Promise.resolve({success: true, ramFree: 1048576, ramTotal: 2097152, flashFree: 4194304, flashTotal: 8388608});
}
function Backend_GetEventLog(handle) {
log(2, `Backend_GetEventLog(${handle}) called - stub`);
return Promise.resolve({success: true, events: []});
}
function Backend_ClearEventLog(handle) {
log(2, `Backend_ClearEventLog(${handle}) called - stub`);
return Promise.resolve({success: true});
}
function Backend_RunSelfTest(handle, testType) {
log(2, `Backend_RunSelfTest(${handle}, ${testType}) called - stub`);
return Promise.resolve({success: true, results: {}});
}
function Backend_GetAdcReadings(handle) {
log(2, `Backend_GetAdcReadings(${handle}) called - stub`);
return Promise.resolve({success: true, readings: {}});
}
function Backend_DumpMemory(handle, address, length) {
log(2, `Backend_DumpMemory(${handle}, 0x${address.toString(16)}, ${length}) called - stub`);
return Promise.resolve({success: true, data: new Uint8Array(length)});
}
function Backend_GetNetworkConfig(handle) {
log(2, `Backend_GetNetworkConfig(${handle}) called - stub`);
return Promise.resolve({success: true, dhcp: true, ip: '0.0.0.0', netmask: '255.255.255.0', gateway: '0.0.0.0', mac: '00:00:00:00:00:00', hostname: ''});
}
function Backend_SetNetworkConfig(handle, config) {
log(2, `Backend_SetNetworkConfig(${handle}, ${JSON.stringify(config)}) called - stub`);
return Promise.resolve({success: true});
}
function Backend_GetBluetoothConfig(handle) {
log(2, `Backend_GetBluetoothConfig(${handle}) called - stub`);
return Promise.resolve({success: true, name: '', pin: '0000', discoverable: false, paired: []});
}
function Backend_SetBluetoothConfig(handle, config) {
log(2, `Backend_SetBluetoothConfig(${handle}, ${JSON.stringify(config)}) called - stub`);
return Promise.resolve({success: true});
}
function Backend_ConvertImage(imageData, options) {
log(2, `Backend_ConvertImage(${imageData.byteLength} bytes, ${JSON.stringify(options)}) called - stub`);
return Promise.resolve({success: false, error: 'Not implemented'});
}
function Backend_GenerateBarcode(type, data, options) {
log(2, `Backend_GenerateBarcode(${type}, ${data}, ${JSON.stringify(options)}) called - stub`);
return Promise.resolve({success: false, error: 'Not implemented'});
}
function Backend_OpenFileDialog(filter, title) {
log(2, `Backend_OpenFileDialog(${filter}, ${title}) called - stub`);
return Promise.resolve({success: false, filePath: '', error: 'Not implemented'});
}
function Backend_ReadFile(filePath) {
log(2, `Backend_ReadFile(${filePath}) called - stub`);
return Promise.resolve({success: false, error: 'Not implemented'});
}
function Backend_SaveFile(filePath, data) {
log(2, `Backend_SaveFile(${filePath}, ${data.byteLength} bytes) called - stub`);
return Promise.resolve({success: false, error: 'Not implemented'});
}
function Backend_GetAppVersion() {
log(2, 'Backend_GetAppVersion() called - stub');
return Promise.resolve({version: '1.0.0-dev', buildDate: '2024-01-01', qtVersion: '6.x'});
}
function Backend_OpenExternalUrl(url) {
log(2, `Backend_OpenExternalUrl(${url}) called - stub`);
window.open(url, '_blank');
return Promise.resolve({success: true});
}
function Backend_ShowMessageBox(title, message, type) {
log(2, `Backend_ShowMessageBox(${title}, ${message}, ${type}) called - stub`);
alert(`${title}\n\n${message}`);
return Promise.resolve({button: 'ok'});
}
function Backend_LoadSerialNumber(handle, serialNumber) {
log(2, `Backend_LoadSerialNumber(${handle}, ${serialNumber}) called - stub`);
return Promise.resolve({success: true});
}
function Backend_LoadModelNumber(handle, modelNumber) {
log(2, `Backend_LoadModelNumber(${handle}, ${modelNumber}) called - stub`);
return Promise.resolve({success: true});
}
function Backend_LoadMacAddress(handle, macAddress) {
log(2, `Backend_LoadMacAddress(${handle}, ${macAddress}) called - stub`);
return Promise.resolve({success: true});
}
function Backend_LoadLicense(handle, licenseKey) {
log(2, `Backend_LoadLicense(${handle}, ${licenseKey}) called - stub`);
return Promise.resolve({success: true});
}
function Backend_RunMfgTest(handle, testSequence) {
log(2, `Backend_RunMfgTest(${handle}, ${testSequence}) called - stub`);
return Promise.resolve({success: true, passed: true, results: {}});
}
function $(id) {
return document.getElementById(id);
}
function escapeHtml(text) {
const div = document.createElement('div');
div.textContent = text;
return div.innerHTML;
}
function announce(message) {
const announcer = $('status-announcer');
if (announcer) {
announcer.textContent = message;
}
}
function log(level, message) {
const timestamp = new Date().toISOString().substring(11, 23);
State.logMessages.push({
level: level,
timestamp: timestamp,
message: message
});
updateDebugConsole();
}
function updateDebugConsole() {
const console = $('debug_console');
if (!console) return;
const searchTerm = $('log_search').value.toLowerCase();
const lines = [];
State.logMessages.forEach(entry => {
if (entry.level < State.logLevel) return;
if (searchTerm && !entry.message.toLowerCase().includes(searchTerm)) return;
let className = 'log-info';
let levelText = 'INFO';
if (entry.level === 1) { className = 'log-trace'; levelText = 'TRACE'; }
else if (entry.level === 2) { className = 'log-info'; levelText = 'INFO'; }
else if (entry.level === 3) { className = 'log-warning'; levelText = 'WARN'; }
else if (entry.level === 4) { className = 'log-error'; levelText = 'ERROR'; }
else if (entry.level === 5) { className = 'log-exception'; levelText = 'EXCPT'; }
lines.push(`<span class="${className}">[${entry.timestamp}] [${levelText}] ${escapeHtml(entry.message)}</span>`);
});
console.innerHTML = lines.join('\n');
console.scrollTop = console.scrollHeight;
}
function clearIntervals() {
State.activeIntervals.forEach(id => clearInterval(id));
State.activeIntervals = [];
}
function saveState() {
try {
const state = {
printers: State.printers,
printerCounter: State.printerCounter,
theme: document.body.dataset.theme,
layout: document.body.dataset.layout
};
localStorage.setItem('cognitivetpg_state', JSON.stringify(state));
log(1, 'State saved to localStorage');
} catch (e) {
log(4, 'Failed to save state: ' + e.message);
}
}
function loadState() {
try {
const stored = localStorage.getItem('cognitivetpg_state');
if (stored) {
const state = JSON.parse(stored);
State.printers = state.printers || [];
State.printerCounter = state.printerCounter || 0;
if (state.theme) {
document.body.dataset.theme = state.theme;
$('theme_selector').value = state.theme;
}
if (state.layout) {
document.body.dataset.layout = state.layout;
$('layout_selector').value = state.layout;
}
log(2, 'State loaded from localStorage');
return true;
}
} catch (e) {
log(4, 'Failed to load state: ' + e.message);
}
return false;
}
function createPrinter() {
State.printerCounter++;
return {
id: State.printerCounter,
name: `Printer ${State.printerCounter}`,
type: 'ser',
comPort: 'COM1',
ipAddress: '192.168.1.' + (10 + State.printerCounter),
port: 9100,
btDevice: 'Device 1',
btCom: 'COM5',
parPort: 'LPT1',
connected: false,
config: {
darkness: 0,
printSpeed: 'Normal',
noMedia: 12,
debugLevel: 0,
autoReprint: false,
auxPower: false,
mediaAdjust: 0,
pitch: 203,
language: 'auto',
thermalMode: 'dt',
baud: 115200,
stopBits: 1,
xonXoff: false
}
};
}
function addPrinter() {
const printer = createPrinter();
State.printers.push(printer);
updatePrinterList();
updatePrinterDropdowns();
selectPrinter(printer.id, false, false);
saveState();
announce(`Printer added: ${printer.name}`);
log(2, `Printer added: ${printer.name}`);
}
function removePrinter() {
if (State.selectedPrinterIds.length === 0) {
announce('No printer selected');
return;
}
const removedNames = State.printers.filter(p => State.selectedPrinterIds.includes(p.id)).map(p => p.name);
State.printers = State.printers.filter(p => !State.selectedPrinterIds.includes(p.id));
Object.keys(State.multiSelectStates).forEach(key => {
State.multiSelectStates[key] = State.multiSelectStates[key].filter(id =>
State.printers.some(p => p.id === id)
);
});
State.selectedPrinterIds = [];
State.lastSelectedIndex = -1;
updatePrinterList();
updatePrinterDropdowns();
updatePrinterStatus();
saveState();
announce(`Printers removed: ${removedNames.join(', ')}`);
log(2, `Printers removed: ${removedNames.join(', ')}`);
}
function selectPrinter(id, isCtrlClick, isShiftClick) {
const printerIndex = State.printers.findIndex(p => p.id === id);
if (printerIndex === -1) return;
if (isShiftClick && State.lastSelectedIndex !== -1) {
const start = Math.min(State.lastSelectedIndex, printerIndex);
const end = Math.max(State.lastSelectedIndex, printerIndex);
State.selectedPrinterIds = [];
for (let i = start; i <= end; i++) {
State.selectedPrinterIds.push(State.printers[i].id);
}
} else if (isCtrlClick) {
const idx = State.selectedPrinterIds.indexOf(id);
if (idx > -1) {
State.selectedPrinterIds.splice(idx, 1);
} else {
State.selectedPrinterIds.push(id);
}
State.lastSelectedIndex = printerIndex;
} else {
State.selectedPrinterIds = [id];
State.lastSelectedIndex = printerIndex;
}
updatePrinterList();
if (State.selectedPrinterIds.length === 1) {
loadPrinterConfig(State.selectedPrinterIds[0]);
}
}
function getPortDisplay(printer) {
switch(printer.type) {
case 'ser': return printer.comPort;
case 'net': return printer.ipAddress;
case 'bt': return printer.btCom;
case 'par': return printer.parPort;
case 'usb': return 'USB';
default: return 'N/A';
}
}
function updatePrinterList() {
const list = $('printer_list');
list.innerHTML = '';
State.printers.forEach(p => {
const div = document.createElement('div');
div.className = 'printer-item' + (State.selectedPrinterIds.includes(p.id) ? ' selected' : '');
div.setAttribute('role', 'option');
div.setAttribute('aria-selected', State.selectedPrinterIds.includes(p.id));
div.onclick = (e) => {
selectPrinter(p.id, e.ctrlKey || e.metaKey, e.shiftKey);
};
div.innerHTML = `
<div class="printer-item-left">
<div class="printer-status${p.connected ? ' connected' : ''}" role="img" aria-label="${p.connected ? 'Connected' : 'Disconnected'}"></div>
<span>${escapeHtml(p.name)}</span>
</div>
<span class="printer-item-port">${escapeHtml(getPortDisplay(p))}</span>
`;
list.appendChild(div);
});
if (typeof updateAutoTestPrinterList === 'function') {
updateAutoTestPrinterList();
}
}
function loadPrinterConfig(printerId) {
const printer = State.printers.find(p => p.id === printerId);
if (!printer) return;
document.querySelector(`input[name="ct"][value="${printer.type}"]`).checked = true;
uiConn();
if (printer.type === 'net') {
$('net_ip').value = printer.ipAddress;
$('net_port').value = printer.port;
} else if (printer.type === 'ser') {
$('com_list').value = printer.comPort;
$('baud').value = printer.config.baud;
$('stop_bits').value = printer.config.stopBits;
$('xon_xoff').checked = printer.config.xonXoff;
} else if (printer.type === 'bt') {
$('bt_com').value = printer.btCom;
} else if (printer.type === 'par') {
$('par_port').value = printer.parPort;
}
if ($('darkness_val')) $('darkness_val').value = printer.config.darkness;
if ($('darkness_slider')) $('darkness_slider').value = printer.config.darkness;
if ($('print_speed')) $('print_speed').value = printer.config.printSpeed;
if ($('no_media')) $('no_media').value = printer.config.noMedia;
if ($('debug_level')) $('debug_level').selectedIndex = printer.config.debugLevel;
if ($('auto_reprint')) $('auto_reprint').checked = printer.config.autoReprint;
if ($('aux_power')) $('aux_power').checked = printer.config.auxPower;
if ($('media_adjust')) $('media_adjust').value = printer.config.mediaAdjust;
if ($('pitch')) $('pitch').value = printer.config.pitch;
document.querySelectorAll('input[name="lang"]').forEach(radio => {
if (radio.value === printer.config.language) radio.checked = true;
});
document.querySelectorAll('input[name="tm"]').forEach(radio => {
if (radio.value === printer.config.thermalMode) radio.checked = true;
});
log(1, `Loaded configuration for: ${printer.name}`);
}
function updateSelectedPrinterConfig() {
if (State.selectedPrinterIds.length !== 1) return;
const printer = State.printers.find(p => p.id === State.selectedPrinterIds[0]);
if (!printer) return;
const connType = document.querySelector('input[name="ct"]:checked').value;
printer.type = connType;
if (connType === 'net') {
printer.ipAddress = $('net_ip').value;
printer.port = $('net_port').value;
} else if (connType === 'ser') {
printer.comPort = $('com_list').value;
printer.config.baud = parseInt($('baud').value);
printer.config.stopBits = parseInt($('stop_bits').value);
printer.config.xonXoff = $('xon_xoff').checked;
} else if (connType === 'bt') {
printer.btCom = $('bt_com').value;
} else if (connType === 'par') {
printer.parPort = $('par_port').value;
}
updatePrinterList();
saveState();
log(1, `Updated configuration for: ${printer.name}`);
}
function uiConn() {
const t = document.querySelector('input[name="ct"]:checked').value;
$('p_ser').style.display = (t === 'ser') ? 'block' : 'none';
$('p_net').style.display = (t === 'net') ? 'block' : 'none';
$('p_bt').style.display = (t === 'bt') ? 'block' : 'none';
$('p_par').style.display = (t === 'par') ? 'block' : 'none';
$('p_usb').style.display = (t === 'usb') ? 'block' : 'none';
updateSelectedPrinterConfig();
}
function connectSelectedPrinters() {
State.selectedPrinterIds.forEach(id => {
const printer = State.printers.find(p => p.id === id);
if (printer) {
printer.connected = true;
announce(`Connected to ${printer.name}`);
log(2, `Connected to printer: ${printer.name}`);
}
});
updatePrinterList();
updatePrinterDropdowns();
updatePrinterStatus();
saveState();
}
function disconnectSelectedPrinters() {
State.selectedPrinterIds.forEach(id => {
const printer = State.printers.find(p => p.id === id);
if (printer) {
printer.connected = false;
announce(`Disconnected from ${printer.name}`);
log(2, `Disconnected from printer: ${printer.name}`);
}
});
updatePrinterList();
updatePrinterDropdowns();
updatePrinterStatus();
saveState();
}
function connectAllPrinters() {
State.printers.forEach(p => {
p.connected = true;
log(2, `Connected to printer: ${p.name}`);
});
updatePrinterList();
updatePrinterDropdowns();
updatePrinterStatus();
saveState();
announce('All printers connected');
}
function disconnectAllPrinters() {
State.printers.forEach(p => {
p.connected = false;
log(2, `Disconnected from printer: ${p.name}`);
});
updatePrinterList();
updatePrinterDropdowns();
updatePrinterStatus();
saveState();
announce('All printers disconnected');
}
function updatePrinterStatus() {
const connCount = State.printers.filter(p => p.connected).length;
const box = $('status_box');
const textNode = box.childNodes[0];
textNode.textContent = `${connCount} Connected`;
box.setAttribute('aria-label', `${connCount} printers connected`);
if (connCount > 0) {
box.classList.add('connected');
} else {
box.classList.remove('connected');
}
}
async function scanForDevices() {
announce('Scanning for devices...');
log(2, 'Scanning for devices (async)...');
if (typeof Backend !== 'undefined' && Backend.scanDevices) {
try {
const currentDevices = await Backend.scanDevices();
log(2, `Immediate result: ${currentDevices.length} devices known`);
if (currentDevices && currentDevices.length > 0) {
processDiscoveredDevices(currentDevices);
}
announce('Device scan started - results will appear as devices are found');
} catch (e) {
log(4, 'Backend device scan error: ' + e.message);
simulateDeviceDiscovery();
}
} else {
simulateDeviceDiscovery();
}
}
window.addEventListener('message', function(evt) {
if (evt.data && evt.data.event === 'devicesDiscovered') {
try {
const devices = JSON.parse(evt.data.data);
log(2, `Async discovery complete: ${devices.length} devices found`);
processDiscoveredDevices(devices);
announce(`Discovered ${devices.length} device(s)`);
} catch (e) {
log(4, 'Error processing discovered devices: ' + e.message);
}
}
});
function processDiscoveredDevices(devices) {
if (!Array.isArray(devices)) return;
devices.forEach(dev => {
const existing = State.printers.find(p => p.id === dev.id);
if (existing) {
existing.connected = dev.connected;
} else {
const printer = createPrinter();
printer.id = dev.id || printer.id;
printer.name = dev.description || dev.type || 'Unknown Printer';
printer.connected = dev.connected || false;
if (dev.id.startsWith('USB:')) {
printer.type = 'usb';
} else if (dev.id.startsWith('NET:')) {
printer.type = 'net';
printer.ipAddress = dev.id.replace('NET:', '');
} else if (dev.id.startsWith('SERIAL:')) {
printer.type = 'ser';
printer.comPort = dev.id.replace('SERIAL:', '');
} else if (dev.id.startsWith('BT:')) {
printer.type = 'bt';
}
State.printers.push(printer);
log(2, `Device found: ${printer.name} (${printer.id})`);
}
});
updatePrinterList();
updatePrinterDropdowns();
updateConnectionStatus();
saveState();
}
function simulateDeviceDiscovery() {
const newDevices = [
{type: 'ser', comPort: 'COM3', name: 'CXi4 Series'},
{type: 'net', ipAddress: '192.168.1.100', name: 'Ci Series'},
{type: 'usb', name: 'USB Printer'}
];
newDevices.forEach(dev => {
const printer = createPrinter();
printer.name = dev.name + ` ${printer.id}`;
printer.type = dev.type;
if (dev.comPort) printer.comPort = dev.comPort;
if (dev.ipAddress) printer.ipAddress = dev.ipAddress;
State.printers.push(printer);
log(2, `Device found: ${printer.name} at ${getPortDisplay(printer)}`);
});
updatePrinterList();
updatePrinterDropdowns();
saveState();
announce(`Found ${newDevices.length} device(s)`);
}
function initMultiSelects() {
const multiSelectIds = ['print_target', 'pos_target', 'fonts_target', 'prof_target', 'firm_target', 'img_src', 'img_target', 'script_target'];
multiSelectIds.forEach(id => {
State.multiSelectStates[id] = [];
});
}
function toggleMultiSelect(id) {
const dropdown = $(id);
let optionsDiv = dropdown.querySelector('.multi-select-options');
if (!optionsDiv) {
optionsDiv = document.createElement('div');
optionsDiv.className = 'multi-select-options';
State.printers.forEach(p => {
const opt = document.createElement('div');
opt.className = 'multi-select-option';
opt.textContent = p.name;
opt.dataset.printerId = p.id;
opt.onclick = (e) => {
e.stopPropagation();
toggleMultiSelectOption(id, p.id);
};
optionsDiv.appendChild(opt);
});
dropdown.appendChild(optionsDiv);
}
optionsDiv.classList.toggle('visible');
updateMultiSelectDisplay(id);
}
function toggleMultiSelectOption(dropdownId, printerId) {
const state = State.multiSelectStates[dropdownId];
const idx = state.indexOf(printerId);
if (idx > -1) {
state.splice(idx, 1);
} else {
state.push(printerId);
}
updateMultiSelectDisplay(dropdownId);
}
function updateMultiSelectDisplay(dropdownId) {
const dropdown = $(dropdownId);
const state = State.multiSelectStates[dropdownId];
const optionsDiv = dropdown.querySelector('.multi-select-options');
if (optionsDiv) {
optionsDiv.querySelectorAll('.multi-select-option').forEach(opt => {
const pid = parseInt(opt.dataset.printerId);
if (state.includes(pid)) {
opt.classList.add('selected');
} else {
opt.classList.remove('selected');
}
});
}
dropdown.innerHTML = '';
if (state.length === 0) {
const placeholder = document.createElement('span');
placeholder.style.color = 'var(--text-secondary)';
placeholder.style.fontSize = 'var(--font-size-small)';
placeholder.textContent = 'Select printer(s)...';
dropdown.appendChild(placeholder);
} else {
state.forEach(pid => {
const printer = State.printers.find(p => p.id === pid);
if (printer) {
const tag = document.createElement('div');
tag.className = 'multi-select-tag';
const removeBtn = document.createElement('span');
removeBtn.className = 'multi-select-tag-remove';
removeBtn.textContent = '';
removeBtn.onclick = (e) => {
e.stopPropagation();
removeMultiSelectTag(dropdownId, pid);
};
tag.appendChild(document.createTextNode(printer.name));
tag.appendChild(removeBtn);
dropdown.appendChild(tag);
}
});
}
if (optionsDiv) {
dropdown.appendChild(optionsDiv);
}
}
function removeMultiSelectTag(dropdownId, printerId) {
const state = State.multiSelectStates[dropdownId];
const idx = state.indexOf(printerId);
if (idx > -1) {
state.splice(idx, 1);
}
updateMultiSelectDisplay(dropdownId);
}
function updatePrinterDropdowns() {
const singleSelects = ['designer_target'];
singleSelects.forEach(id => {
const sel = $(id);
if (sel) {
sel.innerHTML = '';
State.printers.forEach(p => {
const opt = document.createElement('option');
opt.value = p.id;
opt.textContent = p.name + (p.connected ? ' (Connected)' : '');
sel.appendChild(opt);
});
}
});
Object.keys(State.multiSelectStates).forEach(id => {
const dropdown = $(id);
if (dropdown) {
const optionsDiv = dropdown.querySelector('.multi-select-options');
if (optionsDiv) {
optionsDiv.innerHTML = '';
State.printers.forEach(p => {
const opt = document.createElement('div');
opt.className = 'multi-select-option';
opt.textContent = p.name;
opt.dataset.printerId = p.id;
opt.onclick = (e) => {
e.stopPropagation();
toggleMultiSelectOption(id, p.id);
};
optionsDiv.appendChild(opt);
});
}
updateMultiSelectDisplay(id);
}
});
}
function renderTabs() {
console.log('[DEBUG renderTabs] Starting...');
const tabBar = $('tab-bar');
console.log('[DEBUG renderTabs] tabBar element:', tabBar);
if (!tabBar) {
console.error('[DEBUG renderTabs] tab-bar element not found!');
return;
}
tabBar.innerHTML = '';
const roleInfo = ROLES[State.currentRole];
console.log('[DEBUG renderTabs] currentRole:', State.currentRole, 'roleInfo:', roleInfo);
const allowedTabs = roleInfo ? roleInfo.tabs : TAB_ORDER;
console.log('[DEBUG renderTabs] allowedTabs:', allowedTabs);
if (State.currentRole === 'server') {
tabBar.style.display = 'none';
return;
} else {
tabBar.style.display = '';
}
let tabCount = 0;
TAB_ORDER.forEach(tabId => {
if (!allowedTabs.includes(tabId)) return;
const tab = document.createElement('div');
tab.className = 'tab-item';
tab.textContent = TAB_NAMES[tabId];
tab.dataset.tabId = tabId;
tab.draggable = true;
tab.setAttribute('role', 'tab');
tab.setAttribute('tabindex', '0');
tab.onclick = () => nav(tabId);
tab.onkeydown = (e) => {
if (e.key === 'Enter' || e.key === ' ') {
e.preventDefault();
nav(tabId);
}
};
tab.ondragstart = handleTabDragStart;
tab.ondragover = handleTabDragOver;
tab.ondrop = handleTabDrop;
tab.ondragend = handleTabDragEnd;
tabBar.appendChild(tab);
tabCount++;
});
console.log('[DEBUG renderTabs] Created', tabCount, 'tabs');
const firstTab = document.querySelector('.tab-item');
if (firstTab) firstTab.classList.add('active');
console.log('[DEBUG renderTabs] Complete');
}
function handleTabDragStart(e) {
State.draggedTab = this;
this.classList.add('dragging');
e.dataTransfer.effectAllowed = 'move';
}
function handleTabDragOver(e) {
e.preventDefault();
e.dataTransfer.dropEffect = 'move';
return false;
}
function handleTabDrop(e) {
e.stopPropagation();
if (State.draggedTab !== this) {
const draggedId = State.draggedTab.dataset.tabId;
const targetId = this.dataset.tabId;
const draggedIdx = TAB_ORDER.indexOf(draggedId);
const targetIdx = TAB_ORDER.indexOf(targetId);
TAB_ORDER.splice(draggedIdx, 1);
TAB_ORDER.splice(targetIdx, 0, draggedId);
renderTabs();
const activeTab = document.querySelector('.tab-item.active');
if (activeTab) {
nav(activeTab.dataset.tabId);
}
log(1, `Tab order changed: ${draggedId} moved to position ${targetIdx}`);
}
return false;
}
function handleTabDragEnd(e) {
this.classList.remove('dragging');
State.draggedTab = null;
}
function nav(id) {
document.querySelectorAll('.workspace').forEach(e => {
e.classList.remove('visible');
e.setAttribute('aria-hidden', 'true');
});
document.querySelectorAll('.tab-item').forEach(e => {
e.classList.remove('active');
e.setAttribute('aria-selected', 'false');
});
$(id).classList.add('visible');
$(id).setAttribute('aria-hidden', 'false');
const activeTab = document.querySelector(`.tab-item[data-tab-id="${id}"]`);
activeTab.classList.add('active');
activeTab.setAttribute('aria-selected', 'true');
announce(`Navigated to ${TAB_NAMES[id]}`);
log(1, `Navigated to tab: ${TAB_NAMES[id]}`);
}
function applyTheme(theme) {
document.body.dataset.theme = theme;
saveState();
announce(`Theme changed to ${theme}`);
log(2, `Theme changed to: ${theme}`);
}
function applyLayout(layout) {
document.body.dataset.layout = layout;
saveState();
announce(`Layout changed to ${layout}`);
log(2, `Layout changed to: ${layout}`);
}
function applyBorders(showBorders) {
document.body.dataset.borders = showBorders ? 'true' : 'false';
saveState();
announce(`Window borders ${showBorders ? 'enabled' : 'disabled'}`);
log(2, `Window borders: ${showBorders ? 'enabled' : 'disabled'}`);
}
const AutoTest = {
running: false,
currentTest: null,
results: { passed: 0, failed: 0, skipped: 0 },
testQueue: [],
aborted: false,
testInterval: null,
reset() {
this.running = false;
this.currentTest = null;
this.results = { passed: 0, failed: 0, skipped: 0 };
this.testQueue = [];
this.aborted = false;
if (this.testInterval) clearInterval(this.testInterval);
document.querySelectorAll('.autotest-status').forEach(el => el.textContent = '');
document.querySelectorAll('.autotest-status').forEach(el => el.className = 'autotest-status');
document.querySelectorAll('.autotest-suite-status').forEach(el => {
el.textContent = '';
el.className = 'autotest-suite-status';
});
this.updateProgress(0, 0);
this.updateSummary();
},
updateProgress(current, total) {
const percent = total > 0 ? (current / total * 100) : 0;
$('autotest_progress').style.width = percent + '%';
$('autotest_progress_text').textContent = `${current} / ${total} tests`;
},
updateSummary() {
$('autotest_summary').innerHTML = `
<span style="color:var(--status-green);">Passed: ${this.results.passed}</span> |
<span style="color:var(--status-red);">Failed: ${this.results.failed}</span> |
<span style="color:var(--text-secondary);">Skipped: ${this.results.skipped}</span>
`;
},
logMessage(msg, type = 'info') {
const logEl = $('autotest_log');
const entry = document.createElement('div');
entry.className = `log-${type}`;
const timestamp = new Date().toISOString().substring(11, 23);
entry.textContent = `[${timestamp}] ${msg}`;
logEl.appendChild(entry);
logEl.scrollTop = logEl.scrollHeight;
},
getSelectedTests() {
const tests = [];
const target = document.querySelector('input[name="autotest_target"]:checked').value;
document.querySelectorAll('.autotest-item input[type="checkbox"]:checked').forEach(cb => {
const testItem = cb.closest('.autotest-item');
const testId = testItem.dataset.test;
const suite = testItem.closest('.autotest-suite').dataset.suite;
if (target === 'printer' && suite === 'cadmin') return;
if (target === 'cadmin' && !['cadmin'].includes(suite) && !testId.startsWith('cadmin')) return;
tests.push({ id: testId, suite: suite, element: testItem });
});
return tests;
},
async runTest(test) {
const statusEl = test.element.querySelector('.autotest-status');
statusEl.textContent = 'Running...';
statusEl.className = 'autotest-status running';
this.logMessage(`Running: ${test.id}`, 'info');
const delay = 200 + Math.random() * 800;
await new Promise(resolve => setTimeout(resolve, delay));
if (this.aborted) {
statusEl.textContent = 'Skipped';
statusEl.className = 'autotest-status skipped';
this.results.skipped++;
return 'skipped';
}
const result = await this.executeTestById(test.id);
if (result.success) {
statusEl.textContent = 'Passed';
statusEl.className = 'autotest-status passed';
this.results.passed++;
this.logMessage(` ${test.id}: ${result.message || 'OK'}`, 'info');
return 'passed';
} else {
statusEl.textContent = 'Failed';
statusEl.className = 'autotest-status failed';
this.results.failed++;
this.logMessage(` ${test.id}: ${result.message || 'Failed'}`, 'error');
return 'failed';
}
},
async executeTestById(testId) {
if (testId === 'cadmin_ui') {
const wrapper = document.querySelector('.app-wrapper');
const container = document.querySelector('.app-container');
return { success: wrapper && container, message: 'UI elements present' };
}
if (testId === 'cadmin_tabs') {
const tabs = document.querySelectorAll('.tab-item');
return { success: tabs.length > 0, message: `${tabs.length} tabs found` };
}
if (testId === 'cadmin_themes') {
const themeSelect = $('theme_selector');
const themes = themeSelect ? themeSelect.options.length : 0;
return { success: themes >= 5, message: `${themes} themes available` };
}
if (testId === 'cadmin_layouts') {
const layoutSelect = $('layout_selector');
const layouts = layoutSelect ? layoutSelect.options.length : 0;
return { success: layouts >= 2, message: `${layouts} layouts available` };
}
if (testId === 'cadmin_roles') {
const roleSelect = $('role_selector');
const roles = roleSelect ? roleSelect.options.length : 0;
return { success: roles >= 4, message: `${roles} roles configured` };
}
if (testId === 'cadmin_state') {
try {
const key = 'cognitivetpg_test_' + Date.now();
localStorage.setItem(key, 'test');
const val = localStorage.getItem(key);
localStorage.removeItem(key);
return { success: val === 'test', message: 'LocalStorage working' };
} catch (e) {
return { success: false, message: 'LocalStorage error' };
}
}
if (testId === 'cadmin_cpl') {
return { success: typeof CPL_DB === 'object' && Object.keys(CPL_DB).length > 0, message: 'CPL database loaded' };
}
if (testId === 'cadmin_designer') {
const canvas = $('canvas_el');
return { success: canvas && canvas.getContext, message: 'Canvas available' };
}
if (testId === 'cadmin_multiselect') {
const multiSelects = document.querySelectorAll('.multi-select-dropdown');
return { success: multiSelects.length > 0, message: `${multiSelects.length} multi-selects found` };
}
if (testId === 'cadmin_logging') {
const debugConsole = $('debug_console');
return { success: debugConsole !== null, message: 'Logging system ready' };
}
const printerConnected = State.printers.some(p => p.connected);
if (testId.startsWith('printer_') || testId.startsWith('comm_') || testId.startsWith('print_') || testId.startsWith('fw_')) {
if (!printerConnected) {
return { success: false, message: 'No printer connected' };
}
try {
const device = State.printers.find(p => p.connected);
if (device && typeof Backend !== 'undefined' && Backend.startTest) {
const result = await Backend.startTest(device.id, { testId: testId });
if (result && typeof result.success === 'boolean') {
return { success: result.success, message: result.message || 'Backend test completed' };
}
}
return { success: Math.random() > 0.1, message: 'Simulated test result' };
} catch (e) {
return { success: false, message: 'Test error: ' + e.message };
}
}
if (testId.startsWith('int_') || testId.startsWith('stress_')) {
try {
const device = State.printers.find(p => p.connected);
if (device && typeof Backend !== 'undefined' && Backend.startTest) {
const result = await Backend.startTest(device.id, { testId: testId });
if (result && typeof result.success === 'boolean') {
return { success: result.success, message: result.message || 'Backend test completed' };
}
}
return { success: Math.random() > 0.15, message: 'Simulated test result' };
} catch (e) {
return { success: false, message: 'Test error: ' + e.message };
}
}
return { success: true, message: 'Test completed' };
},
updateSuiteStatus(suite) {
const suiteEl = document.querySelector(`.autotest-suite[data-suite="${suite}"]`);
if (!suiteEl) return;
const items = suiteEl.querySelectorAll('.autotest-item');
let passed = 0, failed = 0, total = 0;
items.forEach(item => {
const status = item.querySelector('.autotest-status');
if (status.classList.contains('passed')) { passed++; total++; }
else if (status.classList.contains('failed')) { failed++; total++; }
else if (status.classList.contains('skipped')) { total++; }
});
const statusEl = suiteEl.querySelector('.autotest-suite-status');
if (total === 0) {
statusEl.textContent = '';
statusEl.className = 'autotest-suite-status';
} else if (failed > 0) {
statusEl.textContent = `${passed}/${total}`;
statusEl.className = 'autotest-suite-status failed';
} else if (passed === total) {
statusEl.textContent = `${passed}/${total}`;
statusEl.className = 'autotest-suite-status passed';
} else {
statusEl.textContent = `${passed}/${total}`;
statusEl.className = 'autotest-suite-status running';
}
},
async runAllTests() {
if (this.running) return;
this.reset();
this.running = true;
this.aborted = false;
$('btn_autotest_stop').disabled = false;
$('btn_autotest_run_all').disabled = true;
$('btn_autotest_run_selected').disabled = true;
const tests = this.getSelectedTests();
const total = tests.length;
let current = 0;
this.logMessage(`Starting ${total} tests...`, 'info');
this.logMessage(`Target: ${document.querySelector('input[name="autotest_target"]:checked').value}`, 'info');
const stopOnFail = $('autotest_stop_on_fail').checked;
for (const test of tests) {
if (this.aborted) {
this.logMessage('Tests aborted by user', 'warning');
break;
}
current++;
this.updateProgress(current, total);
const result = await this.runTest(test);
this.updateSummary();
this.updateSuiteStatus(test.suite);
if (stopOnFail && result === 'failed') {
this.logMessage('Stopping on first failure', 'warning');
break;
}
}
this.running = false;
$('btn_autotest_stop').disabled = true;
$('btn_autotest_run_all').disabled = false;
$('btn_autotest_run_selected').disabled = false;
const status = this.results.failed > 0 ? 'FAILED' : 'PASSED';
this.logMessage(`Test run complete: ${status}`, this.results.failed > 0 ? 'error' : 'info');
this.logMessage(`Results: ${this.results.passed} passed, ${this.results.failed} failed, ${this.results.skipped} skipped`, 'info');
if ($('autotest_generate_report').checked) {
this.logMessage('Report generated', 'info');
}
announce(`Tests complete: ${this.results.passed} passed, ${this.results.failed} failed`);
},
stop() {
this.aborted = true;
this.logMessage('Stopping tests...', 'warning');
}
};
function toggleAutoTestSuite(suite) {
const suiteEl = document.querySelector(`.autotest-suite[data-suite="${suite}"]`);
const content = $(`suite_${suite}_content`);
if (suiteEl && content) {
suiteEl.classList.toggle('expanded');
content.style.display = suiteEl.classList.contains('expanded') ? 'block' : 'none';
}
}
function setupAutoTestHandlers() {
$('btn_autotest_run_all').onclick = () => AutoTest.runAllTests();
$('btn_autotest_run_selected').onclick = () => AutoTest.runAllTests();
$('btn_autotest_stop').onclick = () => AutoTest.stop();
$('btn_autotest_reset').onclick = () => {
AutoTest.reset();
$('autotest_log').innerHTML = '';
announce('Tests reset');
};
$('btn_autotest_clear_log').onclick = () => {
$('autotest_log').innerHTML = '';
};
$('btn_autotest_export').onclick = () => {
const log = $('autotest_log').innerText;
const report = `CAdmin Automated Test Report\n` +
`Generated: ${new Date().toISOString()}\n` +
`====================================\n\n` +
`Results Summary:\n` +
`  Passed: ${AutoTest.results.passed}\n` +
`  Failed: ${AutoTest.results.failed}\n` +
`  Skipped: ${AutoTest.results.skipped}\n\n` +
`Test Log:\n` +
`------------------------------------\n` +
log;
const blob = new Blob([report], { type: 'text/plain' });
const a = document.createElement('a');
a.href = URL.createObjectURL(blob);
a.download = `autotest_report_${new Date().toISOString().replace(/[:.]/g, '-')}.txt`;
a.click();
announce('Report exported');
};
$('autotest_all_printers').onchange = function() {
const select = $('autotest_printer_select');
if (this.checked) {
Array.from(select.options).forEach(opt => opt.selected = true);
} else {
Array.from(select.options).forEach(opt => opt.selected = false);
}
};
}
function updateAutoTestPrinterList() {
const select = $('autotest_printer_select');
if (!select) return;
select.innerHTML = '';
State.printers.filter(p => p.connected).forEach(p => {
const opt = document.createElement('option');
opt.value = p.id;
opt.textContent = `${p.name} (${p.port})`;
select.appendChild(opt);
});
}
function filterCPL(cat) {
const content = $('cpl_content');
content.innerHTML = '';
const h = document.createElement('h3');
h.textContent = cat === 'all' ? 'All CPL Commands' : cat.charAt(0).toUpperCase() + cat.slice(1) + ' Commands';
content.appendChild(h);
const categories = cat === 'all' ? Object.keys(CPL_DB) : [cat];
categories.forEach(category => {
if (!CPL_DB[category]) return;
CPL_DB[category].forEach(cmd => {
const div = document.createElement('div');
div.className = 'cpl-command-card';
div.innerHTML = `
<div class="cpl-command-title">${escapeHtml(cmd.cmd)}${cmd.short ? ` (${escapeHtml(cmd.short)})` : ''}</div>
<div class="cpl-command-syntax">${escapeHtml(cmd.cmd)} ${escapeHtml(cmd.params)}</div>
<div class="cpl-command-desc">${escapeHtml(cmd.desc)}</div>
${cmd.response ? `<div class="cpl-response"><strong>Response:</strong> ${escapeHtml(cmd.response)}${cmd.responseBytes ? ` <span class="response-bytes">[${cmd.responseBytes} bytes]</span>` : ''}</div>` : ''}
${cmd.exampleResponse ? `<div class="cpl-example-response"><strong>Example Response:</strong> <code>${escapeHtml(cmd.exampleResponse)}</code></div>` : ''}
${cmd.example ? `<div class="cpl-example">Example:\n${escapeHtml(cmd.example)}</div>` : ''}
`;
content.appendChild(div);
});
});
}
function searchCPL() {
const query = $('cpl_search').value.toLowerCase();
if (!query) {
filterCPL('all');
return;
}
const content = $('cpl_content');
content.innerHTML = '<h3>Search Results</h3>';
let found = false;
Object.keys(CPL_DB).forEach(category => {
CPL_DB[category].forEach(cmd => {
if (cmd.cmd.toLowerCase().includes(query) || cmd.desc.toLowerCase().includes(query) || (cmd.response && cmd.response.toLowerCase().includes(query))) {
found = true;
const div = document.createElement('div');
div.className = 'cpl-command-card';
div.innerHTML = `
<div class="cpl-command-title">${escapeHtml(cmd.cmd)}${cmd.short ? ` (${escapeHtml(cmd.short)})` : ''}</div>
<div class="cpl-command-syntax">${escapeHtml(cmd.cmd)} ${escapeHtml(cmd.params)}</div>
<div class="cpl-command-desc">${escapeHtml(cmd.desc)}</div>
${cmd.response ? `<div class="cpl-response"><strong>Response:</strong> ${escapeHtml(cmd.response)}${cmd.responseBytes ? ` <span class="response-bytes">[${cmd.responseBytes} bytes]</span>` : ''}</div>` : ''}
${cmd.exampleResponse ? `<div class="cpl-example-response"><strong>Example Response:</strong> <code>${escapeHtml(cmd.exampleResponse)}</code></div>` : ''}
${cmd.example ? `<div class="cpl-example">Example:\n${escapeHtml(cmd.example)}</div>` : ''}
`;
content.appendChild(div);
}
});
});
if (!found) {
content.innerHTML += '<p style="color:var(--text-secondary);">No commands found.</p>';
}
}
let canvasDragState = { dragging: false, resizing: false, startX: 0, startY: 0, origX: 0, origY: 0, origW: 0, origH: 0, resizeHandle: null };
function addLabelElement(type) {
const elem = {
type: type,
x: 50 + State.labelElements.length * 20,
y: 50 + State.labelElements.length * 15,
width: type === 'circle' ? 50 : (type === 'ellipse' ? 80 : 100),
height: type === 'circle' ? 50 : (type === 'ellipse' ? 50 : 30),
text: type === 'text' ? 'Sample Text' : '',
font: 'TEXT 3',
barcodeType: 'CODE128',
thickness: 2,
radius: type === 'circle' ? 25 : 0,
zIndex: State.labelElements.length
};
State.labelElements.push(elem);
State.selectedElement = elem;
renderCanvas();
updateProperties();
announce(`Added ${type} element to canvas`);
log(1, `Added ${type} element to canvas`);
}
function getElementAtPoint(x, y) {
for (let i = State.labelElements.length - 1; i >= 0; i--) {
const elem = State.labelElements[i];
let bounds;
if (elem.type === 'circle') {
bounds = { x: elem.x, y: elem.y, w: elem.radius * 2, h: elem.radius * 2 };
} else if (elem.type === 'text') {
bounds = { x: elem.x - 2, y: elem.y - 12, w: elem.width, h: 16 };
} else {
bounds = { x: elem.x, y: elem.y, w: elem.width, h: elem.height };
}
if (x >= bounds.x && x <= bounds.x + bounds.w && y >= bounds.y && y <= bounds.y + bounds.h) {
return elem;
}
}
return null;
}
function getResizeHandle(elem, x, y) {
if (!elem || elem.type === 'line') return null;
const handleSize = 8;
let bounds;
if (elem.type === 'circle') {
bounds = { x: elem.x, y: elem.y, w: elem.radius * 2, h: elem.radius * 2 };
} else if (elem.type === 'text') {
bounds = { x: elem.x - 2, y: elem.y - 12, w: elem.width, h: 16 };
} else {
bounds = { x: elem.x, y: elem.y, w: elem.width, h: elem.height };
}
const corners = [
{ name: 'se', x: bounds.x + bounds.w - handleSize/2, y: bounds.y + bounds.h - handleSize/2 },
{ name: 'sw', x: bounds.x - handleSize/2, y: bounds.y + bounds.h - handleSize/2 },
{ name: 'ne', x: bounds.x + bounds.w - handleSize/2, y: bounds.y - handleSize/2 },
{ name: 'nw', x: bounds.x - handleSize/2, y: bounds.y - handleSize/2 }
];
for (const corner of corners) {
if (x >= corner.x && x <= corner.x + handleSize && y >= corner.y && y <= corner.y + handleSize) {
return corner.name;
}
}
return null;
}
function bringToFront() {
if (State.selectedElement) {
const idx = State.labelElements.indexOf(State.selectedElement);
if (idx > -1) {
State.labelElements.splice(idx, 1);
State.labelElements.push(State.selectedElement);
State.selectedElement.zIndex = State.labelElements.length - 1;
renderCanvas();
announce('Element brought to front');
}
}
}
function sendToBack() {
if (State.selectedElement) {
const idx = State.labelElements.indexOf(State.selectedElement);
if (idx > -1) {
State.labelElements.splice(idx, 1);
State.labelElements.unshift(State.selectedElement);
State.labelElements.forEach((el, i) => el.zIndex = i);
renderCanvas();
announce('Element sent to back');
}
}
}
function duplicateElement() {
if (State.selectedElement) {
const copy = JSON.parse(JSON.stringify(State.selectedElement));
copy.x += 20;
copy.y += 20;
copy.zIndex = State.labelElements.length;
State.labelElements.push(copy);
State.selectedElement = copy;
renderCanvas();
updateProperties();
announce('Element duplicated');
}
}
function showContextMenu(x, y) {
let menu = $('canvas_context_menu');
if (!menu) {
menu = document.createElement('div');
menu.id = 'canvas_context_menu';
menu.style.cssText = 'position:fixed;background:var(--bg-window);border:1px solid var(--border-dark);box-shadow:2px 2px 5px rgba(0,0,0,0.2);z-index:1000;padding:2px 0;min-width:120px;font-size:var(--font-size-small);';
menu.innerHTML = `
<div class="ctx-item" data-action="front" style="padding:4px 12px;cursor:pointer;">Bring to Front</div>
<div class="ctx-item" data-action="back" style="padding:4px 12px;cursor:pointer;">Send to Back</div>
<div style="border-top:1px solid var(--border-shadow);margin:2px 0;"></div>
<div class="ctx-item" data-action="duplicate" style="padding:4px 12px;cursor:pointer;">Duplicate</div>
<div class="ctx-item" data-action="delete" style="padding:4px 12px;cursor:pointer;color:var(--status-red);">Delete</div>
`;
document.body.appendChild(menu);
menu.querySelectorAll('.ctx-item').forEach(item => {
item.onmouseenter = () => item.style.background = 'var(--accent-primary)';
item.onmouseleave = () => item.style.background = '';
item.onclick = () => {
const action = item.dataset.action;
if (action === 'front') bringToFront();
else if (action === 'back') sendToBack();
else if (action === 'duplicate') duplicateElement();
else if (action === 'delete') deleteElement();
hideContextMenu();
};
});
}
menu.style.left = x + 'px';
menu.style.top = y + 'px';
menu.style.display = 'block';
}
function hideContextMenu() {
const menu = $('canvas_context_menu');
if (menu) menu.style.display = 'none';
}
function renderCanvas() {
const canvas = $('canvas_el');
const ctx = canvas.getContext('2d');
ctx.clearRect(0, 0, canvas.width, canvas.height);
const sortedElements = [...State.labelElements].sort((a, b) => (a.zIndex || 0) - (b.zIndex || 0));
sortedElements.forEach(elem => {
const isSelected = elem === State.selectedElement;
ctx.strokeStyle = isSelected ? '#ff0000' : '#000000';
ctx.lineWidth = elem.thickness || 2;
if (elem.type === 'box') {
ctx.strokeRect(elem.x, elem.y, elem.width, elem.height);
} else if (elem.type === 'line') {
ctx.beginPath();
ctx.moveTo(elem.x, elem.y);
ctx.lineTo(elem.x + elem.width, elem.y + elem.height);
ctx.stroke();
} else if (elem.type === 'text') {
ctx.font = '12px Arial';
ctx.fillStyle = '#000';
ctx.fillText(elem.text, elem.x, elem.y);
ctx.strokeRect(elem.x - 2, elem.y - 12, elem.width, 16);
} else if (elem.type === 'barcode') {
ctx.fillStyle = '#000';
for (let i = 0; i < 10; i++) {
if (i % 2 === 0) ctx.fillRect(elem.x + i * 10, elem.y, 8, elem.height);
}
ctx.strokeRect(elem.x, elem.y, elem.width, elem.height);
} else if (elem.type === 'circle') {
ctx.beginPath();
ctx.arc(elem.x + elem.radius, elem.y + elem.radius, elem.radius, 0, Math.PI * 2);
ctx.stroke();
} else if (elem.type === 'ellipse') {
ctx.beginPath();
ctx.ellipse(elem.x + elem.width / 2, elem.y + elem.height / 2, elem.width / 2, elem.height / 2, 0, 0, Math.PI * 2);
ctx.stroke();
}
if (isSelected && elem.type !== 'line') {
ctx.fillStyle = '#0078d7';
const handleSize = 6;
let bounds;
if (elem.type === 'circle') {
bounds = { x: elem.x, y: elem.y, w: elem.radius * 2, h: elem.radius * 2 };
} else if (elem.type === 'text') {
bounds = { x: elem.x - 2, y: elem.y - 12, w: elem.width, h: 16 };
} else {
bounds = { x: elem.x, y: elem.y, w: elem.width, h: elem.height };
}
ctx.fillRect(bounds.x - handleSize/2, bounds.y - handleSize/2, handleSize, handleSize);
ctx.fillRect(bounds.x + bounds.w - handleSize/2, bounds.y - handleSize/2, handleSize, handleSize);
ctx.fillRect(bounds.x - handleSize/2, bounds.y + bounds.h - handleSize/2, handleSize, handleSize);
ctx.fillRect(bounds.x + bounds.w - handleSize/2, bounds.y + bounds.h - handleSize/2, handleSize, handleSize);
}
});
}
function updateProperties() {
const props = $('element_props');
if (!State.selectedElement) {
props.innerHTML = '<div style="font-weight:bold; margin-bottom:5px;">Properties</div><div style="font-size:var(--font-size-small); color:var(--text-secondary);">Select an element</div>';
return;
}
const elem = State.selectedElement;
props.innerHTML = `
<div style="font-weight:bold; margin-bottom:5px;">Properties - ${elem.type}</div>
<div class="grid-2" style="font-size:var(--font-size-small);">
<span>X:</span><input type="number" value="${elem.x}" id="prop_x" style="width:60px;">
<span>Y:</span><input type="number" value="${elem.y}" id="prop_y" style="width:60px;">
${elem.type === 'circle' ? `<span>Radius:</span><input type="number" value="${elem.radius}" id="prop_r" style="width:60px;">` : ''}
${(elem.type !== 'line' && elem.type !== 'circle') ? `<span>Width:</span><input type="number" value="${elem.width}" id="prop_w" style="width:60px;">` : ''}
${(elem.type !== 'line' && elem.type !== 'circle') ? `<span>Height:</span><input type="number" value="${elem.height}" id="prop_h" style="width:60px;">` : ''}
${elem.type === 'text' ? `<span>Text:</span><input type="text" value="${escapeHtml(elem.text)}" id="prop_text">` : ''}
</div>
<button id="btn_delete_element" style="width:100%; margin-top:var(--spacing-md);">Delete</button>
`;
$('prop_x').onchange = () => { elem.x = parseInt($('prop_x').value) || 0; renderCanvas(); };
$('prop_y').onchange = () => { elem.y = parseInt($('prop_y').value) || 0; renderCanvas(); };
if ($('prop_r')) $('prop_r').onchange = () => { elem.radius = parseInt($('prop_r').value) || 10; renderCanvas(); };
if ($('prop_w')) $('prop_w').onchange = () => { elem.width = parseInt($('prop_w').value) || 0; renderCanvas(); };
if ($('prop_h')) $('prop_h').onchange = () => { elem.height = parseInt($('prop_h').value) || 0; renderCanvas(); };
if ($('prop_text')) $('prop_text').onchange = () => { elem.text = $('prop_text').value; renderCanvas(); };
$('btn_delete_element').onclick = deleteElement;
}
function deleteElement() {
if (State.selectedElement) {
State.labelElements = State.labelElements.filter(e => e !== State.selectedElement);
State.selectedElement = null;
renderCanvas();
updateProperties();
announce('Element deleted');
log(1, 'Deleted element from canvas');
}
}
function clearCanvas() {
State.labelElements = [];
State.selectedElement = null;
renderCanvas();
updateProperties();
announce('Canvas cleared');
log(2, 'Canvas cleared');
}
function generateCPL() {
let cpl = '! 0 200 200 1\n';
State.labelElements.forEach(elem => {
if (elem.type === 'text') {
cpl += `TEXT 3 0 ${elem.x} ${elem.y} ${elem.text}\n`;
} else if (elem.type === 'barcode') {
cpl += `BARCODE ${elem.barcodeType} 0 ${elem.x} ${elem.y} ${elem.height} 123456789\n`;
} else if (elem.type === 'box') {
cpl += `DRAW_BOX ${elem.x} ${elem.y} ${elem.width} ${elem.height} ${elem.thickness}\n`;
} else if (elem.type === 'line') {
cpl += `DRAW_LINE ${elem.x} ${elem.y} ${elem.x + elem.width} ${elem.y + elem.height} ${elem.thickness}\n`;
} else if (elem.type === 'circle') {
cpl += `DRAW_ELLIPSE ${elem.x} ${elem.y} ${elem.radius * 2} ${elem.radius * 2} ${elem.thickness}\n`;
} else if (elem.type === 'ellipse') {
cpl += `DRAW_ELLIPSE ${elem.x} ${elem.y} ${elem.width} ${elem.height} ${elem.thickness}\n`;
}
});
cpl += 'END\n';
$('generated_cpl').value = cpl;
announce('CPL code generated');
log(2, 'CPL code generated');
}
function applyConfigToSelected(targetKey, configKey, getValue, logMessage) {
const targets = State.multiSelectStates[targetKey] || [];
if (targets.length === 0) {
announce('No printers selected');
return;
}
targets.forEach(id => {
const printer = State.printers.find(p => p.id === id);
if (printer) {
printer.config[configKey] = getValue();
log(2, `${logMessage} ${getValue()} to ${printer.name}`);
}
});
saveState();
announce(`${logMessage} applied to ${targets.length} printer(s)`);
}
function setupEventHandlers() {
$('role_selector').onchange = function() {
localStorage.setItem('cognitivetpg_role', this.value);
applyRole(this.value);
};
$('btn_add_printer').onclick = addPrinter;
$('btn_remove_printer').onclick = removePrinter;
$('btn_scan_devices').onclick = scanForDevices;
$('btn_connect_selected').onclick = connectSelectedPrinters;
$('btn_connect_all').onclick = connectAllPrinters;
$('btn_disconnect_all').onclick = disconnectAllPrinters;
$('btn_scan_bluetooth').onclick = () => {
announce('Scanning for Bluetooth devices...');
log(2, 'Scanning for Bluetooth devices...');
};
document.querySelectorAll('input[name="ct"]').forEach(radio => {
radio.onchange = () => {
uiConn();
updateWifiPanelVisibility();
};
});
['com_list', 'baud', 'stop_bits', 'xon_xoff', 'net_ip', 'net_port', 'bt_com', 'par_port'].forEach(id => {
const el = $(id);
if (el) {
el.onchange = updateSelectedPrinterConfig;
}
});
$('wifi_dhcp').onchange = function() {
$('wifi_static').style.display = this.checked ? 'none' : 'grid';
};
$('btn_scan_wifi').onclick = () => {
const list = $('wifi_list');
list.innerHTML = '<div style="color:var(--text-secondary);">Scanning...</div>';
announce('Scanning for WiFi networks...');
log(2, 'Scanning for WiFi networks...');
setTimeout(() => {
list.innerHTML = `
<div style="padding:3px; cursor:pointer; border-bottom:1px solid var(--border-light);" onclick="$('wifi_ssid').value='Office-Network';">Office-Network (WPA2) - Strong</div>
<div style="padding:3px; cursor:pointer; border-bottom:1px solid var(--border-light);" onclick="$('wifi_ssid').value='Guest-WiFi';">Guest-WiFi (Open) - Medium</div>
<div style="padding:3px; cursor:pointer; border-bottom:1px solid var(--border-light);" onclick="$('wifi_ssid').value='Production-5G';">Production-5G (WPA3) - Weak</div>
`;
announce('Found 3 WiFi networks');
log(2, 'Found 3 WiFi networks');
}, 1000);
};
$('btn_apply_wifi').onclick = () => {
announce('WiFi configuration applied');
log(2, 'WiFi configuration applied to selected printer(s)');
};
$('btn_apply_darkness').onclick = () => {
applyConfigToSelected('print_target', 'darkness', () => parseInt($('darkness_val').value), 'Applied darkness');
};
$('btn_darkness_down').onclick = () => {
const slider = $('darkness_slider');
const val = $('darkness_val');
let current = parseInt(slider.value);
current = Math.max(-200, current - 10);
slider.value = current;
val.value = current;
};
$('btn_darkness_up').onclick = () => {
const slider = $('darkness_slider');
const val = $('darkness_val');
let current = parseInt(slider.value);
current = Math.min(200, current + 10);
slider.value = current;
val.value = current;
};
$('darkness_slider').oninput = function() {
$('darkness_val').value = this.value;
};
$('darkness_val').onchange = function() {
let v = parseInt(this.value) || 0;
v = Math.max(-200, Math.min(200, v));
this.value = v;
$('darkness_slider').value = v;
};
$('btn_refresh_time').onclick = () => {
const now = new Date();
$('rtc_time').value = now.toTimeString().slice(0, 8);
$('rtc_date').value = now.toISOString().slice(0, 10);
announce('RTC refreshed from printer');
log(2, 'RTC time/date refreshed');
};
$('btn_apply_datetime').onclick = () => {
announce('RTC set to ' + $('rtc_time').value + ' ' + $('rtc_date').value);
log(2, 'RTC time/date applied: ' + $('rtc_time').value + ' ' + $('rtc_date').value);
};
$('btn_apply_print_speed').onclick = () => {
applyConfigToSelected('print_target', 'printSpeed', () => $('print_speed').value, 'Applied print speed');
};
$('btn_apply_no_media').onclick = () => {
applyConfigToSelected('print_target', 'noMedia', () => parseInt($('no_media').value), 'Applied no-media-out');
};
$('btn_apply_debug_level').onclick = () => {
applyConfigToSelected('print_target', 'debugLevel', () => $('debug_level').selectedIndex, 'Applied debug level');
};
$('btn_apply_auto_reprint').onclick = () => {
applyConfigToSelected('print_target', 'autoReprint', () => $('auto_reprint').checked, 'Applied auto-reprint');
};
$('btn_apply_aux_power').onclick = () => {
applyConfigToSelected('print_target', 'auxPower', () => $('aux_power').checked, 'Applied aux power');
};
$('btn_apply_media_adjust').onclick = () => {
applyConfigToSelected('print_target', 'mediaAdjust', () => parseInt($('media_adjust').value), 'Applied media adjust');
};
$('btn_apply_pitch').onclick = () => {
applyConfigToSelected('print_target', 'pitch', () => parseInt($('pitch').value), 'Applied pitch');
};
$('btn_apply_language').onclick = () => {
applyConfigToSelected('print_target', 'language', () => document.querySelector('input[name="lang"]:checked').value, 'Applied language');
};
$('btn_apply_thermal_mode').onclick = () => {
applyConfigToSelected('print_target', 'thermalMode', () => document.querySelector('input[name="tm"]:checked').value, 'Applied thermal mode');
};
$('btn_refresh_printer_settings').onclick = () => {
announce('Refreshing printer settings...');
log(2, 'Refreshing printer settings...');
};
$('btn_print_test_label').onclick = () => {
announce('Printing test label...');
log(2, 'Printing test label on selected printer(s)...');
};
$('btn_calibrate_sensor').onclick = () => {
announce('Calibrating sensor...');
log(2, 'Calibrating sensor...');
};
$('btn_refresh_positioning').onclick = () => {
announce('Refreshing positioning settings...');
log(2, 'Refreshing positioning settings...');
};
$('btn_pos_test_label').onclick = () => {
announce('Printing position test label...');
log(2, 'Printing position test label');
};
const applyPresEnable = $('btn_apply_pres_enable');
if (applyPresEnable) applyPresEnable.onclick = () => {
announce('Label presentation ' + ($('present_enable').checked ? 'enabled' : 'disabled'));
log(2, 'Label presentation setting applied');
};
const applyAdvance = $('btn_apply_advance');
if (applyAdvance) applyAdvance.onclick = () => {
announce('Advance distance set to ' + $('present_advance').value);
log(2, 'Advance distance applied: ' + $('present_advance').value);
};
const applyRetract = $('btn_apply_retract');
if (applyRetract) applyRetract.onclick = () => {
announce('Retract distance set to ' + $('present_retract').value);
log(2, 'Retract distance applied: ' + $('present_retract').value);
};
const applyPresentTime = $('btn_apply_present_time');
if (applyPresentTime) applyPresentTime.onclick = () => {
announce('Presentation time set to ' + $('present_time').value + 'ms');
log(2, 'Presentation time applied: ' + $('present_time').value + 'ms');
};
$('btn_load_objects').onclick = () => {
const tb = $('obj_table').querySelector('tbody');
tb.innerHTML = '';
for (let i = 0; i < 10; i++) {
const tr = document.createElement('tr');
tr.innerHTML = `<td>CP${10 + i}</td><td>Font</td><td>Flash</td><td>900</td><td>CodePage ${850 + i}</td>`;
tb.appendChild(tr);
}
announce('Objects loaded from printer');
log(2, 'Objects loaded from printer');
};
$('btn_send_objects').onclick = () => {
announce('Sending objects to selected printer(s)');
log(2, 'Sending objects to selected printer(s)');
};
$('btn_delete_objects').onclick = () => {
announce('Selected objects deleted');
log(2, 'Selected objects deleted');
};
$('btn_get_profile').onclick = () => {
$('prof_txt').value = '!! 0 0 0 0\n! 0 0 0 0\nVARIABLE DARKNESS 100\nVARIABLE WIDTH 812\nVARIABLE PRINT_SPEED 4\nVARIABLE INDEX ON\nVARIABLE FEED_TYPE GAP\n';
announce('Profile retrieved from printer');
log(2, 'Profile retrieved from printer');
};
$('btn_apply_profile').onclick = () => {
announce('Profile applied to selected printer(s)');
log(2, 'Profile applied to selected printer(s)');
};
$('btn_save_profile').onclick = () => {
const blob = new Blob([$('prof_txt').value], {type: 'text/plain'});
const url = URL.createObjectURL(blob);
const a = document.createElement('a');
a.href = url;
a.download = 'printer_profile.txt';
a.click();
URL.revokeObjectURL(url);
announce('Profile saved to file');
log(2, 'Profile saved to file');
};
$('btn_load_profile_file').onclick = () => {
announce('Load profile from file');
log(2, 'Load profile from file');
};
$('btn_refresh_firmware').onclick = () => {
$('fw_part').textContent = '195-170-409';
$('fw_ver').textContent = 'V4.09$';
$('fw_date').textContent = 'Jan 15 2020 15:00:00';
announce('Firmware info refreshed');
log(2, 'Firmware info refreshed');
};
$('btn_browse_firmware').onclick = () => {
$('fw_file').value = 'firmware_v4.10.bin';
announce('Firmware file selected');
log(2, 'Firmware file selected');
};
$('btn_update_firmware').onclick = () => {
announce('Firmware upgrade started');
log(2, 'Firmware upgrade started');
let w = 0;
const b = $('fw_prog');
const interval = setInterval(() => {
w += 1;
b.style.width = w + '%';
if (w >= 100) {
clearInterval(interval);
announce('Firmware upgrade completed');
log(2, 'Firmware upgrade completed');
}
}, 30);
State.activeIntervals.push(interval);
};
$('btn_load_cpr').onclick = () => {
announce('Load CPR file');
log(2, 'CPR file loaded');
};
$('btn_save_cpr').onclick = () => {
announce('Save CPR file');
log(2, 'CPR file saved');
};
$('btn_apply_pcl_window').onclick = () => {
const x = $('pcl_origin_x').value;
const y = $('pcl_origin_y').value;
const w = $('pcl_width').value;
const l = $('pcl_length').value;
$('pjl_commands').value = `@PJL SET LPARM:CPL LABEL ORIGIN X = ${x}\n@PJL SET LPARM:CPL LABEL ORIGIN Y = ${y}\n@PJL SET LPARM:CPL LABEL WIDTH = ${w}\n@PJL SET LPARM:CPL LABEL LENGTH = ${l}`;
announce('PCL window parameters applied');
log(2, `PCL window: X=${x}, Y=${y}, W=${w}, L=${l}`);
};
$('btn_refresh_pcl_window').onclick = () => {
announce('Refreshing PCL window parameters from printer');
log(2, 'Refreshing PCL window parameters');
};
$('btn_load_pjl').onclick = () => {
announce('Load PJL file');
log(2, 'Loading PJL file');
};
$('btn_save_pjl').onclick = () => {
const blob = new Blob([$('pjl_commands').value], {type: 'text/plain'});
const url = URL.createObjectURL(blob);
const a = document.createElement('a');
a.href = url;
a.download = 'pjl_commands.pjl';
a.click();
URL.revokeObjectURL(url);
announce('PJL file saved');
log(2, 'PJL file saved');
};
$('btn_send_pjl').onclick = () => {
announce('Sending PJL commands to printer');
log(2, 'Sending PJL commands: ' + $('pjl_commands').value.split('\n')[0] + '...');
};
$('btn_browse_pcl').onclick = () => {
$('pcl_file').value = 'sample_label.pcl';
announce('PCL file selected');
log(2, 'PCL file selected');
};
$('btn_send_pcl').onclick = () => {
announce('Sending PCL file to printer');
log(2, 'Sending PCL file to printer');
};
$('btn_scan_barcode').onclick = () => {
announce('Scan barcode for model number');
log(2, 'Scanning barcode for model number');
};
$('btn_print_serial_label').onclick = () => {
announce('Printing serial number label');
log(2, 'Printing serial number label');
};
$('btn_print_box_label').onclick = () => {
announce('Printing box label');
log(2, 'Printing box label');
};
$('btn_start_test').onclick = () => {
announce('Manufacturing test sequence started');
log(2, 'Manufacturing test sequence started');
MfgTest.start();
};
$('btn_run_next').onclick = () => {
MfgTest.runNext();
};
$('btn_rerun_test').onclick = () => {
announce('Test sequence reset');
log(2, 'Test sequence reset');
MfgTest.reset();
};
$('btn_stop_test').onclick = () => {
MfgTest.abort();
announce('Test sequence aborted');
log(3, 'Test sequence aborted');
};
$('btn_enable_pcl').onclick = () => {
announce('Enabling PCL mode on printer...');
log(2, 'Enabling PCL mode');
MfgTest.enablePCL();
};
$('btn_insert_template').onclick = () => {
announce('Insert CPL template');
log(2, 'Insert CPL template');
};
$('btn_send_script').onclick = () => {
const script = $('cpl_in').value;
$('cpl_out').value += '\n[SENT TO PRINTER(S)]\n' + script + '\n';
announce('Script sent to printer(s)');
log(2, 'Script sent to printer(s)');
};
$('btn_save_script').onclick = () => {
const blob = new Blob([$('cpl_in').value], {type: 'text/plain'});
const url = URL.createObjectURL(blob);
const a = document.createElement('a');
a.href = url;
a.download = 'cpl_script.txt';
a.click();
URL.revokeObjectURL(url);
announce('Script saved');
log(2, 'Script saved');
};
$('btn_load_script').onclick = () => {
announce('Load script');
log(2, 'Script loaded');
};
$('btn_clear_script').onclick = () => {
$('cpl_in').value = '';
announce('Script cleared');
};
$('btn_view_variables').onclick = () => {
$('cpl_out').value += '\n[VARIABLE DUMP]\nDARKNESS 100\nWIDTH 812\nPRINT_SPEED 4\n';
announce('Variables displayed');
log(2, 'Variables requested');
};
$('btn_view_status').onclick = () => {
$('cpl_out').value += '\n[STATUS]\nReady\nPaper Loaded\nHead Closed\n';
announce('Status displayed');
log(2, 'Status requested');
};
$('btn_clear_output').onclick = () => {
$('cpl_out').value = '';
announce('Output cleared');
};
let timerState = { interval: null, count: 0, paused: false };
$('btn_timer_start').onclick = () => {
const intervalSecs = parseInt($('timer_interval').value) || 5;
const repeat = parseInt($('timer_repeat').value) || 1;
timerState.count = 0;
timerState.paused = false;
$('btn_timer_start').disabled = true;
$('btn_timer_pause').disabled = false;
$('btn_timer_resume').disabled = true;
$('btn_timer_stop').disabled = false;
$('timer_current').textContent = `0 / ${repeat}`;
timerState.interval = setInterval(() => {
if (!timerState.paused) {
timerState.count++;
$('timer_current').textContent = `${timerState.count} / ${repeat}`;
const script = $('cpl_in').value;
$('cpl_out').value += `\n[TIMER ${timerState.count}/${repeat}]\n${script}\n`;
log(2, `Timer sent script (${timerState.count}/${repeat})`);
if (timerState.count >= repeat) {
clearInterval(timerState.interval);
$('btn_timer_start').disabled = false;
$('btn_timer_pause').disabled = true;
$('btn_timer_resume').disabled = true;
$('btn_timer_stop').disabled = true;
announce('Timer completed');
}
}
}, intervalSecs * 1000);
State.activeIntervals.push(timerState.interval);
announce(`Timer started: ${repeat} times every ${intervalSecs}s`);
log(2, `Timer started: ${repeat} repetitions at ${intervalSecs}s interval`);
};
$('btn_timer_pause').onclick = () => {
timerState.paused = true;
$('btn_timer_pause').disabled = true;
$('btn_timer_resume').disabled = false;
announce('Timer paused');
log(2, 'Timer paused');
};
$('btn_timer_resume').onclick = () => {
timerState.paused = false;
$('btn_timer_pause').disabled = false;
$('btn_timer_resume').disabled = true;
announce('Timer resumed');
log(2, 'Timer resumed');
};
$('btn_timer_stop').onclick = () => {
clearInterval(timerState.interval);
const idx = State.activeIntervals.indexOf(timerState.interval);
if (idx > -1) State.activeIntervals.splice(idx, 1);
$('btn_timer_start').disabled = false;
$('btn_timer_pause').disabled = true;
$('btn_timer_resume').disabled = true;
$('btn_timer_stop').disabled = true;
announce('Timer stopped');
log(2, 'Timer stopped');
};
$('log_level').onchange = () => {
State.logLevel = parseInt($('log_level').value);
updateDebugConsole();
};
$('log_search').oninput = updateDebugConsole;
$('btn_clear_logs').onclick = () => {
State.logMessages = [];
updateDebugConsole();
announce('Debug console cleared');
log(2, 'Debug console cleared');
};
$('btn_export_logs').onclick = () => {
let logText = '';
State.logMessages.forEach(entry => {
let levelText = 'INFO';
if (entry.level === 1) levelText = 'TRACE';
else if (entry.level === 3) levelText = 'WARN';
else if (entry.level === 4) levelText = 'ERROR';
else if (entry.level === 5) levelText = 'EXCPT';
logText += `[${entry.timestamp}] [${levelText}] ${entry.message}\n`;
});
const blob = new Blob([logText], {type: 'text/plain'});
const url = URL.createObjectURL(blob);
const a = document.createElement('a');
a.href = url;
a.download = `debug_log_${new Date().toISOString().replace(/[:.]/g, '-')}.txt`;
a.click();
URL.revokeObjectURL(url);
announce('Logs exported to file');
log(2, 'Logs exported to file');
};
$('cpl_search').oninput = searchCPL;
document.querySelectorAll('#cpl a[data-category]').forEach(link => {
link.onclick = () => {
document.querySelectorAll('#cpl a[data-category]').forEach(l => l.classList.remove('active'));
link.classList.add('active');
const cat = link.dataset.category;
filterCPL(cat);
};
link.onkeydown = (e) => {
if (e.key === 'Enter' || e.key === ' ') {
e.preventDefault();
document.querySelectorAll('#cpl a[data-category]').forEach(l => l.classList.remove('active'));
link.classList.add('active');
const cat = link.dataset.category;
filterCPL(cat);
}
};
});
$('btn_add_text').onclick = () => {
$('dlg_text_value').value = 'Sample Text';
$('dlg_text_x').value = 50 + State.labelElements.length * 20;
$('dlg_text_y').value = 50 + State.labelElements.length * 15;
$('dlg_add_text').showModal();
};
$('dlg_add_text').onclose = function() {
if (this.returnValue === 'ok') {
const elem = {
type: 'text',
x: parseInt($('dlg_text_x').value) || 50,
y: parseInt($('dlg_text_y').value) || 50,
width: 100,
height: 30,
text: $('dlg_text_value').value || 'Sample Text',
font: $('dlg_text_font').value || 'TEXT 3',
barcodeType: '',
thickness: 2,
radius: 0,
zIndex: State.labelElements.length
};
State.labelElements.push(elem);
State.selectedElement = elem;
renderCanvas();
updateProperties();
announce('Added text element to canvas');
log(1, 'Added text element: ' + elem.text);
}
};
$('btn_add_barcode').onclick = () => {
$('dlg_bc_data').value = '12345678';
$('dlg_bc_x').value = 50 + State.labelElements.length * 20;
$('dlg_bc_y').value = 100 + State.labelElements.length * 15;
$('dlg_add_barcode').showModal();
};
$('dlg_add_barcode').onclose = function() {
if (this.returnValue === 'ok') {
const bcType = $('dlg_bc_type').value;
const is2D = ['QR', 'DATAMATRIX', 'PDF417'].includes(bcType);
const elem = {
type: 'barcode',
x: parseInt($('dlg_bc_x').value) || 50,
y: parseInt($('dlg_bc_y').value) || 100,
width: is2D ? 80 : 150,
height: is2D ? 80 : parseInt($('dlg_bc_height').value) || 50,
text: $('dlg_bc_data').value || '12345678',
font: '',
barcodeType: bcType,
narrowBar: parseInt($('dlg_bc_narrow').value) || 2,
thickness: 2,
radius: 0,
zIndex: State.labelElements.length
};
State.labelElements.push(elem);
State.selectedElement = elem;
renderCanvas();
updateProperties();
announce('Added barcode element to canvas');
log(1, 'Added barcode: ' + bcType + ' = ' + elem.text);
}
};
$('btn_add_box').onclick = () => addLabelElement('box');
$('btn_add_line').onclick = () => addLabelElement('line');
$('btn_add_circle').onclick = () => addLabelElement('circle');
$('btn_add_ellipse').onclick = () => addLabelElement('ellipse');
$('btn_clear_canvas').onclick = clearCanvas;
$('btn_generate_cpl').onclick = generateCPL;
$('btn_send_label').onclick = () => {
generateCPL();
announce('Label sent to selected printer');
log(2, 'Label sent to selected printer');
};
$('btn_save_label').onclick = () => {
announce('Save label');
log(2, 'Label saved');
};
$('btn_load_label').onclick = () => {
announce('Load label');
log(2, 'Label loaded');
};
const canvas = $('canvas_el');
canvas.onmousedown = (e) => {
hideContextMenu();
const rect = canvas.getBoundingClientRect();
const x = e.clientX - rect.left;
const y = e.clientY - rect.top;
if (State.selectedElement) {
const handle = getResizeHandle(State.selectedElement, x, y);
if (handle) {
canvasDragState.resizing = true;
canvasDragState.resizeHandle = handle;
canvasDragState.startX = x;
canvasDragState.startY = y;
canvasDragState.origX = State.selectedElement.x;
canvasDragState.origY = State.selectedElement.y;
canvasDragState.origW = State.selectedElement.width || State.selectedElement.radius * 2;
canvasDragState.origH = State.selectedElement.height || State.selectedElement.radius * 2;
return;
}
}
const elem = getElementAtPoint(x, y);
State.selectedElement = elem;
renderCanvas();
updateProperties();
if (elem) {
canvasDragState.dragging = true;
canvasDragState.startX = x;
canvasDragState.startY = y;
canvasDragState.origX = elem.x;
canvasDragState.origY = elem.y;
}
};
canvas.onmousemove = (e) => {
const rect = canvas.getBoundingClientRect();
const x = e.clientX - rect.left;
const y = e.clientY - rect.top;
if (State.selectedElement && getResizeHandle(State.selectedElement, x, y)) {
canvas.style.cursor = 'nwse-resize';
} else if (getElementAtPoint(x, y)) {
canvas.style.cursor = 'move';
} else {
canvas.style.cursor = 'default';
}
if (canvasDragState.dragging && State.selectedElement) {
const dx = x - canvasDragState.startX;
const dy = y - canvasDragState.startY;
State.selectedElement.x = Math.max(0, canvasDragState.origX + dx);
State.selectedElement.y = Math.max(0, canvasDragState.origY + dy);
renderCanvas();
updateProperties();
}
if (canvasDragState.resizing && State.selectedElement) {
const dx = x - canvasDragState.startX;
const dy = y - canvasDragState.startY;
const handle = canvasDragState.resizeHandle;
const elem = State.selectedElement;
if (elem.type === 'circle') {
const newRadius = Math.max(10, (canvasDragState.origW / 2) + (dx + dy) / 2);
elem.radius = newRadius;
} else {
if (handle.includes('e')) elem.width = Math.max(20, canvasDragState.origW + dx);
if (handle.includes('w')) {
elem.x = canvasDragState.origX + dx;
elem.width = Math.max(20, canvasDragState.origW - dx);
}
if (handle.includes('s')) elem.height = Math.max(10, canvasDragState.origH + dy);
if (handle.includes('n')) {
elem.y = canvasDragState.origY + dy;
elem.height = Math.max(10, canvasDragState.origH - dy);
}
}
renderCanvas();
updateProperties();
}
};
canvas.onmouseup = () => {
canvasDragState.dragging = false;
canvasDragState.resizing = false;
};
canvas.onmouseleave = () => {
canvasDragState.dragging = false;
canvasDragState.resizing = false;
};
canvas.onwheel = (e) => {
if (State.selectedElement) {
e.preventDefault();
const delta = e.deltaY > 0 ? -5 : 5;
const elem = State.selectedElement;
if (elem.type === 'circle') {
elem.radius = Math.max(10, elem.radius + delta);
} else if (elem.type !== 'line') {
elem.width = Math.max(20, elem.width + delta);
elem.height = Math.max(10, elem.height + delta * (elem.height / elem.width || 1));
}
renderCanvas();
updateProperties();
}
};
canvas.oncontextmenu = (e) => {
e.preventDefault();
const rect = canvas.getBoundingClientRect();
const x = e.clientX - rect.left;
const y = e.clientY - rect.top;
const elem = getElementAtPoint(x, y);
if (elem) {
State.selectedElement = elem;
renderCanvas();
updateProperties();
showContextMenu(e.clientX, e.clientY);
} else {
hideContextMenu();
}
};
document.addEventListener('click', (e) => {
if (!e.target.closest('#canvas_context_menu')) {
hideContextMenu();
}
});
$('btn_extract_image').onclick = () => {
announce('Image extraction started');
log(2, 'Image extraction started');
const prog = $('img_prog');
let w = 0;
const interval = setInterval(() => {
w += 2;
prog.style.width = w + '%';
if (w >= 100) {
clearInterval(interval);
const idx = State.activeIntervals.indexOf(interval);
if (idx > -1) State.activeIntervals.splice(idx, 1);
$('img_data').value = '00400000: 4E 71 4E 71 FF FF 01 02 03 04 05 06 07 08\n00400010: 10 11 12 13 14 15 16 17 18 19 1A 1B 1C 1D\n00400020: A5 B6 C7 D8 E9 FA 0B 1C 2D 3E 4F 5A 6B 7C\n...';
announce('Image extraction completed');
log(2, 'Image extraction completed');
}
}, 30);
State.activeIntervals.push(interval);
};
$('btn_save_image').onclick = () => {
announce('Image saved: printer_image.bin');
log(2, 'Image saved: printer_image.bin');
};
$('btn_load_image_file').onclick = () => {
$('img_file').value = 'printer_image.bin';
announce('Image file loaded');
log(2, 'Image file loaded');
};
$('btn_deploy_image').onclick = () => {
if (!confirm('This will overwrite all data on target printer(s). Continue?')) return;
announce('Image deployment started - WARNING: This will overwrite all data');
log(3, 'Image deployment started - WARNING: This will overwrite all data');
const prog = $('deploy_prog');
let w = 0;
const interval = setInterval(() => {
w += 1;
prog.style.width = w + '%';
if (w >= 100) {
clearInterval(interval);
const idx = State.activeIntervals.indexOf(interval);
if (idx > -1) State.activeIntervals.splice(idx, 1);
announce('Image deployed successfully. Reset printer(s).');
log(2, 'Image deployed successfully');
}
}, 40);
State.activeIntervals.push(interval);
};
$('btn_verify_image').onclick = () => {
announce('Image verification: PASS - Checksums match');
log(2, 'Image verification: PASS');
};
$('btn_enter_bootloader').onclick = () => {
$('bootloader_status').innerHTML = '<div style="color:#008000;"> Bootloader command sent</div><div style="font-size:8px; margin-top:5px;">Printer in recovery mode.</div>';
announce('Bootloader command sent');
log(2, 'Bootloader command sent');
};
$('btn_check_bootloader').onclick = () => {
$('bootloader_status').innerHTML = '<div style="color:var(--text-secondary);">Checking...</div>';
announce('Checking bootloader status...');
log(2, 'Checking bootloader status...');
setTimeout(() => {
$('bootloader_status').innerHTML = '<div style="color:#008000;"> Bootloader Active</div><div style="font-size:8px;">Version: v2.4.1<br>Ready for upload</div>';
announce('Bootloader active - version v2.4.1');
log(2, 'Bootloader active - version v2.4.1');
}, 500);
};
$('btn_send_bootloader_cmd').onclick = () => {
const cmd = prompt('Enter bootloader command:');
if (cmd) {
$('bootloader_status').innerHTML += `<div style="margin-top:5px;">Sent: ${escapeHtml(cmd)}</div>`;
announce(`Bootloader command sent: ${cmd}`);
log(2, `Bootloader command sent: ${cmd}`);
}
};
$('theme_selector').onchange = function() {
applyTheme(this.value);
};
$('layout_selector').onchange = function() {
applyLayout(this.value);
};
$('chk_borders').onchange = function() {
applyBorders(this.checked);
};
setupAutoTestHandlers();
$('status_box').onclick = toggleStatusMenu;
$('status_box').onkeydown = (e) => {
if (e.key === 'Enter' || e.key === ' ') {
e.preventDefault();
toggleStatusMenu(e);
}
};
const statusMenuItems = $('status_menu').querySelectorAll('.status-menu-item');
statusMenuItems[0].onclick = (e) => { e.stopPropagation(); connectAllPrinters(); };
statusMenuItems[1].onclick = (e) => { e.stopPropagation(); disconnectAllPrinters(); };
statusMenuItems[2].onclick = (e) => { e.stopPropagation(); connectSelectedPrinters(); };
statusMenuItems[3].onclick = (e) => { e.stopPropagation(); disconnectSelectedPrinters(); };
$('chk_heart').onchange = function() {
if (this.checked) {
State.heartbeatInterval = setInterval(() => {
log(1, 'Heartbeat: Checking printer status...');
updatePrinterStatus();
}, 5000);
announce('Heartbeat monitoring enabled');
log(2, 'Heartbeat monitoring enabled (5 sec interval)');
} else {
if (State.heartbeatInterval) {
clearInterval(State.heartbeatInterval);
State.heartbeatInterval = null;
}
announce('Heartbeat monitoring disabled');
log(2, 'Heartbeat monitoring disabled');
}
};
['print_target', 'pos_target', 'fonts_target', 'prof_target', 'firm_target', 'img_src', 'img_target', 'script_target', 'pcl_target'].forEach(id => {
const elem = $(id);
if (elem) {
elem.onclick = () => toggleMultiSelect(id);
elem.onkeydown = (e) => {
if (e.key === 'Enter' || e.key === ' ') {
e.preventDefault();
toggleMultiSelect(id);
}
};
}
});
document.addEventListener('click', (e) => {
if (!e.target.closest('.multi-select-dropdown')) {
document.querySelectorAll('.multi-select-options').forEach(opt => {
opt.classList.remove('visible');
});
}
if (!e.target.closest('.status-box')) {
$('status_menu').classList.remove('visible');
}
});
}
function toggleStatusMenu(e) {
e.stopPropagation();
const menu = $('status_menu');
menu.classList.toggle('visible');
}
function applyRole(role) {
State.currentRole = role;
document.body.dataset.role = role;
const roleInfo = ROLES[role];
$('app_subtitle').textContent = roleInfo.subtitle;
document.title = `Cognitive LLC - ${roleInfo.subtitle}`;
renderTabs();
if (role === 'server') {
document.querySelectorAll('.workspace').forEach(e => {
e.classList.remove('visible');
e.setAttribute('aria-hidden', 'true');
});
$('server_dashboard').classList.add('visible');
$('server_dashboard').setAttribute('aria-hidden', 'false');
startServerDashboard();
} else {
stopServerDashboard();
$('server_dashboard').classList.remove('visible');
nav(roleInfo.tabs[0] || 'conn');
}
saveState();
announce(`Role changed to ${roleInfo.name}`);
log(2, `Role changed to: ${roleInfo.name}`);
}
function startServerDashboard() {
if (State.serverDashboardInterval) return;
State.serverUptime = Math.floor(Math.random() * 86400 * 30);
State.networkData = Array(20).fill(0).map(() => Math.random() * 100);
updateServerDashboard();
State.serverDashboardInterval = setInterval(updateServerDashboard, 2000);
State.activeIntervals.push(State.serverDashboardInterval);
}
function stopServerDashboard() {
if (State.serverDashboardInterval) {
clearInterval(State.serverDashboardInterval);
const idx = State.activeIntervals.indexOf(State.serverDashboardInterval);
if (idx > -1) State.activeIntervals.splice(idx, 1);
State.serverDashboardInterval = null;
}
}
function updateServerDashboard() {
State.serverUptime += 2;
const days = Math.floor(State.serverUptime / 86400);
const hours = Math.floor((State.serverUptime % 86400) / 3600);
$('stat_uptime').textContent = `${days}d ${hours}h`;
$('stat_jobs_today').textContent = Math.floor(Math.random() * 500 + 200);
$('stat_response').textContent = Math.floor(Math.random() * 50 + 10) + 'ms';
$('stat_success').textContent = (95 + Math.random() * 5).toFixed(1) + '%';
const cpu = Math.random() * 60 + 20;
const mem = Math.random() * 40 + 40;
const disk = Math.random() * 20 + 50;
$('gauge_cpu').setAttribute('stroke-dasharray', `${cpu}, 100`);
$('gauge_cpu_text').textContent = Math.floor(cpu) + '%';
$('gauge_mem').setAttribute('stroke-dasharray', `${mem}, 100`);
$('gauge_mem_text').textContent = Math.floor(mem) + '%';
$('gauge_disk').setAttribute('stroke-dasharray', `${disk}, 100`);
$('gauge_disk_text').textContent = Math.floor(disk) + '%';
State.networkData.shift();
State.networkData.push(Math.random() * 100);
const netChart = $('network_chart');
netChart.innerHTML = '';
const barWidth = netChart.offsetWidth / 20;
State.networkData.forEach((val, i) => {
const bar = document.createElement('div');
bar.className = 'chart-bar';
bar.style.left = (i * barWidth + 2) + 'px';
bar.style.height = val + '%';
bar.style.width = Math.max(barWidth - 4, 4) + 'px';
netChart.appendChild(bar);
});
$('net_in').textContent = Math.floor(Math.random() * 500 + 100);
$('net_out').textContent = Math.floor(Math.random() * 300 + 50);
const printerGrid = $('server_printer_grid');
const connectedCount = Math.floor(Math.random() * 15 + 5);
$('printer_count').textContent = connectedCount;
printerGrid.innerHTML = '';
for (let i = 0; i < connectedCount; i++) {
const status = Math.random() > 0.2 ? 'healthy' : (Math.random() > 0.5 ? 'warning' : 'critical');
const tile = document.createElement('div');
tile.className = 'printer-tile';
tile.innerHTML = `<div class="printer-tile-icon"></div><span class="status-indicator status-${status}"></span>P${i+1}`;
printerGrid.appendChild(tile);
}
const jobsChart = $('jobs_chart');
const complete = Math.floor(Math.random() * 200 + 100);
const pending = Math.floor(Math.random() * 30 + 5);
const failed = Math.floor(Math.random() * 5);
$('jobs_complete').textContent = complete;
$('jobs_pending').textContent = pending;
$('jobs_failed').textContent = failed;
const total = complete + pending + failed;
jobsChart.innerHTML = `<div style="display:flex;height:100%;align-items:flex-end;justify-content:space-around;padding:10px;">
<div style="width:30%;background:var(--status-green);height:${complete/total*100}%;border-radius:3px 3px 0 0;"></div>
<div style="width:30%;background:#f0ad4e;height:${pending/total*100}%;border-radius:3px 3px 0 0;"></div>
<div style="width:30%;background:var(--status-red);height:${Math.max(failed/total*100, 5)}%;border-radius:3px 3px 0 0;"></div>
</div>`;
const openTickets = Math.floor(Math.random() * 20 + 5);
const closedTickets = Math.floor(Math.random() * 100 + 50);
$('tickets_open').textContent = openTickets;
$('tickets_closed').textContent = closedTickets;
const ticketList = $('ticket_list');
ticketList.innerHTML = '';
const priorities = ['high', 'medium', 'low'];
const ticketTitles = ['Printer offline', 'Paper jam', 'Config issue', 'Network error', 'Firmware update', 'Calibration needed'];
for (let i = 0; i < 5; i++) {
const priority = priorities[Math.floor(Math.random() * 3)];
const title = ticketTitles[Math.floor(Math.random() * ticketTitles.length)];
const item = document.createElement('div');
item.className = `ticket-item ticket-priority-${priority}`;
item.innerHTML = `<span>#${1000 + i}: ${title}</span><span style="text-transform:uppercase;font-size:8px;">${priority}</span>`;
ticketList.appendChild(item);
}
const errorRate = Math.random() * 3;
const errorStatus = $('error_status');
errorStatus.className = 'status-indicator ' + (errorRate < 1 ? 'status-healthy' : (errorRate < 2 ? 'status-warning' : 'status-critical'));
$('error_rate_text').textContent = errorRate.toFixed(2) + '% error rate';
const errorChart = $('error_chart');
errorChart.innerHTML = `<div style="display:flex;flex-direction:column;height:100%;justify-content:space-around;padding:5px;">`;
for (let h = 0; h < 6; h++) {
const hourRate = Math.random() * 3;
const color = hourRate < 1 ? 'var(--status-green)' : (hourRate < 2 ? '#f0ad4e' : 'var(--status-red)');
errorChart.innerHTML += `<div style="display:flex;align-items:center;gap:5px;font-size:9px;"><span style="width:40px;">${(h*4)}:00</span><div style="flex:1;height:8px;background:var(--border-light);border-radius:4px;"><div style="width:${hourRate/3*100}%;height:100%;background:${color};border-radius:4px;"></div></div></div>`;
}
errorChart.innerHTML += '</div>';
const logFeed = $('server_log');
const logMessages = [
'[INFO] Print job #4521 completed successfully',
'[INFO] Printer P3 connected',
'[DEBUG] Heartbeat received from P7',
'[WARN] Low paper on Printer P12',
'[INFO] Configuration backup created',
'[DEBUG] Network latency: 23ms',
'[INFO] User admin logged in',
'[ERROR] Connection timeout on P5'
];
const timestamp = new Date().toISOString().substring(11, 19);
const msg = logMessages[Math.floor(Math.random() * logMessages.length)];
const entry = document.createElement('div');
entry.className = 'log-entry';
entry.textContent = `[${timestamp}] ${msg}`;
logFeed.appendChild(entry);
if (logFeed.children.length > 50) logFeed.removeChild(logFeed.firstChild);
logFeed.scrollTop = logFeed.scrollHeight;
}
function updateWifiPanelVisibility() {
const connType = document.querySelector('input[name="ct"]:checked');
const wifiPanel = $('wifi_panel');
if (wifiPanel) {
if (connType && connType.value === 'net') {
wifiPanel.classList.remove('hidden');
wifiPanel.style.display = '';
} else {
wifiPanel.classList.add('hidden');
wifiPanel.style.display = 'none';
}
}
}
function init() {
log(2, 'Application initializing...');
const stateLoaded = loadState();
if (!stateLoaded || State.printers.length === 0) {
for (let i = 0; i < 3; i++) {
addPrinter();
}
}
const savedRole = localStorage.getItem('cognitivetpg_role') || 'admin';
State.currentRole = savedRole;
$('role_selector').value = savedRole;
document.body.dataset.role = savedRole;
renderTabs();
initMultiSelects();
updatePrinterList();
updatePrinterDropdowns();
updatePrinterStatus();
filterCPL('all');
const allCmdLink = document.querySelector('#cpl a[data-category="all"]');
if (allCmdLink) allCmdLink.classList.add('active');
setupEventHandlers();
renderCanvas();
updateWifiPanelVisibility();
applyRole(savedRole);
const tabFolder = $('tab-bar');
if (tabFolder) {
tabFolder.addEventListener('wheel', function(e) {
if (e.deltaY !== 0) {
e.preventDefault();
this.scrollLeft += e.deltaY * 2;
}
}, { passive: false });
}
function maintainAspectRatio() {
const wrapper = document.querySelector('.app-wrapper');
if (wrapper) {
const viewportMin = Math.min(window.innerWidth, window.innerHeight);
const size = Math.min(viewportMin * 0.88, viewportMin * 0.88);
document.documentElement.style.setProperty('--container-size', `${size}px`);
}
}
maintainAspectRatio();
window.addEventListener('resize', maintainAspectRatio);
log(2, 'Application initialized successfully');
announce('Application ready');
}
window.CAdmin = {
init: init,
renderTabs: renderTabs,
nav: nav,
applyTheme: applyTheme,
applyLayout: applyLayout,
applyBorders: applyBorders,
applyRole: applyRole,
addPrinter: addPrinter,
updatePrinterList: updatePrinterList,
log: log,
AutoTest: AutoTest,
runAutoTests: () => AutoTest.runAllTests(),
stopAutoTests: () => AutoTest.stop()
};
if (document.readyState === 'loading') {
document.addEventListener('DOMContentLoaded', init);
} else {
init();
}
window.addEventListener('beforeunload', () => {
clearIntervals();
saveState();
});
})();
</script>
</body>
</html>
)HTMLRAW";
std::string getShowcaseHTML() {
CADMIN_LOG_DEBUG("getShowcaseHTML() - Starting...");
if (EMBEDDED_SHOWCASE_HTML_SIZE > 0) {
try {
std::vector<uint8_t> compressed(EMBEDDED_SHOWCASE_HTML_DATA,
EMBEDDED_SHOWCASE_HTML_DATA + EMBEDDED_SHOWCASE_HTML_SIZE);
auto decompressed = Utilities::Compression::decompress(compressed);
CADMIN_LOG_DEBUG("getShowcaseHTML() - Using embedded data");
return std::string(decompressed.begin(), decompressed.end());
} catch (...) {
CADMIN_LOG_DEBUG("getShowcaseHTML() - Embedded data decompression failed");
}
}
std::string exePath;
#ifdef _WIN32
char buffer[MAX_PATH];
DWORD len = GetModuleFileNameA(NULL, buffer, MAX_PATH);
if (len > 0) {
exePath = buffer;
size_t lastSlash = exePath.find_last_of("\\/");
if (lastSlash != std::string::npos) {
exePath = exePath.substr(0, lastSlash);
}
CADMIN_LOG_DEBUG("getShowcaseHTML() - Executable path: " << exePath);
}
#endif
std::vector<std::string> paths = {
exePath + "/../../../Showcase.html",
exePath + "/../../../../Showcase.html",
exePath + "/../../Showcase.html",
exePath + "/../Showcase.html",
exePath + "/Showcase.html",
"Showcase.html",
"../Showcase.html",
"../../Showcase.html",
"../../../Showcase.html",
"../../../../Showcase.html",
"../../../../../Showcase.html",
"C:/Users/Mike/Downloads/CAdmin-Gemini-3/CAdminSeed/Showcase.html",
};
for (const auto& path : paths) {
CADMIN_LOG_DEBUG("getShowcaseHTML() - Trying: " << path);
std::ifstream file(path, std::ios::binary);
if (file) {
std::stringstream buffer;
buffer << file.rdbuf();
std::string content = buffer.str();
CADMIN_LOG_DEBUG("getShowcaseHTML() - Found at: " << path << " (size=" << content.size() << ")");
return content;
}
}
CADMIN_LOG_WARN("getShowcaseHTML() - Could not find Showcase.html, using fallback");
return fallbackHTML;
}
std::vector<uint8_t> getShowcaseHTMLCompressed() {
std::string html = getShowcaseHTML();
std::vector<uint8_t> data(html.begin(), html.end());
return Utilities::Compression::compress(data);
}
size_t getShowcaseHTMLSize() {
return getShowcaseHTML().size();
}
}
```
## File: CAdmin/Backend/ShowcaseResource.hpp
```
#pragma once
#include <string>
namespace Cognitive::Resource {
std::string getShowcaseHTML();
}
```
## File: CAdmin/Backend/TestEngine.cpp
```cpp
#include "TestEngine.hpp"
#include "PrinterHelper.hpp"
#include "CPLParser.hpp"
#include "DeviceManager.hpp"
#include "Obfuscation.hpp"
#include <chrono>
#include <ctime>
#include <sstream>
#include <algorithm>
namespace Cognitive::Business {
TestEngine::TestEngine() = default;
TestEngine::~TestEngine() {
stop();
if (testThread_.joinable()) {
testThread_.join();
}
}
TestEngine& TestEngine::instance() {
static TestEngine inst;
return inst;
}
std::string TestEngine::getResultsJson() const {
std::ostringstream oss;
oss << "[";
bool first = true;
for (const auto& result : results_) {
if (!first) oss << ",";
first = false;
oss << "{";
oss << "\"step\":" << static_cast<int>(result.step) << ",";
oss << "\"stepName\":\"" << stepToString(result.step) << "\",";
oss << "\"status\":" << static_cast<int>(result.status) << ",";
oss << "\"statusName\":\"" << statusToString(result.status) << "\",";
oss << "\"message\":\"" << result.message << "\",";
oss << "\"duration\":" << result.duration.count();
oss << "}";
}
oss << "]";
return oss.str();
}
void TestEngine::start(const std::string& modelNumber, TestCallback callback) {
if (running_.load()) {
return;
}
testCallback_ = std::move(callback);
results_.clear();
currentStepNumber_ = 0;
aborted_.store(false);
paused_.store(false);
if (!parseModelNumber(modelNumber)) {
reportResult(TestStep::InitialSetup, TestStatus::Failed, "Failed to parse model number");
return;
}
running_.store(true);
if (testThread_.joinable()) {
testThread_.join();
}
testThread_ = std::thread(&TestEngine::runTestSequence, this);
}
void TestEngine::stop() {
aborted_.store(true);
running_.store(false);
paused_.store(false);
}
void TestEngine::pause() {
paused_.store(true);
}
void TestEngine::resume() {
paused_.store(false);
}
void TestEngine::setProgressCallback(ProgressCallback callback) {
progressCallback_ = std::move(callback);
}
void TestEngine::setProgressCallback(TestCallback callback) {
testCallback_ = std::move(callback);
}
void TestEngine::setUserPromptCallback(UserPromptCallback callback) {
promptCallback_ = std::move(callback);
}
void TestEngine::startTest(const TestConfig& config) {
if (running_.load()) {
return;
}
start("GENERIC", testCallback_);
}
void TestEngine::setSkipFlags(bool skipFirmware, bool skipFonts, bool skipCPRs) {
skipFirmware_ = skipFirmware;
skipFonts_ = skipFonts;
skipCPRs_ = skipCPRs;
}
bool TestEngine::parseModelNumber(const std::string& modelNumber) {
config_.modelNumber = modelNumber;
config_.isWingman = false;
config_.isGattaca = false;
config_.isLX = false;
config_.isBluetooth = false;
config_.isNetwork = false;
if (modelNumber.substr(0, 2) == "DB" || modelNumber.substr(0, 2) == "LB") {
return parseDLX_LXModelNumber(modelNumber);
} else if (modelNumber[0] == 'C') {
return parseCModelNumber(modelNumber);
}
return false;
}
bool TestEngine::parseDLX_LXModelNumber(const std::string& mn) {
if (mn.length() < 14) return false;
if (mn.substr(0, 2) == "DB") {
config_.productLine = ProductLine::DLX;
} else {
config_.productLine = ProductLine::LX;
config_.isLX = true;
}
char c = mn[2];
switch (c) {
case 'D': config_.printMethod = PrintMethod::DirectThermal; break;
case 'T': config_.printMethod = PrintMethod::ThermalTransfer; break;
default: return false;
}
config_.mediaWidth = mn[3] - '0';
c = mn[6];
switch (c) {
case '2': config_.printDensity = 200; break;
case '3': config_.printDensity = 300; break;
default: return false;
}
c = mn[7];
switch (c) {
case '0': config_.exitOption = ExitOption::Standard; break;
case '1': config_.exitOption = ExitOption::TearBar; break;
case '4': config_.exitOption = ExitOption::Peeler; break;
default: return false;
}
c = mn[8];
switch (c) {
case '4': config_.memRTC = MemRTC::MB4; break;
case '8':
config_.memRTC = config_.isLX ? MemRTC::MB8_RTC : MemRTC::MB8;
break;
case '9': config_.memRTC = MemRTC::MB8_RTC; break;
default: return false;
}
config_.printSpeed = mn[9] - '0';
if (config_.isLX) {
config_.isGattaca = true;
} else {
c = mn[11];
switch (c) {
case 'G': config_.isGattaca = true; break;
case '0': break;
case 'Z':
case 'M': config_.isWingman = true; break;
case 'P': config_.isPCL = true; break;
}
}
if (config_.isGattaca && mn.length() > 13) {
c = mn[13];
switch (c) {
case 'U': config_.commInterface = CommunicationInterface::USB_AB; break;
case 'E': config_.commInterface = CommunicationInterface::USB_AB_Network_Serial;
config_.isNetwork = true; break;
case 'S': config_.commInterface = CommunicationInterface::USB_AB_Serial; break;
case 'B':
case 'A': config_.commInterface = CommunicationInterface::USB_AB_Serial_Bluetooth;
config_.isBluetooth = true; break;
case 'P': config_.commInterface = CommunicationInterface::USB_AB_Parallel; break;
case 'M': config_.commInterface = CommunicationInterface::USB_AB_Serial_Parallel; break;
}
}
return true;
}
bool TestEngine::parseCModelNumber(const std::string& mn) {
if (mn.length() < 9) return false;
char c = mn[1];
switch (c) {
case 'I': config_.productLine = ProductLine::CI; break;
case 'X': config_.productLine = ProductLine::CXI; break;
default: return false;
}
c = mn[2];
switch (c) {
case 'D': config_.printMethod = PrintMethod::DirectThermal; break;
case 'T': config_.printMethod = PrintMethod::ThermalTransfer; break;
default: return false;
}
config_.mediaWidth = mn[3] - '0';
c = mn[6];
switch (c) {
case '0': config_.printDensity = 200; break;
case '3': config_.printDensity = 300; break;
default: return false;
}
config_.memRTC = MemRTC::MB8_RTC;
config_.commInterface = CommunicationInterface::All;
return true;
}
void TestEngine::runTestSequence() {
auto runStep = [this](TestStep step, std::function<TestStatus()> testFunc) {
if (aborted_.load()) return TestStatus::Aborted;
while (paused_.load() && !aborted_.load()) {
std::this_thread::sleep_for(std::chrono::milliseconds(100));
}
currentStep_ = step;
currentStepNumber_++;
reportProgress(currentStepNumber_ * 100 / totalSteps_, stepToString(step));
auto start = std::chrono::system_clock::now();
TestStatus status = testFunc();
auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(
std::chrono::system_clock::now() - start);
TestResult result{step, status, "", std::chrono::system_clock::now(), duration};
results_.push_back(result);
reportResult(step, status, statusToString(status));
return status;
};
// Run test sequence
TestStatus status;
status = runStep(TestStep::InitialSetup, [this]() { return doInitialSetup(); });
if (status == TestStatus::Failed || status == TestStatus::Aborted) goto done;
status = runStep(TestStep::FirmwareDownload, [this]() { return doFirmwareDownload(); });
if (status == TestStatus::Failed || status == TestStatus::Aborted) goto done;
status = runStep(TestStep::PrinterIdentification, [this]() { return doPrinterIdentification(); });
if (status == TestStatus::Failed || status == TestStatus::Aborted) goto done;
status = runStep(TestStep::FontDownload, [this]() { return doFontDownload(); });
if (status == TestStatus::Failed || status == TestStatus::Aborted) goto done;
status = runStep(TestStep::CPRDownload, [this]() { return doCPRDownload(); });
if (status == TestStatus::Failed || status == TestStatus::Aborted) goto done;
status = runStep(TestStep::ToneCheck, [this]() { return doToneCheck(); });
if (status == TestStatus::Failed || status == TestStatus::Aborted) goto done;
status = runStep(TestStep::RTCSetup, [this]() { return doRTCSetup(); });
if (status == TestStatus::Failed || status == TestStatus::Aborted) goto done;
status = runStep(TestStep::Calibration, [this]() { return doCalibration(); });
if (status == TestStatus::Failed || status == TestStatus::Aborted) goto done;
status = runStep(TestStep::BackupMemoryTest, [this]() { return doBackupMemoryTest(); });
if (status == TestStatus::Failed || status == TestStatus::Aborted) goto done;
status = runStep(TestStep::PrintQualityTest, [this]() { return doPrintQualityTest(); });
if (status == TestStatus::Failed || status == TestStatus::Aborted) goto done;
status = runStep(TestStep::FinalSettings, [this]() { return doFinalSettings(); });
if (status == TestStatus::Failed || status == TestStatus::Aborted) goto done;
status = runStep(TestStep::SelfTest, [this]() { return doSelfTest(); });
done:
running_.store(false);
reportProgress(100, "Test sequence complete");
}
TestStatus TestEngine::doInitialSetup() {
if (!establishConnection()) {
return TestStatus::Failed;
}
PrinterHelper::send(OBF("!SET OEMMODELID 0"));
PrinterHelper::send(OBF("!SET OEMIDENTIFIER COGNITIVE"));
PrinterHelper::send(PrinterHelper::variableReset());
return TestStatus::Passed;
}
TestStatus TestEngine::doFirmwareDownload(bool askUser) {
if (skipFirmware_) {
return TestStatus::Skipped;
}
std::string currentFW = PrinterHelper::getFirmwareVersion();
if (currentFW.empty()) {
return TestStatus::Failed;
}
config_.firmwareVersion = currentFW;
return TestStatus::Passed;
}
TestStatus TestEngine::doPrinterIdentification(bool getNewId) {
config_.serialNumber = PrinterHelper::getSerialNumber();
if (config_.isNetwork) {
config_.macAddress = PrinterHelper::getMACAddress();
}
std::string actualModel = PrinterHelper::getModelNumber();
if (actualModel != config_.modelNumber) {
PrinterHelper::send(OBF("!LOAD MODELNUMBER ") + config_.modelNumber);
}
return TestStatus::Passed;
}
TestStatus TestEngine::doFontDownload() {
if (skipFonts_) {
return TestStatus::Skipped;
}
return TestStatus::Passed;
}
TestStatus TestEngine::doCPRDownload() {
if (skipCPRs_) {
return TestStatus::Skipped;
}
return TestStatus::Passed;
}
TestStatus TestEngine::doControlPanel() {
return TestStatus::Passed;
}
TestStatus TestEngine::doConnectionTypes() {
return TestStatus::Passed;
}
TestStatus TestEngine::doPrintheadUpDown() {
return TestStatus::Passed;
}
TestStatus TestEngine::doToneCheck() {
if (config_.isLX) {
return TestStatus::Skipped;
}
PrinterHelper::send(OBF("!0 0 0 0\nBEEP 60\nEND\n"));
if (promptCallback_) {
bool heard = promptCallback_("Did you hear the beep?", true);
PrinterHelper::send(OBF("!0 0 0 0\nBEEP 1\nEND\n"));
return heard ? TestStatus::Passed : TestStatus::Failed;
}
return TestStatus::Passed;
}
TestStatus TestEngine::doRTCSetup() {
if (config_.memRTC != MemRTC::MB8_RTC) {
return TestStatus::Skipped;
}
auto now = std::chrono::system_clock::now();
auto time = std::chrono::system_clock::to_time_t(now);
std::tm* tm = std::localtime(&time);
std::ostringstream cmd;
cmd << OBF("!SET TIME ")
<< (tm->tm_year + 1900) << " "
<< (tm->tm_mon + 1) << " "
<< tm->tm_mday << " "
<< tm->tm_hour << " "
<< tm->tm_min << " "
<< tm->tm_sec;
PrinterHelper::send(cmd.str());
return TestStatus::Passed;
}
TestStatus TestEngine::doCalibration() {
PrinterHelper::send(PrinterHelper::calibrate(0));
if (!PrinterHelper::waitFor(PrinterHelper::GENERAL_PRINTER_READY, 30)) {
return TestStatus::Failed;
}
return TestStatus::Passed;
}
TestStatus TestEngine::doFeedButtonTest() {
return TestStatus::Passed;
}
TestStatus TestEngine::doPeelerTest() {
if (config_.exitOption != ExitOption::Peeler) {
return TestStatus::Skipped;
}
return TestStatus::Passed;
}
TestStatus TestEngine::doPrintheadTest() {
return TestStatus::Passed;
}
TestStatus TestEngine::doBackupMemoryTest(bool powerCycle) {
std::string inchCount = PrinterHelper::commandWaitResponse(OBF("!SHOW INCHCOUNT"));
if (inchCount.empty()) {
return TestStatus::Failed;
}
std::string cleaned = CPLParser::clean(inchCount);
for (char c : cleaned) {
if (!std::isdigit(c)) {
return TestStatus::Failed;
}
}
return TestStatus::Passed;
}
TestStatus TestEngine::doPrintQualityTest() {
PrinterHelper::printTestLabel("", "", "Quality Test");
if (promptCallback_) {
bool passed = promptCallback_("Is the print quality acceptable?", true);
return passed ? TestStatus::Passed : TestStatus::Failed;
}
return TestStatus::Passed;
}
TestStatus TestEngine::doRibbonWrinkleTest() {
if (config_.printMethod == PrintMethod::DirectThermal) {
return TestStatus::Skipped;
}
return TestStatus::Passed;
}
TestStatus TestEngine::doFinalSettings() {
PrinterHelper::send(PrinterHelper::variableReset());
return TestStatus::Passed;
}
TestStatus TestEngine::doSelfTest() {
PrinterHelper::send(PrinterHelper::printSelfTest());
return TestStatus::Passed;
}
TestStatus TestEngine::doSerialNumberLabel() {
return TestStatus::Passed;
}
TestStatus TestEngine::doBoxLabel() {
return TestStatus::Passed;
}
bool TestEngine::establishConnection(int baudRate) {
auto& manager = HAL::DeviceManager::instance();
manager.discoverAll();
auto devices = manager.listDevices();
if (devices.empty()) {
return false;
}
auto device = manager.getDevice(devices[0]);
if (!device) return false;
if (!device->isOpen()) {
if (!manager.openDevice(devices[0])) {
return false;
}
}
PrinterHelper::setDevice(device);
return true;
}
void TestEngine::reportResult(TestStep step, TestStatus status, const std::string& message) {
if (testCallback_) {
testCallback_(step, status, message);
}
}
void TestEngine::reportProgress(int percent, const std::string& message) {
if (progressCallback_) {
progressCallback_(percent, message);
}
}
bool TestEngine::promptUser(const std::string& message, bool yesNo) {
if (promptCallback_) {
return promptCallback_(message, yesNo);
}
return true;
}
std::string TestEngine::statusToString(TestStatus status) {
switch (status) {
case TestStatus::Passed: return "Passed";
case TestStatus::Failed: return "Failed";
case TestStatus::Skipped: return "Skipped";
case TestStatus::Cancelled: return "Cancelled";
case TestStatus::Redo: return "Redo";
case TestStatus::Aborted: return "Aborted";
case TestStatus::InProgress: return "In Progress";
case TestStatus::NotStarted: return "Not Started";
default: return "Unknown";
}
}
std::string TestEngine::stepToString(TestStep step) {
switch (step) {
case TestStep::InitialSetup: return "Initial Setup";
case TestStep::FirmwareDownload: return "Firmware Download";
case TestStep::PrinterIdentification: return "Printer Identification";
case TestStep::FontDownload: return "Font Download";
case TestStep::CPRDownload: return "CPR Download";
case TestStep::ControlPanel: return "Control Panel";
case TestStep::ConnectionTypes: return "Connection Types";
case TestStep::PrintheadUpDown: return "Printhead Up/Down";
case TestStep::ToneCheck: return "Tone Check";
case TestStep::RTCSetup: return "RTC Setup";
case TestStep::Calibration: return "Calibration";
case TestStep::FeedButtonTest: return "Feed Button Test";
case TestStep::PeelerTest: return "Peeler Test";
case TestStep::PrintheadTest: return "Printhead Test";
case TestStep::BackupMemoryTest: return "Backup Memory Test";
case TestStep::PrintQualityTest: return "Print Quality Test";
case TestStep::RibbonWrinkleTest: return "Ribbon Wrinkle Test";
case TestStep::FinalSettings: return "Final Settings";
case TestStep::SelfTest: return "Self Test";
case TestStep::SerialNumberLabel: return "Serial Number Label";
case TestStep::BoxLabel: return "Box Label";
default: return "Unknown";
}
}
}
```
## File: CAdmin/Backend/TestEngine.hpp
```
#pragma once
#include <functional>
#include <string>
#include <vector>
#include <map>
#include <chrono>
#include <atomic>
#include <thread>
#include <memory>
namespace Cognitive::HAL {
class Device;
}
namespace Cognitive::Business {
enum class TestStatus {
Passed,
Failed,
Skipped,
Cancelled,
Redo,
Aborted,
InProgress,
NotStarted
};
enum class TestStep {
InitialSetup,
FirmwareDownload,
PrinterIdentification,
FontDownload,
CPRDownload,
ControlPanel,
ConnectionTypes,
PrintheadUpDown,
ToneCheck,
RTCSetup,
Calibration,
FeedButtonTest,
PeelerTest,
PrintheadTest,
BackupMemoryTest,
PrintQualityTest,
RibbonWrinkleTest,
FinalSettings,
SelfTest,
SerialNumberLabel,
BoxLabel
};
enum class ProductLine {
CI,
CXI,
DLX,
LX
};
enum class PrintMethod {
DirectThermal,
ThermalTransfer
};
enum class ExitOption {
Standard,
TearBar,
Peeler
};
enum class MemRTC {
MB4,
MB8,
MB8_RTC
};
enum class CommunicationInterface {
USB_AB,
USB_AB_Network,
USB_AB_Network_Serial,
USB_AB_Network_Serial_Parallel,
USB_AB_Serial,
USB_AB_Serial_Bluetooth,
USB_AB_Parallel,
USB_AB_Serial_Parallel,
Serial,
Parallel,
Serial_Parallel,
Serial_Network,
Serial_Network_Parallel,
All
};
enum class LocationCode {
L,
V,
E,
C
};
struct PrinterConfig {
std::string modelNumber;
std::string serialNumber;
std::string macAddress;
std::string firmwareVersion;
ProductLine productLine;
PrintMethod printMethod;
int mediaWidth = 2;
int printDensity = 200;
int printSpeed = 4;
ExitOption exitOption = ExitOption::Standard;
MemRTC memRTC = MemRTC::MB8_RTC;
CommunicationInterface commInterface = CommunicationInterface::USB_AB;
LocationCode locationCode = LocationCode::L;
std::string customization;
bool isWingman = false;
bool isGattaca = false;
bool isLX = false;
bool isBluetooth = false;
bool isNetwork = false;
bool isMadeInChina = false;
bool isPCL = false;
};
struct TestConfig {
std::shared_ptr<HAL::Device> targetDevice;
std::vector<TestStep> skipSteps;
int loopCount = 1;
bool stopOnFailure = true;
};
struct TestResult {
TestStep step;
TestStatus status;
std::string message;
std::chrono::system_clock::time_point timestamp;
std::chrono::milliseconds duration{0};
};
using TestCallback = std::function<void(TestStep step, TestStatus status, const std::string& message)>;
using ProgressCallback = std::function<void(int percent, const std::string& message)>;
using UserPromptCallback = std::function<bool(const std::string& message, bool yesNo)>;
class TestEngine {
public:
TestEngine();
~TestEngine();
TestEngine(const TestEngine&) = delete;
TestEngine& operator=(const TestEngine&) = delete;
static TestEngine& instance();
void start(const std::string& modelNumber, TestCallback callback);
void startTest(const TestConfig& config);
void stop();
void stopTest() { stop(); }
void pause();
void resume();
[[nodiscard]] bool isRunning() const { return running_.load(); }
[[nodiscard]] bool isPaused() const { return paused_.load(); }
[[nodiscard]] TestStep getCurrentStep() const { return currentStep_; }
[[nodiscard]] int getCurrentStepNumber() const { return currentStepNumber_; }
[[nodiscard]] int getTotalSteps() const { return totalSteps_; }
void setProgressCallback(ProgressCallback callback);
void setProgressCallback(TestCallback callback);
void setUserPromptCallback(UserPromptCallback callback);
[[nodiscard]] const PrinterConfig& getConfig() const { return config_; }
void setSkipFlags(bool skipFirmware, bool skipFonts, bool skipCPRs);
bool parseModelNumber(const std::string& modelNumber);
[[nodiscard]] const std::vector<TestResult>& getResults() const { return results_; }
[[nodiscard]] std::string getResultsJson() const;
[[nodiscard]] TestStatus getStatus() const { return overallStatus_; }
TestStatus doInitialSetup();
TestStatus doFirmwareDownload(bool askUser = true);
TestStatus doPrinterIdentification(bool getNewId = true);
TestStatus doFontDownload();
TestStatus doCPRDownload();
TestStatus doControlPanel();
TestStatus doConnectionTypes();
TestStatus doPrintheadUpDown();
TestStatus doToneCheck();
TestStatus doRTCSetup();
TestStatus doCalibration();
TestStatus doFeedButtonTest();
TestStatus doPeelerTest();
TestStatus doPrintheadTest();
TestStatus doBackupMemoryTest(bool powerCycle = true);
TestStatus doPrintQualityTest();
TestStatus doRibbonWrinkleTest();
TestStatus doFinalSettings();
TestStatus doSelfTest();
TestStatus doSerialNumberLabel();
TestStatus doBoxLabel();
static std::string statusToString(TestStatus status);
static std::string stepToString(TestStep step);
private:
std::atomic<bool> running_{false};
std::atomic<bool> paused_{false};
std::atomic<bool> aborted_{false};
TestStep currentStep_ = TestStep::InitialSetup;
int currentStepNumber_ = 0;
int totalSteps_ = 21;
TestStatus overallStatus_ = TestStatus::NotStarted;
PrinterConfig config_;
std::vector<TestResult> results_;
TestCallback testCallback_;
ProgressCallback progressCallback_;
UserPromptCallback promptCallback_;
bool skipFirmware_ = false;
bool skipFonts_ = false;
bool skipCPRs_ = false;
std::thread testThread_;
void runTestSequence();
void reportResult(TestStep step, TestStatus status, const std::string& message);
void reportProgress(int percent, const std::string& message);
bool promptUser(const std::string& message, bool yesNo = true);
bool establishConnection(int baudRate = 115200);
bool parseDLX_LXModelNumber(const std::string& modelNumber);
bool parseCModelNumber(const std::string& modelNumber);
};
}
```
## File: CAdmin/Backend/USBDevice.cpp
```cpp
#include "USBDevice.hpp"
#include <span>
#include <cstring>
#ifdef _WIN32
#include <windows.h>
#include <winusb.h>
#include <setupapi.h>
#include <initguid.h>
#include <usbiodef.h>
#pragma comment(lib, "setupapi.lib")
#pragma comment(lib, "winusb.lib")
#else
#include <libusb-1.0/libusb.h>
#endif
namespace Cognitive::HAL {
struct USBDevice::Impl {
#ifdef _WIN32
HANDLE hDevice = INVALID_HANDLE_VALUE;
WINUSB_INTERFACE_HANDLE hWinUSB = nullptr;
bool usingWinUSB = true;
#else
libusb_context* ctx = nullptr;
libusb_device_handle* handle = nullptr;
#endif
uint8_t writeEndpoint = 0x01;
uint8_t readEndpoint = 0x81;
int interfaceNumber = 0;
bool isOpen = false;
std::string lastError;
USBDeviceId deviceId;
#ifndef _WIN32
bool claimInterface() {
if (handle) {
return libusb_claim_interface(handle, interfaceNumber) == 0;
}
return false;
}
void releaseInterface() {
if (handle) {
libusb_release_interface(handle, interfaceNumber);
}
}
#endif
};
USBDevice::USBDevice() : pImpl_(std::make_unique<Impl>()) {
}
USBDevice::~USBDevice() {
close();
}
USBDevice::USBDevice(USBDevice&&) noexcept = default;
USBDevice& USBDevice::operator=(USBDevice&&) noexcept = default;
bool USBDevice::open(const std::string& path) {
path_ = path;
#ifdef _WIN32
pImpl_->hDevice = CreateFileA(
path.c_str(),
GENERIC_READ | GENERIC_WRITE,
FILE_SHARE_READ | FILE_SHARE_WRITE,
nullptr,
OPEN_EXISTING,
FILE_FLAG_OVERLAPPED,
nullptr
);
if (pImpl_->hDevice == INVALID_HANDLE_VALUE) {
pImpl_->lastError = "CreateFile failed: " + std::to_string(GetLastError());
return false;
}
if (!WinUsb_Initialize(pImpl_->hDevice, &pImpl_->hWinUSB)) {
pImpl_->lastError = "WinUsb_Initialize failed: " + std::to_string(GetLastError());
CloseHandle(pImpl_->hDevice);
pImpl_->hDevice = INVALID_HANDLE_VALUE;
return false;
}
USB_INTERFACE_DESCRIPTOR ifaceDesc;
if (WinUsb_QueryInterfaceSettings(pImpl_->hWinUSB, 0, &ifaceDesc)) {
for (UCHAR i = 0; i < ifaceDesc.bNumEndpoints; i++) {
WINUSB_PIPE_INFORMATION pipeInfo;
if (WinUsb_QueryPipe(pImpl_->hWinUSB, 0, i, &pipeInfo)) {
if (USB_ENDPOINT_DIRECTION_IN(pipeInfo.PipeId)) {
pImpl_->readEndpoint = pipeInfo.PipeId;
} else {
pImpl_->writeEndpoint = pipeInfo.PipeId;
}
}
}
}
ULONG timeout = 5000;
WinUsb_SetPipePolicy(pImpl_->hWinUSB, pImpl_->readEndpoint, PIPE_TRANSFER_TIMEOUT, sizeof(timeout), &timeout);
WinUsb_SetPipePolicy(pImpl_->hWinUSB, pImpl_->writeEndpoint, PIPE_TRANSFER_TIMEOUT, sizeof(timeout), &timeout);
pImpl_->isOpen = true;
return true;
#else
int result = libusb_init(&pImpl_->ctx);
if (result != 0) {
pImpl_->lastError = "libusb_init failed: " + std::string(libusb_error_name(result));
return false;
}
uint16_t vid = 0, pid = 0;
if (sscanf(path.c_str(), "%hx:%hx", &vid, &pid) != 2) {
pImpl_->lastError = "Invalid device path format. Expected VID:PID";
libusb_exit(pImpl_->ctx);
pImpl_->ctx = nullptr;
return false;
}
libusb_device **devices = nullptr;
ssize_t count = libusb_get_device_list(pImpl_->ctx, &devices);
if (count < 0) {
pImpl_->lastError = "Failed to enumerate USB devices: " + std::string(libusb_error_name(static_cast<int>(count)));
libusb_exit(pImpl_->ctx);
pImpl_->ctx = nullptr;
return false;
}
bool deviceFound = false;
for (ssize_t i = 0; i < count; i++) {
libusb_device_descriptor desc;
if (libusb_get_device_descriptor(devices[i], &desc) == 0) {
if (desc.idVendor == vid && desc.idProduct == pid) {
deviceFound = true;
int result = libusb_open(devices[i], &pImpl_->handle);
if (result == LIBUSB_ERROR_ACCESS) {
pImpl_->lastError = "Permission denied opening USB device. "
"On Linux, check udev rules or run: sudo usermod -aG plugdev $USER";
libusb_free_device_list(devices, 1);
libusb_exit(pImpl_->ctx);
pImpl_->ctx = nullptr;
return false;
} else if (result != 0) {
pImpl_->lastError = "Failed to open USB device: " + std::string(libusb_error_name(result));
libusb_free_device_list(devices, 1);
libusb_exit(pImpl_->ctx);
pImpl_->ctx = nullptr;
return false;
}
break;
}
}
}
libusb_free_device_list(devices, 1);
if (!deviceFound) {
pImpl_->lastError = "USB device not found: " + path;
libusb_exit(pImpl_->ctx);
pImpl_->ctx = nullptr;
return false;
}
if (!pImpl_->handle) {
pImpl_->lastError = "Failed to obtain device handle";
libusb_exit(pImpl_->ctx);
pImpl_->ctx = nullptr;
return false;
}
if (libusb_kernel_driver_active(pImpl_->handle, pImpl_->interfaceNumber) == 1) {
libusb_detach_kernel_driver(pImpl_->handle, pImpl_->interfaceNumber);
}
if (!pImpl_->claimInterface()) {
pImpl_->lastError = "Failed to claim interface";
libusb_close(pImpl_->handle);
pImpl_->handle = nullptr;
libusb_exit(pImpl_->ctx);
pImpl_->ctx = nullptr;
return false;
}
pImpl_->deviceId.vendorId = vid;
pImpl_->deviceId.productId = pid;
pImpl_->isOpen = true;
return true;
#endif
}
void USBDevice::close() {
if (!pImpl_->isOpen) return;
#ifdef _WIN32
if (pImpl_->hWinUSB) {
WinUsb_Free(pImpl_->hWinUSB);
pImpl_->hWinUSB = nullptr;
}
if (pImpl_->hDevice != INVALID_HANDLE_VALUE) {
CloseHandle(pImpl_->hDevice);
pImpl_->hDevice = INVALID_HANDLE_VALUE;
}
#else
pImpl_->releaseInterface();
if (pImpl_->handle) {
libusb_close(pImpl_->handle);
pImpl_->handle = nullptr;
}
if (pImpl_->ctx) {
libusb_exit(pImpl_->ctx);
pImpl_->ctx = nullptr;
}
#endif
pImpl_->isOpen = false;
}
bool USBDevice::isOpen() const {
return pImpl_->isOpen;
}
bool USBDevice::write(std::span<const uint8_t> data) {
if (!pImpl_->isOpen) {
pImpl_->lastError = "Device not open";
return false;
}
#ifdef _WIN32
ULONG written = 0;
BOOL result = WinUsb_WritePipe(
pImpl_->hWinUSB,
pImpl_->writeEndpoint,
const_cast<PUCHAR>(data.data()),
static_cast<ULONG>(data.size()),
&written,
nullptr
);
if (!result) {
pImpl_->lastError = "WinUsb_WritePipe failed: " + std::to_string(GetLastError());
return false;
}
return written == data.size();
#else
int transferred = 0;
int result = libusb_bulk_transfer(
pImpl_->handle,
pImpl_->writeEndpoint,
const_cast<unsigned char*>(data.data()),
static_cast<int>(data.size()),
&transferred,
5000
);
if (result != 0) {
pImpl_->lastError = "libusb_bulk_transfer failed: " + std::string(libusb_error_name(result));
return false;
}
return transferred == static_cast<int>(data.size());
#endif
}
std::vector<uint8_t> USBDevice::read(size_t maxBytes, std::chrono::milliseconds timeout) {
std::vector<uint8_t> buffer(maxBytes);
if (!pImpl_->isOpen) {
pImpl_->lastError = "Device not open";
return {};
}
#ifdef _WIN32
ULONG timeoutMs = static_cast<ULONG>(timeout.count());
WinUsb_SetPipePolicy(pImpl_->hWinUSB, pImpl_->readEndpoint, PIPE_TRANSFER_TIMEOUT, sizeof(timeoutMs), &timeoutMs);
ULONG bytesRead = 0;
BOOL result = WinUsb_ReadPipe(
pImpl_->hWinUSB,
pImpl_->readEndpoint,
buffer.data(),
static_cast<ULONG>(maxBytes),
&bytesRead,
nullptr
);
if (result) {
buffer.resize(bytesRead);
return buffer;
}
pImpl_->lastError = "WinUsb_ReadPipe failed: " + std::to_string(GetLastError());
return {};
#else
int transferred = 0;
int result = libusb_bulk_transfer(
pImpl_->handle,
pImpl_->readEndpoint,
buffer.data(),
static_cast<int>(maxBytes),
&transferred,
static_cast<unsigned int>(timeout.count())
);
if (result == 0 || result == LIBUSB_ERROR_TIMEOUT) {
buffer.resize(transferred);
return buffer;
}
pImpl_->lastError = "libusb_bulk_transfer failed: " + std::string(libusb_error_name(result));
return {};
#endif
}
std::string USBDevice::getDescription() const {
std::string desc = "USB Device";
if (pImpl_->deviceId.vendorId != 0) {
char buf[32];
snprintf(buf, sizeof(buf), " [%04X:%04X]", pImpl_->deviceId.vendorId, pImpl_->deviceId.productId);
desc += buf;
}
if (!pImpl_->deviceId.product.empty()) {
desc += " - " + pImpl_->deviceId.product;
}
return desc;
}
DeviceInfo USBDevice::getInfo() const {
DeviceInfo info;
info.path = path_;
info.description = getDescription();
info.type = DeviceType::USB;
info.state = pImpl_->isOpen ? DeviceState::Connected : DeviceState::Disconnected;
info.manufacturer = pImpl_->deviceId.manufacturer;
info.serialNumber = pImpl_->deviceId.serialNumber;
return info;
}
USBDeviceId USBDevice::getDeviceId() const {
return pImpl_->deviceId;
}
void USBDevice::setEndpoints(const USBEndpoints& endpoints) {
endpoints_ = endpoints;
pImpl_->readEndpoint = endpoints.bulkIn;
pImpl_->writeEndpoint = endpoints.bulkOut;
pImpl_->interfaceNumber = endpoints.interfaceNum;
}
USBEndpoints USBDevice::getEndpoints() const {
return endpoints_;
}
int USBDevice::controlTransfer(uint8_t requestType, uint8_t request, uint16_t value,
uint16_t index, std::span<uint8_t> data,
std::chrono::milliseconds timeout) {
if (!pImpl_->isOpen) return -1;
#ifdef _WIN32
WINUSB_SETUP_PACKET setupPacket{};
setupPacket.RequestType = requestType;
setupPacket.Request = request;
setupPacket.Value = value;
setupPacket.Index = index;
setupPacket.Length = static_cast<USHORT>(data.size());
ULONG transferred = 0;
BOOL result = WinUsb_ControlTransfer(pImpl_->hWinUSB, setupPacket, data.data(),
static_cast<ULONG>(data.size()), &transferred, nullptr);
return result ? static_cast<int>(transferred) : -1;
#else
int result = libusb_control_transfer(
pImpl_->handle,
requestType,
request,
value,
index,
data.data(),
static_cast<uint16_t>(data.size()),
static_cast<unsigned int>(timeout.count())
);
return result;
#endif
}
bool USBDevice::reset() {
if (!pImpl_->isOpen) return false;
#ifdef _WIN32
WinUsb_AbortPipe(pImpl_->hWinUSB, pImpl_->readEndpoint);
WinUsb_AbortPipe(pImpl_->hWinUSB, pImpl_->writeEndpoint);
return true;
#else
return libusb_reset_device(pImpl_->handle) == 0;
#endif
}
bool USBDevice::clearHalt(uint8_t endpoint) {
if (!pImpl_->isOpen) return false;
#ifdef _WIN32
return WinUsb_ResetPipe(pImpl_->hWinUSB, endpoint) != FALSE;
#else
return libusb_clear_halt(pImpl_->handle, endpoint) == 0;
#endif
}
std::vector<std::string> USBDevice::enumerate() {
std::vector<std::string> devices;
#ifdef _WIN32
HDEVINFO hDevInfo = SetupDiGetClassDevs(
&GUID_DEVINTERFACE_USB_DEVICE,
nullptr,
nullptr,
DIGCF_PRESENT | DIGCF_DEVICEINTERFACE
);
if (hDevInfo == INVALID_HANDLE_VALUE) {
return devices;
}
SP_DEVICE_INTERFACE_DATA ifaceData{};
ifaceData.cbSize = sizeof(SP_DEVICE_INTERFACE_DATA);
for (DWORD i = 0; SetupDiEnumDeviceInterfaces(hDevInfo, nullptr, &GUID_DEVINTERFACE_USB_DEVICE, i, &ifaceData); i++) {
DWORD requiredSize = 0;
SetupDiGetDeviceInterfaceDetailA(hDevInfo, &ifaceData, nullptr, 0, &requiredSize, nullptr);
if (requiredSize == 0) continue;
std::vector<char> detailBuf(requiredSize);
auto* detail = reinterpret_cast<PSP_DEVICE_INTERFACE_DETAIL_DATA_A>(detailBuf.data());
detail->cbSize = sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA_A);
SP_DEVINFO_DATA devInfoData{};
devInfoData.cbSize = sizeof(SP_DEVINFO_DATA);
if (SetupDiGetDeviceInterfaceDetailA(hDevInfo, &ifaceData, detail, requiredSize, nullptr, &devInfoData)) {
devices.push_back(detail->DevicePath);
}
}
SetupDiDestroyDeviceInfoList(hDevInfo);
#else
libusb_context* ctx = nullptr;
if (libusb_init(&ctx) == 0) {
libusb_device** list = nullptr;
ssize_t cnt = libusb_get_device_list(ctx, &list);
for (ssize_t i = 0; i < cnt; i++) {
libusb_device_descriptor desc;
if (libusb_get_device_descriptor(list[i], &desc) == 0) {
char pathBuf[32];
snprintf(pathBuf, sizeof(pathBuf), "%04x:%04x", desc.idVendor, desc.idProduct);
devices.push_back(pathBuf);
}
}
libusb_free_device_list(list, 1);
libusb_exit(ctx);
}
#endif
return devices;
}
std::vector<USBDeviceId> USBDevice::enumerateDetailed() {
std::vector<USBDeviceId> devices;
#ifdef _WIN32
HDEVINFO hDevInfo = SetupDiGetClassDevs(
&GUID_DEVINTERFACE_USB_DEVICE,
nullptr,
nullptr,
DIGCF_PRESENT | DIGCF_DEVICEINTERFACE
);
if (hDevInfo == INVALID_HANDLE_VALUE) {
return devices;
}
SP_DEVICE_INTERFACE_DATA ifaceData{};
ifaceData.cbSize = sizeof(SP_DEVICE_INTERFACE_DATA);
for (DWORD i = 0; SetupDiEnumDeviceInterfaces(hDevInfo, nullptr, &GUID_DEVINTERFACE_USB_DEVICE, i, &ifaceData); i++) {
DWORD requiredSize = 0;
SetupDiGetDeviceInterfaceDetailA(hDevInfo, &ifaceData, nullptr, 0, &requiredSize, nullptr);
if (requiredSize == 0) continue;
std::vector<char> detailBuf(requiredSize);
auto* detail = reinterpret_cast<PSP_DEVICE_INTERFACE_DETAIL_DATA_A>(detailBuf.data());
detail->cbSize = sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA_A);
SP_DEVINFO_DATA devInfoData{};
devInfoData.cbSize = sizeof(SP_DEVINFO_DATA);
if (SetupDiGetDeviceInterfaceDetailA(hDevInfo, &ifaceData, detail, requiredSize, nullptr, &devInfoData)) {
USBDeviceId id;
std::string path = detail->DevicePath;
std::string pathUpper = path;
for (auto& c : pathUpper) c = static_cast<char>(toupper(c));
auto vidPos = pathUpper.find("VID_");
auto pidPos = pathUpper.find("PID_");
if (vidPos != std::string::npos) {
id.vendorId = static_cast<uint16_t>(strtol(pathUpper.c_str() + vidPos + 4, nullptr, 16));
}
if (pidPos != std::string::npos) {
id.productId = static_cast<uint16_t>(strtol(pathUpper.c_str() + pidPos + 4, nullptr, 16));
}
char buffer[256];
if (SetupDiGetDeviceRegistryPropertyA(hDevInfo, &devInfoData, SPDRP_FRIENDLYNAME, nullptr,
reinterpret_cast<PBYTE>(buffer), sizeof(buffer), nullptr)) {
id.product = buffer;
}
if (SetupDiGetDeviceRegistryPropertyA(hDevInfo, &devInfoData, SPDRP_MFG, nullptr,
reinterpret_cast<PBYTE>(buffer), sizeof(buffer), nullptr)) {
id.manufacturer = buffer;
}
devices.push_back(id);
}
}
SetupDiDestroyDeviceInfoList(hDevInfo);
#else
libusb_context* ctx = nullptr;
if (libusb_init(&ctx) == 0) {
libusb_device** list = nullptr;
ssize_t cnt = libusb_get_device_list(ctx, &list);
for (ssize_t i = 0; i < cnt; i++) {
libusb_device_descriptor desc;
if (libusb_get_device_descriptor(list[i], &desc) == 0) {
USBDeviceId id;
id.vendorId = desc.idVendor;
id.productId = desc.idProduct;
libusb_device_handle* handle = nullptr;
if (libusb_open(list[i], &handle) == 0) {
unsigned char strBuf[256];
if (desc.iManufacturer && libusb_get_string_descriptor_ascii(handle, desc.iManufacturer, strBuf, sizeof(strBuf)) > 0) {
id.manufacturer = reinterpret_cast<char*>(strBuf);
}
if (desc.iProduct && libusb_get_string_descriptor_ascii(handle, desc.iProduct, strBuf, sizeof(strBuf)) > 0) {
id.product = reinterpret_cast<char*>(strBuf);
}
if (desc.iSerialNumber && libusb_get_string_descriptor_ascii(handle, desc.iSerialNumber, strBuf, sizeof(strBuf)) > 0) {
id.serialNumber = reinterpret_cast<char*>(strBuf);
}
libusb_close(handle);
}
devices.push_back(id);
}
}
libusb_free_device_list(list, 1);
libusb_exit(ctx);
}
#endif
return devices;
}
}
```
## File: CAdmin/Backend/USBDevice.hpp
```
#pragma once
#include "Device.hpp"
#include <memory>
namespace Cognitive::HAL {
struct USBEndpoints {
uint8_t bulkIn = 0x81;
uint8_t bulkOut = 0x01;
uint8_t interfaceNum = 0;
};
struct USBDeviceId {
uint16_t vendorId = 0;
uint16_t productId = 0;
std::string serialNumber;
std::string manufacturer;
std::string product;
};
class USBDevice : public Device {
public:
USBDevice();
~USBDevice() override;
USBDevice(const USBDevice&) = delete;
USBDevice& operator=(const USBDevice&) = delete;
USBDevice(USBDevice&&) noexcept;
USBDevice& operator=(USBDevice&&) noexcept;
bool open(const std::string& path) override;
void close() override;
[[nodiscard]] bool isOpen() const override;
bool write(std::span<const uint8_t> data) override;
std::vector<uint8_t> read(size_t maxBytes, std::chrono::milliseconds timeout) override;
[[nodiscard]] DeviceType getType() const override { return DeviceType::USB; }
[[nodiscard]] std::string getPath() const override { return path_; }
[[nodiscard]] std::string getDescription() const override;
[[nodiscard]] DeviceInfo getInfo() const override;
static std::vector<std::string> enumerate();
static std::vector<USBDeviceId> enumerateDetailed();
[[nodiscard]] USBDeviceId getDeviceId() const;
void setEndpoints(const USBEndpoints& endpoints);
[[nodiscard]] USBEndpoints getEndpoints() const;
int controlTransfer(uint8_t requestType, uint8_t request, uint16_t value,
uint16_t index, std::span<uint8_t> data,
std::chrono::milliseconds timeout);
bool reset();
bool clearHalt(uint8_t endpoint);
private:
struct Impl;
std::unique_ptr<Impl> pImpl_;
USBEndpoints endpoints_;
};
}
```
## File: CAdmin/Backend/WebBridge.cpp
```cpp
#include "WebBridge.hpp"
#include "DeviceManager.hpp"
#include "PrinterHelper.hpp"
#include "TestEngine.hpp"
#include "Configurator.hpp"
#include "CPLParser.hpp"
#include "Debug.hpp"
#include "MainFrame.hpp"
#include "SerialDevice.hpp"
#include "USBDevice.hpp"
#include "LANDevice.hpp"
#include "BTDevice.hpp"
#include "Base64.hpp"
#include "Device.hpp"
#include <wx/wx.h>
#include <wx/filedlg.h>
#include <boost/json.hpp>
#include <functional>
#include <fstream>
#include <sstream>
#include <filesystem>
namespace json = boost::json;
namespace Cognitive::UI {
static bool isPathSafe(const std::string& path) {
if (path.find("..") != std::string::npos) {
return false;
}
if (path.find('\0') != std::string::npos) {
return false;
}
try {
std::filesystem::path fsPath(path);
auto canonical = std::filesystem::weakly_canonical(fsPath);
#ifdef _WIN32
std::string pathStr = canonical.string();
if (pathStr.find("\\\\") == 0 || pathStr.find("//") == 0) {
return false;
}
#endif
return true;
} catch (...) {
return false;
}
}
bool RPCRequest::fromJson(const std::string& jsonStr) {
try {
auto obj = json::parse(jsonStr).as_object();
if (obj.contains("id")) {
id = std::string(obj["id"].as_string());
}
if (obj.contains("method") || obj.contains("cmd")) {
method = obj.contains("method") ?
std::string(obj["method"].as_string()) :
std::string(obj["cmd"].as_string());
}
if (obj.contains("params")) {
params = json::serialize(obj["params"]);
} else if (obj.contains("args")) {
params = json::serialize(obj["args"]);
}
return !method.empty();
} catch (...) {
return false;
}
}
std::string RPCResponse::toJson() const {
json::object obj;
obj["id"] = id;
obj["success"] = success;
if (success) {
try {
obj["result"] = json::parse(result);
} catch (...) {
obj["result"] = result;
}
} else {
obj["error"] = error;
obj["errorCode"] = errorCode;
}
return json::serialize(obj);
}
RPCResponse RPCResponse::ok(const std::string& reqId, const std::string& res) {
RPCResponse response;
response.id = reqId;
response.success = true;
response.result = res;
return response;
}
RPCResponse RPCResponse::err(const std::string& reqId, const std::string& errMsg, int code) {
RPCResponse response;
response.id = reqId;
response.success = false;
response.error = errMsg;
response.errorCode = code;
return response;
}
WebBridge::WebBridge(wxWebView* webView) : webView_(webView) {
setupDefaultHandlers();
}
WebBridge::~WebBridge() = default;
void WebBridge::handleMessage(const std::string& message) {
RPCRequest request;
if (!request.fromJson(message)) {
sendResponse(RPCResponse::err("", "Invalid request format"));
return;
}
auto response = processRequest(request);
sendResponse(response);
}
RPCResponse WebBridge::processRequest(const RPCRequest& request) {
auto it = handlers_.find(request.method);
if (it == handlers_.end()) {
return RPCResponse::err(request.id, "Unknown method: " + request.method);
}
try {
std::string result = it->second(request.params);
return RPCResponse::ok(request.id, result);
} catch (const std::exception& e) {
return RPCResponse::err(request.id, std::string("Handler error: ") + e.what());
}
}
void WebBridge::sendToJS(const std::string& event, const std::string& data) {
if (!webView_) return;
std::string script = "window.dispatchEvent(new CustomEvent('backend-message', "
"{detail:{event:'" + event + "',data:" + data + "}}));";
if (wxTheApp) {
wxTheApp->CallAfter([this, script]() {
if (webView_) {
webView_->RunScript(script);
}
});
}
}
void WebBridge::sendResponse(const RPCResponse& response) {
sendToJS("response", response.toJson());
}
void WebBridge::executeScript(const std::string& script) {
if (!webView_) return;
if (wxTheApp) {
wxTheApp->CallAfter([this, script]() {
if (webView_) {
webView_->RunScript(script);
}
});
}
}
void WebBridge::callJSFunction(const std::string& functionName, const std::string& argsJson) {
std::string script = functionName + ".apply(null, " + argsJson + ");";
executeScript(script);
}
std::string WebBridge::getJavaScriptAPI() const {
return R"(
window.Backend = {
_id: 0,
_pending: {},
_call: function(method, args) {
return new Promise((resolve, reject) => {
const id = String(++this._id);
this._pending[id] = { resolve, reject };
const message = JSON.stringify({
id: id,
cmd: method,
args: args || {}
});
try {
if (window.wx && window.wx.postMessage) {
window.wx.postMessage('bridge', message);
} else if (window.chrome && window.chrome.webview && window.chrome.webview.postMessage) {
window.chrome.webview.postMessage(message);
} else if (window.webkit && window.webkit.messageHandlers && window.webkit.messageHandlers.bridge) {
window.webkit.messageHandlers.bridge.postMessage(message);
} else {
console.warn('No message handler available');
reject(new Error('No backend message handler available'));
return;
}
} catch (e) {
console.error('Error posting message:', e);
reject(e);
}
});
},
scanDevices: function() { return this._call('Backend_ScanDevices'); },
connect: function(deviceId) { return this._call('Backend_Connect', {deviceId}); },
disconnect: function(deviceId) { return this._call('Backend_Disconnect', {deviceId}); },
getDeviceStatus: function(deviceId) { return this._call('Backend_GetDeviceStatus', {deviceId}); },
printLabel: function(deviceId, cpl) { return this._call('Backend_PrintLabel', {deviceId, cpl}); },
printTestLabel: function(deviceId) { return this._call('Backend_PrintTestLabel', {deviceId}); },
sendRawData: function(deviceId, data) { return this._call('Backend_SendRawData', {deviceId, data}); },
queryStatus: function(deviceId) { return this._call('Backend_QueryStatus', {deviceId}); },
querySettings: function(deviceId) { return this._call('Backend_QuerySettings', {deviceId}); },
setDarkness: function(deviceId, level) { return this._call('Backend_SetDarkness', {deviceId, level}); },
setSpeed: function(deviceId, speed) { return this._call('Backend_SetSpeed', {deviceId, speed}); },
calibrate: function(deviceId) { return this._call('Backend_Calibrate', {deviceId}); },
startTest: function(deviceId, config) { return this._call('Backend_StartTest', {deviceId, config}); },
stopTest: function() { return this._call('Backend_StopTest'); },
getTestStatus: function() { return this._call('Backend_GetTestStatus'); },
getConfig: function(key) { return this._call('Backend_GetConfig', {key}); },
setConfig: function(key, value) { return this._call('Backend_SetConfig', {key, value}); },
saveConfig: function(path) { return this._call('Backend_SaveConfig', {path}); },
loadConfig: function(path) { return this._call('Backend_LoadConfig', {path}); },
getProfiles: function() { return this._call('Backend_GetProfiles'); },
saveProfile: function(name, config) { return this._call('Backend_SaveProfile', {name, config}); },
deleteProfile: function(name) { return this._call('Backend_DeleteProfile', {name}); },
parseCPL: function(cpl) { return this._call('Backend_ParseCPL', {cpl}); },
validateCPL: function(cpl) { return this._call('Backend_ValidateCPL', {cpl}); },
setTheme: function(theme) { return this._call('Backend_SetTheme', {theme}); },
setBorderless: function(enabled) { return this._call('Backend_SetBorderless', {enabled}); },
windowControl: function(action) { return this._call('Backend_WindowControl', {action}); }
};
window.addEventListener('backend-message', function(e) {
if (e.detail && e.detail.event === 'response') {
const data = e.detail.data;
const pending = Backend._pending[data.id];
if (pending) {
delete Backend._pending[data.id];
if (data.success) {
pending.resolve(data.result);
} else {
pending.reject(new Error(data.error));
}
}
}
});
(function() {
var hookSelectors = function() {
var themeSelector = document.getElementById('theme_selector');
var layoutSelector = document.getElementById('layout_selector');
var borderlessCheckbox = document.getElementById('chk_borderless');
if (themeSelector) {
themeSelector.addEventListener('change', function(e) {
var theme = this.value;
console.log('[Backend] Theme changed to:', theme);
Backend.setTheme(theme).catch(function(err) {
console.warn('Failed to set theme in backend:', err);
});
});
console.log('[Backend] Theme selector hooked');
var currentTheme = document.body.dataset.theme || 'default';
Backend.setTheme(currentTheme).catch(function(err) {
console.warn('Failed to set initial theme:', err);
});
}
if (borderlessCheckbox) {
var initialBorderless = borderlessCheckbox.checked;
console.log('[Backend] Initial borderless state:', initialBorderless);
Backend._call('Backend_SetBorderless', {enabled: initialBorderless}).catch(function(err) {
console.warn('Failed to set initial borderless mode:', err);
});
console.log('[Backend] Borderless checkbox hooked');
}
if (layoutSelector) {
console.log('[Backend] Layout selector found and hooked');
}
};
var attempts = 0;
var tryHook = function() {
attempts++;
var themeSelector = document.getElementById('theme_selector');
if (themeSelector || attempts > 20) {
hookSelectors();
} else {
setTimeout(tryHook, 100);
}
};
setTimeout(tryHook, 100);
})();
window.Backend_EnumerateSerialPorts = function() {
return Backend._call('Backend_EnumerateSerialPorts', {});
};
window.Backend_EnumerateUsbPrinters = function() {
return Backend._call('Backend_EnumerateUsbPrinters', {});
};
window.Backend_DiscoverNetworkPrinters = function(broadcastAddr, port, timeoutMs) {
return Backend._call('Backend_DiscoverNetworkPrinters', {broadcastAddr, port, timeoutMs});
};
window.Backend_DiscoverBluetoothPrinters = function(timeoutMs) {
return Backend._call('Backend_DiscoverBluetoothPrinters', {timeoutMs});
};
window.Backend_OpenSerialPort = function(portName, baudRate, parity, dataBits, stopBits) {
return Backend._call('Backend_OpenSerialPort', {portName, baudRate, parity, dataBits, stopBits});
};
window.Backend_CloseSerialPort = function(handle) {
return Backend._call('Backend_CloseConnection', {handle});
};
window.Backend_OpenTcpConnection = function(ipAddress, port) {
return Backend._call('Backend_OpenTcpConnection', {ipAddress, port});
};
window.Backend_CloseTcpConnection = function(handle) {
return Backend._call('Backend_CloseConnection', {handle});
};
window.Backend_OpenBluetoothConnection = function(address, pin) {
return Backend._call('Backend_OpenBluetoothConnection', {address, pin});
};
window.Backend_CloseBluetoothConnection = function(handle) {
return Backend._call('Backend_CloseConnection', {handle});
};
window.Backend_OpenUsbConnection = function(devicePath) {
return Backend._call('Backend_OpenUsbConnection', {devicePath});
};
window.Backend_CloseUsbConnection = function(handle) {
return Backend._call('Backend_CloseConnection', {handle});
};
window.Backend_SendData = function(handle, data) {
return Backend._call('Backend_SendData', {handle, data});
};
window.Backend_ReceiveData = function(handle, maxBytes, timeoutMs) {
return Backend._call('Backend_ReceiveData', {handle, maxBytes, timeoutMs});
};
window.Backend_SendCommand = function(handle, command, timeoutMs) {
return Backend._call('Backend_SendCommand', {handle, command, timeoutMs});
};
window.Backend_GetPrinterStatus = function(handle) {
return Backend._call('Backend_GetPrinterStatus', {handle});
};
window.Backend_GetPrinterIdentity = function(handle) {
return Backend._call('Backend_GetPrinterIdentity', {handle});
};
window.Backend_GetPrinterVariables = function(handle) {
return Backend._call('Backend_GetPrinterVariables', {handle});
};
window.Backend_SetVariable = function(handle, varName, value, saveToFlash) {
return Backend._call('Backend_SetVariable', {handle, varName, value, saveToFlash});
};
window.Backend_CalibrateMedia = function(handle, mode) {
return Backend._call('Backend_CalibrateMedia', {handle, mode});
};
window.Backend_FactoryReset = function(handle, fullReset) {
return Backend._call('Backend_FactoryReset', {handle, fullReset});
};
window.Backend_FeedLabel = function(handle) {
return Backend._call('Backend_FeedLabel', {handle});
};
window.Backend_PrintTestLabel = function(handle, testType) {
return Backend._call('Backend_PrintTestLabel', {handle, testType});
};
window.Backend_PrintLabel = function(handle, cplData) {
return Backend._call('Backend_PrintLabel', {handle, cpl: cplData});
};
window.Backend_GetPrintHeadTemperature = function(handle) {
return Backend._call('Backend_GetPrintHeadTemperature', {handle});
};
window.Backend_GetMediaSensors = function(handle) {
return Backend._call('Backend_GetMediaSensors', {handle});
};
window.Backend_GetPrintStatistics = function(handle) {
return Backend._call('Backend_GetPrintStatistics', {handle});
};
window.Backend_ResetPrinter = function(handle) {
return Backend._call('Backend_ResetPrinter', {handle});
};
window.Backend_CancelPrint = function(handle) {
return Backend._call('Backend_CancelPrint', {handle});
};
window.Backend_GetFirmwareVersions = function(handle) {
return Backend._call('Backend_GetFirmwareVersions', {handle});
};
window.Backend_GetMemoryInfo = function(handle) {
return Backend._call('Backend_GetMemoryInfo', {handle});
};
window.Backend_ListObjects = function(handle, location) {
return Backend._call('Backend_ListObjects', {handle, location});
};
window.Backend_GetEventLog = function(handle) {
return Backend._call('Backend_GetEventLog', {handle});
};
window.Backend_ClearEventLog = function(handle) {
return Backend._call('Backend_ClearEventLog', {handle});
};
window.Backend_RunSelfTest = function(handle, testType) {
return Backend._call('Backend_RunSelfTest', {handle, testType});
};
window.Backend_OpenFileDialog = function(filter, title) {
return Backend._call('Backend_OpenFileDialog', {filter, title});
};
window.Backend_ReadFile = function(filePath) {
return Backend._call('Backend_ReadFile', {filePath});
};
window.Backend_SaveFile = function(filePath, data) {
return Backend._call('Backend_SaveFile', {filePath, data});
};
window.Backend_GetAppVersion = function() {
return Backend._call('Backend_GetAppVersion', {});
};
window.Backend_OpenExternalUrl = function(url) {
return Backend._call('Backend_OpenExternalUrl', {url});
};
window.Backend_ShowMessageBox = function(title, message, type) {
return Backend._call('Backend_ShowMessageBox', {title, message, type});
};
window.Backend_LoadSerialNumber = function(handle, serialNumber) {
return Backend._call('Backend_LoadSerialNumber', {handle, serialNumber});
};
window.Backend_LoadModelNumber = function(handle, modelNumber) {
return Backend._call('Backend_LoadModelNumber', {handle, modelNumber});
};
window.Backend_LoadMacAddress = function(handle, macAddress) {
return Backend._call('Backend_LoadMacAddress', {handle, macAddress});
};
window.Backend_RunMfgTest = function(handle, testSequence) {
return Backend._call('Backend_RunMfgTest', {handle, testSequence});
};
window.Backend_UpdateFirmware = function(handle, firmwareData, progressCallback) {
return Backend._call('Backend_UpdateFirmware', {handle, firmwareData: firmwareData});
};
window.Backend_VerifyFirmware = function(firmwareData) {
return Backend._call('Backend_VerifyFirmware', {firmwareData: firmwareData});
};
window.Backend_DownloadObject = function(handle, name, type, data, location) {
return Backend._call('Backend_DownloadObject', {handle, name, type, data: data, location});
};
window.Backend_DeleteObject = function(handle, name) {
return Backend._call('Backend_DeleteObject', {handle, name});
};
window.Backend_GetNetworkConfig = function(handle) {
return Backend._call('Backend_GetNetworkConfig', {handle});
};
window.Backend_SetNetworkConfig = function(handle, config) {
return Backend._call('Backend_SetNetworkConfig', {handle, config});
};
window.Backend_GetBluetoothConfig = function(handle) {
return Backend._call('Backend_GetBluetoothConfig', {handle});
};
window.Backend_SetBluetoothConfig = function(handle, config) {
return Backend._call('Backend_SetBluetoothConfig', {handle, config});
};
window.Backend_ConvertImage = function(imageData, options) {
return Backend._call('Backend_ConvertImage', {imageData: imageData, options});
};
window.Backend_GenerateBarcode = function(type, data, options) {
return Backend._call('Backend_GenerateBarcode', {type, data, options});
};
window.Backend_GetAdcReadings = function(handle) {
return Backend._call('Backend_GetAdcReadings', {handle});
};
window.Backend_DumpMemory = function(handle, address, length) {
return Backend._call('Backend_DumpMemory', {handle, address, length});
};
window.Backend_WindowControl = function(action) {
return Backend._call('Backend_WindowControl', {action});
};
window.Backend_SaveFileDialog = function(filter, title, defaultName) {
return Backend._call('Backend_SaveFileDialog', {filter, title, defaultName});
};
console.log('[Backend API] C++ backend bridge initialized');
)";
}
// ==================== Handler Registration ====================
void WebBridge::registerHandler(const std::string& method, RPCHandler handler) {
handlers_[method] = std::move(handler);
}
void WebBridge::unregisterHandler(const std::string& method) {
handlers_.erase(method);
}
bool WebBridge::hasHandler(const std::string& method) const {
return handlers_.find(method) != handlers_.end();
}
std::vector<std::string> WebBridge::getRegisteredMethods() const {
std::vector<std::string> methods;
for (const auto& [name, _] : handlers_) {
methods.push_back(name);
}
return methods;
}
// ==================== Event Subscription ====================
size_t WebBridge::subscribeToEvents(EventCallback callback) {
size_t id = nextCallbackId_++;
eventCallbacks_[id] = std::move(callback);
return id;
}
void WebBridge::unsubscribeFromEvents(size_t subscriptionId) {
eventCallbacks_.erase(subscriptionId);
}
// ==================== Bridge Setup ====================
void WebBridge::injectBridgeScript() {
executeScript(getJavaScriptAPI());
}
std::string WebBridge::getBridgeScript() {
WebBridge temp(nullptr);
return temp.getJavaScriptAPI();
}
void WebBridge::setWebView(wxWebView* webView) {
webView_ = webView;
}
// ==================== Setup Default Handlers ====================
void WebBridge::setupDefaultHandlers() {
// Device Management
registerHandler("Backend_ScanDevices", [this](const std::string& args) {
return handleScanDevices(args);
});
registerHandler("Backend_Connect", [this](const std::string& args) {
return handleConnect(args);
});
registerHandler("Backend_Disconnect", [this](const std::string& args) {
return handleDisconnect(args);
});
registerHandler("Backend_GetDeviceStatus", [this](const std::string& args) {
return handleGetDeviceStatus(args);
});
registerHandler("Backend_PrintLabel", [this](const std::string& args) {
return handlePrintLabel(args);
});
registerHandler("Backend_PrintTestLabel", [this](const std::string& args) {
return handlePrintTestLabel(args);
});
registerHandler("Backend_SendRawData", [this](const std::string& args) {
return handleSendRawData(args);
});
registerHandler("Backend_QueryStatus", [this](const std::string& args) {
return handleQueryStatus(args);
});
registerHandler("Backend_QuerySettings", [this](const std::string& args) {
return handleQuerySettings(args);
});
registerHandler("Backend_SetDarkness", [this](const std::string& args) {
return handleSetDarkness(args);
});
registerHandler("Backend_SetSpeed", [this](const std::string& args) {
return handleSetSpeed(args);
});
registerHandler("Backend_Calibrate", [this](const std::string& args) {
return handleCalibrate(args);
});
registerHandler("Backend_StartTest", [this](const std::string& args) {
return handleStartTest(args);
});
registerHandler("Backend_StopTest", [this](const std::string& args) {
return handleStopTest(args);
});
registerHandler("Backend_GetTestStatus", [this](const std::string& args) {
return handleGetTestStatus(args);
});
registerHandler("Backend_GetConfig", [this](const std::string& args) {
return handleGetConfig(args);
});
registerHandler("Backend_SetConfig", [this](const std::string& args) {
return handleSetConfig(args);
});
registerHandler("Backend_SaveConfig", [this](const std::string& args) {
return handleSaveConfig(args);
});
registerHandler("Backend_LoadConfig", [this](const std::string& args) {
return handleLoadConfig(args);
});
registerHandler("Backend_GetProfiles", [this](const std::string& args) {
return handleGetProfiles(args);
});
registerHandler("Backend_SaveProfile", [this](const std::string& args) {
return handleSaveProfile(args);
});
registerHandler("Backend_DeleteProfile", [this](const std::string& args) {
return handleDeleteProfile(args);
});
registerHandler("Backend_ParseCPL", [this](const std::string& args) {
return handleParseCPL(args);
});
registerHandler("Backend_ValidateCPL", [this](const std::string& args) {
return handleValidateCPL(args);
});
registerHandler("Backend_SetTheme", [this](const std::string& args) {
return handleSetTheme(args);
});
registerHandler("Backend_SetBorderless", [this](const std::string& args) {
return handleSetBorderless(args);
});
registerHandler("Backend_WindowControl", [this](const std::string& args) {
return handleWindowControl(args);
});
registerHandler("Backend_EnumerateSerialPorts", [this](const std::string& args) {
return handleEnumerateSerialPorts(args);
});
registerHandler("Backend_EnumerateUsbPrinters", [this](const std::string& args) {
return handleEnumerateUsbPrinters(args);
});
registerHandler("Backend_DiscoverNetworkPrinters", [this](const std::string& args) {
return handleDiscoverNetworkPrinters(args);
});
registerHandler("Backend_DiscoverBluetoothPrinters", [this](const std::string& args) {
return handleDiscoverBluetoothPrinters(args);
});
registerHandler("Backend_OpenSerialPort", [this](const std::string& args) {
return handleOpenSerialPort(args);
});
registerHandler("Backend_OpenTcpConnection", [this](const std::string& args) {
return handleOpenTcpConnection(args);
});
registerHandler("Backend_OpenUsbConnection", [this](const std::string& args) {
return handleOpenUsbConnection(args);
});
registerHandler("Backend_OpenBluetoothConnection", [this](const std::string& args) {
return handleOpenBluetoothConnection(args);
});
registerHandler("Backend_CloseConnection", [this](const std::string& args) {
return handleCloseConnection(args);
});
registerHandler("Backend_SendData", [this](const std::string& args) {
return handleSendData(args);
});
registerHandler("Backend_SendCommand", [this](const std::string& args) {
return handleSendCommand(args);
});
registerHandler("Backend_ReceiveData", [this](const std::string& args) {
return handleReceiveData(args);
});
registerHandler("Backend_GetPrinterStatus", [this](const std::string& args) {
return handleGetPrinterStatus(args);
});
registerHandler("Backend_GetPrinterIdentity", [this](const std::string& args) {
return handleGetPrinterIdentity(args);
});
registerHandler("Backend_GetPrinterVariables", [this](const std::string& args) {
return handleGetPrinterVariables(args);
});
registerHandler("Backend_SetVariable", [this](const std::string& args) {
return handleSetVariable(args);
});
registerHandler("Backend_CalibrateMedia", [this](const std::string& args) {
return handleCalibrateMedia(args);
});
registerHandler("Backend_FactoryReset", [this](const std::string& args) {
return handleFactoryReset(args);
});
registerHandler("Backend_FeedLabel", [this](const std::string& args) {
return handleFeedLabel(args);
});
registerHandler("Backend_GetPrintHeadTemperature", [this](const std::string& args) {
return handleGetPrintHeadTemperature(args);
});
registerHandler("Backend_GetMediaSensors", [this](const std::string& args) {
return handleGetMediaSensors(args);
});
registerHandler("Backend_GetPrintStatistics", [this](const std::string& args) {
return handleGetPrintStatistics(args);
});
registerHandler("Backend_ResetPrinter", [this](const std::string& args) {
return handleResetPrinter(args);
});
registerHandler("Backend_CancelPrint", [this](const std::string& args) {
return handleCancelPrint(args);
});
registerHandler("Backend_GetFirmwareVersions", [this](const std::string& args) {
return handleGetFirmwareVersions(args);
});
registerHandler("Backend_GetMemoryInfo", [this](const std::string& args) {
return handleGetMemoryInfo(args);
});
registerHandler("Backend_ListObjects", [this](const std::string& args) {
return handleListObjects(args);
});
registerHandler("Backend_GetEventLog", [this](const std::string& args) {
return handleGetEventLog(args);
});
registerHandler("Backend_ClearEventLog", [this](const std::string& args) {
return handleClearEventLog(args);
});
registerHandler("Backend_RunSelfTest", [this](const std::string& args) {
return handleRunSelfTest(args);
});
registerHandler("Backend_OpenFileDialog", [this](const std::string& args) {
return handleOpenFileDialog(args);
});
registerHandler("Backend_ReadFile", [this](const std::string& args) {
return handleReadFile(args);
});
registerHandler("Backend_SaveFile", [this](const std::string& args) {
return handleSaveFile(args);
});
registerHandler("Backend_GetAppVersion", [this](const std::string& args) {
return handleGetAppVersion(args);
});
registerHandler("Backend_OpenExternalUrl", [this](const std::string& args) {
return handleOpenExternalUrl(args);
});
registerHandler("Backend_ShowMessageBox", [this](const std::string& args) {
return handleShowMessageBox(args);
});
registerHandler("Backend_LoadSerialNumber", [this](const std::string& args) {
return handleLoadSerialNumber(args);
});
registerHandler("Backend_LoadModelNumber", [this](const std::string& args) {
return handleLoadModelNumber(args);
});
registerHandler("Backend_LoadMacAddress", [this](const std::string& args) {
return handleLoadMacAddress(args);
});
registerHandler("Backend_RunMfgTest", [this](const std::string& args) {
return handleRunMfgTest(args);
});
registerHandler("Backend_UpdateFirmware", [this](const std::string& args) {
return handleUpdateFirmware(args);
});
registerHandler("Backend_VerifyFirmware", [this](const std::string& args) {
return handleVerifyFirmware(args);
});
registerHandler("Backend_DownloadObject", [this](const std::string& args) {
return handleDownloadObject(args);
});
registerHandler("Backend_DeleteObject", [this](const std::string& args) {
return handleDeleteObject(args);
});
registerHandler("Backend_GetNetworkConfig", [this](const std::string& args) {
return handleGetNetworkConfig(args);
});
registerHandler("Backend_SetNetworkConfig", [this](const std::string& args) {
return handleSetNetworkConfig(args);
});
registerHandler("Backend_GetBluetoothConfig", [this](const std::string& args) {
return handleGetBluetoothConfig(args);
});
registerHandler("Backend_SetBluetoothConfig", [this](const std::string& args) {
return handleSetBluetoothConfig(args);
});
registerHandler("Backend_ConvertImage", [this](const std::string& args) {
return handleConvertImage(args);
});
registerHandler("Backend_GenerateBarcode", [this](const std::string& args) {
return handleGenerateBarcode(args);
});
registerHandler("Backend_GetAdcReadings", [this](const std::string& args) {
return handleGetAdcReadings(args);
});
registerHandler("Backend_DumpMemory", [this](const std::string& args) {
return handleDumpMemory(args);
});
registerHandler("Backend_SaveFileDialog", [this](const std::string& args) {
return handleSaveFileDialog(args);
});
}
std::string WebBridge::handleScanDevices(const std::string& ) {
auto& manager = HAL::DeviceManager::instance();
manager.discoverAllAsync([this](const std::vector<HAL::DeviceInfo>& discoveredDevices) {
json::array arr;
for (const auto& device : discoveredDevices) {
json::object obj;
obj["id"] = device.path;
obj["type"] = device.description;
obj["description"] = device.description;
obj["connected"] = (device.state == HAL::DeviceState::Connected);
arr.push_back(obj);
}
sendEvent("devicesDiscovered", json::serialize(arr));
});
auto currentDevices = manager.getAllDeviceInfo();
json::array arr;
for (const auto& device : currentDevices) {
json::object obj;
obj["id"] = device.path;
obj["type"] = device.description;
obj["description"] = device.description;
obj["connected"] = (device.state == HAL::DeviceState::Connected);
arr.push_back(obj);
}
return json::serialize(arr);
}
std::string WebBridge::handleConnect(const std::string& args) {
auto parsed = json::parse(args).as_object();
std::string deviceId = std::string(parsed["deviceId"].as_string());
auto device = HAL::DeviceManager::instance().getDevice(deviceId);
json::object result;
if (device) {
bool success = device->open(deviceId);
result["success"] = success;
if (!success) {
result["error"] = device->getLastError();
}
} else {
result["success"] = false;
result["error"] = "Device not found";
}
return json::serialize(result);
}
std::string WebBridge::handleDisconnect(const std::string& args) {
auto parsed = json::parse(args).as_object();
std::string deviceId = std::string(parsed["deviceId"].as_string());
auto device = HAL::DeviceManager::instance().getDevice(deviceId);
json::object result;
if (device) {
device->close();
result["success"] = true;
} else {
result["success"] = false;
result["error"] = "Device not found";
}
return json::serialize(result);
}
std::string WebBridge::handleGetDeviceStatus(const std::string& args) {
auto parsed = json::parse(args).as_object();
std::string deviceId = std::string(parsed["deviceId"].as_string());
auto device = HAL::DeviceManager::instance().getDevice(deviceId);
json::object result;
if (device) {
result["connected"] = device->isOpen();
result["state"] = HAL::deviceStateToString(device->getState());
result["type"] = HAL::deviceTypeToString(device->getType());
result["description"] = device->getDescription();
result["lastError"] = device->getLastError();
} else {
result["error"] = "Device not found";
}
return json::serialize(result);
}
std::string WebBridge::handlePrintLabel(const std::string& args) {
auto parsed = json::parse(args).as_object();
std::string deviceId = std::string(parsed["deviceId"].as_string());
std::string cpl = std::string(parsed["cpl"].as_string());
auto device = HAL::DeviceManager::instance().getDevice(deviceId);
json::object result;
if (device && device->isOpen()) {
bool success = device->writeString(cpl);
result["success"] = success;
if (!success) {
result["error"] = device->getLastError();
}
} else {
result["success"] = false;
result["error"] = device ? "Device not connected" : "Device not found";
}
return json::serialize(result);
}
std::string WebBridge::handlePrintTestLabel(const std::string& args) {
auto parsed = json::parse(args).as_object();
std::string deviceId = std::string(parsed["deviceId"].as_string());
auto device = HAL::DeviceManager::instance().getDevice(deviceId);
json::object result;
if (device && device->isOpen()) {
std::string testLabel = Business::PrinterHelper::printTestLabel();
bool success = device->writeString(testLabel);
result["success"] = success;
} else {
result["success"] = false;
result["error"] = device ? "Device not connected" : "Device not found";
}
return json::serialize(result);
}
std::string WebBridge::handleSendRawData(const std::string& args) {
auto parsed = json::parse(args).as_object();
std::string deviceId = std::string(parsed["deviceId"].as_string());
std::string data = std::string(parsed["data"].as_string());
auto device = HAL::DeviceManager::instance().getDevice(deviceId);
json::object result;
if (device && device->isOpen()) {
bool success = device->writeString(data);
result["success"] = success;
} else {
result["success"] = false;
result["error"] = device ? "Device not connected" : "Device not found";
}
return json::serialize(result);
}
std::string WebBridge::handleQueryStatus(const std::string& args) {
auto parsed = json::parse(args).as_object();
std::string deviceId = std::string(parsed["deviceId"].as_string());
auto device = HAL::DeviceManager::instance().getDevice(deviceId);
json::object result;
if (device && device->isOpen()) {
std::string cmd = Business::PrinterHelper::queryStatus();
std::string response;
bool success = device->sendCommand(cmd, response, std::chrono::seconds(5));
if (success) {
result["success"] = true;
result["response"] = response;
auto status = Business::PrinterHelper::parseStatusResponse(response);
json::object statusObj;
for (const auto& [key, value] : status) {
statusObj[key] = value;
}
result["parsed"] = statusObj;
} else {
result["success"] = false;
result["error"] = "No response from printer";
}
} else {
result["success"] = false;
result["error"] = "Device not connected";
}
return json::serialize(result);
}
std::string WebBridge::handleQuerySettings(const std::string& args) {
auto parsed = json::parse(args).as_object();
std::string deviceId = std::string(parsed["deviceId"].as_string());
auto device = HAL::DeviceManager::instance().getDevice(deviceId);
json::object result;
if (device && device->isOpen()) {
std::string cmd = Business::PrinterHelper::queryVariable("all");
std::string response;
bool success = device->sendCommand(cmd, response, std::chrono::seconds(5));
if (success) {
result["success"] = true;
result["response"] = response;
} else {
result["success"] = false;
result["error"] = "No response from printer";
}
} else {
result["success"] = false;
result["error"] = "Device not connected";
}
return json::serialize(result);
}
std::string WebBridge::handleSetDarkness(const std::string& args) {
auto parsed = json::parse(args).as_object();
std::string deviceId = std::string(parsed["deviceId"].as_string());
int level = static_cast<int>(parsed["level"].as_int64());
auto device = HAL::DeviceManager::instance().getDevice(deviceId);
json::object result;
if (device && device->isOpen()) {
std::string cmd = Business::PrinterHelper::setDarkness(level);
bool success = device->writeString(cmd);
result["success"] = success;
} else {
result["success"] = false;
result["error"] = "Device not connected";
}
return json::serialize(result);
}
std::string WebBridge::handleSetSpeed(const std::string& args) {
auto parsed = json::parse(args).as_object();
std::string deviceId = std::string(parsed["deviceId"].as_string());
int speed = static_cast<int>(parsed["speed"].as_int64());
auto device = HAL::DeviceManager::instance().getDevice(deviceId);
json::object result;
if (device && device->isOpen()) {
std::string cmd = Business::PrinterHelper::setSpeed(speed);
bool success = device->writeString(cmd);
result["success"] = success;
} else {
result["success"] = false;
result["error"] = "Device not connected";
}
return json::serialize(result);
}
std::string WebBridge::handleCalibrate(const std::string& args) {
auto parsed = json::parse(args).as_object();
std::string deviceId = std::string(parsed["deviceId"].as_string());
auto device = HAL::DeviceManager::instance().getDevice(deviceId);
json::object result;
if (device && device->isOpen()) {
std::string cmd = Business::PrinterHelper::calibrate();
bool success = device->writeString(cmd);
result["success"] = success;
} else {
result["success"] = false;
result["error"] = "Device not connected";
}
return json::serialize(result);
}
std::string WebBridge::handleStartTest(const std::string& args) {
auto parsed = json::parse(args).as_object();
std::string deviceId = std::string(parsed["deviceId"].as_string());
auto device = HAL::DeviceManager::instance().getDevice(deviceId);
json::object result;
if (device) {
Business::TestConfig config;
config.targetDevice = device;
if (parsed.contains("config")) {
auto& cfg = parsed["config"].as_object();
if (cfg.contains("loopCount")) {
config.loopCount = static_cast<int>(cfg["loopCount"].as_int64());
}
}
auto& engine = Business::TestEngine::instance();
engine.setProgressCallback([this](Business::TestStep step, Business::TestStatus status, const std::string& msg) {
json::object progress;
progress["step"] = static_cast<int>(step);
progress["status"] = static_cast<int>(status);
progress["message"] = msg;
sendToJS("testProgress", json::serialize(progress));
});
engine.startTest(config);
result["success"] = true;
} else {
result["success"] = false;
result["error"] = "Device not found";
}
return json::serialize(result);
}
std::string WebBridge::handleStopTest(const std::string& ) {
Business::TestEngine::instance().stopTest();
json::object result;
result["success"] = true;
return json::serialize(result);
}
std::string WebBridge::handleGetTestStatus(const std::string& ) {
auto& engine = Business::TestEngine::instance();
json::object result;
result["isRunning"] = engine.isRunning();
result["currentStep"] = static_cast<int>(engine.getCurrentStep());
result["status"] = static_cast<int>(engine.getStatus());
result["results"] = engine.getResultsJson();
return json::serialize(result);
}
std::string WebBridge::handleGetConfig(const std::string& args) {
auto parsed = json::parse(args).as_object();
std::string key = parsed.contains("key") ? std::string(parsed["key"].as_string()) : "";
auto& config = Business::Configurator::global();
json::object result;
if (key.empty()) {
result["config"] = config.exportToJson();
} else {
result["value"] = config.get(key);
}
result["success"] = true;
return json::serialize(result);
}
std::string WebBridge::handleSetConfig(const std::string& args) {
auto parsed = json::parse(args).as_object();
std::string key = std::string(parsed["key"].as_string());
std::string value = std::string(parsed["value"].as_string());
auto& config = Business::Configurator::global();
config.set(key, value);
json::object result;
result["success"] = true;
return json::serialize(result);
}
std::string WebBridge::handleSaveConfig(const std::string& args) {
auto parsed = json::parse(args).as_object();
std::string path = parsed.contains("path") ? std::string(parsed["path"].as_string()) : "";
json::object result;
// Security: Validate path if provided
if (!path.empty() && !isPathSafe(path)) {
result["success"] = false;
result["error"] = "Invalid file path";
return json::serialize(result);
}
auto& config = Business::Configurator::global();
bool success = path.empty() ? config.save() : config.save(path);
result["success"] = success;
return json::serialize(result);
}
std::string WebBridge::handleLoadConfig(const std::string& args) {
auto parsed = json::parse(args).as_object();
std::string path = parsed.contains("path") ? std::string(parsed["path"].as_string()) : "";
json::object result;
// Security: Validate path if provided
if (!path.empty() && !isPathSafe(path)) {
result["success"] = false;
result["error"] = "Invalid file path";
return json::serialize(result);
}
auto& config = Business::Configurator::global();
bool success = path.empty() ? config.reload() : config.load(path);
result["success"] = success;
return json::serialize(result);
}
std::string WebBridge::handleGetProfiles(const std::string& ) {
auto& config = Business::Configurator::global();
auto profiles = config.listProfiles();
json::array arr;
for (const auto& name : profiles) {
arr.push_back(json::value(name));
}
return json::serialize(arr);
}
std::string WebBridge::handleSaveProfile(const std::string& args) {
auto parsed = json::parse(args).as_object();
std::string name = std::string(parsed["name"].as_string());
auto& config = Business::Configurator::global();
Business::PrinterProfile profile;
profile.name = name;
config.saveProfile(profile);
json::object result;
result["success"] = true;
return json::serialize(result);
}
std::string WebBridge::handleDeleteProfile(const std::string& args) {
auto parsed = json::parse(args).as_object();
std::string name = std::string(parsed["name"].as_string());
auto& config = Business::Configurator::global();
config.deleteProfile(name);
json::object result;
result["success"] = true;
return json::serialize(result);
}
std::string WebBridge::handleParseCPL(const std::string& args) {
auto parsed = json::parse(args);
std::string cpl = parsed.is_string() ?
std::string(parsed.as_string()) :
std::string(parsed.as_object()["cpl"].as_string());
Business::CPLParser parser;
auto commands = parser.parseCommands(cpl);
json::array arr;
for (const auto& cmd : commands) {
json::object obj;
obj["command"] = cmd.command;
json::array paramsArr;
for (const auto& param : cmd.parameters) {
paramsArr.push_back(json::value(param));
}
obj["parameters"] = paramsArr;
arr.push_back(obj);
}
return json::serialize(arr);
}
std::string WebBridge::handleValidateCPL(const std::string& args) {
auto parsed = json::parse(args);
std::string cpl = parsed.is_string() ?
std::string(parsed.as_string()) :
std::string(parsed.as_object()["cpl"].as_string());
Business::CPLParser parser;
auto validationResult = parser.validate(cpl);
json::object obj;
obj["valid"] = validationResult.isValid;
json::array errorsArr;
for (const auto& error : validationResult.errors) {
errorsArr.push_back(json::value(error));
}
obj["errors"] = errorsArr;
json::array warningsArr;
for (const auto& warning : validationResult.warnings) {
warningsArr.push_back(json::value(warning));
}
obj["warnings"] = warningsArr;
return json::serialize(obj);
}
std::string WebBridge::handleSetTheme(const std::string& args) {
auto parsed = json::parse(args).as_object();
std::string themeName = std::string(parsed["theme"].as_string());
if (wxTheApp) {
wxTheApp->CallAfter([this, themeName]() {
wxWindow* window = webView_ ? webView_->GetParent() : nullptr;
while (window && !window->IsTopLevel()) {
window = window->GetParent();
}
if (window) {
auto* mainFrame = dynamic_cast<Cognitive::App::MainFrame*>(window);
if (mainFrame) {
mainFrame->ApplyThemeWindowStyle(themeName);
}
}
});
}
json::object result;
result["success"] = true;
result["theme"] = themeName;
return json::serialize(result);
}
std::string WebBridge::handleSetBorderless(const std::string& args) {
CADMIN_LOG_DEBUG("handleSetBorderless() - args: " << args);
auto parsed = json::parse(args).as_object();
bool enabled = parsed["enabled"].as_bool();
CADMIN_LOG_DEBUG("handleSetBorderless() - enabled: " << (enabled ? "true" : "false"));
if (wxTheApp) {
wxTheApp->CallAfter([enabled]() {
wxWindow* window = wxTheApp->GetTopWindow();
if (window) {
auto* mainFrame = dynamic_cast<Cognitive::App::MainFrame*>(window);
if (mainFrame) {
mainFrame->SetBorderlessEnabled(enabled);
}
}
});
}
json::object result;
result["success"] = true;
result["enabled"] = enabled;
return json::serialize(result);
}
std::string WebBridge::handleWindowControl(const std::string& args) {
CADMIN_LOG_DEBUG("handleWindowControl() - args: " << args);
auto parsed = json::parse(args).as_object();
std::string action = std::string(parsed["action"].as_string());
CADMIN_LOG_DEBUG("handleWindowControl() - action: " << action);
json::object result;
result["success"] = true;
if (wxTheApp) {
wxTheApp->CallAfter([action]() {
CADMIN_LOG_DEBUG("handleWindowControl() - executing action: " << action);
wxWindow* window = wxTheApp->GetTopWindow();
auto* frame = dynamic_cast<wxFrame*>(window);
if (frame) {
CADMIN_LOG_DEBUG("handleWindowControl() - found frame, executing...");
if (action == "minimize") {
frame->Iconize(true);
} else if (action == "maximize") {
frame->Maximize(!frame->IsMaximized());
} else if (action == "close") {
frame->Close();
} else if (action == "restore") {
frame->Iconize(false);
frame->Maximize(false);
}
} else {
CADMIN_LOG_DEBUG("handleWindowControl() - frame not found!");
}
});
}
return json::serialize(result);
}
std::string WebBridge::handleEnumerateSerialPorts(const std::string& ) {
auto ports = HAL::SerialDevice::enumerate();
json::array arr;
for (const auto& port : ports) {
json::object obj;
obj["name"] = port;
obj["description"] = "Serial Port";
obj["manufacturer"] = "Unknown";
arr.push_back(obj);
}
return json::serialize(arr);
}
std::string WebBridge::handleEnumerateUsbPrinters(const std::string& ) {
auto devices = HAL::USBDevice::enumerateDetailed();
json::array arr;
for (const auto& dev : devices) {
json::object obj;
obj["path"] = dev.serialNumber;
obj["vendorId"] = dev.vendorId;
obj["productId"] = dev.productId;
obj["serialNumber"] = dev.serialNumber;
obj["description"] = dev.product;
obj["manufacturer"] = dev.manufacturer;
arr.push_back(obj);
}
return json::serialize(arr);
}
std::string WebBridge::handleDiscoverNetworkPrinters(const std::string& args) {
auto parsed = json::parse(args).as_object();
int timeout = parsed.contains("timeoutMs") ?
static_cast<int>(parsed["timeoutMs"].as_int64()) : 3000;
auto devices = HAL::LANDevice::discoverDetailed(std::chrono::milliseconds(timeout));
json::array arr;
for (const auto& dev : devices) {
json::object obj;
obj["ipAddress"] = dev.ipAddress;
obj["port"] = dev.port;
obj["hostname"] = dev.hostname;
obj["modelName"] = dev.modelNumber;
obj["serialNumber"] = dev.serialNumber;
obj["macAddress"] = dev.macAddress;
arr.push_back(obj);
}
return json::serialize(arr);
}
std::string WebBridge::handleDiscoverBluetoothPrinters(const std::string& args) {
auto parsed = json::parse(args).as_object();
[[maybe_unused]] int timeout = parsed.contains("timeoutMs") ?
static_cast<int>(parsed["timeoutMs"].as_int64()) : 10000;
auto devices = HAL::BTDevice::enumerateDetailed();
json::array arr;
for (const auto& dev : devices) {
json::object obj;
obj["address"] = dev.address;
obj["name"] = dev.name;
obj["paired"] = dev.paired;
obj["connected"] = dev.connected;
obj["rssi"] = dev.rssi;
arr.push_back(obj);
}
return json::serialize(arr);
}
std::string WebBridge::handleOpenSerialPort(const std::string& args) {
auto parsed = json::parse(args).as_object();
std::string portName = std::string(parsed["portName"].as_string());
[[maybe_unused]] int baudRate = parsed.contains("baudRate") ?
static_cast<int>(parsed["baudRate"].as_int64()) : 115200;
auto& manager = HAL::DeviceManager::instance();
auto device = manager.createAndConnect(HAL::DeviceType::Serial, portName);
json::object result;
if (device && device->isOpen()) {
result["success"] = true;
result["handle"] = "SERIAL:" + portName;
} else {
result["success"] = false;
result["error"] = "Failed to open serial port";
}
return json::serialize(result);
}
std::string WebBridge::handleOpenTcpConnection(const std::string& args) {
auto parsed = json::parse(args).as_object();
std::string ipAddress = std::string(parsed["ipAddress"].as_string());
int port = parsed.contains("port") ?
static_cast<int>(parsed["port"].as_int64()) : 9100;
std::string path = ipAddress + ":" + std::to_string(port);
auto& manager = HAL::DeviceManager::instance();
auto device = manager.createAndConnect(HAL::DeviceType::Network, path);
json::object result;
if (device && device->isOpen()) {
result["success"] = true;
result["handle"] = "NET:" + path;
} else {
result["success"] = false;
result["error"] = "Failed to open TCP connection";
}
return json::serialize(result);
}
std::string WebBridge::handleOpenUsbConnection(const std::string& args) {
auto parsed = json::parse(args).as_object();
std::string devicePath = std::string(parsed["devicePath"].as_string());
auto& manager = HAL::DeviceManager::instance();
auto device = manager.createAndConnect(HAL::DeviceType::USB, devicePath);
json::object result;
if (device && device->isOpen()) {
result["success"] = true;
result["handle"] = "USB:" + devicePath;
} else {
result["success"] = false;
result["error"] = "Failed to open USB device";
}
return json::serialize(result);
}
std::string WebBridge::handleOpenBluetoothConnection(const std::string& args) {
auto parsed = json::parse(args).as_object();
std::string address = std::string(parsed["address"].as_string());
auto& manager = HAL::DeviceManager::instance();
auto device = manager.createAndConnect(HAL::DeviceType::Bluetooth, address);
json::object result;
if (device && device->isOpen()) {
result["success"] = true;
result["handle"] = "BT:" + address;
} else {
result["success"] = false;
result["error"] = "Failed to open Bluetooth connection";
}
return json::serialize(result);
}
std::string WebBridge::handleCloseConnection(const std::string& args) {
auto parsed = json::parse(args).as_object();
std::string handle = std::string(parsed["handle"].as_string());
auto& manager = HAL::DeviceManager::instance();
manager.closeDevice(handle);
json::object result;
result["success"] = true;
return json::serialize(result);
}
std::string WebBridge::handleSendData(const std::string& args) {
auto parsed = json::parse(args).as_object();
std::string handle = std::string(parsed["handle"].as_string());
std::string data = std::string(parsed["data"].as_string());
auto device = HAL::DeviceManager::instance().getDevice(handle);
json::object result;
if (device && device->isOpen()) {
bool success = device->writeString(data);
result["success"] = success;
result["bytesSent"] = success ? static_cast<int64_t>(data.size()) : 0;
} else {
result["success"] = false;
result["error"] = "Device not connected";
result["bytesSent"] = 0;
}
return json::serialize(result);
}
std::string WebBridge::handleSendCommand(const std::string& args) {
auto parsed = json::parse(args).as_object();
std::string handle = std::string(parsed["handle"].as_string());
std::string command = std::string(parsed["command"].as_string());
int timeout = parsed.contains("timeoutMs") ?
static_cast<int>(parsed["timeoutMs"].as_int64()) : 5000;
auto device = HAL::DeviceManager::instance().getDevice(handle);
json::object result;
if (device && device->isOpen()) {
std::string response;
bool success = device->sendCommand(command, response, std::chrono::milliseconds(timeout));
result["success"] = success;
result["response"] = response;
} else {
result["success"] = false;
result["error"] = "Device not connected";
result["response"] = "";
}
return json::serialize(result);
}
std::string WebBridge::handleReceiveData(const std::string& args) {
auto parsed = json::parse(args).as_object();
std::string handle = std::string(parsed["handle"].as_string());
int maxBytes = parsed.contains("maxBytes") ?
static_cast<int>(parsed["maxBytes"].as_int64()) : 4096;
int timeout = parsed.contains("timeoutMs") ?
static_cast<int>(parsed["timeoutMs"].as_int64()) : 1000;
auto device = HAL::DeviceManager::instance().getDevice(handle);
json::object result;
if (device && device->isOpen()) {
std::string data = device->readString(maxBytes, std::chrono::milliseconds(timeout));
result["success"] = true;
result["data"] = data;
} else {
result["success"] = false;
result["error"] = "Device not connected";
result["data"] = "";
}
return json::serialize(result);
}
// ==================== Printer Operation Handlers ====================
std::string WebBridge::handleGetPrinterStatus(const std::string& args) {
auto parsed = json::parse(args).as_object();
std::string handle = std::string(parsed["handle"].as_string());
auto device = HAL::DeviceManager::instance().getDevice(handle);
json::object result;
if (device && device->isOpen()) {
Business::PrinterHelper::setDevice(device);
auto status = Business::PrinterHelper::getStatus();
result["success"] = true;
result["ready"] = status.ready;
result["paused"] = status.paused;
result["paperOut"] = status.paperOut;
result["headUp"] = status.headUp;
result["ribbonOut"] = status.ribbonOut;
result["error"] = status.error;
result["statusText"] = status.toString();
} else {
result["success"] = false;
result["error"] = "Device not connected";
}
return json::serialize(result);
}
std::string WebBridge::handleGetPrinterIdentity(const std::string& args) {
auto parsed = json::parse(args).as_object();
std::string handle = std::string(parsed["handle"].as_string());
auto device = HAL::DeviceManager::instance().getDevice(handle);
json::object result;
if (device && device->isOpen()) {
Business::PrinterHelper::setDevice(device);
result["success"] = true;
result["model"] = Business::PrinterHelper::getModelNumber();
result["serial"] = Business::PrinterHelper::getSerialNumber();
result["firmware"] = Business::PrinterHelper::getFirmwareVersion();
result["macAddress"] = Business::PrinterHelper::getMACAddress();
} else {
result["success"] = false;
result["error"] = "Device not connected";
}
return json::serialize(result);
}
std::string WebBridge::handleGetPrinterVariables(const std::string& args) {
auto parsed = json::parse(args).as_object();
std::string handle = std::string(parsed["handle"].as_string());
auto device = HAL::DeviceManager::instance().getDevice(handle);
json::object result;
if (device && device->isOpen()) {
Business::PrinterHelper::setDevice(device);
std::string response = Business::PrinterHelper::commandWaitResponse(
Business::PrinterHelper::queryVariable("all"));
result["success"] = true;
result["rawResponse"] = response;
result["variables"] = json::object{};
} else {
result["success"] = false;
result["error"] = "Device not connected";
}
return json::serialize(result);
}
std::string WebBridge::handleSetVariable(const std::string& args) {
auto parsed = json::parse(args).as_object();
std::string handle = std::string(parsed["handle"].as_string());
std::string varName = std::string(parsed["varName"].as_string());
std::string value = std::string(parsed["value"].as_string());
auto device = HAL::DeviceManager::instance().getDevice(handle);
json::object result;
if (device && device->isOpen()) {
Business::PrinterHelper::setDevice(device);
bool success = Business::PrinterHelper::setVariable(varName, value);
result["success"] = success;
} else {
result["success"] = false;
result["error"] = "Device not connected";
}
return json::serialize(result);
}
std::string WebBridge::handleCalibrateMedia(const std::string& args) {
auto parsed = json::parse(args).as_object();
std::string handle = std::string(parsed["handle"].as_string());
int mode = parsed.contains("mode") ? static_cast<int>(parsed["mode"].as_int64()) : 0;
auto device = HAL::DeviceManager::instance().getDevice(handle);
json::object result;
if (device && device->isOpen()) {
Business::PrinterHelper::setDevice(device);
bool success = Business::PrinterHelper::send(Business::PrinterHelper::calibrate(mode));
result["success"] = success;
} else {
result["success"] = false;
result["error"] = "Device not connected";
}
return json::serialize(result);
}
std::string WebBridge::handleFactoryReset(const std::string& args) {
auto parsed = json::parse(args).as_object();
std::string handle = std::string(parsed["handle"].as_string());
auto device = HAL::DeviceManager::instance().getDevice(handle);
json::object result;
if (device && device->isOpen()) {
Business::PrinterHelper::setDevice(device);
bool success = Business::PrinterHelper::send(Business::PrinterHelper::factoryRestore());
result["success"] = success;
} else {
result["success"] = false;
result["error"] = "Device not connected";
}
return json::serialize(result);
}
std::string WebBridge::handleFeedLabel(const std::string& args) {
auto parsed = json::parse(args).as_object();
std::string handle = std::string(parsed["handle"].as_string());
int lines = parsed.contains("lines") ? static_cast<int>(parsed["lines"].as_int64()) : 1;
auto device = HAL::DeviceManager::instance().getDevice(handle);
json::object result;
if (device && device->isOpen()) {
Business::PrinterHelper::setDevice(device);
bool success = Business::PrinterHelper::send(Business::PrinterHelper::feed(lines));
result["success"] = success;
} else {
result["success"] = false;
result["error"] = "Device not connected";
}
return json::serialize(result);
}
std::string WebBridge::handleGetPrintHeadTemperature(const std::string& args) {
auto parsed = json::parse(args).as_object();
std::string handle = std::string(parsed["handle"].as_string());
auto device = HAL::DeviceManager::instance().getDevice(handle);
json::object result;
if (device && device->isOpen()) {
Business::PrinterHelper::setDevice(device);
std::string response = Business::PrinterHelper::commandWaitResponse(
"!SHOW AD\r\n");
result["success"] = true;
result["rawResponse"] = response;
int temp = 25;
std::regex tempRegex(R"((?:PHT|PRINT\s*HEAD\s*TEMP)\s*=\s*(\d+))", std::regex::icase);
std::smatch match;
if (std::regex_search(response, match, tempRegex)) {
temp = std::stoi(match[1].str());
}
result["tempCelsius"] = temp;
} else {
result["success"] = false;
result["error"] = "Device not connected";
}
return json::serialize(result);
}
std::string WebBridge::handleGetMediaSensors(const std::string& args) {
auto parsed = json::parse(args).as_object();
std::string handle = std::string(parsed["handle"].as_string());
auto device = HAL::DeviceManager::instance().getDevice(handle);
json::object result;
if (device && device->isOpen()) {
Business::PrinterHelper::setDevice(device);
std::string response = Business::PrinterHelper::commandWaitResponse(
"!QI\r\n");
result["success"] = true;
result["rawResponse"] = response;
int gapSensor = 128;
int markSensor = 64;
std::regex gapRegex(R"(GAP(?:\s*SENSOR)?\s*=\s*(\d+))", std::regex::icase);
std::regex markRegex(R"(MARK(?:\s*SENSOR)?\s*=\s*(\d+))", std::regex::icase);
std::smatch match;
if (std::regex_search(response, match, gapRegex)) {
gapSensor = std::stoi(match[1].str());
}
if (std::regex_search(response, match, markRegex)) {
markSensor = std::stoi(match[1].str());
}
result["gapSensor"] = gapSensor;
result["markSensor"] = markSensor;
} else {
result["success"] = false;
result["error"] = "Device not connected";
}
return json::serialize(result);
}
std::string WebBridge::handleGetPrintStatistics(const std::string& args) {
auto parsed = json::parse(args).as_object();
std::string handle = std::string(parsed["handle"].as_string());
auto device = HAL::DeviceManager::instance().getDevice(handle);
json::object result;
if (device && device->isOpen()) {
Business::PrinterHelper::setDevice(device);
std::string response = Business::PrinterHelper::commandWaitResponse(
Business::PrinterHelper::queryVariable("STATS"));
result["success"] = true;
result["inchCount"] = 0;
result["labelCount"] = 0;
result["headLifePct"] = 100;
result["rawResponse"] = response;
} else {
result["success"] = false;
result["error"] = "Device not connected";
}
return json::serialize(result);
}
std::string WebBridge::handleResetPrinter(const std::string& args) {
auto parsed = json::parse(args).as_object();
std::string handle = std::string(parsed["handle"].as_string());
auto device = HAL::DeviceManager::instance().getDevice(handle);
json::object result;
if (device && device->isOpen()) {
Business::PrinterHelper::setDevice(device);
bool success = Business::PrinterHelper::send(Business::PrinterHelper::variableReset());
result["success"] = success;
} else {
result["success"] = false;
result["error"] = "Device not connected";
}
return json::serialize(result);
}
std::string WebBridge::handleCancelPrint(const std::string& args) {
auto parsed = json::parse(args).as_object();
std::string handle = std::string(parsed["handle"].as_string());
auto device = HAL::DeviceManager::instance().getDevice(handle);
json::object result;
if (device && device->isOpen()) {
Business::PrinterHelper::setDevice(device);
bool success = Business::PrinterHelper::send("!ABORT\r\n");
result["success"] = success;
} else {
result["success"] = false;
result["error"] = "Device not connected";
}
return json::serialize(result);
}
std::string WebBridge::handleGetFirmwareVersions(const std::string& args) {
auto parsed = json::parse(args).as_object();
std::string handle = std::string(parsed["handle"].as_string());
auto device = HAL::DeviceManager::instance().getDevice(handle);
json::object result;
if (device && device->isOpen()) {
Business::PrinterHelper::setDevice(device);
std::string mainVersion = Business::PrinterHelper::getFirmwareVersion();
result["success"] = true;
result["mainVersion"] = mainVersion;
result["bootVersion"] = "1.0.0";
} else {
result["success"] = false;
result["error"] = "Device not connected";
}
return json::serialize(result);
}
std::string WebBridge::handleGetMemoryInfo(const std::string& args) {
auto parsed = json::parse(args).as_object();
std::string handle = std::string(parsed["handle"].as_string());
auto device = HAL::DeviceManager::instance().getDevice(handle);
json::object result;
if (device && device->isOpen()) {
Business::PrinterHelper::setDevice(device);
std::string response = Business::PrinterHelper::commandWaitResponse(
Business::PrinterHelper::queryVariable("MEM"));
result["success"] = true;
result["ramFree"] = 1048576;
result["ramTotal"] = 2097152;
result["flashFree"] = 4194304;
result["flashTotal"] = 8388608;
result["rawResponse"] = response;
} else {
result["success"] = false;
result["error"] = "Device not connected";
}
return json::serialize(result);
}
std::string WebBridge::handleListObjects(const std::string& args) {
auto parsed = json::parse(args).as_object();
std::string handle = std::string(parsed["handle"].as_string());
std::string location = parsed.contains("location") ?
std::string(parsed["location"].as_string()) : "flash";
auto device = HAL::DeviceManager::instance().getDevice(handle);
json::object result;
if (device && device->isOpen()) {
Business::PrinterHelper::setDevice(device);
std::string cmd = "!LIST OBJECTS " + location + "\r\n";
std::string response = Business::PrinterHelper::commandWaitResponse(cmd);
result["success"] = true;
result["objects"] = json::array{};
result["rawResponse"] = response;
} else {
result["success"] = false;
result["error"] = "Device not connected";
}
return json::serialize(result);
}
std::string WebBridge::handleGetEventLog(const std::string& args) {
auto parsed = json::parse(args).as_object();
std::string handle = std::string(parsed["handle"].as_string());
auto device = HAL::DeviceManager::instance().getDevice(handle);
json::object result;
if (device && device->isOpen()) {
Business::PrinterHelper::setDevice(device);
std::string response = Business::PrinterHelper::commandWaitResponse(
Business::PrinterHelper::queryVariable("LOG"));
result["success"] = true;
result["events"] = json::array{};
result["rawResponse"] = response;
} else {
result["success"] = false;
result["error"] = "Device not connected";
}
return json::serialize(result);
}
std::string WebBridge::handleClearEventLog(const std::string& args) {
auto parsed = json::parse(args).as_object();
std::string handle = std::string(parsed["handle"].as_string());
auto device = HAL::DeviceManager::instance().getDevice(handle);
json::object result;
if (device && device->isOpen()) {
Business::PrinterHelper::setDevice(device);
bool success = Business::PrinterHelper::send("LOG CLEAR\r\n");
result["success"] = success;
} else {
result["success"] = false;
result["error"] = "Device not connected";
}
return json::serialize(result);
}
std::string WebBridge::handleRunSelfTest(const std::string& args) {
auto parsed = json::parse(args).as_object();
std::string handle = std::string(parsed["handle"].as_string());
[[maybe_unused]] std::string testType = parsed.contains("testType") ?
std::string(parsed["testType"].as_string()) : "basic";
auto device = HAL::DeviceManager::instance().getDevice(handle);
json::object result;
if (device && device->isOpen()) {
Business::PrinterHelper::setDevice(device);
std::string response = Business::PrinterHelper::commandWaitResponse(
Business::PrinterHelper::printSelfTest());
result["success"] = true;
result["results"] = json::object{};
result["rawResponse"] = response;
} else {
result["success"] = false;
result["error"] = "Device not connected";
}
return json::serialize(result);
}
std::string WebBridge::handleOpenFileDialog(const std::string& args) {
auto parsed = json::parse(args).as_object();
std::string filter = parsed.contains("filter") ?
std::string(parsed["filter"].as_string()) : "*.*";
std::string title = parsed.contains("title") ?
std::string(parsed["title"].as_string()) : "Open File";
json::object result;
if (wxTheApp && wxThread::IsMain()) {
wxFileDialog dialog(nullptr, wxString::FromUTF8(title), "", "",
wxString::FromUTF8(filter), wxFD_OPEN | wxFD_FILE_MUST_EXIST);
if (dialog.ShowModal() == wxID_OK) {
wxString selectedFile = dialog.GetPath();
result["success"] = true;
result["filePath"] = std::string(selectedFile.utf8_str());
} else {
result["success"] = false;
result["error"] = "Dialog cancelled";
}
} else {
result["success"] = false;
result["error"] = "UI not available";
}
return json::serialize(result);
}
std::string WebBridge::handleReadFile(const std::string& args) {
auto parsed = json::parse(args).as_object();
std::string filePath = std::string(parsed["filePath"].as_string());
json::object result;
if (!isPathSafe(filePath)) {
result["success"] = false;
result["error"] = "Invalid file path";
return json::serialize(result);
}
if (!std::filesystem::exists(filePath)) {
result["success"] = false;
result["error"] = "File not found";
return json::serialize(result);
}
auto fileSize = std::filesystem::file_size(filePath);
if (fileSize > HAL::MAX_OBJECT_SIZE) {
result["success"] = false;
result["error"] = "File exceeds maximum allowed size";
return json::serialize(result);
}
std::ifstream file(filePath, std::ios::binary);
if (file) {
std::stringstream buffer;
buffer << file.rdbuf();
result["success"] = true;
result["data"] = buffer.str();
} else {
result["success"] = false;
result["error"] = "Failed to open file";
}
return json::serialize(result);
}
std::string WebBridge::handleSaveFile(const std::string& args) {
auto parsed = json::parse(args).as_object();
std::string filePath = std::string(parsed["filePath"].as_string());
std::string data = std::string(parsed["data"].as_string());
json::object result;
if (!isPathSafe(filePath)) {
result["success"] = false;
result["error"] = "Invalid file path";
return json::serialize(result);
}
if (data.size() > HAL::MAX_OBJECT_SIZE) {
result["success"] = false;
result["error"] = "Data exceeds maximum allowed size";
return json::serialize(result);
}
std::ofstream file(filePath, std::ios::binary);
if (file) {
file.write(data.data(), data.size());
result["success"] = true;
} else {
result["success"] = false;
result["error"] = "Failed to save file";
}
return json::serialize(result);
}
std::string WebBridge::handleGetAppVersion(const std::string& ) {
json::object result;
result["version"] = "1.0.0";
result["buildDate"] = __DATE__;
wxString wxVer = wxVERSION_STRING;
result["wxVersion"] = std::string(wxVer.utf8_str());
return json::serialize(result);
}
std::string WebBridge::handleOpenExternalUrl(const std::string& args) {
auto parsed = json::parse(args).as_object();
std::string url = std::string(parsed["url"].as_string());
json::object result;
if (wxTheApp) {
bool success = wxLaunchDefaultBrowser(wxString::FromUTF8(url));
result["success"] = success;
} else {
result["success"] = false;
result["error"] = "UI not available";
}
return json::serialize(result);
}
std::string WebBridge::handleShowMessageBox(const std::string& args) {
auto parsed = json::parse(args).as_object();
std::string title = std::string(parsed["title"].as_string());
std::string message = std::string(parsed["message"].as_string());
std::string type = parsed.contains("type") ?
std::string(parsed["type"].as_string()) : "info";
json::object result;
if (wxTheApp) {
int style = wxOK;
if (type == "error") style |= wxICON_ERROR;
else if (type == "warning") style |= wxICON_WARNING;
else if (type == "question") style = wxYES_NO | wxICON_QUESTION;
else style |= wxICON_INFORMATION;
wxTheApp->CallAfter([=]() {
wxMessageBox(wxString::FromUTF8(message), wxString::FromUTF8(title), style);
});
result["button"] = "ok";
} else {
result["error"] = "UI not available";
}
return json::serialize(result);
}
std::string WebBridge::handleLoadSerialNumber(const std::string& args) {
auto parsed = json::parse(args).as_object();
std::string handle = std::string(parsed["handle"].as_string());
std::string serialNumber = std::string(parsed["serialNumber"].as_string());
auto device = HAL::DeviceManager::instance().getDevice(handle);
json::object result;
if (device && device->isOpen()) {
Business::PrinterHelper::setDevice(device);
bool success = Business::PrinterHelper::setVariable("SERIAL", serialNumber);
result["success"] = success;
} else {
result["success"] = false;
result["error"] = "Device not connected";
}
return json::serialize(result);
}
std::string WebBridge::handleLoadModelNumber(const std::string& args) {
auto parsed = json::parse(args).as_object();
std::string handle = std::string(parsed["handle"].as_string());
std::string modelNumber = std::string(parsed["modelNumber"].as_string());
auto device = HAL::DeviceManager::instance().getDevice(handle);
json::object result;
if (device && device->isOpen()) {
Business::PrinterHelper::setDevice(device);
bool success = Business::PrinterHelper::setVariable("MODEL", modelNumber);
result["success"] = success;
} else {
result["success"] = false;
result["error"] = "Device not connected";
}
return json::serialize(result);
}
std::string WebBridge::handleLoadMacAddress(const std::string& args) {
auto parsed = json::parse(args).as_object();
std::string handle = std::string(parsed["handle"].as_string());
std::string macAddress = std::string(parsed["macAddress"].as_string());
auto device = HAL::DeviceManager::instance().getDevice(handle);
json::object result;
if (device && device->isOpen()) {
Business::PrinterHelper::setDevice(device);
bool success = Business::PrinterHelper::setVariable("MAC", macAddress);
result["success"] = success;
} else {
result["success"] = false;
result["error"] = "Device not connected";
}
return json::serialize(result);
}
std::string WebBridge::handleRunMfgTest(const std::string& args) {
auto parsed = json::parse(args).as_object();
std::string handle = std::string(parsed["handle"].as_string());
[[maybe_unused]] std::string testSequence = parsed.contains("testSequence") ?
std::string(parsed["testSequence"].as_string()) : "standard";
auto device = HAL::DeviceManager::instance().getDevice(handle);
json::object result;
if (device && device->isOpen()) {
auto& engine = Business::TestEngine::instance();
Business::TestConfig config;
config.targetDevice = device;
engine.startTest(config);
result["success"] = true;
result["passed"] = true;
result["results"] = json::object{};
} else {
result["success"] = false;
result["error"] = "Device not connected";
}
return json::serialize(result);
}
std::string WebBridge::handleUpdateFirmware(const std::string& args) {
auto parsed = json::parse(args).as_object();
std::string handle = std::string(parsed["handle"].as_string());
std::string firmwareDataB64 = std::string(parsed["firmwareData"].as_string());
auto device = HAL::DeviceManager::instance().getDevice(handle);
json::object result;
if (!device || !device->isOpen()) {
result["success"] = false;
result["error"] = "Device not connected";
return json::serialize(result);
}
std::vector<uint8_t> firmwareData = Utilities::Base64::decode(firmwareDataB64);
if (firmwareData.empty()) {
result["success"] = false;
result["error"] = "Invalid firmware data";
return json::serialize(result);
}
try {
Business::PrinterHelper::setDevice(device);
Business::PrinterHelper::setVariable("BUFFER_TIMED_RESET", "100");
bool success = device->write(firmwareData);
if (success) {
result["success"] = true;
result["message"] = "Firmware upload complete. Printer may be rebooting.";
Business::PrinterHelper::setVariable("BUFFER_TIMED_RESET", "65534");
} else {
result["success"] = false;
result["error"] = "Failed to send firmware data";
}
} catch (const std::exception& e) {
result["success"] = false;
result["error"] = std::string("Exception: ") + e.what();
}
return json::serialize(result);
}
std::string WebBridge::handleVerifyFirmware(const std::string& args) {
auto parsed = json::parse(args).as_object();
std::string firmwareDataB64 = std::string(parsed["firmwareData"].as_string());
json::object result;
std::vector<uint8_t> firmwareData = Utilities::Base64::decode(firmwareDataB64);
if (firmwareData.size() < 128) {
result["success"] = false;
result["error"] = "Firmware file too small";
result["compatible"] = false;
return json::serialize(result);
}
std::string version = "0.0.0";
uint32_t checksum = 0;
for (uint8_t byte : firmwareData) {
checksum += byte;
}
char checksumStr[9];
snprintf(checksumStr, sizeof(checksumStr), "%08X", checksum);
result["success"] = true;
result["version"] = version;
result["checksum"] = std::string(checksumStr);
result["size"] = static_cast<int64_t>(firmwareData.size());
result["compatible"] = true;
return json::serialize(result);
}
std::string WebBridge::handleDownloadObject(const std::string& args) {
auto parsed = json::parse(args).as_object();
std::string handle = std::string(parsed["handle"].as_string());
std::string name = std::string(parsed["name"].as_string());
std::string type = std::string(parsed["type"].as_string());
std::string dataB64 = std::string(parsed["data"].as_string());
std::string location = parsed.contains("location") ?
std::string(parsed["location"].as_string()) : "flash";
auto device = HAL::DeviceManager::instance().getDevice(handle);
json::object result;
if (!device || !device->isOpen()) {
result["success"] = false;
result["error"] = "Device not connected";
return json::serialize(result);
}
std::vector<uint8_t> data = Utilities::Base64::decode(dataB64);
if (data.empty()) {
result["success"] = false;
result["error"] = "Invalid object data";
return json::serialize(result);
}
try {
Business::PrinterHelper::setDevice(device);
std::string storageCmd;
if (type == "font" || type == "FONT") {
storageCmd = "!+ FONT " + name + " " + std::to_string(data.size()) + " " + location + "\r\n";
} else if (type == "graphic" || type == "GRAPHIC" || type == "image") {
storageCmd = "GRAPHIC STORE \"" + name + "\" " + std::to_string(data.size()) + " " + location + "\r\n";
} else if (type == "cpr" || type == "CPR") {
storageCmd = "";
} else {
// Generic object
storageCmd = "OBJECT STORE \"" + name + "\" " + std::to_string(data.size()) + " " + location + "\r\n";
}
bool success = true;
if (!storageCmd.empty()) {
success = Business::PrinterHelper::send(storageCmd);
}
if (success) {
success = device->write(data);
}
result["success"] = success;
if (!success) {
result["error"] = "Failed to download object to printer";
}
} catch (const std::exception& e) {
result["success"] = false;
result["error"] = std::string("Exception: ") + e.what();
}
return json::serialize(result);
}
std::string WebBridge::handleDeleteObject(const std::string& args) {
auto parsed = json::parse(args).as_object();
std::string handle = std::string(parsed["handle"].as_string());
std::string name = std::string(parsed["name"].as_string());
auto device = HAL::DeviceManager::instance().getDevice(handle);
json::object result;
if (!device || !device->isOpen()) {
result["success"] = false;
result["error"] = "Device not connected";
return json::serialize(result);
}
try {
Business::PrinterHelper::setDevice(device);
std::string deleteCmd = "OBJECT DELETE \"" + name + "\"\r\n";
bool success = Business::PrinterHelper::send(deleteCmd);
result["success"] = success;
} catch (const std::exception& e) {
result["success"] = false;
result["error"] = std::string("Exception: ") + e.what();
}
return json::serialize(result);
}
std::string WebBridge::handleGetNetworkConfig(const std::string& args) {
auto parsed = json::parse(args).as_object();
std::string handle = std::string(parsed["handle"].as_string());
auto device = HAL::DeviceManager::instance().getDevice(handle);
json::object result;
if (!device || !device->isOpen()) {
result["success"] = false;
result["error"] = "Device not connected";
return json::serialize(result);
}
try {
Business::PrinterHelper::setDevice(device);
std::string dhcp = Business::PrinterHelper::getVariable("DHCP");
std::string ip = Business::PrinterHelper::getVariable("IP");
std::string netmask = Business::PrinterHelper::getVariable("NETMASK");
std::string gateway = Business::PrinterHelper::getVariable("GATEWAY");
std::string mac = Business::PrinterHelper::getMACAddress();
std::string hostname = Business::PrinterHelper::getVariable("HOSTNAME");
result["success"] = true;
result["dhcp"] = (dhcp == "ON" || dhcp == "1" || dhcp == "TRUE");
result["ip"] = ip.empty() ? "0.0.0.0" : ip;
result["netmask"] = netmask.empty() ? "255.255.255.0" : netmask;
result["gateway"] = gateway.empty() ? "0.0.0.0" : gateway;
result["mac"] = mac.empty() ? "00:00:00:00:00:00" : mac;
result["hostname"] = hostname;
} catch (const std::exception& e) {
result["success"] = false;
result["error"] = std::string("Exception: ") + e.what();
}
return json::serialize(result);
}
std::string WebBridge::handleSetNetworkConfig(const std::string& args) {
auto parsed = json::parse(args).as_object();
std::string handle = std::string(parsed["handle"].as_string());
auto config = parsed["config"].as_object();
auto device = HAL::DeviceManager::instance().getDevice(handle);
json::object result;
if (!device || !device->isOpen()) {
result["success"] = false;
result["error"] = "Device not connected";
return json::serialize(result);
}
try {
Business::PrinterHelper::setDevice(device);
if (config.contains("dhcp")) {
bool dhcp = config["dhcp"].as_bool();
Business::PrinterHelper::setVariable("DHCP", dhcp ? "ON" : "OFF");
}
if (config.contains("ip")) {
Business::PrinterHelper::setVariable("IP", std::string(config["ip"].as_string()));
}
if (config.contains("netmask")) {
Business::PrinterHelper::setVariable("NETMASK", std::string(config["netmask"].as_string()));
}
if (config.contains("gateway")) {
Business::PrinterHelper::setVariable("GATEWAY", std::string(config["gateway"].as_string()));
}
if (config.contains("hostname")) {
Business::PrinterHelper::setVariable("HOSTNAME", std::string(config["hostname"].as_string()));
}
result["success"] = true;
} catch (const std::exception& e) {
result["success"] = false;
result["error"] = std::string("Exception: ") + e.what();
}
return json::serialize(result);
}
std::string WebBridge::handleGetBluetoothConfig(const std::string& args) {
auto parsed = json::parse(args).as_object();
std::string handle = std::string(parsed["handle"].as_string());
auto device = HAL::DeviceManager::instance().getDevice(handle);
json::object result;
if (!device || !device->isOpen()) {
result["success"] = false;
result["error"] = "Device not connected";
return json::serialize(result);
}
try {
Business::PrinterHelper::setDevice(device);
std::string btName = Business::PrinterHelper::getVariable("BT_NAME");
std::string btPin = Business::PrinterHelper::getVariable("BT_PIN");
std::string btDiscoverable = Business::PrinterHelper::getVariable("BT_DISCOVERABLE");
result["success"] = true;
result["name"] = btName.empty() ? "" : btName;
result["pin"] = btPin.empty() ? "0000" : btPin;
result["discoverable"] = (btDiscoverable == "ON" || btDiscoverable == "1" || btDiscoverable == "TRUE");
result["paired"] = json::array{};
} catch (const std::exception& e) {
result["success"] = false;
result["error"] = std::string("Exception: ") + e.what();
}
return json::serialize(result);
}
std::string WebBridge::handleSetBluetoothConfig(const std::string& args) {
auto parsed = json::parse(args).as_object();
std::string handle = std::string(parsed["handle"].as_string());
auto config = parsed["config"].as_object();
auto device = HAL::DeviceManager::instance().getDevice(handle);
json::object result;
if (!device || !device->isOpen()) {
result["success"] = false;
result["error"] = "Device not connected";
return json::serialize(result);
}
try {
Business::PrinterHelper::setDevice(device);
if (config.contains("name")) {
Business::PrinterHelper::setVariable("BT_NAME", std::string(config["name"].as_string()));
}
if (config.contains("pin")) {
Business::PrinterHelper::setVariable("BT_PIN", std::string(config["pin"].as_string()));
}
if (config.contains("discoverable")) {
bool discoverable = config["discoverable"].as_bool();
Business::PrinterHelper::setVariable("BT_DISCOVERABLE", discoverable ? "ON" : "OFF");
}
result["success"] = true;
} catch (const std::exception& e) {
result["success"] = false;
result["error"] = std::string("Exception: ") + e.what();
}
return json::serialize(result);
}
std::string WebBridge::handleConvertImage(const std::string& args) {
auto parsed = json::parse(args).as_object();
std::string imageDataB64 = std::string(parsed["imageData"].as_string());
json::object options = parsed.contains("options") ? parsed["options"].as_object() : json::object{};
json::object result;
std::vector<uint8_t> imageData = Utilities::Base64::decode(imageDataB64);
if (imageData.empty()) {
result["success"] = false;
result["error"] = "Invalid image data";
return json::serialize(result);
}
int dpi = options.contains("dpi") ? static_cast<int>(options["dpi"].as_int64()) : 200;
int threshold = options.contains("threshold") ? static_cast<int>(options["threshold"].as_int64()) : 128;
bool dither = options.contains("dither") ? options["dither"].as_bool() : false;
result["success"] = true;
result["width"] = 0;
result["height"] = 0;
result["dpi"] = dpi;
result["threshold"] = threshold;
result["dither"] = dither;
result["data"] = imageDataB64;
result["format"] = "PCX";
return json::serialize(result);
}
std::string WebBridge::handleGenerateBarcode(const std::string& args) {
auto parsed = json::parse(args).as_object();
std::string barcodeType = std::string(parsed["type"].as_string());
std::string data = std::string(parsed["data"].as_string());
json::object options = parsed.contains("options") ? parsed["options"].as_object() : json::object{};
json::object result;
int height = options.contains("height") ? static_cast<int>(options["height"].as_int64()) : 50;
int width = options.contains("width") ? static_cast<int>(options["width"].as_int64()) : 2;
bool humanReadable = options.contains("humanReadable") ? options["humanReadable"].as_bool() : true;
std::string symbology;
if (barcodeType == "CODE128" || barcodeType == "code128") {
symbology = "128";
} else if (barcodeType == "CODE39" || barcodeType == "code39") {
symbology = "39";
} else if (barcodeType == "EAN13" || barcodeType == "ean13") {
symbology = "EAN13";
} else if (barcodeType == "UPC-A" || barcodeType == "upca") {
symbology = "UPCA";
} else if (barcodeType == "QR" || barcodeType == "qrcode") {
symbology = "QR";
} else if (barcodeType == "DATAMATRIX" || barcodeType == "datamatrix") {
symbology = "DATAMATRIX";
} else {
symbology = barcodeType;
}
std::string cpl;
if (symbology == "QR" || symbology == "DATAMATRIX") {
cpl = "BARCODE " + symbology + " 100 100 M=" + std::to_string(width) + " \"" + data + "\"\r\n";
} else {
cpl = "BARCODE " + symbology + " 100 100 " + std::to_string(height) + " " +
std::to_string(width) + " " + (humanReadable ? "1" : "0") + " \"" + data + "\"\r\n";
}
result["success"] = true;
result["cpl"] = cpl;
result["symbology"] = symbology;
return json::serialize(result);
}
std::string WebBridge::handleGetAdcReadings(const std::string& args) {
auto parsed = json::parse(args).as_object();
std::string handle = std::string(parsed["handle"].as_string());
auto device = HAL::DeviceManager::instance().getDevice(handle);
json::object result;
if (!device || !device->isOpen()) {
result["success"] = false;
result["error"] = "Device not connected";
return json::serialize(result);
}
try {
Business::PrinterHelper::setDevice(device);
std::string response = Business::PrinterHelper::commandWaitResponse(
Business::PrinterHelper::queryVariable("ADC"));
json::object readings;
readings["gapSensor"] = 128;
readings["markSensor"] = 64;
readings["headTemp"] = 25;
readings["voltage"] = 24000;
result["success"] = true;
result["readings"] = readings;
result["rawResponse"] = response;
} catch (const std::exception& e) {
result["success"] = false;
result["error"] = std::string("Exception: ") + e.what();
}
return json::serialize(result);
}
std::string WebBridge::handleDumpMemory(const std::string& args) {
auto parsed = json::parse(args).as_object();
std::string handle = std::string(parsed["handle"].as_string());
uint32_t address = parsed.contains("address") ?
static_cast<uint32_t>(parsed["address"].as_int64()) : 0;
size_t length = parsed.contains("length") ?
static_cast<size_t>(parsed["length"].as_int64()) : 256;
auto device = HAL::DeviceManager::instance().getDevice(handle);
json::object result;
if (!device || !device->isOpen()) {
result["success"] = false;
result["error"] = "Device not connected";
return json::serialize(result);
}
if (length > 4096) length = 4096;
std::vector<uint8_t> data(length, 0);
std::string encoded = Utilities::Base64::encode(data);
result["success"] = true;
result["address"] = static_cast<int64_t>(address);
result["length"] = static_cast<int64_t>(length);
result["data"] = encoded;
return json::serialize(result);
}
std::string WebBridge::handleSaveFileDialog(const std::string& args) {
auto parsed = json::parse(args).as_object();
std::string filter = parsed.contains("filter") ?
std::string(parsed["filter"].as_string()) : "*.*";
std::string title = parsed.contains("title") ?
std::string(parsed["title"].as_string()) : "Save File";
std::string defaultName = parsed.contains("defaultName") ?
std::string(parsed["defaultName"].as_string()) : "";
json::object result;
// File dialogs must be shown on the UI thread synchronously
if (wxTheApp && wxThread::IsMain()) {
wxFileDialog dialog(nullptr, wxString::FromUTF8(title), "",
wxString::FromUTF8(defaultName),
wxString::FromUTF8(filter),
wxFD_SAVE | wxFD_OVERWRITE_PROMPT);
if (dialog.ShowModal() == wxID_OK) {
wxString selectedFile = dialog.GetPath();
result["success"] = true;
result["filePath"] = std::string(selectedFile.utf8_str());
} else {
result["success"] = false;
result["error"] = "Dialog cancelled";
}
} else {
result["success"] = false;
result["error"] = "Must be called on UI thread";
}
return json::serialize(result);
}
}
```
## File: CAdmin/Backend/WebBridge.hpp
```
#pragma once
#include <wx/webview.h>
#include <string>
#include <functional>
#include <map>
#include <memory>
#include <vector>
namespace Cognitive::UI {
struct RPCRequest {
std::string id;
std::string method;
std::string params;
bool fromJson(const std::string& json);
};
struct RPCResponse {
std::string id;
bool success = true;
std::string result;
std::string error;
int errorCode = 0;
[[nodiscard]] std::string toJson() const;
static RPCResponse ok(const std::string& id, const std::string& result);
static RPCResponse err(const std::string& id, const std::string& error, int code = -1);
};
using RPCHandler = std::function<std::string(const std::string& params)>;
using EventCallback = std::function<void(const std::string& event, const std::string& data)>;
class WebBridge {
public:
explicit WebBridge(wxWebView* webView);
~WebBridge();
WebBridge(const WebBridge&) = delete;
WebBridge& operator=(const WebBridge&) = delete;
void handleMessage(const std::string& message);
RPCResponse processRequest(const RPCRequest& request);
void sendToJS(const std::string& event, const std::string& data);
void sendEvent(const std::string& event, const std::string& data) { sendToJS(event, data); }
std::string getJavaScriptAPI() const;
void sendResponse(const RPCResponse& response);
void executeScript(const std::string& script);
void callJSFunction(const std::string& functionName, const std::string& argsJson = "[]");
void registerHandler(const std::string& method, RPCHandler handler);
void unregisterHandler(const std::string& method);
[[nodiscard]] bool hasHandler(const std::string& method) const;
[[nodiscard]] std::vector<std::string> getRegisteredMethods() const;
void setupDefaultHandlers();
size_t subscribeToEvents(EventCallback callback);
void unsubscribeFromEvents(size_t subscriptionId);
void injectBridgeScript();
static std::string getBridgeScript();
void setWebView(wxWebView* webView);
[[nodiscard]] wxWebView* getWebView() const { return webView_; }
private:
wxWebView* webView_;
std::map<std::string, RPCHandler> handlers_;
std::map<size_t, EventCallback> eventCallbacks_;
size_t nextCallbackId_ = 0;
std::string handleScanDevices(const std::string& args);
std::string handleConnect(const std::string& args);
std::string handleDisconnect(const std::string& args);
std::string handleGetDeviceStatus(const std::string& args);
std::string handlePrintLabel(const std::string& args);
std::string handlePrintTestLabel(const std::string& args);
std::string handleSendRawData(const std::string& args);
std::string handleQueryStatus(const std::string& args);
std::string handleQuerySettings(const std::string& args);
std::string handleSetDarkness(const std::string& args);
std::string handleSetSpeed(const std::string& args);
std::string handleCalibrate(const std::string& args);
std::string handleStartTest(const std::string& args);
std::string handleStopTest(const std::string& args);
std::string handleGetTestStatus(const std::string& args);
std::string handleGetConfig(const std::string& args);
std::string handleSetConfig(const std::string& args);
std::string handleSaveConfig(const std::string& args);
std::string handleLoadConfig(const std::string& args);
std::string handleGetProfiles(const std::string& args);
std::string handleSaveProfile(const std::string& args);
std::string handleDeleteProfile(const std::string& args);
std::string handleParseCPL(const std::string& args);
std::string handleValidateCPL(const std::string& args);
std::string handleSetTheme(const std::string& args);
std::string handleSetBorderless(const std::string& args);
std::string handleWindowControl(const std::string& args);
std::string handleEnumerateSerialPorts(const std::string& args);
std::string handleDiscoverNetworkPrinters(const std::string& args);
std::string handleDiscoverBluetoothPrinters(const std::string& args);
std::string handleEnumerateUsbPrinters(const std::string& args);
std::string handleOpenSerialPort(const std::string& args);
std::string handleOpenTcpConnection(const std::string& args);
std::string handleOpenUsbConnection(const std::string& args);
std::string handleOpenBluetoothConnection(const std::string& args);
std::string handleCloseConnection(const std::string& args);
std::string handleSendData(const std::string& args);
std::string handleSendCommand(const std::string& args);
std::string handleReceiveData(const std::string& args);
std::string handleGetPrinterStatus(const std::string& args);
std::string handleGetPrinterIdentity(const std::string& args);
std::string handleGetPrinterVariables(const std::string& args);
std::string handleSetVariable(const std::string& args);
std::string handleFeedLabel(const std::string& args);
std::string handleCalibrateMedia(const std::string& args);
std::string handleFactoryReset(const std::string& args);
std::string handleGetPrintHeadTemperature(const std::string& args);
std::string handleGetMediaSensors(const std::string& args);
std::string handleGetPrintStatistics(const std::string& args);
std::string handleResetPrinter(const std::string& args);
std::string handleCancelPrint(const std::string& args);
std::string handleGetFirmwareVersions(const std::string& args);
std::string handleGetMemoryInfo(const std::string& args);
std::string handleListObjects(const std::string& args);
std::string handleGetEventLog(const std::string& args);
std::string handleClearEventLog(const std::string& args);
std::string handleRunSelfTest(const std::string& args);
std::string handleOpenFileDialog(const std::string& args);
std::string handleReadFile(const std::string& args);
std::string handleSaveFile(const std::string& args);
std::string handleGetAppVersion(const std::string& args);
std::string handleOpenExternalUrl(const std::string& args);
std::string handleShowMessageBox(const std::string& args);
std::string handleLoadSerialNumber(const std::string& args);
std::string handleLoadModelNumber(const std::string& args);
std::string handleLoadMacAddress(const std::string& args);
std::string handleRunMfgTest(const std::string& args);
std::string handleUpdateFirmware(const std::string& args);
std::string handleVerifyFirmware(const std::string& args);
std::string handleDownloadObject(const std::string& args);
std::string handleDeleteObject(const std::string& args);
std::string handleGetNetworkConfig(const std::string& args);
std::string handleSetNetworkConfig(const std::string& args);
std::string handleGetBluetoothConfig(const std::string& args);
std::string handleSetBluetoothConfig(const std::string& args);
std::string handleConvertImage(const std::string& args);
std::string handleGenerateBarcode(const std::string& args);
std::string handleGetAdcReadings(const std::string& args);
std::string handleDumpMemory(const std::string& args);
std::string handleSaveFileDialog(const std::string& args);
};
}
```
## File: CAdmin/CAdmin.sln
```
Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.0.31903.59
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "CAdmin", "CAdmin.vcxproj", "{A1B2C3D4-E5F6-7890-ABCD-EF1234567890}"
EndProject
Global
GlobalSection(SolutionConfigurationPlatforms) = preSolution
Debug|x64 = Debug|x64
Release|x64 = Release|x64
EndGlobalSection
GlobalSection(ProjectConfigurationPlatforms) = postSolution
{A1B2C3D4-E5F6-7890-ABCD-EF1234567890}.Debug|x64.ActiveCfg = Debug|x64
{A1B2C3D4-E5F6-7890-ABCD-EF1234567890}.Debug|x64.Build.0 = Debug|x64
{A1B2C3D4-E5F6-7890-ABCD-EF1234567890}.Release|x64.ActiveCfg = Release|x64
{A1B2C3D4-E5F6-7890-ABCD-EF1234567890}.Release|x64.Build.0 = Release|x64
EndGlobalSection
GlobalSection(SolutionProperties) = preSolution
HideSolutionNode = FALSE
EndGlobalSection
EndGlobal
```
## File: CAdmin/CAdmin.vcxproj
```
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
<ItemGroup Label="ProjectConfigurations">
<ProjectConfiguration Include="Debug|x64">
<Configuration>Debug</Configuration>
<Platform>x64</Platform>
</ProjectConfiguration>
<ProjectConfiguration Include="Release|x64">
<Configuration>Release</Configuration>
<Platform>x64</Platform>
</ProjectConfiguration>
</ItemGroup>
<Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
<PropertyGroup Label="Globals">
<ProjectGuid>{A1B2C3D4-E5F6-7890-ABCD-EF1234567890}</ProjectGuid>
<RootNamespace>CAdmin</RootNamespace>
<ProjectName>CAdmin</ProjectName>
<WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
<VcpkgTriplet>x64-llvm</VcpkgTriplet>
<VcpkgRoot>C:\Code\vcpkg</VcpkgRoot>
<VcpkgEnabled>true</VcpkgEnabled>
<VcpkgEnableManifest>false</VcpkgEnableManifest>
</PropertyGroup>
<PropertyGroup Label="Configuration" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
<ConfigurationType>Application</ConfigurationType>
<UseDebugLibraries>true</UseDebugLibraries>
<PlatformToolset>ClangCL</PlatformToolset>
<CharacterSet>Unicode</CharacterSet>
<PreferredToolArchitecture>x64</PreferredToolArchitecture>
<UseOfMfc>Static</UseOfMfc>
<UseDynamicDebugging>true</UseDynamicDebugging>
<LLVMToolsVersion>20</LLVMToolsVersion>
</PropertyGroup>
<PropertyGroup Label="Configuration" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
<ConfigurationType>Application</ConfigurationType>
<UseDebugLibraries>false</UseDebugLibraries>
<PlatformToolset>ClangCL</PlatformToolset>
<CharacterSet>NotSet</CharacterSet>
<WholeProgramOptimization>true</WholeProgramOptimization>
<UseOfMfc>false</UseOfMfc>
<LLVMToolsVersion>20</LLVMToolsVersion>
<PreferredToolArchitecture>x64</PreferredToolArchitecture>
</PropertyGroup>
<Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
<!-- vcpkg integration -->
<Import Project="$(VcpkgRoot)\scripts\buildsystems\msbuild\vcpkg.props" Condition="Exists('$(VcpkgRoot)\scripts\buildsystems\msbuild\vcpkg.props')" />
<PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
<OutDir>$(ProjectDir)Builds\$(Configuration) ($(Platform))\</OutDir>
<IntDir>$(ProjectDir)Builds\$(Configuration) ($(Platform))\Objects\$(ProjectName)\</IntDir>
<ManagedAssembly>false</ManagedAssembly>
<LinkIncremental>false</LinkIncremental>
<GenerateManifest>false</GenerateManifest>
</PropertyGroup>
<PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
<IntDir>$(ProjectDir)Builds\$(Configuration) ($(Platform))\Objects\$(ProjectName)\</IntDir>
<OutDir>$(ProjectDir)Builds\$(Configuration) ($(Platform))\</OutDir>
<ManagedAssembly>false</ManagedAssembly>
</PropertyGroup>
<PropertyGroup Label="Vcpkg">
<VcpkgManifestInstall>true</VcpkgManifestInstall>
<VcpkgAutoLink>false</VcpkgAutoLink>
<VcpkgApplocalDeps>true</VcpkgApplocalDeps>
<VcpkgXUseBuiltInApplocalDeps>false</VcpkgXUseBuiltInApplocalDeps>
</PropertyGroup>
<PropertyGroup Label="Vcpkg" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
<VcpkgUseStatic>true</VcpkgUseStatic>
<VcpkgUseMD>false</VcpkgUseMD>
<VcpkgHostTriplet>
</VcpkgHostTriplet>
<VcpkgConfiguration>Release</VcpkgConfiguration>
</PropertyGroup>
<PropertyGroup Label="Vcpkg" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
<VcpkgUseMD>false</VcpkgUseMD>
<VcpkgUseStatic>true</VcpkgUseStatic>
</PropertyGroup>
<ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
<ClCompile>
<WarningLevel>TurnOffAllWarnings</WarningLevel>
<Optimization>Disabled</Optimization>
<SDLCheck>true</SDLCheck>
<PreprocessorDefinitions>_DEBUG;_WINDOWS;WIN32_LEAN_AND_MEAN;NOMINMAX;%(PreprocessorDefinitions)</PreprocessorDefinitions>
<ConformanceMode>true</ConformanceMode>
<LanguageStandard>stdcpp17</LanguageStandard>
<RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
<AdditionalIncludeDirectories>$(ProjectDir)Backend;$(VcpkgRoot)\installed\$(VcpkgTriplet)\include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
<ExceptionHandling>Sync</ExceptionHandling>
<AdditionalOptions>/EHsc %(AdditionalOptions)</AdditionalOptions>
<LanguageStandard_C>stdclatest</LanguageStandard_C>
<MultiProcessorCompilation>true</MultiProcessorCompilation>
<RuntimeTypeInfo>true</RuntimeTypeInfo>
<BuildStlModules>true</BuildStlModules>
</ClCompile>
<Link>
<SubSystem>Windows</SubSystem>
<GenerateDebugInformation>true</GenerateDebugInformation>
<AdditionalLibraryDirectories>$(VcpkgRoot)\installed\$(VcpkgTriplet)\debug\lib;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
<AdditionalDependencies>wxbase33ud.lib;wxmsw33ud_core.lib;wxmsw33ud_webview.lib;wxmsw33ud_html.lib;wxmsw33ud_adv.lib;wxbase33ud_net.lib;wxbase33ud_xml.lib;wxlexillad.lib;wxscintillad.lib;lzma.lib;libusb-1.0.lib;libssl.lib;libcrypto.lib;zlib.lib;libpng16.lib;libjpeg.lib;libtiff.lib;SetupAPI.lib;WinUsb.lib;ws2_32.lib;Crypt32.lib;Bcrypt.lib;Comctl32.lib;Rpcrt4.lib;Ole32.lib;OleAut32.lib;Uuid.lib;Shlwapi.lib;Version.lib;UxTheme.lib;Wininet.lib;Winspool.lib;%(AdditionalDependencies)</AdditionalDependencies>
<ForceFileOutput>MultiplyDefinedSymbolOnly</ForceFileOutput>
</Link>
</ItemDefinitionGroup>
<ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
<ClCompile>
<WarningLevel>TurnOffAllWarnings</WarningLevel>
<Optimization>MaxSpeed</Optimization>
<FunctionLevelLinking>true</FunctionLevelLinking>
<IntrinsicFunctions>true</IntrinsicFunctions>
<SDLCheck>false</SDLCheck>
<PreprocessorDefinitions>NDEBUG;_WINDOWS;WIN32_LEAN_AND_MEAN;NOMINMAX;_CRT_SECURE_NO_WARNINGS;wxUSE_NO_MANIFEST;__WXMSW__;UNICODE;_UNICODE</PreprocessorDefinitions>
<ConformanceMode>true</ConformanceMode>
<LanguageStandard>stdcpplatest</LanguageStandard>
<RuntimeLibrary>MultiThreaded</RuntimeLibrary>
<AdditionalIncludeDirectories>$(ProjectDir)Backend;$(VcpkgRoot)\installed\$(VcpkgTriplet)\include;$(VcpkgRoot)\installed\$(VcpkgTriplet)\include\boost;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
<ExceptionHandling>SyncCThrow</ExceptionHandling>
<AdditionalOptions>/Ob3</AdditionalOptions>
<LanguageStandard_C>stdclatest</LanguageStandard_C>
<MultiProcessorCompilation>true</MultiProcessorCompilation>
<DebugInformationFormat>None</DebugInformationFormat>
<InlineFunctionExpansion>AnySuitable</InlineFunctionExpansion>
<FavorSizeOrSpeed>Speed</FavorSizeOrSpeed>
<EnableFiberSafeOptimizations>true</EnableFiberSafeOptimizations>
<StringPooling>true</StringPooling>
<ControlFlowGuard>Guard</ControlFlowGuard>
<EnableEnhancedInstructionSet>AdvancedVectorExtensions2</EnableEnhancedInstructionSet>
<FloatingPointExceptions>false</FloatingPointExceptions>
<IntelJCCErratum>true</IntelJCCErratum>
<GuardEHContMetadata>true</GuardEHContMetadata>
<RuntimeTypeInfo>true</RuntimeTypeInfo>
<BuildStlModules>true</BuildStlModules>
<UseStandardPreprocessor>true</UseStandardPreprocessor>
<OmitFramePointers>true</OmitFramePointers>
<EnableParallelCodeGeneration>true</EnableParallelCodeGeneration>
<EnableVectorLength>VectorLength256</EnableVectorLength>
<EnforceTypeConversionRules>false</EnforceTypeConversionRules>
<OpenMPSupport>false</OpenMPSupport>
<EnableModules>false</EnableModules>
<UseUnicodeForAssemblerListing>true</UseUnicodeForAssemblerListing>
<CallingConvention>Cdecl</CallingConvention>
</ClCompile>
<Link>
<SubSystem>Windows</SubSystem>
<EnableCOMDATFolding>true</EnableCOMDATFolding>
<OptimizeReferences>true</OptimizeReferences>
<GenerateDebugInformation>false</GenerateDebugInformation>
<AdditionalLibraryDirectories>$(VcpkgRoot)\installed\$(VcpkgTriplet)\lib;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
<AdditionalDependencies>wxbase33u.lib;wxmsw33u_core.lib;wxmsw33u_webview.lib;wxmsw33u_html.lib;wxmsw33u_adv.lib;wxbase33u_net.lib;wxbase33u_xml.lib;wxlexilla.lib;wxscintilla.lib;boost_json-vc143-mt-x64-1_89.lib;boost_filesystem-vc143-mt-x64-1_89.lib;boost_thread-vc143-mt-x64-1_89.lib;boost_chrono-vc143-mt-x64-1_89.lib;boost_atomic-vc143-mt-x64-1_89.lib;boost_container-vc143-mt-x64-1_89.lib;boost_context-vc143-mt-x64-1_89.lib;boost_date_time-vc143-mt-x64-1_89.lib;lzma.lib;libusb-1.0.lib;libssl.lib;libcrypto.lib;zlib.lib;libpng16.lib;jpeg.lib;tiff.lib;libwebp.lib;libwebpdemux.lib;libwebpmux.lib;libsharpyuv.lib;nanosvg.lib;nanosvgrast.lib;SetupAPI.lib;WinUsb.lib;ws2_32.lib;Crypt32.lib;Bcrypt.lib;Comctl32.lib;Rpcrt4.lib;Ole32.lib;OleAut32.lib;Uuid.lib;Shlwapi.lib;Version.lib;UxTheme.lib;Wininet.lib;Winspool.lib;%(AdditionalDependencies)</AdditionalDependencies>
<LinkStatus>false</LinkStatus>
<TreatLinkerWarningAsErrors>false</TreatLinkerWarningAsErrors>
<IgnoreAllDefaultLibraries>false</IgnoreAllDefaultLibraries>
<AssemblyDebug>false</AssemblyDebug>
<LargeAddressAware>true</LargeAddressAware>
<LinkTimeCodeGeneration>UseLinkTimeCodeGeneration</LinkTimeCodeGeneration>
<FixedBaseAddress>false</FixedBaseAddress>
<ForceFileOutput>MultiplyDefinedSymbolOnly</ForceFileOutput>
</Link>
<ProjectReference>
<UseLibraryDependencyInputs>true</UseLibraryDependencyInputs>
</ProjectReference>
</ItemDefinitionGroup>
<ItemGroup>
<ClCompile Include="Backend\Application.cpp" />
<ClCompile Include="Backend\BTDevice.cpp" />
<ClCompile Include="Backend\Compression.cpp" />
<ClCompile Include="Backend\Configurator.cpp" />
<ClCompile Include="Backend\CPLParser.cpp" />
<ClCompile Include="Backend\Device.cpp" />
<ClCompile Include="Backend\DeviceManager.cpp" />
<ClCompile Include="Backend\HttpClient.cpp" />
<ClCompile Include="Backend\HttpServer.cpp" />
<ClCompile Include="Backend\LANDevice.cpp" />
<ClCompile Include="Backend\main.cpp" />
<ClCompile Include="Backend\MainFrame.cpp" />
<ClCompile Include="Backend\Obfuscation.cpp" />
<ClCompile Include="Backend\PrinterHelper.cpp" />
<ClCompile Include="Backend\SerialDevice.cpp" />
<ClCompile Include="Backend\ShowcaseResource.cpp" />
<ClCompile Include="Backend\TestEngine.cpp" />
<ClCompile Include="Backend\USBDevice.cpp" />
<ClCompile Include="Backend\WebBridge.cpp" />
</ItemGroup>
<ItemGroup>
<ClInclude Include="Backend\Application.hpp" />
<ClInclude Include="Backend\Base64.hpp" />
<ClInclude Include="Backend\BTDevice.hpp" />
<ClInclude Include="Backend\Compression.hpp" />
<ClInclude Include="Backend\Configurator.hpp" />
<ClInclude Include="Backend\CPLParser.hpp" />
<ClInclude Include="Backend\Device.hpp" />
<ClInclude Include="Backend\DeviceManager.hpp" />
<ClInclude Include="Backend\HttpClient.hpp" />
<ClInclude Include="Backend\HttpServer.hpp" />
<ClInclude Include="Backend\LANDevice.hpp" />
<ClInclude Include="Backend\MainFrame.hpp" />
<ClInclude Include="Backend\Obfuscation.hpp" />
<ClInclude Include="Backend\PrinterHelper.hpp" />
<ClInclude Include="Backend\SerialDevice.hpp" />
<ClInclude Include="Backend\ShowcaseResource.hpp" />
<ClInclude Include="Backend\TestEngine.hpp" />
<ClInclude Include="Backend\USBDevice.hpp" />
<ClInclude Include="Backend\WebBridge.hpp" />
</ItemGroup>
<Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
<Import Project="$(VcpkgRoot)\scripts\buildsystems\msbuild\vcpkg.targets" Condition="Exists('$(VcpkgRoot)\scripts\buildsystems\msbuild\vcpkg.targets')" />
</Project>
```
## File: CAdmin/CAdmin.vcxproj.filters
```
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
<ItemGroup>
<Filter Include="Source Files">
<UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
<Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
</Filter>
<Filter Include="Header Files">
<UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
<Extensions>h;hh;hpp;hxx;hm;inl;inc;ipp;xsd</Extensions>
</Filter>
</ItemGroup>
<ItemGroup>
<ClCompile Include="Backend\Application.cpp">
<Filter>Source Files</Filter>
</ClCompile>
<ClCompile Include="Backend\BTDevice.cpp">
<Filter>Source Files</Filter>
</ClCompile>
<ClCompile Include="Backend\Compression.cpp">
<Filter>Source Files</Filter>
</ClCompile>
<ClCompile Include="Backend\Configurator.cpp">
<Filter>Source Files</Filter>
</ClCompile>
<ClCompile Include="Backend\CPLParser.cpp">
<Filter>Source Files</Filter>
</ClCompile>
<ClCompile Include="Backend\Device.cpp">
<Filter>Source Files</Filter>
</ClCompile>
<ClCompile Include="Backend\DeviceManager.cpp">
<Filter>Source Files</Filter>
</ClCompile>
<ClCompile Include="Backend\HttpClient.cpp">
<Filter>Source Files</Filter>
</ClCompile>
<ClCompile Include="Backend\HttpServer.cpp">
<Filter>Source Files</Filter>
</ClCompile>
<ClCompile Include="Backend\LANDevice.cpp">
<Filter>Source Files</Filter>
</ClCompile>
<ClCompile Include="Backend\main.cpp">
<Filter>Source Files</Filter>
</ClCompile>
<ClCompile Include="Backend\MainFrame.cpp">
<Filter>Source Files</Filter>
</ClCompile>
<ClCompile Include="Backend\Obfuscation.cpp">
<Filter>Source Files</Filter>
</ClCompile>
<ClCompile Include="Backend\PrinterHelper.cpp">
<Filter>Source Files</Filter>
</ClCompile>
<ClCompile Include="Backend\SerialDevice.cpp">
<Filter>Source Files</Filter>
</ClCompile>
<ClCompile Include="Backend\ShowcaseResource.cpp">
<Filter>Source Files</Filter>
</ClCompile>
<ClCompile Include="Backend\TestEngine.cpp">
<Filter>Source Files</Filter>
</ClCompile>
<ClCompile Include="Backend\USBDevice.cpp">
<Filter>Source Files</Filter>
</ClCompile>
<ClCompile Include="Backend\WebBridge.cpp">
<Filter>Source Files</Filter>
</ClCompile>
</ItemGroup>
<ItemGroup>
<ClInclude Include="Backend\Application.hpp">
<Filter>Header Files</Filter>
</ClInclude>
<ClInclude Include="Backend\Base64.hpp">
<Filter>Header Files</Filter>
</ClInclude>
<ClInclude Include="Backend\BTDevice.hpp">
<Filter>Header Files</Filter>
</ClInclude>
<ClInclude Include="Backend\Compression.hpp">
<Filter>Header Files</Filter>
</ClInclude>
<ClInclude Include="Backend\Configurator.hpp">
<Filter>Header Files</Filter>
</ClInclude>
<ClInclude Include="Backend\CPLParser.hpp">
<Filter>Header Files</Filter>
</ClInclude>
<ClInclude Include="Backend\Device.hpp">
<Filter>Header Files</Filter>
</ClInclude>
<ClInclude Include="Backend\DeviceManager.hpp">
<Filter>Header Files</Filter>
</ClInclude>
<ClInclude Include="Backend\HttpClient.hpp">
<Filter>Header Files</Filter>
</ClInclude>
<ClInclude Include="Backend\HttpServer.hpp">
<Filter>Header Files</Filter>
</ClInclude>
<ClInclude Include="Backend\LANDevice.hpp">
<Filter>Header Files</Filter>
</ClInclude>
<ClInclude Include="Backend\MainFrame.hpp">
<Filter>Header Files</Filter>
</ClInclude>
<ClInclude Include="Backend\Obfuscation.hpp">
<Filter>Header Files</Filter>
</ClInclude>
<ClInclude Include="Backend\PrinterHelper.hpp">
<Filter>Header Files</Filter>
</ClInclude>
<ClInclude Include="Backend\SerialDevice.hpp">
<Filter>Header Files</Filter>
</ClInclude>
<ClInclude Include="Backend\ShowcaseResource.hpp">
<Filter>Header Files</Filter>
</ClInclude>
<ClInclude Include="Backend\TestEngine.hpp">
<Filter>Header Files</Filter>
</ClInclude>
<ClInclude Include="Backend\USBDevice.hpp">
<Filter>Header Files</Filter>
</ClInclude>
<ClInclude Include="Backend\WebBridge.hpp">
<Filter>Header Files</Filter>
</ClInclude>
</ItemGroup>
</Project>
```
## File: CAdmin/CAdmin.vcxproj.user
```
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
<PropertyGroup />
</Project>
```
## File: CAdmin/CMakeLists.txt
```
cmake_minimum_required(VERSION 3.20)
# ==================== VCPKG Configuration ====================
# Detect vcpkg toolchain file location
if(NOT DEFINED CMAKE_TOOLCHAIN_FILE)
if(DEFINED ENV{VCPKG_ROOT})
set(CMAKE_TOOLCHAIN_FILE "$ENV{VCPKG_ROOT}/scripts/buildsystems/vcpkg.cmake" CACHE STRING "")
elseif(EXISTS "C:/Code/vcpkg/scripts/buildsystems/vcpkg.cmake")
set(CMAKE_TOOLCHAIN_FILE "C:/Code/vcpkg/scripts/buildsystems/vcpkg.cmake" CACHE STRING "")
elseif(EXISTS "/opt/vcpkg/scripts/buildsystems/vcpkg.cmake")
set(CMAKE_TOOLCHAIN_FILE "/opt/vcpkg/scripts/buildsystems/vcpkg.cmake" CACHE STRING "")
endif()
endif()
# Set vcpkg triplet based on platform
if(NOT DEFINED VCPKG_TARGET_TRIPLET)
if(WIN32)
if(CMAKE_SIZEOF_VOID_P EQUAL 8)
set(VCPKG_TARGET_TRIPLET "x64-windows" CACHE STRING "")
else()
set(VCPKG_TARGET_TRIPLET "x86-windows" CACHE STRING "")
endif()
elseif(APPLE)
set(VCPKG_TARGET_TRIPLET "x64-osx" CACHE STRING "")
else()
set(VCPKG_TARGET_TRIPLET "x64-linux" CACHE STRING "")
endif()
endif()
# ==================== Project Definition ====================
project(CAdminSeed
VERSION 1.0.0
DESCRIPTION "CognitiveTPG Printer Administrator - C++23 Port"
LANGUAGES CXX
)
# ==================== C++ Standard ====================
set(CMAKE_CXX_STANDARD 23)
set(CMAKE_CXX_STANDARD_REQUIRED ON)
set(CMAKE_CXX_EXTENSIONS OFF)
# ==================== Build Configuration ====================
option(BUILD_TESTS "Build unit tests" ON)
option(BUILD_SHARED_LIBS "Build shared libraries" OFF)
option(ENABLE_DEVELOPER_TOOLS "Enable WebView developer tools" ON)
# Output directories
set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/bin)
set(CMAKE_LIBRARY_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/lib)
set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/lib)
# Export compile commands for IDE integration
set(CMAKE_EXPORT_COMPILE_COMMANDS ON)
# ==================== Compiler Flags ====================
if(MSVC)
add_compile_options(/W4 /permissive- /Zc:__cplusplus /utf-8)
add_compile_definitions(_CRT_SECURE_NO_WARNINGS _WIN32_WINNT=0x0A00)
# Enable parallel builds
add_compile_options(/MP)
else()
add_compile_options(-Wall -Wextra -Wpedantic)
if(CMAKE_BUILD_TYPE STREQUAL "Debug")
add_compile_options(-g -O0)
else()
add_compile_options(-O3)
endif()
endif()
# ==================== Find Dependencies ====================
# wxWidgets
find_package(wxWidgets 3.2 REQUIRED COMPONENTS core base webview)
include(${wxWidgets_USE_FILE})
# Boost libraries
find_package(Boost 1.80 REQUIRED COMPONENTS system filesystem json)
# OpenSSL (for HTTPS support in HttpClient)
find_package(OpenSSL REQUIRED)
# liblzma
find_package(LibLZMA REQUIRED)
# libusb
find_package(libusb CONFIG)
if(NOT libusb_FOUND)
find_package(PkgConfig)
if(PKG_CONFIG_FOUND)
pkg_check_modules(LIBUSB libusb-1.0)
endif()
endif()
# nlohmann-json (optional, can use Boost.JSON instead)
find_package(nlohmann_json CONFIG QUIET)
# ==================== Platform-Specific Configuration ====================
set(PLATFORM_SOURCES "")
set(PLATFORM_LIBRARIES "")
set(PLATFORM_INCLUDES "")
set(PLATFORM_DEFINITIONS "")
if(WIN32)
# Windows-specific
list(APPEND PLATFORM_DEFINITIONS WIN32_LEAN_AND_MEAN NOMINMAX)
list(APPEND PLATFORM_LIBRARIES 
setupapi 
winusb 
ws2_32 
bthprops
crypt32
)
# Windows Resource File
if(EXISTS "${CMAKE_CURRENT_SOURCE_DIR}/resources/app.rc")
list(APPEND PLATFORM_SOURCES "${CMAKE_CURRENT_SOURCE_DIR}/resources/app.rc")
endif()
elseif(APPLE)
# macOS-specific
find_library(IOKIT IOKit REQUIRED)
find_library(CORE_FOUNDATION CoreFoundation REQUIRED)
find_library(CORE_SERVICES CoreServices REQUIRED)
find_library(IOBT IOBluetooth)
find_library(SECURITY Security REQUIRED)
list(APPEND PLATFORM_LIBRARIES 
${IOKIT} 
${CORE_FOUNDATION} 
${CORE_SERVICES}
${SECURITY}
)
if(IOBT)
list(APPEND PLATFORM_LIBRARIES ${IOBT})
list(APPEND PLATFORM_DEFINITIONS HAVE_IOBLUETOOTH)
endif()
# macOS bundle configuration
set(MACOSX_BUNDLE_BUNDLE_NAME "CognitiveTPG Admin")
set(MACOSX_BUNDLE_GUI_IDENTIFIER "com.cognitivetpg.admin")
set(MACOSX_BUNDLE_INFO_STRING "CognitiveTPG Printer Administrator")
set(MACOSX_BUNDLE_ICON_FILE "app.icns")
set(MACOSX_BUNDLE_SHORT_VERSION_STRING "${PROJECT_VERSION}")
set(MACOSX_BUNDLE_BUNDLE_VERSION "${PROJECT_VERSION}")
elseif(UNIX)
# Linux-specific
find_package(PkgConfig REQUIRED)
# BlueZ (Bluetooth)
pkg_check_modules(BLUEZ bluez)
if(BLUEZ_FOUND)
list(APPEND PLATFORM_INCLUDES ${BLUEZ_INCLUDE_DIRS})
list(APPEND PLATFORM_LIBRARIES ${BLUEZ_LIBRARIES})
list(APPEND PLATFORM_DEFINITIONS HAVE_BLUEZ)
endif()
# DBus (for BlueZ communication)
pkg_check_modules(DBUS dbus-1)
if(DBUS_FOUND)
list(APPEND PLATFORM_INCLUDES ${DBUS_INCLUDE_DIRS})
list(APPEND PLATFORM_LIBRARIES ${DBUS_LIBRARIES})
endif()
# udev (for device enumeration)
pkg_check_modules(UDEV libudev)
if(UDEV_FOUND)
list(APPEND PLATFORM_INCLUDES ${UDEV_INCLUDE_DIRS})
list(APPEND PLATFORM_LIBRARIES ${UDEV_LIBRARIES})
list(APPEND PLATFORM_DEFINITIONS HAVE_UDEV)
endif()
endif()
# ==================== Include Custom CMake Modules ====================
list(APPEND CMAKE_MODULE_PATH "${CMAKE_CURRENT_SOURCE_DIR}/cmake")
include(EmbedResource OPTIONAL)
# ==================== Configure Definitions ====================
if(ENABLE_DEVELOPER_TOOLS)
list(APPEND PLATFORM_DEFINITIONS ENABLE_DEVTOOLS)
endif()
# ==================== Add Subdirectories ====================
add_subdirectory(src)
# ==================== Testing ====================
if(BUILD_TESTS)
enable_testing()
add_subdirectory(tests)
endif()
# ==================== Installation ====================
include(GNUInstallDirs)
install(TARGETS CAdmin
RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR}
BUNDLE DESTINATION .
)
# Install resources
install(DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}/../
DESTINATION ${CMAKE_INSTALL_DATADIR}/cadmin
FILES_MATCHING PATTERN "*.html"
)
# ==================== CPack Configuration ====================
set(CPACK_PACKAGE_NAME "CognitiveTPG-Admin")
set(CPACK_PACKAGE_VENDOR "CognitiveTPG")
set(CPACK_PACKAGE_DESCRIPTION_SUMMARY "Printer Configuration Utility")
set(CPACK_PACKAGE_VERSION_MAJOR ${PROJECT_VERSION_MAJOR})
set(CPACK_PACKAGE_VERSION_MINOR ${PROJECT_VERSION_MINOR})
set(CPACK_PACKAGE_VERSION_PATCH ${PROJECT_VERSION_PATCH})
set(CPACK_RESOURCE_FILE_LICENSE "${CMAKE_CURRENT_SOURCE_DIR}/../LICENSE")
if(WIN32)
set(CPACK_GENERATOR "NSIS;ZIP")
set(CPACK_NSIS_ENABLE_UNINSTALL_BEFORE_INSTALL ON)
set(CPACK_NSIS_MODIFY_PATH ON)
elseif(APPLE)
set(CPACK_GENERATOR "DragNDrop")
else()
set(CPACK_GENERATOR "DEB;RPM;TGZ")
set(CPACK_DEBIAN_PACKAGE_DEPENDS "libwxgtk3.0-gtk3-0v5, libboost-all-dev")
endif()
include(CPack)
# ==================== Summary ====================
message(STATUS "")
message(STATUS "CAdminSeed Configuration Summary")
message(STATUS "================================")
message(STATUS "  Version:          ${PROJECT_VERSION}")
message(STATUS "  C++ Standard:     ${CMAKE_CXX_STANDARD}")
message(STATUS "  Build Type:       ${CMAKE_BUILD_TYPE}")
message(STATUS "  Platform:         ${CMAKE_SYSTEM_NAME}")
message(STATUS "  Compiler:         ${CMAKE_CXX_COMPILER_ID} ${CMAKE_CXX_COMPILER_VERSION}")
message(STATUS "")
message(STATUS "  wxWidgets:        ${wxWidgets_VERSION_STRING}")
message(STATUS "  Boost:            ${Boost_VERSION}")
message(STATUS "  OpenSSL:          ${OPENSSL_VERSION}")
message(STATUS "  LibLZMA:          ${LIBLZMA_VERSION_STRING}")
message(STATUS "")
message(STATUS "  Build Tests:      ${BUILD_TESTS}")
message(STATUS "  DevTools:         ${ENABLE_DEVELOPER_TOOLS}")
message(STATUS "")
```
## File: CAdmin/vcpkg.json
```json
{
"name": "cadmin-seed",
"version": "1.0.0",
"description": "C++23 port of JAdmin printer administration utility",
"dependencies": [
"wxwidgets",
"boost-asio",
"boost-beast",
"boost-system",
"boost-filesystem",
"boost-json",
"liblzma",
"libusb",
"openssl",
"nlohmann-json"
],
"builtin-baseline": "9aee6e968f51e15ee93606f064691d8f6d228190"
}
```
````
````JAdmin
This file is a merged representation of the entire codebase, combined into a single document by Repomix.
The content has been processed where comments have been removed, empty lines have been removed, content has been formatted for parsing in markdown style, security check has been disabled.
# File Summary
## Purpose
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
## File Format
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  a. A header with the file path (## File: path/to/file)
  b. The full contents of the file in a code block
## Usage Guidelines
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
## Notes
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Code comments have been removed from supported file types
- Empty lines have been removed from all files
- Content has been formatted for parsing in markdown style
- Security check has been disabled - content may contain sensitive information
- Files are sorted by Git change count (files with more changes are at the bottom)
# Directory Structure
```
JAdmin/
  src/
    com/
      cognitive/
        admin/
          CompositeAbout.java
          CompositeConnectionSettings.java
          CompositeCPLEditor.java
          CompositeFirmwareCPR.java
          CompositeFontsAndObjects.java
          CompositeLabelPositioning.java
          CompositeManufacturing.java
          CompositePCLWindowing.java
          CompositePrinterSettings.java
          CompositeProfileManagement.java
          CompositeRepair.java
          Configurator.java
          FirmwareMap.java
          FirmwareUpdater.java
          FontMap.java
          GUIHelper.java
          JAdminDialogMessage.java
          JAdminDialogRadio.java
          MainShell.java
          messages_fr.properties
          Messages.java
          messages.properties
          PrinterHelper.java
          PrinterId.java
          QualityScanner.java
          SecurityConfig.java
          TestEngine.java
          TGModelNumbers.java
          TimerTaskCPL.java
          TimerTaskHeartbeat.java
          Versions.java
          WindowsPrinterManager.java
        printer/
          CPLParser.java
          IOEnvironment.java
          IPrinterConnection.java
          NetworkConnection.java
          ParallelConnection.java
          Printer.java
          SerialConnection.java
          UsbPort.java
          WindowsPrinterConnection.java
          WindowsPrinterConnectionDLL.java
        util/
          exception/
            CPLParsingException.java
            DBException.java
            HasCallback.java
            ManufacturingTestException.java
            NativeLibraryException.java
            PrinterOperationException.java
```
# Files
## File: JAdmin/src/com/cognitive/admin/CompositeAbout.java
```java
public class CompositeAbout extends Composite
{
private Label filler1=null;
private Label filler4=null;
private Label filler11=null;
private Composite compositeAboutManufacturing=null;
private Label labelFirmware=null;
private Label labelFirmwareVersion=null;
private Label labelCPR=null;
private Label labelCPRVersion=null;
private Label labelFonts=null;
private Label labelFontsVersion=null;
private Label labelLabels=null;
private Label labelLabelsVersion=null;
private Composite compositeAboutBasic=null;
private Label labelFPK=null;
private Label labelFPKVersion=null;
private Composite compositeAbout=null;
private Label labelLogo=null;
private Label labelAddress1=null;
private Label labelAddress2=null;
private Label labelPhone=null;
private Link linkUrl=null;
private Label labelCopyright=null;
private Link linkEmail=null;
private Label labelJAdmin=null;
private Label labelVersion=null;
private Label labelRevision=null;
private Label labelCompany=null;
public CompositeAbout(Composite parent, int style)
{
super(parent, style);
initialize();
customize();
}
private void initialize()
{
GridData gridData4=new GridData();
gridData4.grabExcessHorizontalSpace=true;
GridData gridData3=new GridData();
gridData3.grabExcessHorizontalSpace=true;
GridData gridData1=new GridData();
gridData1.grabExcessVerticalSpace=true;
Label filler14=new Label(this, SWT.NONE);
Label filler=new Label(this, SWT.NONE);
GridLayout gridLayout=new GridLayout();
gridLayout.numColumns=4;
gridLayout.verticalSpacing=11;
gridLayout.horizontalSpacing=20;
filler1=new Label(this, SWT.NONE);
filler1.setText("Label");
filler1.setVisible(false);
filler1.setLayoutData(gridData1);
Label filler7=new Label(this, SWT.NONE);
Label filler2=new Label(this, SWT.NONE);
createCompositeAbout();
Label filler6=new Label(this, SWT.NONE);
Label filler12=new Label(this, SWT.NONE);
createCompositeAboutBasic();
filler4=new Label(this, SWT.NONE);
filler11=new Label(this, SWT.NONE);
filler11.setText("Label");
filler11.setVisible(false);
filler11.setLayoutData(gridData4);
filler4.setText("Label");
filler4.setLayoutData(gridData3);
filler4.setVisible(false);
this.setLayout(gridLayout);
this.setSize(new Point(422, 537));
}
private void createCompositeAboutManufacturing()
{
GridData gridData41=new GridData();
gridData41.horizontalAlignment=GridData.CENTER;
gridData41.horizontalSpan=2;
gridData41.verticalAlignment=GridData.CENTER;
GridData gridData23=new GridData();
gridData23.horizontalAlignment=GridData.END;
gridData23.verticalAlignment=GridData.CENTER;
GridData gridData22=new GridData();
gridData22.horizontalAlignment=GridData.END;
gridData22.verticalAlignment=GridData.CENTER;
GridData gridData21=new GridData();
gridData21.horizontalAlignment=GridData.END;
gridData21.verticalAlignment=GridData.CENTER;
GridData gridData20=new GridData();
gridData20.horizontalAlignment=GridData.END;
gridData20.verticalAlignment=GridData.CENTER;
GridData gridData19=new GridData();
gridData19.horizontalAlignment=GridData.END;
gridData19.verticalAlignment=GridData.CENTER;
GridLayout gridLayout1=new GridLayout();
gridLayout1.numColumns=2;
gridLayout1.verticalSpacing=10;
gridLayout1.horizontalSpacing=20;
compositeAboutManufacturing=new Composite(compositeAboutBasic, SWT.NONE);
compositeAboutManufacturing.setLayout(gridLayout1);
compositeAboutManufacturing.setLayoutData(gridData41);
labelFirmware=new Label(compositeAboutManufacturing, SWT.NONE);
labelFirmware.setText(Messages.getString("CompositeAbout.0"));
labelFirmwareVersion=new Label(compositeAboutManufacturing, SWT.NONE);
labelFirmwareVersion.setText(Versions.manFirmware);
labelFirmwareVersion.setLayoutData(gridData19);
labelCPR=new Label(compositeAboutManufacturing, SWT.NONE);
labelCPR.setText("CPRs:");
labelCPRVersion=new Label(compositeAboutManufacturing, SWT.NONE);
labelCPRVersion.setText(Versions.manCpr);
labelCPRVersion.setLayoutData(gridData20);
labelFonts=new Label(compositeAboutManufacturing, SWT.NONE);
labelFonts.setText(Messages.getString("CompositeAbout.1"));
labelFontsVersion=new Label(compositeAboutManufacturing, SWT.NONE);
labelFontsVersion.setText(Versions.manFonts);
labelFontsVersion.setLayoutData(gridData21);
labelLabels=new Label(compositeAboutManufacturing, SWT.NONE);
labelLabels.setText(Messages.getString("CompositeAbout.2"));
labelLabelsVersion=new Label(compositeAboutManufacturing, SWT.NONE);
labelLabelsVersion.setText(Versions.manLabels);
labelLabelsVersion.setLayoutData(gridData22);
labelFPK=new Label(compositeAboutManufacturing, SWT.NONE);
labelFPK.setText("FPK:");
labelFPKVersion=new Label(compositeAboutManufacturing, SWT.NONE);
labelFPKVersion.setText(Versions.manFpk);
labelFPKVersion.setLayoutData(gridData23);
}
private void customize()
{
boolean manufacturing=GUIHelper.prefs.getBoolean("ACTIVATE_MANUFACTURING", false);
boolean repair=GUIHelper.prefs.getBoolean("ACTIVATE_REPAIR", false);
compositeAboutBasic.setVisible(false);
compositeAboutManufacturing.setVisible(manufacturing||repair);
}
private void createCompositeAboutBasic()
{
GridData gridData=new GridData();
gridData.horizontalSpan=2;
gridData.verticalAlignment=GridData.CENTER;
gridData.horizontalAlignment=GridData.CENTER;
GridData gridData14=new GridData();
gridData14.horizontalAlignment=GridData.END;
gridData14.verticalAlignment=GridData.CENTER;
GridLayout gridLayout2=new GridLayout();
gridLayout2.horizontalSpacing=20;
gridLayout2.numColumns=2;
gridLayout2.verticalSpacing=10;
GridData gridData5=new GridData();
gridData5.horizontalSpan=2;
gridData5.verticalAlignment=GridData.CENTER;
gridData5.horizontalAlignment=GridData.CENTER;
compositeAboutBasic=new Composite(this, SWT.NONE);
compositeAboutBasic.setLayoutData(gridData5);
compositeAboutBasic.setLayout(gridLayout2);
labelRevision=new Label(compositeAboutBasic, SWT.NONE);
labelRevision.setText("Revision Numbers");
labelRevision.setFont(new Font(Display.getDefault(), "Tahoma", 8, SWT.BOLD));
labelRevision.setLayoutData(gridData);
createCompositeAboutManufacturing();
}
private void createCompositeAbout()
{
GridData gridData17=new GridData();
gridData17.horizontalAlignment=GridData.CENTER;
gridData17.verticalAlignment=GridData.CENTER;
GridData gridData13=new GridData();
gridData13.horizontalAlignment=GridData.CENTER;
gridData13.verticalAlignment=GridData.CENTER;
GridData gridData2=new GridData();
gridData2.horizontalAlignment=GridData.CENTER;
gridData2.verticalAlignment=GridData.CENTER;
GridData gridData16=new GridData();
gridData16.horizontalAlignment=GridData.CENTER;
gridData16.verticalAlignment=GridData.CENTER;
GridData gridData12=new GridData();
gridData12.horizontalAlignment=GridData.CENTER;
gridData12.verticalAlignment=GridData.CENTER;
GridData gridData11=new GridData();
gridData11.horizontalAlignment=GridData.CENTER;
gridData11.verticalAlignment=GridData.CENTER;
GridData gridData10=new GridData();
gridData10.horizontalAlignment=GridData.CENTER;
gridData10.verticalAlignment=GridData.CENTER;
GridData gridData9=new GridData();
gridData9.horizontalAlignment=GridData.CENTER;
gridData9.verticalAlignment=GridData.CENTER;
GridData gridData8=new GridData();
gridData8.horizontalAlignment=GridData.CENTER;
gridData8.verticalAlignment=GridData.CENTER;
GridData gridData7=new GridData();
gridData7.horizontalAlignment=GridData.CENTER;
gridData7.verticalAlignment=GridData.CENTER;
GridData gridData6=new GridData();
gridData6.horizontalAlignment=GridData.CENTER;
gridData6.horizontalSpan=2;
gridData6.verticalAlignment=GridData.CENTER;
GridLayout gridLayout3=new GridLayout();
gridLayout3.numColumns=1;
gridLayout3.verticalSpacing=10;
gridLayout3.horizontalSpacing=20;
compositeAbout=new Composite(this, SWT.BORDER);
compositeAbout.setLayout(gridLayout3);
compositeAbout.setLayoutData(gridData6);
labelLogo=new Label(compositeAbout, SWT.NONE);
labelLogo.setText("Label");
labelLogo.setLayoutData(gridData16);
labelLogo.setImage(new Image(Display.getCurrent(), GUIHelper.myShell.getClass().getClassLoader().getResourceAsStream("com/cognitive/brand/About.gif")));
labelJAdmin=new Label(compositeAbout, SWT.NONE);
labelJAdmin.setText(Messages.getString("CompositeAbout.8").replace("Cognitive", GUIHelper.brand.getProperty("company.name", "CognitiveTPG")));
labelJAdmin.setLayoutData(gridData13);
labelJAdmin.setFont(new Font(Display.getDefault(), "Tahoma", 8, SWT.BOLD));
labelVersion=new Label(compositeAbout, SWT.NONE);
labelVersion.setText("Version "+Versions.jadmin);
labelVersion.setLayoutData(gridData2);
labelVersion.setFont(new Font(Display.getDefault(), "Tahoma", 8, SWT.BOLD));
labelCompany=new Label(compositeAbout, SWT.NONE);
labelCompany.setText(GUIHelper.brand.getProperty("company.about", "CognitiveTPG"));
labelCompany.setLayoutData(gridData17);
labelAddress1=new Label(compositeAbout, SWT.NONE);
labelAddress1.setText(GUIHelper.brand.getProperty("company.address1", "CognitiveTPG")+", "+GUIHelper.brand.getProperty("company.address2", "CognitiveTPG"));
labelAddress1.setLayoutData(gridData7);
labelAddress2=new Label(compositeAbout, SWT.NONE);
if(!labelCompany.getText().startsWith("DASCOM"))
{
labelAddress2.setText(GUIHelper.brand.getProperty("company.city", "CognitiveTPG")+", "+GUIHelper.brand.getProperty("company.state", "CognitiveTPG")+" "+GUIHelper.brand.getProperty("company.zip", "CognitiveTPG")+", "+GUIHelper.brand.getProperty("company.country", "CognitiveTPG"));
}
else
{
labelAddress2.setText(GUIHelper.brand.getProperty("company.country", "CognitiveTPG"));
}
labelAddress2.setLayoutData(gridData8);
labelPhone=new Label(compositeAbout, SWT.NONE);
labelPhone.setText(Messages.getString("CompositeAbout.5")+": "+GUIHelper.brand.getProperty("company.phone", "CognitiveTPG"));
labelPhone.setLayoutData(gridData9);
linkEmail=new Link(compositeAbout, SWT.NONE);
linkEmail.setText("<a>"+GUIHelper.brand.getProperty("company.email", "CognitiveTPG")+"</a>");
linkEmail.setLayoutData(gridData10);
linkEmail.addSelectionListener(new org.eclipse.swt.events.SelectionAdapter()
{
public void widgetSelected(org.eclipse.swt.events.SelectionEvent e)
{
Program.launch("mailto:"+GUIHelper.brand.getProperty("company.email", "CognitiveTPG"));
}
});
linkUrl=new Link(compositeAbout, SWT.NONE);
linkUrl.setText("<a>"+GUIHelper.brand.getProperty("company.url", "CognitiveTPG")+"</a>");
linkUrl.setLayoutData(gridData11);
linkUrl.addSelectionListener(new org.eclipse.swt.events.SelectionAdapter()
{
public void widgetSelected(org.eclipse.swt.events.SelectionEvent e)
{
Program.launch("http://"+GUIHelper.brand.getProperty("company.url", "CognitiveTPG"));
}
});
labelCopyright=new Label(compositeAbout, SWT.NONE);
labelCopyright.setText(Messages.getString("CompositeAbout.6")+" \u00a9 2021 "+GUIHelper.brand.getProperty("company.name", "Cognitive").replaceAll("Tally Dascom", "Dascom")+", "+Messages.getString("CompositeAbout.7"));
labelCopyright.setLayoutData(gridData12);
}
}
```
## File: JAdmin/src/com/cognitive/admin/CompositeConnectionSettings.java
```java
public class CompositeConnectionSettings extends Composite
{
private ConnectionType connectionType=ConnectionType.UNKNOWN;
private Group groupConnectionType=null;
private Group groupConnectionParameters=null;
private Button buttonConnect=null;
private Group groupSerialParameters=null;
private Group groupNetworkParameters=null;
private Button radioButtonSerialConnection=null;
private Label labelComPort=null;
private Label labelBaudRate=null;
private Combo comboBaudRate=null;
private Button radioButtonSystemPrinterConnection=null;
private Button radioButtonNetworkConnection=null;
private Text textIPAddress=null;
private Label labelIPAddress=null;
private Label labelIPPort=null;
private Text textIPPort=null;
private Button buttonTestLabel=null;
private Combo comboComPort=null;
private Label labelNPIPAddress=null;
private Label labelNPNetmask=null;
private Label labelNPGateway=null;
private Button checkBoxNPLPD=null;
private Button checkBoxNPRTEL=null;
private Button checkBoxNPDHCP=null;
private Label labelNPRTELPort=null;
private Label labelNPBufSize=null;
private Text textNPIPAddress=null;
private Text textNPNetmask=null;
private Text textNPRTELPort=null;
private Text textNPBufSize=null;
private Label filler3=null;
private Label filler5=null;
private Label filler6=null;
private Label filler7=null;
private Text textNPGateway=null;
private Label filler9=null;
private Label filler22=null;
private Label filler12=null;
private Label filler15=null;
private Label filler33=null;
private Label filler37=null;
private Label filler41=null;
private Button buttonNPApply=null;
private Button buttonNPRefresh=null;
private Label labelSCBaudRate=null;
private Label labelSCBufSize=null;
private Label labelSCBufOverflow=null;
private Combo comboSCBaudRate=null;
private Text textSCBufSize=null;
private Text textSCBufOverflow=null;
private Label filler48=null;
private Label filler50=null;
private Label filler64=null;
private Label filler74=null;
private Button buttonSCApply=null;
private Button buttonSCRefresh=null;
private Label filler59=null;
private Label filler63=null;
private Button checkBoxDumbTerminal=null;
public static String comPort;
public static int baudRate;
public static int stopBits;
String printerName;
String IPAddress;
int IPPort;
String lptPort;
boolean dumbTerminal;
private Button radioButtonParallelConnection=null;
private Label labelParallelPort=null;
private Combo comboParallelPort=null;
private Label labelParallelNote=null;
private Combo comboStopBits=null;
private Label labelStopBits=null;
private Button checkBoxSCXonXoff=null;
private Label labelSCStopBits=null;
private Combo comboSCStopBits=null;
static public boolean isConnectionTypeParallel=false;
static public boolean isConnectionTypeSerial=false;
private Label filler121=null;
private Label filler1811=null;
private Text textArea=null;
private Label labelNoteEthernetSettings=null;
private Button checkBoxIsBT=null;
private void enableSerialConnection()
{
GUIHelper.logger.trace("");
checkBoxDumbTerminal.setSelection(false);
checkBoxDumbTerminal.setEnabled(false);
radioButtonSerialConnection.setSelection(true);
radioButtonSystemPrinterConnection.setSelection(false);
radioButtonNetworkConnection.setSelection(false);
radioButtonParallelConnection.setSelection(false);
comboComPort.setEnabled(true);
comboBaudRate.setEnabled(true);
labelComPort.setEnabled(true);
labelBaudRate.setEnabled(true);
comboStopBits.setEnabled(true);
labelStopBits.setEnabled(true);
textIPAddress.setEnabled(false);
textIPPort.setEnabled(false);
labelIPAddress.setEnabled(false);
labelIPPort.setEnabled(false);
comboParallelPort.setEnabled(false);
labelParallelPort.setEnabled(false);
}
private void enableOSPrinterConnection()
{
GUIHelper.logger.trace("");
checkBoxDumbTerminal.setSelection(false);
checkBoxDumbTerminal.setEnabled(false);
radioButtonSerialConnection.setSelection(false);
radioButtonSystemPrinterConnection.setSelection(true);
radioButtonNetworkConnection.setSelection(false);
radioButtonParallelConnection.setSelection(false);
comboComPort.setEnabled(false);
comboBaudRate.setEnabled(false);
labelComPort.setEnabled(false);
labelBaudRate.setEnabled(false);
comboStopBits.setEnabled(false);
labelStopBits.setEnabled(false);
textIPAddress.setEnabled(false);
textIPPort.setEnabled(false);
labelIPAddress.setEnabled(false);
labelIPPort.setEnabled(false);
comboParallelPort.setEnabled(false);
labelParallelPort.setEnabled(false);
}
private void enableNetworkConnection()
{
GUIHelper.logger.trace("");
checkBoxDumbTerminal.setSelection(false);
checkBoxDumbTerminal.setEnabled(false);
radioButtonSerialConnection.setSelection(false);
radioButtonSystemPrinterConnection.setSelection(false);
radioButtonNetworkConnection.setSelection(true);
radioButtonParallelConnection.setSelection(false);
comboComPort.setEnabled(false);
comboBaudRate.setEnabled(false);
labelComPort.setEnabled(false);
labelBaudRate.setEnabled(false);
comboStopBits.setEnabled(false);
labelStopBits.setEnabled(false);
textIPAddress.setEnabled(true);
textIPPort.setEnabled(true);
labelIPAddress.setEnabled(true);
labelIPPort.setEnabled(true);
comboParallelPort.setEnabled(false);
labelParallelPort.setEnabled(false);
}
private void enableParallelConnection()
{
GUIHelper.logger.trace("");
checkBoxDumbTerminal.setSelection(true);
checkBoxDumbTerminal.setEnabled(false);
radioButtonSerialConnection.setSelection(false);
radioButtonSystemPrinterConnection.setSelection(false);
radioButtonNetworkConnection.setSelection(false);
radioButtonParallelConnection.setSelection(true);
comboComPort.setEnabled(false);
comboBaudRate.setEnabled(false);
labelComPort.setEnabled(false);
labelBaudRate.setEnabled(false);
comboStopBits.setEnabled(false);
labelStopBits.setEnabled(false);
textIPAddress.setEnabled(false);
textIPPort.setEnabled(false);
labelIPAddress.setEnabled(false);
labelIPPort.setEnabled(false);
comboParallelPort.setEnabled(true);
labelParallelPort.setEnabled(true);
}
private void displayBTText()
{
if(checkBoxIsBT.getSelection())
{
radioButtonSerialConnection.setText(Messages.getString("CompositeConnectionSettings.41"));
}
else
{
radioButtonSerialConnection.setText(Messages.getString("CompositeConnectionSettings.10"));
}
}
private void togglePrinterConnection()
{
GUIHelper.logger.trace("");
dumbTerminal=checkBoxDumbTerminal.getSelection();
if(buttonConnect.getText().equals(Messages.getString("CompositeConnectionSettings.0")))
{
disconnect();
}
else
{
GUIHelper.setCursor(SWT.CURSOR_WAIT);
if(connect())
{
GUIHelper.mainShell.setConnectionState(true, dumbTerminal);
}
else
{
GUIHelper.error(Messages.getString("CompositeConnectionSettings.1"));
}
GUIHelper.setCursor(0);
}
}
private void populateBaudRateCombos()
{
GUIHelper.logger.trace("");
comboBaudRate.add("4800");
comboBaudRate.add("9600");
comboBaudRate.add("19200");
comboBaudRate.add("38400");
comboBaudRate.add("115200");
comboBaudRate.select(4);
comboSCBaudRate.add("4800");
comboSCBaudRate.add("9600");
comboSCBaudRate.add("19200");
comboSCBaudRate.add("38400");
comboSCBaudRate.add("115200");
comboSCBaudRate.select(4);
}
private void populateStopBitsCombos()
{
GUIHelper.logger.trace("");
comboStopBits.add("1");
comboStopBits.add("2");
comboStopBits.select(0);
comboSCStopBits.add("1");
comboSCStopBits.add("2");
comboSCStopBits.select(0);
}
public void setConnectionState(boolean connected, boolean dumbTerminal)
{
GUIHelper.logger.trace("");
GUIHelper.setEnabled(groupConnectionParameters, connected&&!dumbTerminal);
if(connected)
{
GUIHelper.setEnabled(groupConnectionType, false);
groupConnectionType.setEnabled(true);
checkBoxDumbTerminal.setSelection(dumbTerminal);
checkBoxDumbTerminal.setEnabled(false);
buttonConnect.setEnabled(true);
buttonConnect.setText(Messages.getString("CompositeConnectionSettings.0"));
buttonTestLabel.setEnabled(true);
if(!dumbTerminal)
{
refreshGroupNetworkParameters();
refreshGroupSerialParameters();
}
}
else
{
GUIHelper.setEnabled(groupConnectionType, true);
switch(connectionType)
{
case SERIAL:
{
enableSerialConnection();
}
break;
case OS_PRINTER:
{
enableOSPrinterConnection();
}
break;
case NETWORK:
{
enableNetworkConnection();
}
break;
case PARALLEL:
{
enableParallelConnection();
}
break;
default:
{
connectionType=ConnectionType.SERIAL;
enableSerialConnection();
}
}
buttonConnect.setText(Messages.getString("CompositeConnectionSettings.3"));
buttonTestLabel.setEnabled(false);
}
layout(true, true);
}
public void disconnect()
{
GUIHelper.logger.trace("");
try
{
if(PrinterHelper.printer!=null)
{
PrinterHelper.printer.closeConnection();
GUIHelper.mainShell.setConnectionState(false, false);
}
}
catch(Exception e)
{
GUIHelper.logger.error("", e);
GUIHelper.myDisplay.syncExec(new Runnable()
{
public void run()
{
GUIHelper.error(Messages.getString("CompositeConnectionSettings.4"));
}
});
}
}
public boolean connect()
{
GUIHelper.logger.trace("");
boolean connected=false;
if(radioButtonSerialConnection.getSelection()==true)
{
comPort=comboComPort.getText();
baudRate=Integer.parseInt(comboBaudRate.getText());
stopBits=Integer.parseInt(comboStopBits.getText());
connectionType=ConnectionType.SERIAL;
GUIHelper.prefs.put("DEFAULT_CONNECTION_TYPE", "SERIAL");
GUIHelper.prefs.put("COM_PORT", comPort);
GUIHelper.prefs.putInt("BAUD_RATE", baudRate);
GUIHelper.prefs.putInt("STOP_BITS", stopBits);
}
else if(radioButtonSystemPrinterConnection.getSelection()==true)
{
printerName="Printer";
connectionType=ConnectionType.OS_PRINTER;
GUIHelper.prefs.put("DEFAULT_CONNECTION_TYPE", "OS_PRINTER");
GUIHelper.prefs.put("PRINTER_NAME", printerName);
}
else if(radioButtonNetworkConnection.getSelection()==true)
{
IPAddress=textIPAddress.getText();
IPPort=Integer.parseInt(textIPPort.getText());
connectionType=ConnectionType.NETWORK;
GUIHelper.prefs.put("DEFAULT_CONNECTION_TYPE", "NETWORK");
GUIHelper.prefs.put("IP_ADDRESS", IPAddress);
GUIHelper.prefs.putInt("IP_PORT", IPPort);
}
else if(radioButtonParallelConnection.getSelection()==true)
{
lptPort=comboParallelPort.getText();
connectionType=ConnectionType.PARALLEL;
GUIHelper.prefs.put("DEFAULT_CONNECTION_TYPE", "PARALLEL");
GUIHelper.prefs.put("LPT_PORT", lptPort);
}
else
{
connectionType=ConnectionType.UNKNOWN;
GUIHelper.error(Messages.getString("CompositeConnectionSettings.5"));
return connected;
}
return establishConnection();
}
public boolean establishConnection()
{
GUIHelper.logger.trace("");
boolean connected=false;
TestEngine.runningManufacturing=false;
try
{
PrinterHelper.printer.closeConnection();
}
catch(Exception e)
{
GUIHelper.logger.warn(e, e);
}
PrinterHelper.printer.addObserver(GUIHelper.mainShell);
IPrinterConnection conn=null;
try
{
switch(connectionType)
{
case SERIAL:
conn=new SerialConnection(comPort, baudRate, stopBits);
PrinterHelper.printer.openConnection(conn);
isConnectionTypeSerial=true;
isConnectionTypeParallel=false;
break;
case OS_PRINTER:
conn=new WindowsPrinterConnection();
PrinterHelper.printer.openConnection(conn);
isConnectionTypeSerial=false;
isConnectionTypeParallel=false;
break;
case NETWORK:
conn=new NetworkConnection(IPAddress, IPPort);
PrinterHelper.printer.openConnection(conn);
isConnectionTypeSerial=false;
isConnectionTypeParallel=false;
break;
case PARALLEL:
conn=new ParallelConnection(lptPort);
PrinterHelper.printer.openConnection(conn);
isConnectionTypeSerial=false;
isConnectionTypeParallel=true;
break;
}
if(!dumbTerminal)
{
if(!PrinterHelper.printer.isConnected())
{
PrinterHelper.printer.closeConnection();
connected=false;
}
else
{
connected=true;
}
}
else
{
connected=true;
}
}
catch(Exception e)
{
connected=false;
GUIHelper.logger.error(e, e);
}
return connected;
}
private void refreshComPortList()
{
GUIHelper.logger.trace("");
ArrayList<String>list=new ArrayList<String>();
CommPortIdentifier port;
Enumeration portList;
boolean portFound=false;
String defaultPort="";
portList=(Enumeration)CommPortIdentifier.getPortIdentifiers();
while(portList.hasMoreElements())
{
port=(CommPortIdentifier)portList.nextElement();
if(port.getPortType()==CommPortIdentifier.PORT_SERIAL)
{
GUIHelper.logger.debug("["+port.getName()+"]");
comboComPort.add(port.getName());
}
}
}
private void refreshParallelPortList()
{
GUIHelper.logger.trace("");
ArrayList<String>list=new ArrayList<String>();
CommPortIdentifier port;
Enumeration portList;
boolean portFound=false;
String defaultPort="";
portList=(Enumeration)CommPortIdentifier.getPortIdentifiers();
while(portList.hasMoreElements())
{
port=(CommPortIdentifier)portList.nextElement();
if(port.getPortType()==CommPortIdentifier.PORT_PARALLEL)
{
GUIHelper.logger.debug("["+port.getName()+"]");
comboParallelPort.add(port.getName());
}
}
}
private void refreshPrinterList()
{
GUIHelper.logger.trace("");
PrintService[] services=PrintServiceLookup.lookupPrintServices(null, null);
for(int i=0; i<services.length; i++)
{
GUIHelper.logger.debug(services[i].getName());
}
}
private void setGroupSerialParameters()
{
try
{
GUIHelper.setCursor(SWT.CURSOR_WAIT);
String value=null;
String xOnOff=null;
if(checkBoxSCXonXoff.getSelection())
{
xOnOff="R";
}
else
{
xOnOff="N";
}
value=comboSCBaudRate.getText()+",N,8,"+comboSCStopBits.getText()+","+xOnOff;
PrinterHelper.setVariable("COMM", value);
PrinterHelper.setVariable("TXTBFR", textSCBufSize.getText()+","+textSCBufOverflow.getText());
}
catch(Exception e)
{
GUIHelper.logger.error("", e);
GUIHelper.error(Messages.getString("CompositeConnectionSettings.6")+e.toString());
}
finally
{
if(connectionType==ConnectionType.SERIAL)
{
try
{
PrinterHelper.printer.closeConnection();
GUIHelper.mainShell.setConnectionState(false, false);
}
catch(Exception e)
{
GUIHelper.logger.error("In finally{}-unable to close connection:", e);
}
}
GUIHelper.setCursor(0);
}
}
private void refreshGroupSerialParameters()
{
GUIHelper.logger.trace("");
try
{
GUIHelper.setCursor(SWT.CURSOR_WAIT);
String comm=PrinterHelper.getVariable("COMM");
if(comm==null)
{
return;
}
String[] params=comm.split(",");
comboSCBaudRate.select(comboSCBaudRate.indexOf(params[0].trim()));
comboSCStopBits.select(comboSCStopBits.indexOf(params[3].trim()));
comboBaudRate.select(comboBaudRate.indexOf(params[0].trim()));
comboStopBits.select(comboStopBits.indexOf(params[3].trim()));
if(params.length>4)
{
if(params[4].equals("ROBUST")||params[4].equals("ON"))
{
checkBoxSCXonXoff.setSelection(true);
}
else
{
checkBoxSCXonXoff.setSelection(false);
}
}
else
{
checkBoxSCXonXoff.setSelection(false);
}
String buffer=PrinterHelper.getVariable("TXTBFR");
if(buffer==null)
{
return;
}
params=buffer.split(",");
textSCBufSize.setText(params[0].trim());
textSCBufOverflow.setText(params[1].trim());
}
finally
{
GUIHelper.setCursor(0);
}
}
private void setGroupNetworkParameters()
{
try
{
GUIHelper.setCursor(SWT.CURSOR_WAIT);
PrinterHelper.setVariable("ETHERNET IP", textNPIPAddress.getText());
PrinterHelper.setVariable("ETHERNET NETMASK", textNPNetmask.getText());
PrinterHelper.setVariable("ETHERNET GATEWAY", textNPGateway.getText());
PrinterHelper.setVariable("ETHERNET DHCP", GUIHelper.stringFromBoolean(checkBoxNPDHCP.getSelection()));
PrinterHelper.setVariable("ETHERNET LPD", GUIHelper.stringFromBoolean(checkBoxNPLPD.getSelection()));
PrinterHelper.setVariable("ETHERNET RTEL", GUIHelper.stringFromBoolean(checkBoxNPRTEL.getSelection()));
PrinterHelper.setVariable("ETHERNET RTEL PORT", textNPRTELPort.getText());
PrinterHelper.setVariable("ETHERNET TXTBFR", textNPBufSize.getText());
}
catch(Exception e)
{
GUIHelper.logger.error("", e);
GUIHelper.error(Messages.getString("CompositeConnectionSettings.6")+e.toString());
}
finally
{
if(connectionType==ConnectionType.NETWORK)
{
try
{
PrinterHelper.printer.closeConnection();
GUIHelper.mainShell.setConnectionState(false, false);
}
catch(Exception e)
{
GUIHelper.logger.error("In finally{}-unable to close connection:", e);
}
}
GUIHelper.setCursor(0);
}
}
private void refreshGroupNetworkParameters()
{
GUIHelper.logger.trace("");
try
{
GUIHelper.setCursor(SWT.CURSOR_WAIT);
GUIHelper.blankify(groupNetworkParameters);
String IPAddress=PrinterHelper.getVariable("ETHERNET IP");
textNPIPAddress.setText(IPAddress);
textNPNetmask.setText(PrinterHelper.getVariable("ETHERNET NETMASK"));
textNPGateway.setText(PrinterHelper.getVariable("ETHERNET GATEWAY"));
checkBoxNPDHCP.setSelection(GUIHelper.booleanFromString(PrinterHelper.printer.getVariable("ETHERNET DHCP")));
checkBoxNPLPD.setSelection(GUIHelper.booleanFromString(PrinterHelper.printer.getVariable("ETHERNET LPD")));
checkBoxNPRTEL.setSelection(GUIHelper.booleanFromString(PrinterHelper.printer.getVariable("ETHERNET RTEL")));
String IPPort=PrinterHelper.getVariable("ETHERNET RTEL PORT");
textNPRTELPort.setText(IPPort);
textNPBufSize.setText(PrinterHelper.getVariable("ETHERNET TXTBFR"));
if(!IPAddress.equalsIgnoreCase(textIPAddress.getText()))
{
}
else
{
textIPAddress.setText(IPAddress);
}
textIPPort.setText(IPPort);
}
catch(NullPointerException npe)
{
throw npe;
}
catch(Exception e)
{
GUIHelper.logger.error("", e);
GUIHelper.error(Messages.getString("CompositeConnectionSettings.6")+e.toString());
}
finally
{
GUIHelper.setCursor(0);
}
}
public CompositeConnectionSettings(Composite parent, int style)
{
super(parent, style);
GUIHelper.logger.trace("");
initialize();
}
private void initialize()
{
GUIHelper.logger.trace("");
GridLayout gridLayout=new GridLayout();
gridLayout.numColumns=2;
gridLayout.makeColumnsEqualWidth=false;
this.setLayout(gridLayout);
createGroupConnectionType();
createGroupConnectionParameters();
this.setSize(new Point(545, 477));
showDumbTerminalCheckBox();
setDefaultConnectionParameters();
}
private void createGroupConnectionType()
{
GUIHelper.logger.trace("");
GridData gridData58=new GridData();
gridData58.horizontalAlignment=GridData.BEGINNING;
gridData58.verticalAlignment=GridData.END;
GridData gridData56=new GridData();
gridData56.horizontalAlignment=GridData.FILL;
gridData56.grabExcessHorizontalSpace=true;
gridData56.grabExcessVerticalSpace=true;
gridData56.verticalAlignment=GridData.FILL;
GridData gridData20=new GridData();
gridData20.horizontalAlignment=GridData.FILL;
gridData20.grabExcessVerticalSpace=true;
gridData20.grabExcessHorizontalSpace=true;
gridData20.verticalAlignment=GridData.FILL;
GridData gridData18=new GridData();
gridData18.horizontalAlignment=GridData.FILL;
gridData18.grabExcessHorizontalSpace=true;
gridData18.grabExcessVerticalSpace=true;
gridData18.verticalAlignment=GridData.FILL;
GridData gridData55=new GridData();
gridData55.horizontalAlignment=GridData.END;
gridData55.verticalAlignment=GridData.CENTER;
GridData gridData54=new GridData();
gridData54.horizontalSpan=2;
GridData gridData53=new GridData();
gridData53.horizontalIndent=0;
GridData gridData52=new GridData();
gridData52.horizontalIndent=0;
GridData gridData51=new GridData();
gridData51.horizontalAlignment=GridData.END;
gridData51.verticalAlignment=GridData.CENTER;
GridData gridData19=new GridData();
gridData19.grabExcessHorizontalSpace=true;
GridData gridData16=new GridData();
gridData16.grabExcessVerticalSpace=true;
gridData16.verticalAlignment=GridData.FILL;
gridData16.grabExcessHorizontalSpace=true;
gridData16.horizontalAlignment=GridData.FILL;
GridData gridData25=new GridData();
gridData25.grabExcessHorizontalSpace=false;
GridData gridData24=new GridData();
gridData24.grabExcessHorizontalSpace=false;
gridData24.horizontalAlignment=GridData.BEGINNING;
gridData24.verticalAlignment=GridData.CENTER;
gridData24.widthHint=-1;
GridData gridData17=new GridData();
gridData17.horizontalAlignment=GridData.CENTER;
gridData17.grabExcessHorizontalSpace=false;
gridData17.horizontalSpan=2;
gridData17.verticalAlignment=GridData.CENTER;
GridData gridData15=new GridData();
gridData15.horizontalIndent=0;
gridData15.verticalAlignment=GridData.CENTER;
gridData15.grabExcessHorizontalSpace=false;
gridData15.horizontalAlignment=GridData.FILL;
GridData gridData14=new GridData();
gridData14.horizontalIndent=0;
gridData14.verticalAlignment=GridData.CENTER;
gridData14.grabExcessHorizontalSpace=false;
gridData14.horizontalAlignment=GridData.BEGINNING;
GridData gridData13=new GridData();
gridData13.horizontalIndent=0;
gridData13.verticalAlignment=GridData.CENTER;
gridData13.grabExcessHorizontalSpace=false;
gridData13.horizontalAlignment=GridData.BEGINNING;
GridData gridData9=new GridData();
gridData9.horizontalAlignment=GridData.END;
gridData9.horizontalIndent=0;
gridData9.grabExcessHorizontalSpace=false;
gridData9.verticalAlignment=GridData.CENTER;
GridData gridData8=new GridData();
gridData8.horizontalAlignment=GridData.END;
gridData8.horizontalIndent=0;
gridData8.grabExcessHorizontalSpace=false;
gridData8.verticalAlignment=GridData.CENTER;
GridData gridData4=new GridData();
gridData4.horizontalAlignment=GridData.END;
gridData4.horizontalIndent=0;
gridData4.grabExcessHorizontalSpace=false;
gridData4.verticalAlignment=GridData.CENTER;
GridData gridData3=new GridData();
gridData3.horizontalAlignment=GridData.END;
gridData3.horizontalIndent=0;
gridData3.grabExcessHorizontalSpace=false;
gridData3.verticalAlignment=GridData.CENTER;
GridData gridData2=new GridData();
gridData2.horizontalAlignment=GridData.END;
gridData2.horizontalIndent=0;
gridData2.grabExcessHorizontalSpace=false;
gridData2.verticalAlignment=GridData.CENTER;
GridLayout gridLayout2=new GridLayout();
gridLayout2.numColumns=4;
gridLayout2.marginWidth=5;
gridLayout2.horizontalSpacing=5;
gridLayout2.verticalSpacing=5;
gridLayout2.makeColumnsEqualWidth=false;
gridLayout2.marginHeight=5;
GridData gridData5=new GridData();
gridData5.horizontalAlignment=GridData.CENTER;
gridData5.grabExcessHorizontalSpace=false;
gridData5.grabExcessVerticalSpace=false;
gridData5.heightHint=-1;
gridData5.widthHint=-1;
gridData5.horizontalSpan=2;
gridData5.verticalAlignment=GridData.END;
GridData gridData1=new GridData();
gridData1.horizontalAlignment=GridData.FILL;
gridData1.grabExcessHorizontalSpace=true;
gridData1.grabExcessVerticalSpace=true;
gridData1.horizontalIndent=0;
gridData1.heightHint=-1;
gridData1.verticalAlignment=GridData.FILL;
groupConnectionType=new Group(this, SWT.NONE);
groupConnectionType.setText(Messages.getString("CompositeConnectionSettings.9"));
groupConnectionType.setLayout(gridLayout2);
groupConnectionType.setLayoutData(gridData1);
filler12=new Label(groupConnectionType, SWT.NONE);
filler12.setText("");
filler12.setLayoutData(gridData16);
checkBoxIsBT=new Button(groupConnectionType, SWT.CHECK);
checkBoxIsBT.setText(Messages.getString("CompositeConnectionSettings.42"));
checkBoxIsBT.setLayoutData(gridData58);
checkBoxIsBT
.addSelectionListener(new org.eclipse.swt.events.SelectionAdapter()
{
public void widgetSelected(org.eclipse.swt.events.SelectionEvent e)
{
displayBTText();
}
});
Label filler35=new Label(groupConnectionType, SWT.NONE);
Label filler181=new Label(groupConnectionType, SWT.NONE);
filler181.setLayoutData(gridData18);
filler15=new Label(groupConnectionType, SWT.NONE);
filler15.setText("");
filler15.setLayoutData(gridData19);
radioButtonSerialConnection=new Button(groupConnectionType, SWT.RADIO);
radioButtonSerialConnection.setText(Messages.getString("CompositeConnectionSettings.10"));
radioButtonSerialConnection.setLayoutData(gridData15);
Label filler34=new Label(groupConnectionType, SWT.NONE);
Label filler180=new Label(groupConnectionType, SWT.NONE);
radioButtonSerialConnection
.addSelectionListener(new org.eclipse.swt.events.SelectionAdapter()
{
public void widgetSelected(org.eclipse.swt.events.SelectionEvent e)
{
enableSerialConnection();
}
});
Label filler30=new Label(groupConnectionType, SWT.NONE);
labelComPort=new Label(groupConnectionType, SWT.NONE);
labelComPort.setText(Messages.getString("CompositeConnectionSettings.11"));
labelComPort.setLayoutData(gridData2);
createComboComPort();
Label filler179=new Label(groupConnectionType, SWT.NONE);
Label filler36=new Label(groupConnectionType, SWT.NONE);
labelBaudRate=new Label(groupConnectionType, SWT.LEFT);
labelBaudRate.setText(Messages.getString("CompositeConnectionSettings.12"));
labelBaudRate.setLayoutData(gridData3);
createComboBaudRate();
Label filler178=new Label(groupConnectionType, SWT.NONE);
Label filler29=new Label(groupConnectionType, SWT.NONE);
labelStopBits=new Label(groupConnectionType, SWT.LEFT);
labelStopBits.setText(Messages.getString("CompositeConnectionSettings.38"));
labelStopBits.setLayoutData(gridData55);
createComboStopBits();
Label filler176=new Label(groupConnectionType, SWT.NONE);
filler33=new Label(groupConnectionType, SWT.NONE);
filler33.setText("");
Label filler177=new Label(groupConnectionType, SWT.NONE);
Label filler27=new Label(groupConnectionType, SWT.NONE);
Label filler174=new Label(groupConnectionType, SWT.NONE);
Label filler165=new Label(groupConnectionType, SWT.NONE);
radioButtonSystemPrinterConnection=new Button(groupConnectionType, SWT.RADIO);
radioButtonSystemPrinterConnection.setText(Messages.getString("CompositeConnectionSettings.39"));
radioButtonSystemPrinterConnection.setLayoutData(gridData13);
Label filler25=new Label(groupConnectionType, SWT.NONE);
Label filler173=new Label(groupConnectionType, SWT.NONE);
radioButtonSystemPrinterConnection
.addSelectionListener(new org.eclipse.swt.events.SelectionAdapter()
{
public void widgetSelected(org.eclipse.swt.events.SelectionEvent e)
{
enableOSPrinterConnection();
}
});
filler37=new Label(groupConnectionType, SWT.NONE);
filler37.setText("");
Label filler175=new Label(groupConnectionType, SWT.NONE);
Label filler24=new Label(groupConnectionType, SWT.NONE);
Label filler172=new Label(groupConnectionType, SWT.NONE);
Label filler279=new Label(groupConnectionType, SWT.NONE);
radioButtonNetworkConnection=new Button(groupConnectionType, SWT.RADIO);
radioButtonNetworkConnection.setText(Messages.getString("CompositeConnectionSettings.15"));
radioButtonNetworkConnection.setLayoutData(gridData14);
Label filler23=new Label(groupConnectionType, SWT.NONE);
Label filler170=new Label(groupConnectionType, SWT.NONE);
radioButtonNetworkConnection
.addSelectionListener(new org.eclipse.swt.events.SelectionAdapter()
{
public void widgetSelected(org.eclipse.swt.events.SelectionEvent e)
{
enableNetworkConnection();
}
});
Label filler28=new Label(groupConnectionType, SWT.NONE);
labelIPAddress=new Label(groupConnectionType, SWT.NONE);
labelIPAddress.setText(Messages.getString("CompositeConnectionSettings.16"));
labelIPAddress.setLayoutData(gridData8);
textIPAddress=new Text(groupConnectionType, SWT.BORDER);
textIPAddress.setText("255.255.255.255");
textIPAddress.setLayoutData(gridData24);
Label filler169=new Label(groupConnectionType, SWT.NONE);
Label filler21=new Label(groupConnectionType, SWT.NONE);
labelIPPort=new Label(groupConnectionType, SWT.NONE);
labelIPPort.setText(Messages.getString("CompositeConnectionSettings.17"));
labelIPPort.setLayoutData(gridData9);
textIPPort=new Text(groupConnectionType, SWT.BORDER);
textIPPort.setText("9100");
textIPPort.setLayoutData(gridData25);
Label filler168=new Label(groupConnectionType, SWT.NONE);
filler41=new Label(groupConnectionType, SWT.NONE);
filler41.setText("");
Label filler171=new Label(groupConnectionType, SWT.NONE);
Label filler17=new Label(groupConnectionType, SWT.NONE);
Label filler167=new Label(groupConnectionType, SWT.NONE);
Label filler1770=new Label(groupConnectionType, SWT.NONE);
radioButtonParallelConnection=new Button(groupConnectionType, SWT.RADIO);
radioButtonParallelConnection.setText(Messages.getString("CompositeConnectionSettings.35"));
radioButtonParallelConnection.setLayoutData(gridData52);
Label filler16=new Label(groupConnectionType, SWT.NONE);
Label filler32=new Label(groupConnectionType, SWT.NONE);
radioButtonParallelConnection
.addSelectionListener(new org.eclipse.swt.events.SelectionAdapter()
{
public void widgetSelected(org.eclipse.swt.events.SelectionEvent e)
{
enableParallelConnection();
}
});
Label filler18=new Label(groupConnectionType, SWT.NONE);
labelParallelPort=new Label(groupConnectionType, SWT.NONE);
labelParallelPort.setText(Messages.getString("CompositeConnectionSettings.36"));
labelParallelPort.setLayoutData(gridData51);
createComboParallelPort();
Label filler31=new Label(groupConnectionType, SWT.NONE);
Label filler184=new Label(groupConnectionType, SWT.NONE);
labelParallelNote=new Label(groupConnectionType, SWT.WRAP);
labelParallelNote.setText(Messages.getString("CompositeConnectionSettings.37"));
labelParallelNote.setLayoutData(gridData54);
Label filler26=new Label(groupConnectionType, SWT.NONE);
Label filler1822=new Label(groupConnectionType, SWT.NONE);
checkBoxDumbTerminal=new Button(groupConnectionType, SWT.CHECK);
checkBoxDumbTerminal.setText(Messages.getString("CompositeConnectionSettings.18"));
checkBoxDumbTerminal.setLayoutData(gridData53);
checkBoxDumbTerminal.setEnabled(false);
Label filler2=new Label(groupConnectionType, SWT.NONE);
Label filler13=new Label(groupConnectionType, SWT.NONE);
Label filler185=new Label(groupConnectionType, SWT.NONE);
buttonConnect=new Button(groupConnectionType, SWT.NONE);
buttonConnect.setText(Messages.getString("CompositeConnectionSettings.0"));
buttonConnect.setLayoutData(gridData5);
Label filler=new Label(groupConnectionType, SWT.NONE);
Label filler166=new Label(groupConnectionType, SWT.NONE);
buttonTestLabel=new Button(groupConnectionType, SWT.NONE);
buttonTestLabel.setText(Messages.getString("CompositeConnectionSettings.20"));
buttonTestLabel.setLayoutData(gridData17);
Label filler14=new Label(groupConnectionType, SWT.NONE);
filler121=new Label(groupConnectionType, SWT.NONE);
filler121.setText("");
filler121.setLayoutData(gridData20);
Label filler38=new Label(groupConnectionType, SWT.NONE);
Label filler39=new Label(groupConnectionType, SWT.NONE);
filler1811=new Label(groupConnectionType, SWT.NONE);
filler1811.setLayoutData(gridData56);
buttonConnect
.addSelectionListener(new org.eclipse.swt.events.SelectionAdapter()
{
public void widgetSelected(org.eclipse.swt.events.SelectionEvent e)
{
togglePrinterConnection();
}
});
buttonTestLabel
.addSelectionListener(new org.eclipse.swt.events.SelectionAdapter()
{
public void widgetSelected(org.eclipse.swt.events.SelectionEvent e)
{
PrinterHelper.printSelfTestLabel();
}
});
}
private void createGroupConnectionParameters()
{
GUIHelper.logger.trace("");
GridLayout gridLayout1=new GridLayout();
gridLayout1.makeColumnsEqualWidth=false;
GridData gridData=new GridData();
gridData.horizontalAlignment=GridData.FILL;
gridData.grabExcessHorizontalSpace=true;
gridData.grabExcessVerticalSpace=true;
gridData.verticalAlignment=GridData.FILL;
groupConnectionParameters=new Group(this, SWT.NONE);
groupConnectionParameters.setText(Messages.getString("CompositeConnectionSettings.21"));
createGroupSerialParameters();
groupConnectionParameters.setLayoutData(gridData);
groupConnectionParameters.setLayout(gridLayout1);
createGroupNetworkParameters();
}
private void createGroupSerialParameters()
{
GUIHelper.logger.trace("");
GridData gridData46=new GridData();
gridData46.horizontalAlignment=GridData.FILL;
gridData46.verticalAlignment=GridData.CENTER;
GridData gridData45=new GridData();
gridData45.horizontalAlignment=GridData.FILL;
gridData45.verticalAlignment=GridData.CENTER;
GridData gridData42=new GridData();
gridData42.grabExcessVerticalSpace=true;
GridData gridData41=new GridData();
gridData41.grabExcessVerticalSpace=true;
GridData gridData40=new GridData();
gridData40.grabExcessVerticalSpace=true;
GridData gridData39=new GridData();
gridData39.grabExcessHorizontalSpace=true;
GridData gridData23=new GridData();
gridData23.grabExcessHorizontalSpace=true;
GridLayout gridLayout4=new GridLayout();
gridLayout4.numColumns=4;
gridLayout4.verticalSpacing=2;
gridLayout4.marginWidth=2;
gridLayout4.marginHeight=2;
gridLayout4.horizontalSpacing=2;
GridData gridData6=new GridData();
gridData6.horizontalAlignment=GridData.FILL;
gridData6.grabExcessVerticalSpace=true;
gridData6.grabExcessHorizontalSpace=true;
gridData6.verticalAlignment=GridData.FILL;
groupSerialParameters=new Group(groupConnectionParameters, SWT.NONE);
groupSerialParameters.setLayoutData(gridData6);
groupSerialParameters.setLayout(gridLayout4);
groupSerialParameters.setText(Messages.getString("CompositeConnectionSettings.22"));
Label filler75=new Label(groupSerialParameters, SWT.NONE);
Label filler47=new Label(groupSerialParameters, SWT.NONE);
filler48=new Label(groupSerialParameters, SWT.NONE);
filler48.setText("");
filler48.setLayoutData(gridData40);
Label filler65=new Label(groupSerialParameters, SWT.NONE);
filler74=new Label(groupSerialParameters, SWT.NONE);
filler74.setText("");
filler74.setLayoutData(gridData23);
labelSCBaudRate=new Label(groupSerialParameters, SWT.NONE);
labelSCBaudRate.setText(Messages.getString("CompositeConnectionSettings.23"));
createComboSCBaudRate();
filler64=new Label(groupSerialParameters, SWT.NONE);
filler64.setText("");
filler64.setLayoutData(gridData39);
Label filler464=new Label(groupSerialParameters, SWT.NONE);
labelSCStopBits=new Label(groupSerialParameters, SWT.LEFT);
labelSCStopBits.setText(Messages.getString("CompositeConnectionSettings.38"));
createComboSCStopBits();
Label filler466=new Label(groupSerialParameters, SWT.NONE);
Label filler461=new Label(groupSerialParameters, SWT.NONE);
checkBoxSCXonXoff=new Button(groupSerialParameters, SWT.CHECK);
checkBoxSCXonXoff.setText("XON/XOFF");
Label filler462=new Label(groupSerialParameters, SWT.NONE);
Label filler463=new Label(groupSerialParameters, SWT.NONE);
Label filler72=new Label(groupSerialParameters, SWT.NONE);
labelSCBufSize=new Label(groupSerialParameters, SWT.NONE);
labelSCBufSize.setText(Messages.getString("CompositeConnectionSettings.24"));
textSCBufSize=new Text(groupSerialParameters, SWT.BORDER);
textSCBufSize.setText("");
textSCBufSize.setLayoutData(gridData45);
Label filler52=new Label(groupSerialParameters, SWT.NONE);
Label filler71=new Label(groupSerialParameters, SWT.NONE);
labelSCBufOverflow=new Label(groupSerialParameters, SWT.NONE);
labelSCBufOverflow.setText(Messages.getString("CompositeConnectionSettings.25"));
textSCBufOverflow=new Text(groupSerialParameters, SWT.BORDER);
textSCBufOverflow.setText("");
textSCBufOverflow.setLayoutData(gridData46);
Label filler51=new Label(groupSerialParameters, SWT.NONE);
Label filler70=new Label(groupSerialParameters, SWT.NONE);
Label filler49=new Label(groupSerialParameters, SWT.NONE);
filler50=new Label(groupSerialParameters, SWT.NONE);
filler50.setText("");
filler50.setLayoutData(gridData41);
Label filler80=new Label(groupSerialParameters, SWT.NONE);
Label filler81=new Label(groupSerialParameters, SWT.NONE);
buttonSCApply=new Button(groupSerialParameters, SWT.NONE);
buttonSCApply.setText(Messages.getString("General.0"));
buttonSCApply
.addSelectionListener(new org.eclipse.swt.events.SelectionAdapter()
{
public void widgetSelected(org.eclipse.swt.events.SelectionEvent e)
{
setGroupSerialParameters();
}
});
buttonSCRefresh=new Button(groupSerialParameters, SWT.NONE);
buttonSCRefresh.setText(Messages.getString("General.1"));
buttonSCRefresh
.addSelectionListener(new org.eclipse.swt.events.SelectionAdapter()
{
public void widgetSelected(org.eclipse.swt.events.SelectionEvent e)
{
refreshGroupSerialParameters();
}
});
Label filler56=new Label(groupSerialParameters, SWT.NONE);
Label filler57=new Label(groupSerialParameters, SWT.NONE);
Label filler58=new Label(groupSerialParameters, SWT.NONE);
filler59=new Label(groupSerialParameters, SWT.NONE);
filler59.setText("");
filler59.setLayoutData(gridData42);
}
private void createGroupNetworkParameters()
{
GUIHelper.logger.trace("");
GridData gridData57=new GridData();
gridData57.verticalSpan=3;
gridData57.verticalAlignment=GridData.BEGINNING;
gridData57.horizontalAlignment=GridData.BEGINNING;
GridData gridData50=new GridData();
gridData50.horizontalAlignment=GridData.FILL;
gridData50.verticalAlignment=GridData.CENTER;
GridData gridData49=new GridData();
gridData49.horizontalAlignment=GridData.FILL;
gridData49.verticalAlignment=GridData.CENTER;
GridData gridData48=new GridData();
gridData48.horizontalAlignment=GridData.FILL;
gridData48.verticalAlignment=GridData.CENTER;
GridData gridData47=new GridData();
gridData47.horizontalAlignment=GridData.FILL;
gridData47.verticalAlignment=GridData.CENTER;
GridData gridData43=new GridData();
gridData43.grabExcessVerticalSpace=true;
GridData gridData22=new GridData();
gridData22.horizontalAlignment=GridData.CENTER;
gridData22.verticalAlignment=GridData.CENTER;
GridData gridData21=new GridData();
gridData21.verticalAlignment=GridData.CENTER;
gridData21.horizontalAlignment=GridData.CENTER;
GridData gridData38=new GridData();
gridData38.horizontalAlignment=GridData.FILL;
gridData38.verticalAlignment=GridData.CENTER;
GridData gridData37=new GridData();
gridData37.horizontalAlignment=GridData.FILL;
gridData37.verticalAlignment=GridData.CENTER;
GridData gridData36=new GridData();
gridData36.horizontalAlignment=GridData.FILL;
gridData36.verticalAlignment=GridData.CENTER;
GridData gridData35=new GridData();
gridData35.horizontalAlignment=GridData.FILL;
gridData35.verticalAlignment=GridData.CENTER;
GridData gridData34=new GridData();
gridData34.horizontalAlignment=GridData.BEGINNING;
gridData34.verticalAlignment=GridData.CENTER;
GridData gridData33=new GridData();
gridData33.horizontalAlignment=GridData.BEGINNING;
gridData33.verticalAlignment=GridData.CENTER;
GridData gridData32=new GridData();
gridData32.horizontalAlignment=GridData.BEGINNING;
gridData32.verticalAlignment=GridData.CENTER;
GridData gridData31=new GridData();
gridData31.horizontalAlignment=GridData.BEGINNING;
gridData31.verticalAlignment=GridData.CENTER;
GridData gridData30=new GridData();
gridData30.horizontalAlignment=GridData.BEGINNING;
gridData30.verticalAlignment=GridData.CENTER;
GridData gridData29=new GridData();
gridData29.grabExcessHorizontalSpace=true;
GridData gridData28=new GridData();
gridData28.grabExcessHorizontalSpace=true;
gridData28.grabExcessVerticalSpace=false;
GridData gridData27=new GridData();
gridData27.grabExcessHorizontalSpace=false;
gridData27.grabExcessVerticalSpace=true;
GridData gridData26=new GridData();
gridData26.grabExcessHorizontalSpace=false;
gridData26.grabExcessVerticalSpace=true;
GridLayout gridLayout3=new GridLayout();
gridLayout3.numColumns=4;
gridLayout3.horizontalSpacing=2;
gridLayout3.marginWidth=2;
gridLayout3.marginHeight=2;
gridLayout3.verticalSpacing=2;
GridData gridData7=new GridData();
gridData7.horizontalAlignment=GridData.FILL;
gridData7.grabExcessHorizontalSpace=true;
gridData7.grabExcessVerticalSpace=true;
gridData7.verticalAlignment=GridData.FILL;
groupNetworkParameters=new Group(groupConnectionParameters, SWT.NONE);
groupNetworkParameters.setLayoutData(gridData7);
groupNetworkParameters.setLayout(gridLayout3);
groupNetworkParameters.setText(Messages.getString("CompositeConnectionSettings.28"));
Label filler935=new Label(groupNetworkParameters, SWT.NONE);
filler3=new Label(groupNetworkParameters, SWT.NONE);
filler3.setText("");
filler3.setLayoutData(gridData26);
Label filler511=new Label(groupNetworkParameters, SWT.NONE);
Label filler936=new Label(groupNetworkParameters, SWT.NONE);
filler7=new Label(groupNetworkParameters, SWT.NONE);
filler7.setText("");
filler7.setLayoutData(gridData29);
labelNPIPAddress=new Label(groupNetworkParameters, SWT.NONE);
labelNPIPAddress.setText(Messages.getString("CompositeConnectionSettings.29"));
labelNPIPAddress.setLayoutData(gridData30);
textNPIPAddress=new Text(groupNetworkParameters, SWT.BORDER);
textNPIPAddress.setText("XXX.XXX.XXX.XXX");
textNPIPAddress.setLayoutData(gridData38);
filler6=new Label(groupNetworkParameters, SWT.NONE);
filler6.setText("");
filler6.setLayoutData(gridData28);
Label filler734=new Label(groupNetworkParameters, SWT.NONE);
labelNPNetmask=new Label(groupNetworkParameters, SWT.NONE);
labelNPNetmask.setText(Messages.getString("CompositeConnectionSettings.30"));
labelNPNetmask.setLayoutData(gridData31);
textNPNetmask=new Text(groupNetworkParameters, SWT.BORDER);
textNPNetmask.setText("XXX.XXX.XXX.XXX");
textNPNetmask.setLayoutData(gridData47);
Label filler625=new Label(groupNetworkParameters, SWT.NONE);
Label filler733=new Label(groupNetworkParameters, SWT.NONE);
labelNPGateway=new Label(groupNetworkParameters, SWT.NONE);
labelNPGateway.setText(Messages.getString("CompositeConnectionSettings.31"));
labelNPGateway.setLayoutData(gridData32);
textNPGateway=new Text(groupNetworkParameters, SWT.BORDER);
textNPGateway.setText("XXX.XXX.XXX.XXX");
textNPGateway.setLayoutData(gridData48);
Label filler972=new Label(groupNetworkParameters, SWT.NONE);
Label filler973=new Label(groupNetworkParameters, SWT.NONE);
filler9=new Label(groupNetworkParameters, SWT.NONE);
filler9.setText("");
Label filler10=new Label(groupNetworkParameters, SWT.NONE);
Label filler11=new Label(groupNetworkParameters, SWT.NONE);
Label filler732=new Label(groupNetworkParameters, SWT.NONE);
checkBoxNPDHCP=new Button(groupNetworkParameters, SWT.CHECK);
checkBoxNPDHCP.setText("DHCP");
checkBoxNPDHCP.setLayoutData(gridData35);
labelNoteEthernetSettings=new Label(groupNetworkParameters, SWT.NONE);
labelNoteEthernetSettings.setText(Messages.getString("CompositeConnectionSettings.40"));
labelNoteEthernetSettings.setLayoutData(gridData57);
Label filler8=new Label(groupNetworkParameters, SWT.NONE);
Label filler731=new Label(groupNetworkParameters, SWT.NONE);
checkBoxNPLPD=new Button(groupNetworkParameters, SWT.CHECK);
checkBoxNPLPD.setText("LPD");
checkBoxNPLPD.setLayoutData(gridData36);
Label filler4=new Label(groupNetworkParameters, SWT.NONE);
Label filler730=new Label(groupNetworkParameters, SWT.NONE);
checkBoxNPRTEL=new Button(groupNetworkParameters, SWT.CHECK);
checkBoxNPRTEL.setText("RTEL");
checkBoxNPRTEL.setLayoutData(gridData37);
Label filler1=new Label(groupNetworkParameters, SWT.NONE);
Label filler19=new Label(groupNetworkParameters, SWT.NONE);
filler22=new Label(groupNetworkParameters, SWT.NONE);
filler22.setText("");
Label filler53=new Label(groupNetworkParameters, SWT.NONE);
Label filler54=new Label(groupNetworkParameters, SWT.NONE);
Label filler729=new Label(groupNetworkParameters, SWT.NONE);
labelNPRTELPort=new Label(groupNetworkParameters, SWT.NONE);
labelNPRTELPort.setText(Messages.getString("CompositeConnectionSettings.32"));
labelNPRTELPort.setLayoutData(gridData33);
textNPRTELPort=new Text(groupNetworkParameters, SWT.BORDER);
textNPRTELPort.setText("9100");
textNPRTELPort.setLayoutData(gridData49);
Label filler620=new Label(groupNetworkParameters, SWT.NONE);
Label filler728=new Label(groupNetworkParameters, SWT.NONE);
labelNPBufSize=new Label(groupNetworkParameters, SWT.NONE);
labelNPBufSize.setText(Messages.getString("CompositeConnectionSettings.33"));
labelNPBufSize.setLayoutData(gridData34);
textNPBufSize=new Text(groupNetworkParameters, SWT.BORDER);
textNPBufSize.setText("32768");
textNPBufSize.setLayoutData(gridData50);
Label filler619=new Label(groupNetworkParameters, SWT.NONE);
Label filler727=new Label(groupNetworkParameters, SWT.NONE);
filler5=new Label(groupNetworkParameters, SWT.NONE);
filler5.setText("");
filler5.setLayoutData(gridData27);
Label filler20=new Label(groupNetworkParameters, SWT.NONE);
Label filler44=new Label(groupNetworkParameters, SWT.NONE);
Label filler45=new Label(groupNetworkParameters, SWT.NONE);
buttonNPApply=new Button(groupNetworkParameters, SWT.NONE);
buttonNPApply.setText(Messages.getString("General.0"));
buttonNPApply.setLayoutData(gridData21);
buttonNPApply
.addSelectionListener(new org.eclipse.swt.events.SelectionAdapter()
{
public void widgetSelected(org.eclipse.swt.events.SelectionEvent e)
{
setGroupNetworkParameters();
}
});
buttonNPRefresh=new Button(groupNetworkParameters, SWT.NONE);
buttonNPRefresh.setText(Messages.getString("General.1"));
buttonNPRefresh.setLayoutData(gridData22);
buttonNPRefresh
.addSelectionListener(new org.eclipse.swt.events.SelectionAdapter()
{
public void widgetSelected(org.eclipse.swt.events.SelectionEvent e)
{
refreshGroupNetworkParameters();
}
});
Label filler60=new Label(groupNetworkParameters, SWT.NONE);
Label filler61=new Label(groupNetworkParameters, SWT.NONE);
Label filler62=new Label(groupNetworkParameters, SWT.NONE);
filler63=new Label(groupNetworkParameters, SWT.NONE);
filler63.setText("");
filler63.setLayoutData(gridData43);
}
private void createComboBaudRate()
{
GUIHelper.logger.trace("");
GridData gridData11=new GridData();
gridData11.horizontalAlignment=GridData.BEGINNING;
gridData11.grabExcessHorizontalSpace=false;
gridData11.verticalAlignment=GridData.CENTER;
comboBaudRate=new Combo(groupConnectionType, SWT.READ_ONLY);
comboBaudRate.setLayoutData(gridData11);
}
private void createComboPrinterName()
{
GUIHelper.logger.trace("");
GridData gridData12=new GridData();
gridData12.horizontalAlignment=GridData.BEGINNING;
gridData12.grabExcessHorizontalSpace=false;
gridData12.horizontalSpan=2;
gridData12.widthHint=100;
gridData12.verticalAlignment=GridData.CENTER;
}
private void createComboComPort()
{
GUIHelper.logger.trace("");
GridData gridData10=new GridData();
gridData10.horizontalAlignment=GridData.BEGINNING;
gridData10.grabExcessHorizontalSpace=false;
gridData10.verticalAlignment=GridData.CENTER;
comboComPort=new Combo(groupConnectionType, SWT.DROP_DOWN|SWT.READ_ONLY);
comboComPort.setLayoutData(gridData10);
}
private void createComboSCBaudRate()
{
GUIHelper.logger.trace("");
GridData gridData44=new GridData();
gridData44.horizontalAlignment=GridData.FILL;
gridData44.verticalAlignment=GridData.CENTER;
comboSCBaudRate=new Combo(groupSerialParameters, SWT.READ_ONLY);
comboSCBaudRate.setLayoutData(gridData44);
}
private void showDumbTerminalCheckBox()
{
checkBoxDumbTerminal.setEnabled(false);
checkBoxDumbTerminal.setVisible(GUIHelper.prefs.getBoolean("SHOW_DUMB_TERMINAL_CHECKBOX", false));
checkBoxDumbTerminal.setSelection(GUIHelper.prefs.getBoolean("DUMB_TERMINAL", false));
}
private void setDefaultConnectionParameters()
{
GUIHelper.logger.trace("");
connectionType=ConnectionType.valueOf(GUIHelper.prefs.get("DEFAULT_CONNECTION_TYPE", "UNKNOWN"));
GUIHelper.logger.debug("Default Connection Type: "+connectionType);
refreshComPortList();
String defaultPort=GUIHelper.prefs.get("COM_PORT", "COM1");
int index=comboComPort.indexOf(defaultPort);
comboComPort.select(index);
populateBaudRateCombos();
String defaultBaudRate=GUIHelper.prefs.get("BAUD_RATE", "115200");
index=comboBaudRate.indexOf(defaultBaudRate);
comboBaudRate.select(index);
populateStopBitsCombos();
String defaultStopBits=GUIHelper.prefs.get("STOP_BITS", "1");
index=comboStopBits.indexOf(defaultStopBits);
comboStopBits.select(index);
textIPAddress.setText(GUIHelper.prefs.get("IP_ADDRESS", ""));
textIPPort.setText(GUIHelper.prefs.get("IP_PORT", "9100"));
refreshParallelPortList();
String defaultLPTPort=GUIHelper.prefs.get("LPT_PORT", "LPT1");
int indexLPT=comboParallelPort.indexOf(defaultLPTPort);
comboParallelPort.select(indexLPT);
}
public ConnectionType getConnectionType()
{
return connectionType;
}
private void createComboParallelPort()
{
GUIHelper.logger.trace("");
comboParallelPort=new Combo(groupConnectionType, SWT.DROP_DOWN|SWT.READ_ONLY);
}
private void createComboStopBits()
{
comboStopBits=new Combo(groupConnectionType, SWT.READ_ONLY);
comboStopBits.setVisibleItemCount(2);
}
private void createComboSCStopBits()
{
comboSCStopBits=new Combo(groupSerialParameters, SWT.READ_ONLY);
comboSCStopBits.setVisibleItemCount(2);
}
}
```
## File: JAdmin/src/com/cognitive/admin/CompositeCPLEditor.java
```java
public class CompositeCPLEditor extends Composite implements Observer, HasCallback
{
private static boolean hasPCLFirmware=false;
private boolean dumbTerminal=true;
private String pathCPLInput=null;
private String pathCPLOutput=null;
private TimerTaskCPL timerTaskCPL=null;
private Text textAreaInput=null;
private Text textAreaOutput=null;
private Group groupInputButtons=null;
private Group groupOutputButtons=null;
private Group groupTimerButtons=null;
private Button buttonOpenFile=null;
private Button buttonSaveFile=null;
private Button buttonSendToPrinter=null;
private Button buttonViewVariables=null;
private Button buttonViewTime=null;
private Button buttonSaveOutput=null;
private Button buttonClearOutput=null;
private Label labelPrinterInput=null;
private Label labelPrinterOutput=null;
private Label labelInterval=null;
private Text textInterval=null;
private Label labelRepeat=null;
private Text textRepeat=null;
private Label labelCurrent=null;
private Label labelCounter=null;
private Button buttonTimerStart=null;
private Button buttonTimerPause=null;
private Button buttonTimerResume=null;
private Button buttonTimerStop=null;
private Label filler11=null;
private Label filler3=null;
private Label filler9=null;
private Label filler12=null;
private Label filler13=null;
private Label filler17=null;
private Label filler24=null;
private Label filler32=null;
private Button buttonClearInput=null;
private Button buttonSendFileToPrinter=null;
public void setConnectionState(boolean connected, boolean dumbTerminal)
{
GUIHelper.logger.trace("");
this.dumbTerminal=dumbTerminal;
GUIHelper.setEnabled(this, connected);
GUIHelper.setEnabled(groupOutputButtons, connected);
textAreaOutput.setEnabled(connected);
if(connected&&!dumbTerminal)
{
PrinterHelper.printer.addObserver(this);
timerStop();
}
}
public CompositeCPLEditor(Composite parent, int style)
{
super(parent, style);
initialize();
}
private void initialize()
{
GridData gridData21=new GridData();
gridData21.horizontalAlignment=GridData.FILL;
gridData21.grabExcessHorizontalSpace=true;
gridData21.grabExcessVerticalSpace=true;
gridData21.verticalAlignment=GridData.FILL;
labelPrinterInput=new Label(this, SWT.NONE);
labelPrinterInput.setText(Messages.getString("CompositeCPLEditor.0"));
GridData gridData1=new GridData();
gridData1.grabExcessHorizontalSpace=true;
gridData1.horizontalAlignment=GridData.FILL;
gridData1.verticalAlignment=GridData.FILL;
gridData1.verticalSpan=2;
gridData1.grabExcessVerticalSpace=true;
labelPrinterOutput=new Label(this, SWT.NONE);
labelPrinterOutput.setText(Messages.getString("CompositeCPLEditor.1"));
textAreaInput=new Text(this, SWT.MULTI|SWT.WRAP|SWT.V_SCROLL|SWT.H_SCROLL);
textAreaInput.setText("");
textAreaInput.setFont(new Font(Display.getDefault(), "Courier New", 8, SWT.NORMAL));
textAreaInput.setLayoutData(gridData1);
textAreaOutput=new Text(this, SWT.MULTI|SWT.WRAP|SWT.V_SCROLL|SWT.H_SCROLL);
textAreaOutput.setText("");
textAreaOutput.setFont(new Font(Display.getDefault(), "Courier New", 8, SWT.NORMAL));
textAreaOutput.setLayoutData(gridData21);
GridLayout gridLayout=new GridLayout();
gridLayout.numColumns=2;
gridLayout.makeColumnsEqualWidth=true;
this.setLayout(gridLayout);
createGroupOutputButtons();
createGroupInputButtons();
createGroupTimerButtons();
this.setSize(new Point(646, 344));
}
private void createGroupInputButtons()
{
GridData gridData25=new GridData();
gridData25.horizontalSpan=4;
gridData25.verticalAlignment=GridData.CENTER;
gridData25.horizontalAlignment=GridData.CENTER;
GridData gridData17=new GridData();
gridData17.horizontalAlignment=GridData.CENTER;
gridData17.grabExcessHorizontalSpace=true;
gridData17.verticalAlignment=GridData.CENTER;
GridData gridData14=new GridData();
gridData14.horizontalAlignment=GridData.CENTER;
gridData14.grabExcessHorizontalSpace=true;
gridData14.verticalAlignment=GridData.CENTER;
GridData gridData13=new GridData();
gridData13.grabExcessVerticalSpace=true;
gridData13.verticalAlignment=GridData.CENTER;
gridData13.horizontalAlignment=GridData.CENTER;
GridLayout gridLayout1=new GridLayout();
gridLayout1.numColumns=6;
GridData gridData3=new GridData();
gridData3.horizontalAlignment=GridData.FILL;
gridData3.grabExcessHorizontalSpace=false;
gridData3.verticalAlignment=GridData.FILL;
groupInputButtons=new Group(this, SWT.NONE);
groupInputButtons.setLayoutData(gridData3);
groupInputButtons.setLayout(gridLayout1);
Label filler14=new Label(groupInputButtons, SWT.NONE);
Label filler16=new Label(groupInputButtons, SWT.NONE);
filler17=new Label(groupInputButtons, SWT.NONE);
filler17.setText("");
filler17.setLayoutData(gridData13);
Label filler1=new Label(groupInputButtons, SWT.NONE);
Label filler19=new Label(groupInputButtons, SWT.NONE);
Label filler20=new Label(groupInputButtons, SWT.NONE);
filler13=new Label(groupInputButtons, SWT.NONE);
filler13.setText("");
filler13.setLayoutData(gridData17);
buttonOpenFile=new Button(groupInputButtons, SWT.NONE);
buttonOpenFile.setText(Messages.getString("CompositeCPLEditor.2"));
buttonOpenFile
.addSelectionListener(new org.eclipse.swt.events.SelectionAdapter()
{
public void widgetSelected(org.eclipse.swt.events.SelectionEvent e)
{
openCPLFile();
}
});
buttonSaveFile=new Button(groupInputButtons, SWT.NONE);
buttonSaveFile.setText(Messages.getString("CompositeCPLEditor.3"));
buttonClearInput=new Button(groupInputButtons, SWT.NONE);
buttonClearInput.setText(Messages.getString("CompositeCPLEditor.4"));
buttonClearInput
.addSelectionListener(new org.eclipse.swt.events.SelectionAdapter()
{
public void widgetSelected(org.eclipse.swt.events.SelectionEvent e)
{
clearInput();
}
});
buttonSaveFile
.addSelectionListener(new org.eclipse.swt.events.SelectionAdapter()
{
public void widgetSelected(org.eclipse.swt.events.SelectionEvent e)
{
if(pathCPLInput==null)
{
pathCPLInput=GUIHelper.prefs.get("PATH_CPL_INPUT", ".");
}
saveCPLFile();
}
});
buttonSendToPrinter=new Button(groupInputButtons, SWT.NONE);
buttonSendToPrinter.setText(Messages.getString("CompositeCPLEditor.5"));
buttonSendToPrinter
.addSelectionListener(new org.eclipse.swt.events.SelectionAdapter()
{
public void widgetSelected(org.eclipse.swt.events.SelectionEvent e)
{
sendToPrinter();
}
});
filler12=new Label(groupInputButtons, SWT.NONE);
filler12.setText("");
filler12.setLayoutData(gridData14);
Label filler46=new Label(groupInputButtons, SWT.NONE);
buttonSendFileToPrinter=new Button(groupInputButtons, SWT.NONE);
buttonSendFileToPrinter.setText(Messages.getString("CompositeCPLEditor.20"));
buttonSendFileToPrinter.setLayoutData(gridData25);
buttonSendFileToPrinter
.addSelectionListener(new org.eclipse.swt.events.SelectionAdapter()
{
public void widgetSelected(org.eclipse.swt.events.SelectionEvent e)
{
sendFile();
}
});
}
private void createGroupOutputButtons()
{
GridData gridData24=new GridData();
gridData24.horizontalAlignment=GridData.FILL;
gridData24.verticalAlignment=GridData.CENTER;
GridData gridData23=new GridData();
gridData23.horizontalAlignment=GridData.FILL;
gridData23.verticalAlignment=GridData.CENTER;
GridData gridData22=new GridData();
gridData22.horizontalAlignment=GridData.FILL;
gridData22.verticalAlignment=GridData.CENTER;
GridData gridData20=new GridData();
gridData20.horizontalAlignment=GridData.FILL;
gridData20.verticalAlignment=GridData.CENTER;
GridData gridData19=new GridData();
gridData19.horizontalAlignment=GridData.CENTER;
gridData19.grabExcessHorizontalSpace=true;
gridData19.verticalAlignment=GridData.CENTER;
GridData gridData18=new GridData();
gridData18.horizontalAlignment=GridData.CENTER;
gridData18.grabExcessHorizontalSpace=true;
gridData18.verticalAlignment=GridData.CENTER;
GridLayout gridLayout3=new GridLayout();
gridLayout3.numColumns=4;
GridData gridData2=new GridData();
gridData2.horizontalAlignment=GridData.FILL;
gridData2.verticalAlignment=GridData.FILL;
groupOutputButtons=new Group(this, SWT.NONE);
groupOutputButtons.setLayoutData(gridData2);
groupOutputButtons.setLayout(gridLayout3);
Label filler33=new Label(groupOutputButtons, SWT.NONE);
buttonViewVariables=new Button(groupOutputButtons, SWT.NONE);
buttonViewVariables.setText(Messages.getString("CompositeCPLEditor.6"));
buttonViewVariables.setLayoutData(gridData20);
buttonViewVariables
.addSelectionListener(new org.eclipse.swt.events.SelectionAdapter()
{
public void widgetSelected(org.eclipse.swt.events.SelectionEvent e)
{
viewVariables();
}
});
buttonViewTime=new Button(groupOutputButtons, SWT.NONE);
buttonViewTime.setText(Messages.getString("CompositeCPLEditor.7"));
buttonViewTime.setLayoutData(gridData24);
buttonViewTime
.addSelectionListener(new org.eclipse.swt.events.SelectionAdapter()
{
public void widgetSelected(org.eclipse.swt.events.SelectionEvent e)
{
viewTime();
}
});
Label filler25=new Label(groupOutputButtons, SWT.NONE);
filler32=new Label(groupOutputButtons, SWT.NONE);
filler32.setText("");
filler32.setLayoutData(gridData19);
buttonSaveOutput=new Button(groupOutputButtons, SWT.NONE);
buttonSaveOutput.setText(Messages.getString("CompositeCPLEditor.8"));
buttonSaveOutput.setLayoutData(gridData22);
buttonSaveOutput
.addSelectionListener(new org.eclipse.swt.events.SelectionAdapter()
{
public void widgetSelected(org.eclipse.swt.events.SelectionEvent e)
{
if(pathCPLOutput==null)
{
pathCPLOutput=GUIHelper.prefs.get("PATH_CPL_OUTPUT", ".");
}
saveOutputFile();
}
});
buttonClearOutput=new Button(groupOutputButtons, SWT.NONE);
buttonClearOutput.setText(Messages.getString("CompositeCPLEditor.9"));
buttonClearOutput.setLayoutData(gridData23);
buttonClearOutput
.addSelectionListener(new org.eclipse.swt.events.SelectionAdapter()
{
public void widgetSelected(org.eclipse.swt.events.SelectionEvent e)
{
clearOutput();
}
});
filler24=new Label(groupOutputButtons, SWT.NONE);
filler24.setText("");
filler24.setLayoutData(gridData18);
}
private void createGroupTimerButtons()
{
GridData gridData16=new GridData();
gridData16.horizontalAlignment=GridData.CENTER;
gridData16.grabExcessHorizontalSpace=true;
gridData16.verticalAlignment=GridData.CENTER;
GridData gridData15=new GridData();
gridData15.horizontalAlignment=GridData.CENTER;
gridData15.grabExcessHorizontalSpace=true;
gridData15.verticalAlignment=GridData.CENTER;
GridData gridData7=new GridData();
gridData7.horizontalAlignment=GridData.FILL;
gridData7.verticalAlignment=GridData.CENTER;
GridData gridData6=new GridData();
gridData6.horizontalAlignment=GridData.FILL;
gridData6.verticalAlignment=GridData.CENTER;
GridData gridData5=new GridData();
gridData5.horizontalAlignment=GridData.FILL;
gridData5.verticalAlignment=GridData.CENTER;
GridData gridData=new GridData();
gridData.horizontalAlignment=GridData.FILL;
gridData.verticalAlignment=GridData.CENTER;
GridData gridData11=new GridData();
gridData11.horizontalAlignment=GridData.FILL;
gridData11.verticalAlignment=GridData.CENTER;
GridData gridData10=new GridData();
gridData10.horizontalAlignment=GridData.FILL;
gridData10.verticalAlignment=GridData.CENTER;
GridData gridData9=new GridData();
gridData9.horizontalAlignment=GridData.END;
gridData9.verticalAlignment=GridData.CENTER;
GridData gridData8=new GridData();
gridData8.horizontalAlignment=GridData.END;
gridData8.verticalAlignment=GridData.CENTER;
GridLayout gridLayout2=new GridLayout();
gridLayout2.numColumns=6;
gridLayout2.makeColumnsEqualWidth=false;
GridData gridData4=new GridData();
gridData4.horizontalAlignment=GridData.FILL;
gridData4.grabExcessVerticalSpace=false;
gridData4.verticalAlignment=GridData.FILL;
groupTimerButtons=new Group(this, SWT.NONE);
groupTimerButtons.setText(Messages.getString("CompositeCPLEditor.10"));
groupTimerButtons.setLayout(gridLayout2);
groupTimerButtons.setLayoutData(gridData4);
Label filler10=new Label(groupTimerButtons, SWT.NONE);
labelInterval=new Label(groupTimerButtons, SWT.NONE);
labelInterval.setText(Messages.getString("CompositeCPLEditor.11"));
labelInterval.setLayoutData(gridData9);
textInterval=new Text(groupTimerButtons, SWT.BORDER);
textInterval.setLayoutData(gridData11);
labelRepeat=new Label(groupTimerButtons, SWT.NONE);
labelRepeat.setText(Messages.getString("CompositeCPLEditor.12"));
labelRepeat.setLayoutData(gridData8);
textRepeat=new Text(groupTimerButtons, SWT.BORDER);
textRepeat.setLayoutData(gridData10);
Label filler4=new Label(groupTimerButtons, SWT.NONE);
filler9=new Label(groupTimerButtons, SWT.NONE);
filler9.setText("");
filler9.setLayoutData(gridData16);
filler11=new Label(groupTimerButtons, SWT.NONE);
filler11.setText("");
labelCurrent=new Label(groupTimerButtons, SWT.NONE);
labelCurrent.setText(Messages.getString("CompositeCPLEditor.13"));
labelCounter=new Label(groupTimerButtons, SWT.NONE);
labelCounter.setText("xxx/yyy");
Label filler5=new Label(groupTimerButtons, SWT.NONE);
filler3=new Label(groupTimerButtons, SWT.NONE);
filler3.setText("");
filler3.setLayoutData(gridData15);
Label filler8=new Label(groupTimerButtons, SWT.NONE);
buttonTimerStart=new Button(groupTimerButtons, SWT.NONE);
buttonTimerStart.setText(Messages.getString("CompositeCPLEditor.14"));
buttonTimerStart.setLayoutData(gridData5);
buttonTimerStart
.addSelectionListener(new org.eclipse.swt.events.SelectionAdapter()
{
public void widgetSelected(org.eclipse.swt.events.SelectionEvent e)
{
timerStart();
}
});
buttonTimerPause=new Button(groupTimerButtons, SWT.NONE);
buttonTimerPause.setText(Messages.getString("CompositeCPLEditor.15"));
buttonTimerPause.setLayoutData(gridData);
buttonTimerPause
.addSelectionListener(new org.eclipse.swt.events.SelectionAdapter()
{
public void widgetSelected(org.eclipse.swt.events.SelectionEvent e)
{
timerPause();
}
});
buttonTimerResume=new Button(groupTimerButtons, SWT.NONE);
buttonTimerResume.setText(Messages.getString("CompositeCPLEditor.16"));
buttonTimerResume.setLayoutData(gridData6);
buttonTimerResume
.addSelectionListener(new org.eclipse.swt.events.SelectionAdapter()
{
public void widgetSelected(org.eclipse.swt.events.SelectionEvent e)
{
timerResume();
}
});
buttonTimerStop=new Button(groupTimerButtons, SWT.NONE);
buttonTimerStop.setText(Messages.getString("CompositeCPLEditor.17"));
buttonTimerStop.setLayoutData(gridData7);
buttonTimerStop
.addSelectionListener(new org.eclipse.swt.events.SelectionAdapter()
{
public void widgetSelected(org.eclipse.swt.events.SelectionEvent e)
{
timerStop();
}
});
}
private void saveOutputFile()
{
pathCPLOutput=GUIHelper.saveTextFile(textAreaOutput.getText(), pathCPLOutput);
GUIHelper.prefs.put("PATH_CPL_INPUT", pathCPLInput);
if(pathCPLInput==null)
{
pathCPLInput=pathCPLOutput;
GUIHelper.prefs.put("PATH_CPL_INPUT", pathCPLInput);
}
}
private void saveCPLFile()
{
pathCPLInput=GUIHelper.saveTextFile(textAreaInput.getText(), pathCPLInput);
GUIHelper.prefs.put("PATH_CPL_INPUT", pathCPLInput);
if(pathCPLOutput==null)
{
pathCPLOutput=pathCPLInput;
GUIHelper.prefs.put("PATH_CPL_OUTPUT", pathCPLOutput);
}
}
private void openCPLFile()
{
if(pathCPLInput==null)
{
pathCPLInput=GUIHelper.prefs.get("PATH_CPL_INPUT", ".");
}
StringBuffer pathUsed=new StringBuffer();
BufferedReader brd=GUIHelper.openTextFile(pathCPLInput, pathUsed);
if(brd==null)
{
return;
}
pathCPLInput=pathUsed.toString();
GUIHelper.prefs.put("PATH_CPL_INPUT", pathCPLInput);
if(pathCPLOutput==null)
{
pathCPLOutput=pathCPLInput;
GUIHelper.prefs.put("PATH_CPL_OUTPUT", pathCPLOutput);
}
try
{
String line;
while((line=brd.readLine())!=null)
{
textAreaInput.append(line+'\n');
}
}
catch(IOException e)
{
GUIHelper.message(Messages.getString("CompositeCPLEditor.18"), SWT.OK|SWT.ICON_ERROR);
return;
}
return;
}
private void sendFile()
{
if(pathCPLInput==null)
{
pathCPLInput=GUIHelper.prefs.get("PATH_CPL_INPUT", ".");
}
FileDialog fd=new FileDialog(GUIHelper.myShell, SWT.OPEN);
fd.setFilterPath(pathCPLInput);
String fileName=fd.open();
if(fileName==null)
{
return;
}
pathCPLInput=fd.getFilterPath();
GUIHelper.prefs.put("PATH_CPL_INPUT", pathCPLInput);
byte[] data;
try
{
data=GUIHelper.readBinaryFile(fileName);
}
catch(Exception e)
{
GUIHelper.error(Messages.getString("CompositePCLWindowing.22")+fileName);
return;
}
try
{
PrinterHelper.send(data);
}
catch(Exception e)
{
GUIHelper.logger.error("Failed:", e);
GUIHelper.error(Messages.getString("CompositeCPLEditor.21")+e.toString());
}
}
private void sendToPrinter()
{
try
{
PrinterHelper.send(textAreaInput.getText());
}
catch(Exception e)
{
GUIHelper.logger.error("Failed:", e);
GUIHelper.error(Messages.getString("CompositeCPLEditor.19")+e.toString());
}
}
private void viewTime()
{
try
{
textAreaOutput.append(PrinterHelper.getVariable("TIME")+"\n");
}
catch(Exception e)
{
GUIHelper.logger.error("Failed:", e);
GUIHelper.error(Messages.getString("CompositeCPLEditor.19")+e.toString());
}
}
public void update(Observable observable, final Object object)
{
GUIHelper.logger.trace("");
String className=observable.getClass().getName();
if(className.equals("com.cognitive.printer.Printer"))
{
if(object==null)
{
GUIHelper.logger.warn("Received null object in notification.  Ignoring it.");
return;
}
GUIHelper.myDisplay.asyncExec(new Runnable()
{
public void run()
{
textAreaOutput.append(object.toString());
}
});
}
else
{
GUIHelper.logger.warn("Received update from unknown observable ["+observable.toString()+"]");
}
}
private void viewVariables()
{
String currentFirmwarePartNumber=TestEngine.getCurrentFirmwarePartNumber();
if(currentFirmwarePartNumber!=null)
{
hasPCLFirmware=currentFirmwarePartNumber.split("-")[1].equals("176");
}
String viewLabel="";
viewLabel+="!QR\r\n";
viewLabel+="!!0 0 0 0\r\n";
viewLabel+="!0 0 0 0\r\n";
viewLabel+="v time ?\r\n";
viewLabel+="v aux_power ?\r\n";
viewLabel+="v buffer_timed_reset ?\r\n";
viewLabel+="v comm ?\r\n";
viewLabel+="v comm dsr ?\r\n";
viewLabel+="v comm dtr ?\r\n";
viewLabel+="v darkness ?\r\n";
viewLabel+="v error_level ?\r\n";
viewLabel+="v index ?\r\n";
if(!hasPCLFirmware)
{
viewLabel+="v print_speed ?\r\n";
}
viewLabel+="v feed ?\r\n";
viewLabel+="v no_media ?\r\n";
viewLabel+="v pitch ?\r\n";
viewLabel+="v position ?\r\n";
viewLabel+="v presentlabel ?\r\n";
viewLabel+="v report_level ?\r\n";
viewLabel+="v report_type ?\r\n";
viewLabel+="v sleep_after ?\r\n";
viewLabel+="v off_after ?\r\n";
viewLabel+="v shift LEFT ?\r\n";
viewLabel+="v user_feedback ?\r\n";
viewLabel+="v width ?\r\n";
viewLabel+="v feed_type ?\r\n";
viewLabel+="cv allocate ?\r\n";
viewLabel+="cv autocut ?\r\n";
viewLabel+="cv low_battery_ignore ?\r\n";
viewLabel+="cv speed\r\n";
viewLabel+="cv media_adjust ?\r\n";
viewLabel+="cv mode ?\r\n";
viewLabel+="cv on_time ?\r\n";
viewLabel+="v print_mode ?\r\n";
viewLabel+="v txtbfr ?\r\n";
viewLabel+="v irda ?\r\n";
viewLabel+="E\r\n";
try
{
PrinterHelper.printer.send(viewLabel);
}
catch(Exception e)
{
GUIHelper.logger.error("Failed:", e);
GUIHelper.error(Messages.getString("CompositeCPLEditor.19")+e.toString());
}
}
private void clearOutput()
{
textAreaOutput.setText("");
}
private void clearInput()
{
textAreaInput.setText("");
}
private void timerStart()
{
buttonTimerStart.setEnabled(false);
buttonTimerPause.setEnabled(true);
buttonTimerResume.setEnabled(false);
buttonTimerStop.setEnabled(true);
timerTaskCPL=new TimerTaskCPL(Integer.parseInt(textRepeat.getText()),
1,
textAreaInput.getText(),
labelCounter,
this);
MainShell.timer.schedule(timerTaskCPL, 0, 1000*(Long.parseLong(textInterval.getText())));
}
private void timerPause()
{
buttonTimerStart.setEnabled(false);
buttonTimerPause.setEnabled(false);
buttonTimerResume.setEnabled(true);
buttonTimerStop.setEnabled(true);
timerTaskCPL.cancel();
timerTaskCPL=null;
}
private void timerResume()
{
buttonTimerStart.setEnabled(false);
buttonTimerPause.setEnabled(true);
buttonTimerResume.setEnabled(false);
buttonTimerStop.setEnabled(true);
String parts[]=labelCounter.getText().split("/");
int current=Integer.parseInt(parts[0])+1;
timerTaskCPL=new TimerTaskCPL(Integer.parseInt(textRepeat.getText()),
current,
textAreaInput.getText(),
labelCounter,
this);
MainShell.timer.schedule(timerTaskCPL, 0, 1000*(Long.parseLong(textInterval.getText())));
}
private void timerStop()
{
buttonTimerStart.setEnabled(true);
buttonTimerPause.setEnabled(false);
buttonTimerResume.setEnabled(false);
buttonTimerStop.setEnabled(false);
if(timerTaskCPL!=null)
{
timerTaskCPL.cancel();
timerTaskCPL=null;
}
}
public void callback()
{
timerStop();
}
}
```
## File: JAdmin/src/com/cognitive/admin/CompositeFirmwareCPR.java
```java
public class CompositeFirmwareCPR extends Composite
{
private boolean connected=false;
private boolean firstPaintSinceConnected=true;
private boolean dumbTerminal=false;
private String pathFirmware=null;
private String currentFirmware=null;
private String fileName=null;
private Group groupFirmware=null;
private Group groupCPR=null;
private Label labelPartNumber=null;
private Label labelVersionNumber=null;
private Label labelReleaseDate=null;
private Label labelPartNumberActual=null;
private Label labelVersionNumberActual=null;
private Label labelReleaseDateActual=null;
private Label separator=null;
private Label labelNewImage=null;
private Button buttonSurfFirmware=null;
private Text textNewImage=null;
private Button buttonUpdateFirmware=null;
private Label labelUpdateProgress=null;
private ProgressBar progressBarFirmwareUpdate=null;
private Button buttonSelectFirmwareFile=null;
private Label filler=null;
private Label filler2=null;
private Label filler8=null;
private Label filler12=null;
private Button buttonFirmwareRefresh=null;
private Label labelFirmwareCurrent=null;
private Label labelFirmwareUpgrade=null;
private Label labelState=null;
static Label labelNote=null;
public CompositeFirmwareCPR(Composite parent, int style)
{
super(parent, style);
initialize();
}
private void initialize()
{
GridData gridData17=new GridData();
gridData17.grabExcessHorizontalSpace=true;
Label filler14=new Label(this, SWT.NONE);
GridData gridData16=new GridData();
gridData16.grabExcessHorizontalSpace=true;
GridData gridData15=new GridData();
gridData15.grabExcessVerticalSpace=true;
GridData gridData14=new GridData();
gridData14.grabExcessVerticalSpace=true;
filler=new Label(this, SWT.NONE);
filler.setText("");
filler.setLayoutData(gridData14);
GridLayout gridLayout1=new GridLayout();
gridLayout1.numColumns=3;
Label filler9=new Label(this, SWT.NONE);
Label filler13=new Label(this, SWT.NONE);
createGroupFirmware();
this.setLayout(gridLayout1);
Label filler7=new Label(this, SWT.NONE);
filler12=new Label(this, SWT.NONE);
filler12.setText("");
filler12.setLayoutData(gridData17);
filler8=new Label(this, SWT.NONE);
filler8.setText("");
filler8.setLayoutData(gridData16);
Label filler11=new Label(this, SWT.NONE);
createGroupCPR();
setSize(new Point(601, 297));
Label filler3=new Label(this, SWT.NONE);
Label filler10=new Label(this, SWT.NONE);
filler2=new Label(this, SWT.NONE);
filler2.setText("");
filler2.setLayoutData(gridData15);
this.addPaintListener(new org.eclipse.swt.events.PaintListener()
{
public void paintControl(org.eclipse.swt.events.PaintEvent e)
{
if(connected&&firstPaintSinceConnected&&!dumbTerminal)
{
firstPaintSinceConnected=false;
refresh();
}
}
});
}
private void createGroupFirmware()
{
GridData gridData20=new GridData();
gridData20.horizontalAlignment=GridData.FILL;
gridData20.horizontalIndent=0;
gridData20.grabExcessHorizontalSpace=false;
gridData20.horizontalSpan=4;
gridData20.verticalSpan=3;
gridData20.grabExcessVerticalSpace=false;
gridData20.verticalAlignment=GridData.FILL;
GridData gridData19=new GridData();
gridData19.horizontalAlignment=GridData.FILL;
gridData19.verticalAlignment=GridData.CENTER;
GridData gridData18=new GridData();
gridData18.horizontalAlignment=GridData.CENTER;
gridData18.verticalAlignment=GridData.CENTER;
GridData gridData13=new GridData();
gridData13.horizontalAlignment=GridData.CENTER;
gridData13.verticalAlignment=GridData.CENTER;
GridData gridData12=new GridData();
gridData12.verticalAlignment=GridData.CENTER;
gridData12.horizontalSpan=2;
gridData12.horizontalAlignment=GridData.FILL;
GridData gridData11=new GridData();
gridData11.horizontalAlignment=GridData.END;
gridData11.verticalAlignment=GridData.CENTER;
GridData gridData10=new GridData();
gridData10.horizontalAlignment=GridData.FILL;
gridData10.horizontalSpan=3;
gridData10.verticalAlignment=GridData.CENTER;
GridData gridData9=new GridData();
gridData9.horizontalAlignment=GridData.END;
gridData9.verticalAlignment=GridData.CENTER;
GridData gridData8=new GridData();
gridData8.horizontalAlignment=GridData.FILL;
gridData8.grabExcessHorizontalSpace=true;
gridData8.horizontalSpan=4;
gridData8.verticalAlignment=GridData.CENTER;
GridData gridData7=new GridData();
gridData7.horizontalAlignment=GridData.FILL;
gridData7.grabExcessHorizontalSpace=true;
gridData7.horizontalSpan=2;
gridData7.verticalAlignment=GridData.CENTER;
GridData gridData6=new GridData();
gridData6.horizontalAlignment=GridData.FILL;
gridData6.grabExcessHorizontalSpace=true;
gridData6.horizontalSpan=2;
gridData6.verticalAlignment=GridData.CENTER;
GridData gridData5=new GridData();
gridData5.horizontalAlignment=GridData.FILL;
gridData5.grabExcessHorizontalSpace=true;
gridData5.horizontalSpan=2;
gridData5.verticalAlignment=GridData.CENTER;
GridLayout gridLayout=new GridLayout();
gridLayout.numColumns=4;
gridLayout.marginWidth=10;
gridLayout.marginHeight=15;
GridData gridData4=new GridData();
gridData4.horizontalAlignment=GridData.END;
gridData4.verticalAlignment=GridData.CENTER;
GridData gridData3=new GridData();
gridData3.horizontalAlignment=GridData.END;
gridData3.verticalAlignment=GridData.CENTER;
GridData gridData2=new GridData();
gridData2.horizontalAlignment=GridData.END;
gridData2.verticalAlignment=GridData.CENTER;
GridData gridData1=new GridData();
gridData1.horizontalAlignment=GridData.FILL;
gridData1.grabExcessHorizontalSpace=true;
gridData1.grabExcessVerticalSpace=true;
gridData1.verticalSpan=2;
gridData1.verticalAlignment=GridData.FILL;
groupFirmware=new Group(this, SWT.NONE);
groupFirmware.setLayoutData(gridData1);
groupFirmware.setLayout(gridLayout);
groupFirmware.setText("Firmware");
labelFirmwareCurrent=new Label(groupFirmware, SWT.NONE);
labelFirmwareCurrent.setText(Messages.getString("CompositeFirmwareCPR.2"));
labelFirmwareCurrent.setFont(new Font(Display.getDefault(), "Tahoma", 8, SWT.BOLD));
Label filler57=new Label(groupFirmware, SWT.NONE);
Label filler58=new Label(groupFirmware, SWT.NONE);
Label filler59=new Label(groupFirmware, SWT.NONE);
labelPartNumber=new Label(groupFirmware, SWT.NONE);
labelPartNumber.setText(Messages.getString("CompositeFirmwareCPR.3"));
labelPartNumber.setLayoutData(gridData2);
labelPartNumberActual=new Label(groupFirmware, SWT.NONE);
labelPartNumberActual.setText("Part Number");
labelPartNumberActual.setLayoutData(gridData5);
Label filler6=new Label(groupFirmware, SWT.NONE);
labelVersionNumber=new Label(groupFirmware, SWT.NONE);
labelVersionNumber.setText(Messages.getString("CompositeFirmwareCPR.4"));
labelVersionNumber.setLayoutData(gridData3);
labelVersionNumberActual=new Label(groupFirmware, SWT.NONE);
labelVersionNumberActual.setText("Version Number");
labelVersionNumberActual.setLayoutData(gridData6);
buttonFirmwareRefresh=new Button(groupFirmware, SWT.NONE);
buttonFirmwareRefresh.setText("Refresh");
buttonFirmwareRefresh.setLayoutData(gridData18);
buttonFirmwareRefresh
.addSelectionListener(new org.eclipse.swt.events.SelectionAdapter()
{
public void widgetSelected(org.eclipse.swt.events.SelectionEvent e)
{
refreshFirmware();
}
});
labelReleaseDate=new Label(groupFirmware, SWT.NONE);
labelReleaseDate.setText(Messages.getString("CompositeFirmwareCPR.5"));
labelReleaseDate.setLayoutData(gridData4);
labelReleaseDateActual=new Label(groupFirmware, SWT.NONE);
labelReleaseDateActual.setText("Release Date");
labelReleaseDateActual.setLayoutData(gridData7);
Label filler4=new Label(groupFirmware, SWT.NONE);
separator=new Label(groupFirmware, SWT.SEPARATOR|SWT.HORIZONTAL);
separator.setText("Label");
separator.setLayoutData(gridData8);
labelFirmwareUpgrade=new Label(groupFirmware, SWT.NONE);
labelFirmwareUpgrade.setText(Messages.getString("CompositeFirmwareCPR.6"));
labelFirmwareUpgrade.setFont(new Font(Display.getDefault(), "Tahoma", 8, SWT.BOLD));
Label filler510=new Label(groupFirmware, SWT.NONE);
Label filler511=new Label(groupFirmware, SWT.NONE);
Label filler512=new Label(groupFirmware, SWT.NONE);
Label filler1=new Label(groupFirmware, SWT.NONE);
buttonSelectFirmwareFile=new Button(groupFirmware, SWT.NONE);
buttonSelectFirmwareFile.setText(Messages.getString("CompositeFirmwareCPR.7"));
buttonSelectFirmwareFile
.addSelectionListener(new org.eclipse.swt.events.SelectionAdapter()
{
public void widgetSelected(org.eclipse.swt.events.SelectionEvent e)
{
selectFirmwareFile();
}
});
buttonSurfFirmware=new Button(groupFirmware, SWT.NONE);
buttonSurfFirmware.setText(Messages.getString("CompositeFirmwareCPR.8").replace("Cognitive", GUIHelper.brand.getProperty("company.name", "CognitiveTPG")));
buttonSurfFirmware.setLayoutData(gridData13);
buttonSurfFirmware
.addSelectionListener(new org.eclipse.swt.events.SelectionAdapter()
{
public void widgetSelected(org.eclipse.swt.events.SelectionEvent e)
{
getLatestFirmware();
}
});
buttonUpdateFirmware=new Button(groupFirmware, SWT.NONE);
buttonUpdateFirmware.setText(Messages.getString("CompositeFirmwareCPR.9"));
buttonUpdateFirmware
.addSelectionListener(new org.eclipse.swt.events.SelectionAdapter()
{
public void widgetSelected(org.eclipse.swt.events.SelectionEvent e)
{
updateFirmware();
}
});
labelNewImage=new Label(groupFirmware, SWT.NONE);
labelNewImage.setText(Messages.getString("CompositeFirmwareCPR.10"));
labelNewImage.setLayoutData(gridData9);
textNewImage=new Text(groupFirmware, SWT.BORDER);
textNewImage.setLayoutData(gridData10);
labelUpdateProgress=new Label(groupFirmware, SWT.NONE);
labelUpdateProgress.setText(Messages.getString("CompositeFirmwareCPR.11"));
labelUpdateProgress.setLayoutData(gridData11);
labelState=new Label(groupFirmware, SWT.CENTER);
labelState.setText(Messages.getString("CompositeFirmwareCPR.12"));
labelState.setLayoutData(gridData19);
labelState.setVisible(false);
labelState.setAlignment(SWT.CENTER);
progressBarFirmwareUpdate=new ProgressBar(groupFirmware, SWT.INDETERMINATE);
progressBarFirmwareUpdate.setVisible(false);
progressBarFirmwareUpdate.setEnabled(false);
progressBarFirmwareUpdate.setLayoutData(gridData12);
labelNote=new Label(groupFirmware, SWT.NONE);
labelNote.setText(Messages.getString("CompositeFirmwareCPR.22"));
labelNote.setLayoutData(gridData20);
}
private void createGroupCPR()
{
GridData gridData=new GridData();
gridData.horizontalAlignment=GridData.FILL;
gridData.grabExcessHorizontalSpace=true;
gridData.grabExcessVerticalSpace=true;
gridData.verticalAlignment=GridData.FILL;
groupCPR=new Group(this, SWT.NONE);
groupCPR.setLayout(new GridLayout());
groupCPR.setLayoutData(gridData);
groupCPR.setText("CPR");
groupCPR.setVisible(false);
}
public void setConnectionState(boolean connected, boolean dumbTerminal)
{
GUIHelper.logger.trace("");
this.connected=connected;
this.dumbTerminal=dumbTerminal;
firstPaintSinceConnected=true;
GUIHelper.setEnabled(this, connected&&!dumbTerminal);
}
private void refresh()
{
GUIHelper.blankify(this);
refreshFirmware();
layout(true, true);
}
private void refreshFirmware()
{
GUIHelper.logger.trace("");
String firmware=GUIHelper.clean((PrinterHelper.commandWaitResponse("!QR")));
String part=null;
String regex=null;
if(firmware==null)
{
return;
}
regex="\\d{3}-\\d{3}-\\d{3}";
currentFirmware=GUIHelper.getMatch(firmware, regex);
labelPartNumberActual.setText(currentFirmware);
regex="[PV]\\d{1,2}\\.\\d{1,2}\\s*[a-zA-Z]{0,1}\\$\\d{0,2}\\s*(RC\\d{1,2}){0,1}";
labelVersionNumberActual.setText(GUIHelper.getMatch(firmware, regex));
regex="(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec).*";
labelReleaseDateActual.setText(GUIHelper.getMatch(firmware, regex));
}
private void selectFirmwareFile()
{
GUIHelper.logger.trace("");
if(pathFirmware==null)
{
pathFirmware=GUIHelper.prefs.get("PATH_FIRMWARE", ".");
}
FileDialog fd=null;
try
{
fd=new FileDialog(Display.getCurrent().getShells()[0], SWT.OPEN);
fd.setFilterPath(pathFirmware);
if(fd.open()==null)
{
return;
}
}
catch(Exception e)
{
GUIHelper.error(Messages.getString("CompositeFirmwareCPR.0"));
return;
}
pathFirmware=fd.getFilterPath();
GUIHelper.prefs.put("PATH_FIRMWARE", pathFirmware);
fileName=fd.getFileName();
textNewImage.setText(pathFirmware+"/"+fileName);
}
private void updateFirmware()
{
GUIHelper.logger.trace("");
boolean reEnableHeartbeats=false;
if(GUIHelper.mainShell.heartbeatsEnabled())
{
reEnableHeartbeats=true;
GUIHelper.mainShell.stopHeartbeats();
}
else
{
reEnableHeartbeats=false;
}
progressBarFirmwareUpdate.setVisible(true);
progressBarFirmwareUpdate.setEnabled(true);
byte[] buff=null;
try
{
buff=GUIHelper.readBinaryFile(textNewImage.getText());
}
catch(Exception e)
{
if(textNewImage.getText().trim().length()>0)
{
GUIHelper.error(Messages.getString("CompositeFirmwareCPR.1")+textNewImage.getText());
}
else
{
GUIHelper.error(Messages.getString("CompositeFirmwareCPR.21"));
}
GUIHelper.logger.error(e, e);
progressBarFirmwareUpdate.setVisible(false);
progressBarFirmwareUpdate.setEnabled(false);
return;
}
if(currentFirmware!=null)
{
String currentFirmwareType=currentFirmware.split("-")[1];
int currentFirmwareVersion=Integer.parseInt(currentFirmware.split("-")[2]);
String toBeDownloadedFirmwareType=fileName.substring(3, 6);
GUIHelper.logger.info("To be downloaded firmware: "+fileName);
int toBeDownloadedFirmwareVersion=Integer.parseInt(fileName.substring(fileName.length()-3, fileName.length()));
if(currentFirmwareType.equals(toBeDownloadedFirmwareType)&&(currentFirmwareVersion>toBeDownloadedFirmwareVersion))
{
GUIHelper.message(Messages.getString("CompositeFirmwareCPR.23"), SWT.OK|SWT.ICON_WARNING);
progressBarFirmwareUpdate.setVisible(false);
progressBarFirmwareUpdate.setEnabled(false);
return;
}
}
FirmwareUpdater firmwareUpdater=new FirmwareUpdater(buff, progressBarFirmwareUpdate);
firmwareUpdater.updateFirmware(false);
progressBarFirmwareUpdate.setVisible(false);
progressBarFirmwareUpdate.setEnabled(false);
refresh();
if(reEnableHeartbeats)
{
GUIHelper.mainShell.startHeartbeats();
}
String currentFirmwarePartNumber=TestEngine.getCurrentFirmwarePartNumber();
boolean hasStandardFirmware=false;
if(currentFirmwarePartNumber!=null)
{
hasStandardFirmware=currentFirmwarePartNumber.split("-")[1].equals("170")||currentFirmwarePartNumber.split("-")[1].equals("184");
}
if(hasStandardFirmware)
{
String language=PrinterHelper.getVariable("LANGUAGE");
if(language.equals("PCL"))
{
PrinterHelper.setVariable("LANGUAGE", "NONE");
}
}
}
private void getLatestFirmware()
{
GUIHelper.logger.trace("");
boolean reEnableHeartbeats=false;
if(GUIHelper.mainShell.heartbeatsEnabled())
{
reEnableHeartbeats=true;
GUIHelper.mainShell.stopHeartbeats();
}
else
{
reEnableHeartbeats=false;
}
boolean hasStandardFirmware=false;
if(currentFirmware!=null)
{
hasStandardFirmware=currentFirmware.split("-")[1].equals("170")||currentFirmware.split("-")[1].equals("184");
}
if(hasStandardFirmware)
{
TestStatus testStatus;
String modelNumber=GUIHelper.clean(PrinterHelper.commandWaitResponse("!SHOW MODELNUMBER"));
String language=PrinterHelper.getVariable("LANGUAGE");
String feedback=PrinterHelper.getVariable("USER_FEEDBACK");
if(modelNumber.startsWith("700"))
{
if(Integer.parseInt(currentFirmware.split("-")[2])>150)
{
modelNumber=GUIHelper.clean(PrinterHelper.commandWaitResponse("!SHOW OEMMODELID"));
}
else
{
TGModelNumbers tgModelNumbers=new TGModelNumbers(false);
modelNumber=tgModelNumbers.getModelID(modelNumber);
}
}
boolean success=TestEngine.parseModelNumber(modelNumber);
if(!success)
{
String msg=Messages.getString("CompositeManufacturing.39");
GUIHelper.logger.info(msg);
GUIHelper.error(msg);
return;
}
testStatus=TestEngine.doFirmwareDownload(true, progressBarFirmwareUpdate, false);
if(testStatus==TestStatus.FAILED||testStatus==TestStatus.CANCELLED)
{
String msg=null;
switch(testStatus)
{
case FAILED:
msg=Messages.getString("CompositeFirmwareCPR.13");
GUIHelper.logger.info(msg);
GUIHelper.error(msg);
break;
case CANCELLED:
msg=Messages.getString("CompositeFirmwareCPR.14");
GUIHelper.logger.info(msg);
GUIHelper.error(msg);
break;
}
}
refresh();
int button=SWT.NO;
if(testStatus==TestStatus.PASSED)
{
button=GUIHelper.message(Messages.getString("CompositeFirmwareCPR.17"), SWT.OK|SWT.ICON_INFORMATION);
}
else if(testStatus==TestStatus.SKIPPED)
{
button=GUIHelper.message(Messages.getString("CompositeFirmwareCPR.18"), SWT.ICON_QUESTION|SWT.YES|SWT.NO);
}
if(button==SWT.YES||button==SWT.OK)
{
progressBarFirmwareUpdate.setVisible(true);
progressBarFirmwareUpdate.setEnabled(true);
progressBarFirmwareUpdate.setMinimum(0);
progressBarFirmwareUpdate.setMaximum(100);
progressBarFirmwareUpdate.setSelection(10);
progressBarFirmwareUpdate.update();
progressBarFirmwareUpdate.setSelection(40);
progressBarFirmwareUpdate.update();
PrinterHelper.setVariable("LANGUAGE", "NONE");
testStatus=TestEngine.doLoadFonts(TestEngine.printDensity);
progressBarFirmwareUpdate.setSelection(95);
progressBarFirmwareUpdate.update();
if(testStatus==TestStatus.FAILED||testStatus==TestStatus.CANCELLED)
{
String msg=null;
switch(testStatus)
{
case FAILED:
msg=Messages.getString("CompositeFirmwareCPR.15");
GUIHelper.logger.info(msg);
GUIHelper.error(msg);
break;
case CANCELLED:
msg=Messages.getString("CompositeFirmwareCPR.16");
GUIHelper.logger.info(msg);
GUIHelper.error(msg);
break;
}
}
PrinterHelper.setVariable("USER_FEEDBACK", feedback);
if(!language.equals("PCL"))
{
PrinterHelper.setVariable("LANGUAGE", language);
}
progressBarFirmwareUpdate.setVisible(false);
progressBarFirmwareUpdate.setEnabled(false);
GUIHelper.message(Messages.getString("CompositeFirmwareCPR.19"), SWT.OK|SWT.ICON_INFORMATION);
}
}
else
{
GUIHelper.message(Messages.getString("CompositeFirmwareCPR.20"), SWT.OK|SWT.ICON_INFORMATION);
}
if(reEnableHeartbeats)
{
GUIHelper.mainShell.startHeartbeats();
}
}
}
```
## File: JAdmin/src/com/cognitive/admin/CompositeFontsAndObjects.java
```java
public class CompositeFontsAndObjects extends Composite
{
String pathObjects=null;
private boolean connected=false;
private boolean dumbTerminal=false;
private boolean firstPaintSinceConnected=true;
private Logger logger=null;
private Table tableObjects=null;
private Button buttonSendObjects=null;
private Button buttonDeleteSelected=null;
private Button buttonRefresh=null;
private ProgressBar progressBar=null;
static Label labelNote=null;
public CompositeFontsAndObjects(Composite parent, int style)
{
super(parent, style);
initialize();
}
private void initialize()
{
GridData gridData2=new GridData();
gridData2.horizontalAlignment=GridData.FILL;
gridData2.horizontalSpan=6;
gridData2.verticalSpan=2;
gridData2.verticalAlignment=GridData.FILL;
GridData gridData1=new GridData();
gridData1.horizontalAlignment=GridData.FILL;
gridData1.verticalAlignment=GridData.CENTER;
GridLayout gridLayout=new GridLayout();
gridLayout.numColumns=6;
GridData gridData=new GridData();
gridData.horizontalAlignment=GridData.FILL;
gridData.grabExcessHorizontalSpace=true;
gridData.grabExcessVerticalSpace=true;
gridData.horizontalSpan=6;
gridData.verticalAlignment=GridData.FILL;
tableObjects=new Table(this, SWT.MULTI|SWT.FULL_SELECTION);
tableObjects.setHeaderVisible(true);
tableObjects.setLayoutData(gridData);
tableObjects.setLinesVisible(true);
buttonSendObjects=new Button(this, SWT.NONE);
buttonSendObjects.setText(Messages.getString("CompositeFontsAndObjects.0"));
Label filler1=new Label(this, SWT.NONE);
buttonSendObjects
.addSelectionListener(new org.eclipse.swt.events.SelectionAdapter()
{
public void widgetSelected(org.eclipse.swt.events.SelectionEvent e)
{
sendObjects();
}
});
buttonDeleteSelected=new Button(this, SWT.NONE);
buttonDeleteSelected.setText(Messages.getString("CompositeFontsAndObjects.1"));
buttonDeleteSelected
.addSelectionListener(new org.eclipse.swt.events.SelectionAdapter()
{
public void widgetSelected(org.eclipse.swt.events.SelectionEvent e)
{
deleteSelectedObjects();
}
});
buttonRefresh=new Button(this, SWT.NONE);
buttonRefresh.setText(Messages.getString("General.1"));
buttonRefresh
.addSelectionListener(new org.eclipse.swt.events.SelectionAdapter()
{
public void widgetSelected(org.eclipse.swt.events.SelectionEvent e)
{
refresh();
}
});
Label filler=new Label(this, SWT.NONE);
progressBar=new ProgressBar(this, SWT.NONE);
progressBar.setLayoutData(gridData1);
labelNote=new Label(this, SWT.NONE);
labelNote.setText(Messages.getString("CompositeFontsAndObjects.12"));
labelNote.setLayoutData(gridData2);
TableColumn tableColumnName=new TableColumn(tableObjects, SWT.NONE);
tableColumnName.setWidth(100);
tableColumnName.setText(Messages.getString("CompositeFontsAndObjects.3"));
TableColumn tableColumnType=new TableColumn(tableObjects, SWT.NONE);
tableColumnType.setWidth(100);
tableColumnType.setText(Messages.getString("CompositeFontsAndObjects.4"));
TableColumn tableColumnStorage=new TableColumn(tableObjects, SWT.NONE);
tableColumnStorage.setWidth(100);
tableColumnStorage.setText(Messages.getString("CompositeFontsAndObjects.5"));
TableColumn tableColumnSize=new TableColumn(tableObjects, SWT.NONE);
tableColumnSize.setWidth(100);
tableColumnSize.setText(Messages.getString("CompositeFontsAndObjects.6"));
TableColumn tableColumnDescription=new TableColumn(tableObjects, SWT.NONE);
tableColumnDescription.setWidth(200);
tableColumnDescription.setText(Messages.getString("CompositeFontsAndObjects.7"));
this.setLayout(gridLayout);
this.setSize(new Point(734, 200));
this.addPaintListener(new org.eclipse.swt.events.PaintListener()
{
public void paintControl(org.eclipse.swt.events.PaintEvent e)
{
if(connected&&firstPaintSinceConnected&&!dumbTerminal)
{
firstPaintSinceConnected=false;
refresh();
}
}
});
}
public void setConnectionState(boolean connected, boolean dumbTerminal)
{
logger=GUIHelper.logger;
logger.trace("");
this.connected=connected;
this.dumbTerminal=dumbTerminal;
firstPaintSinceConnected=true;
GUIHelper.setEnabled(this, connected&&!dumbTerminal);
}
private void refresh()
{
logger.trace("");
displayObjectList(GUIHelper.getParsedObjectList());
layout(true, true);
}
private String[] selectObjects()
{
logger.trace("");
if(pathObjects==null)
{
pathObjects=GUIHelper.prefs.get("PATH_OBJECTS", ".");
}
FileDialog fd=null;
try
{
fd=new FileDialog(Display.getCurrent().getShells()[0], SWT.OPEN|SWT.MULTI);
fd.setFilterPath(pathObjects);
if(fd.open()==null)
{
return null;
}
}
catch(Exception e)
{
GUIHelper.error(Messages.getString("CompositeFontsAndObjects.8"));
return null;
}
String[] fileNames=fd.getFileNames();
pathObjects=fd.getFilterPath()+"/";
GUIHelper.prefs.put("PATH_OBJECTS", pathObjects);
return fileNames;
}
private void sendGenericObject(String objectName, byte[] data)
{
logger.trace("");
boolean success=false;
PrinterHelper.send(data);
success=PrinterHelper.waitFor(PrinterHelper.GENERAL_PRINTER_READY, 120);
if(!success)
{
GUIHelper.error(Messages.getString("CompositeFontsAndObjects.9"));
}
}
private void sendImage(String objectName, String type, byte[] data)
{
logger.trace("");
int dotIndex=objectName.indexOf(".");
if(dotIndex!=-1)
{
objectName=objectName.substring(0, dotIndex);
}
if(objectName.length()>8)
{
objectName=objectName.substring(0, 8);
}
objectName=objectName.replace(' ', '_');
PrinterHelper.send("!!0 0 0 0\n!0 0 0 0\nGRAPHIC STORE "+type+" 3 "+objectName);
PrinterHelper.send(data);
boolean success=PrinterHelper.waitFor(PrinterHelper.GENERAL_PRINTER_READY, 120);
if(!success)
{
GUIHelper.error(Messages.getString("CompositeFontsAndObjects.10"));
}
PrinterHelper.send("!!0 100 400 1\n!0 100 400 1\nGRAPHIC RECALL "+objectName+" 30 30\nEND");
}
private void sendObject(String fileName, byte[] data)
{
logger.trace("");
String fileType=fileName.substring(fileName.indexOf(".")+1);
if(fileType.equalsIgnoreCase("BMP")||fileType.equalsIgnoreCase("PCX"))
{
sendImage(fileName, fileType, data);
}
else
{
sendGenericObject(fileName, data);
}
}
private void sendObjects()
{
logger.trace("");
String[] fileNames=selectObjects();
if(fileNames!=null)
{
int numFiles=fileNames.length;
int currentFile=0;
progressBar.setMaximum(numFiles);
progressBar.setMinimum(currentFile);
PrinterHelper.setVariable("USER_FEEDBACK", "ON");
boolean success;
byte[] data=null;
for(String fileName : fileNames)
{
GUIHelper.logger.debug(fileName);
progressBar.setSelection(++currentFile);
progressBar.setToolTipText(fileName);
try
{
data=GUIHelper.readBinaryFile(pathObjects+fileName);
}
catch(Exception e)
{
GUIHelper.error(Messages.getString("CompositeFontsAndObjects.11")+pathObjects+fileName);
}
if(fileNames.length>1)
{
try
{
Thread.sleep(2000);
}
catch(Exception ex)
{
success=false;
}
}
sendObject(fileName, data);
}
progressBar.setSelection(0);
refresh();
}
}
private void displayObjectList(Vector<String[]>parsedObjectList)
{
GUIHelper.logger.trace("");
tableObjects.removeAll();
if(!parsedObjectList.isEmpty())
{
for(String[] parsedObject : parsedObjectList)
{
addObjectToTable(parsedObject);
}
}
}
private void addObjectToTable(String[] object)
{
if(object!=null)
{
TableItem item=new TableItem(tableObjects, SWT.NONE);
item.setText(object);
tableObjects.update();
}
}
private void deleteSelectedObjects()
{
logger.trace("");
TableItem[] selectedItems=tableObjects.getSelection();
if(selectedItems==null)
{
return;
}
int max=selectedItems.length;
int current=0;
logger.debug(max+" items selected for deletion.");
progressBar.setMaximum(max);
progressBar.setMinimum(current);
String itemName=null;
boolean supportsFontCheckCommand=false;
String command="";
String currentFirmwarePartNumber=TestEngine.getCurrentFirmwarePartNumber();
if(Integer.parseInt(currentFirmwarePartNumber.split("-")[2])>156)
{
supportsFontCheckCommand=true;
}
if(supportsFontCheckCommand)
{
command="!OBJECT MARK ";
}
else
{
command="!D ";
}
for(TableItem item : selectedItems)
{
progressBar.setSelection(++current);
itemName=item.getText(0);
PrinterHelper.send(command+itemName);
if(!supportsFontCheckCommand)
{
PrinterHelper.waitFor(PrinterHelper.GENERAL_PRINTER_READY, 120);
}
}
if(supportsFontCheckCommand)
{
GUIHelper.logger.info("Deleting all the fonts marked..");
PrinterHelper.send("!OBJECT PACK");
PrinterHelper.waitFor(PrinterHelper.GENERAL_PRINTER_READY, 120);
}
progressBar.setSelection(0);
refresh();
}
}
```
## File: JAdmin/src/com/cognitive/admin/CompositeLabelPositioning.java
```java
public class CompositeLabelPositioning extends Composite
{
private boolean connected=false;
private boolean firstPaintSinceConnected=true;
private boolean dumbTerminal=true;
private Logger logger=null;
private Label labelPrintWidth=null;
private Text textPrintWidth=null;
private Button buttonPrintWidth=null;
private Button checkBoxAutoRecalibration=null;
private Button buttonAutoRecalibration=null;
private Button checkBoxAutoTOF=null;
private Button buttonAutoTOF=null;
private Label separator1=null;
private Label separator2=null;
private Label filler3=null;
private Label separator=null;
private Group groupIndexing=null;
private Group groupLabelPresentation=null;
private Button checkBoxIndexingOn=null;
private Button radioButtonFeedBar=null;
private Button radioButtonFeedGap=null;
private Button radioButtonFeedNotch=null;
private Label filler44=null;
private Button buttonIndexing=null;
private Button buttonCalibrate=null;
private Label filler42=null;
private Label filler43=null;
private Label filler47=null;
private Label filler63=null;
private Button checkBoxLabelPresentation=null;
private Text textAdvance=null;
private Text textRetract=null;
private Text textTime=null;
private Label labelAdvance=null;
private Label labelRetract=null;
private Label labelTime=null;
private Button buttonLabelPresentation=null;
private Label filler70=null;
private Label filler72=null;
private Label filler75=null;
private Label filler82=null;
private Composite compositeTOF_SL=null;
private Label filler6=null;
private Label labelShiftLeftArrow=null;
private Label labelShiftLeftTip=null;
private Label labelShiftLeft=null;
private Label labelPrinterImage=null;
private Composite compositeTOFOnly=null;
private Label labelTOF=null;
private Text textTOF=null;
private Button buttonTOF=null;
private Label labelTOFTip=null;
private Label labelTOFArrow=null;
private Label filler13=null;
private Label filler20=null;
private Label separator4=null;
private Label filler30=null;
private Label labelCalibrate=null;
private Composite compositeButtons=null;
private Button buttonRefresh=null;
private Button buttonPrint=null;
private Label filler15=null;
private Label filler17=null;
private Label filler22=null;
private Composite compositeShiftLeft=null;
private Text textShiftLeft=null;
private Button buttonShiftLeft=null;
public CompositeLabelPositioning(Composite parent, int style)
{
super(parent, style);
initialize();
}
private void initialize()
{
GridData gridData110=new GridData();
gridData110.horizontalAlignment=GridData.FILL;
gridData110.verticalAlignment=GridData.CENTER;
GridData gridData158=new GridData();
gridData158.verticalAlignment=GridData.CENTER;
gridData158.horizontalSpan=4;
gridData158.horizontalAlignment=GridData.FILL;
GridData gridData151=new GridData();
gridData151.grabExcessVerticalSpace=true;
GridData gridData150=new GridData();
gridData150.grabExcessVerticalSpace=true;
Label filler7=new Label(this, SWT.NONE);
GridData gridData146=new GridData();
gridData146.grabExcessHorizontalSpace=true;
GridData gridData39=new GridData();
gridData39.horizontalAlignment=GridData.FILL;
gridData39.horizontalSpan=4;
gridData39.verticalAlignment=GridData.CENTER;
GridData gridData62=new GridData();
gridData62.horizontalAlignment=GridData.CENTER;
gridData62.grabExcessHorizontalSpace=true;
gridData62.verticalAlignment=GridData.CENTER;
GridData gridData31=new GridData();
gridData31.horizontalAlignment=GridData.CENTER;
gridData31.verticalSpan=9;
gridData31.widthHint=5;
gridData31.grabExcessHorizontalSpace=true;
gridData31.verticalAlignment=GridData.FILL;
GridData gridData27=new GridData();
gridData27.verticalAlignment=GridData.CENTER;
gridData27.horizontalSpan=4;
gridData27.horizontalAlignment=GridData.FILL;
GridData gridData1=new GridData();
gridData1.horizontalSpan=3;
GridData gridData=new GridData();
gridData.horizontalSpan=3;
GridLayout gridLayout=new GridLayout();
gridLayout.numColumns=8;
Label filler8=new Label(this, SWT.NONE);
Label filler107=new Label(this, SWT.NONE);
Label filler9=new Label(this, SWT.NONE);
Label filler11=new Label(this, SWT.NONE);
Label filler12=new Label(this, SWT.NONE);
filler13=new Label(this, SWT.NONE);
filler13.setText("");
filler13.setLayoutData(gridData150);
Label filler14=new Label(this, SWT.NONE);
filler3=new Label(this, SWT.NONE);
filler3.setText("");
filler3.setLayoutData(gridData62);
Label filler101=new Label(this, SWT.NONE);
Label filler106=new Label(this, SWT.NONE);
Label filler102=new Label(this, SWT.NONE);
Label filler103=new Label(this, SWT.NONE);
separator2=new Label(this, SWT.SEPARATOR);
separator2.setText("");
separator2.setLayoutData(gridData31);
createCompositeTOF_SL();
filler6=new Label(this, SWT.NONE);
filler6.setText("");
filler6.setLayoutData(gridData146);
Label filler360=new Label(this, SWT.NONE);
labelPrintWidth=new Label(this, SWT.NONE);
labelPrintWidth.setText(Messages.getString("CompositeLabelPositioning.0"));
Label filler105=new Label(this, SWT.NONE);
textPrintWidth=new Text(this, SWT.BORDER);
textPrintWidth.setLayoutData(gridData110);
buttonPrintWidth=new Button(this, SWT.NONE);
buttonPrintWidth.setText(Messages.getString("General.0"));
buttonPrintWidth
.addSelectionListener(new org.eclipse.swt.events.SelectionAdapter()
{
public void widgetSelected(org.eclipse.swt.events.SelectionEvent e)
{
applyPrintWidth();
}
});
Label filler5=new Label(this, SWT.NONE);
Label filler359=new Label(this, SWT.NONE);
separator1=new Label(this, SWT.SEPARATOR|SWT.HORIZONTAL);
separator1.setText("");
separator1.setLayoutData(gridData27);
Label filler4=new Label(this, SWT.NONE);
Label filler29=new Label(this, SWT.NONE);
checkBoxAutoRecalibration=new Button(this, SWT.CHECK);
checkBoxAutoRecalibration.setText(Messages.getString("CompositeLabelPositioning.5"));
checkBoxAutoRecalibration.setLayoutData(gridData);
buttonAutoRecalibration=new Button(this, SWT.NONE);
buttonAutoRecalibration.setText(Messages.getString("General.0"));
buttonAutoRecalibration
.addSelectionListener(new org.eclipse.swt.events.SelectionAdapter()
{
public void widgetSelected(org.eclipse.swt.events.SelectionEvent e)
{
applyAutoRecalibration();
}
});
Label filler2=new Label(this, SWT.NONE);
Label filler358=new Label(this, SWT.NONE);
separator=new Label(this, SWT.SEPARATOR|SWT.HORIZONTAL);
separator.setText("Label");
separator.setLayoutData(gridData39);
Label filler1=new Label(this, SWT.NONE);
Label filler21153=new Label(this, SWT.NONE);
checkBoxAutoTOF=new Button(this, SWT.CHECK);
checkBoxAutoTOF.setText(Messages.getString("CompositeLabelPositioning.7"));
checkBoxAutoTOF.setLayoutData(gridData1);
buttonAutoTOF=new Button(this, SWT.NONE);
buttonAutoTOF.setText(Messages.getString("General.0"));
buttonAutoTOF
.addSelectionListener(new org.eclipse.swt.events.SelectionAdapter()
{
public void widgetSelected(org.eclipse.swt.events.SelectionEvent e)
{
applyAutoTOF();
}
});
Label filler21156=new Label(this, SWT.NONE);
Label filler21=new Label(this, SWT.NONE);
separator4=new Label(this, SWT.SEPARATOR|SWT.HORIZONTAL);
separator4.setText(Messages.getString("CompositeLabelPositioning.9"));
separator4.setLayoutData(gridData158);
Label filler27=new Label(this, SWT.NONE);
Label filler4640=new Label(this, SWT.NONE);
createGroupIndexing();
Label filler=new Label(this, SWT.NONE);
filler30=new Label(this, SWT.NONE);
filler30.setText("");
createGroupLabelPresentation();
Label filler36=new Label(this, SWT.NONE);
this.setLayout(gridLayout);
this.setSize(new Point(794, 631));
Label filler10=new Label(this, SWT.NONE);
createCompositeButtons();
Label filler1567=new Label(this, SWT.NONE);
this.addPaintListener(new org.eclipse.swt.events.PaintListener()
{
public void paintControl(org.eclipse.swt.events.PaintEvent e)
{
if(connected&&firstPaintSinceConnected&&!dumbTerminal)
{
firstPaintSinceConnected=false;
labelCalibrate.setText("");
refresh();
}
}
});
Label filler16=new Label(this, SWT.NONE);
Label filler109=new Label(this, SWT.NONE);
Label filler108=new Label(this, SWT.NONE);
Label filler18=new Label(this, SWT.NONE);
Label filler19=new Label(this, SWT.NONE);
filler20=new Label(this, SWT.NONE);
filler20.setText("");
filler20.setLayoutData(gridData151);
}
private void createGroupIndexing()
{
GridData gridData30=new GridData();
gridData30.horizontalSpan=2;
GridData gridData13=new GridData();
gridData13.horizontalAlignment=GridData.CENTER;
gridData13.grabExcessVerticalSpace=true;
gridData13.verticalAlignment=GridData.CENTER;
GridData gridData12=new GridData();
gridData12.horizontalAlignment=GridData.CENTER;
gridData12.grabExcessVerticalSpace=true;
gridData12.verticalAlignment=GridData.CENTER;
GridData gridData11=new GridData();
gridData11.grabExcessHorizontalSpace=true;
gridData11.verticalAlignment=GridData.CENTER;
gridData11.horizontalAlignment=GridData.CENTER;
GridData gridData10=new GridData();
gridData10.horizontalAlignment=GridData.BEGINNING;
gridData10.grabExcessHorizontalSpace=true;
gridData10.verticalAlignment=GridData.CENTER;
GridData gridData9=new GridData();
gridData9.horizontalAlignment=GridData.FILL;
gridData9.verticalAlignment=GridData.CENTER;
GridData gridData8=new GridData();
gridData8.horizontalAlignment=GridData.FILL;
gridData8.verticalAlignment=GridData.CENTER;
GridData gridData7=new GridData();
gridData7.horizontalIndent=10;
GridData gridData6=new GridData();
gridData6.horizontalIndent=10;
GridData gridData5=new GridData();
gridData5.horizontalIndent=10;
GridLayout gridLayout1=new GridLayout();
gridLayout1.numColumns=4;
GridData gridData3=new GridData();
gridData3.horizontalAlignment=GridData.FILL;
gridData3.horizontalSpan=4;
gridData3.verticalAlignment=GridData.FILL;
groupIndexing=new Group(this, SWT.NONE);
groupIndexing.setLayoutData(gridData3);
groupIndexing.setLayout(gridLayout1);
groupIndexing.setText(Messages.getString("CompositeLabelPositioning.10"));
Label filler4763=new Label(groupIndexing, SWT.NONE);
filler47=new Label(groupIndexing, SWT.NONE);
filler47.setText("");
filler47.setLayoutData(gridData12);
Label filler58=new Label(groupIndexing, SWT.NONE);
Label filler59=new Label(groupIndexing, SWT.NONE);
Label filler4762=new Label(groupIndexing, SWT.NONE);
checkBoxIndexingOn=new Button(groupIndexing, SWT.CHECK);
checkBoxIndexingOn.setText(Messages.getString("CompositeLabelPositioning.11"));
checkBoxIndexingOn
.addSelectionListener(new org.eclipse.swt.events.SelectionAdapter()
{
public void widgetSelected(org.eclipse.swt.events.SelectionEvent e)
{
labelCalibrate.setText("");
}
});
filler44=new Label(groupIndexing, SWT.NONE);
filler44.setText("");
Label filler4359=new Label(groupIndexing, SWT.NONE);
filler43=new Label(groupIndexing, SWT.NONE);
filler43.setText("");
filler43.setLayoutData(gridData11);
radioButtonFeedBar=new Button(groupIndexing, SWT.RADIO);
radioButtonFeedBar.setText(Messages.getString("CompositeLabelPositioning.12"));
radioButtonFeedBar.setLayoutData(gridData5);
radioButtonFeedBar
.addSelectionListener(new org.eclipse.swt.events.SelectionAdapter()
{
public void widgetSelected(org.eclipse.swt.events.SelectionEvent e)
{
labelCalibrate.setText("");
}
});
buttonIndexing=new Button(groupIndexing, SWT.NONE);
buttonIndexing.setText(Messages.getString("General.0"));
buttonIndexing.setLayoutData(gridData8);
buttonIndexing
.addSelectionListener(new org.eclipse.swt.events.SelectionAdapter()
{
public void widgetSelected(org.eclipse.swt.events.SelectionEvent e)
{
labelCalibrate.setText("");
applyIndexing();
}
});
filler42=new Label(groupIndexing, SWT.NONE);
filler42.setText("");
filler42.setLayoutData(gridData10);
Label filler4361=new Label(groupIndexing, SWT.NONE);
radioButtonFeedGap=new Button(groupIndexing, SWT.RADIO);
radioButtonFeedGap.setText(Messages.getString("CompositeLabelPositioning.14"));
radioButtonFeedGap.setLayoutData(gridData6);
radioButtonFeedGap
.addSelectionListener(new org.eclipse.swt.events.SelectionAdapter()
{
public void widgetSelected(org.eclipse.swt.events.SelectionEvent e)
{
labelCalibrate.setText("");
}
});
buttonCalibrate=new Button(groupIndexing, SWT.NONE);
buttonCalibrate.setText(Messages.getString("CompositeLabelPositioning.15"));
buttonCalibrate.setLayoutData(gridData9);
buttonCalibrate
.addSelectionListener(new org.eclipse.swt.events.SelectionAdapter()
{
public void widgetSelected(org.eclipse.swt.events.SelectionEvent e)
{
labelCalibrate.setText("");
calibrate();
}
});
Label filler4258=new Label(groupIndexing, SWT.NONE);
Label filler4360=new Label(groupIndexing, SWT.NONE);
radioButtonFeedNotch=new Button(groupIndexing, SWT.RADIO);
radioButtonFeedNotch.setText(Messages.getString("CompositeLabelPositioning.16"));
radioButtonFeedNotch.setLayoutData(gridData7);
radioButtonFeedNotch
.addSelectionListener(new org.eclipse.swt.events.SelectionAdapter()
{
public void widgetSelected(org.eclipse.swt.events.SelectionEvent e)
{
labelCalibrate.setText("");
}
});
labelCalibrate=new Label(groupIndexing, SWT.NONE);
labelCalibrate.setText("");
labelCalibrate.setLayoutData(gridData30);
Label filler62=new Label(groupIndexing, SWT.NONE);
filler63=new Label(groupIndexing, SWT.NONE);
filler63.setText("");
filler63.setLayoutData(gridData13);
}
private void createGroupLabelPresentation()
{
GridData gridData40=new GridData();
gridData40.horizontalAlignment=GridData.FILL;
gridData40.verticalAlignment=GridData.CENTER;
GridData gridData38=new GridData();
gridData38.horizontalAlignment=GridData.FILL;
gridData38.verticalAlignment=GridData.CENTER;
GridData gridData36=new GridData();
gridData36.horizontalAlignment=GridData.FILL;
gridData36.verticalAlignment=GridData.CENTER;
GridData gridData22=new GridData();
gridData22.horizontalSpan=2;
GridData gridData21=new GridData();
gridData21.horizontalAlignment=GridData.CENTER;
gridData21.grabExcessVerticalSpace=true;
gridData21.verticalAlignment=GridData.CENTER;
GridData gridData20=new GridData();
gridData20.grabExcessVerticalSpace=true;
gridData20.verticalAlignment=GridData.CENTER;
gridData20.horizontalAlignment=GridData.CENTER;
GridData gridData19=new GridData();
gridData19.grabExcessHorizontalSpace=true;
gridData19.verticalAlignment=GridData.CENTER;
gridData19.horizontalAlignment=GridData.CENTER;
GridData gridData18=new GridData();
gridData18.horizontalAlignment=GridData.CENTER;
gridData18.grabExcessHorizontalSpace=true;
gridData18.verticalAlignment=GridData.CENTER;
GridData gridData17=new GridData();
gridData17.horizontalAlignment=GridData.END;
gridData17.verticalAlignment=GridData.CENTER;
GridData gridData16=new GridData();
gridData16.horizontalAlignment=GridData.END;
gridData16.verticalAlignment=GridData.CENTER;
GridData gridData14=new GridData();
gridData14.horizontalAlignment=GridData.END;
gridData14.verticalAlignment=GridData.CENTER;
GridLayout gridLayout2=new GridLayout();
gridLayout2.numColumns=5;
GridData gridData4=new GridData();
gridData4.verticalAlignment=GridData.FILL;
gridData4.horizontalSpan=4;
gridData4.horizontalAlignment=GridData.FILL;
groupLabelPresentation=new Group(this, SWT.NONE);
groupLabelPresentation.setText(Messages.getString("CompositeLabelPositioning.18"));
groupLabelPresentation.setLayout(gridLayout2);
groupLabelPresentation.setLayoutData(gridData4);
Label filler74=new Label(groupLabelPresentation, SWT.NONE);
filler75=new Label(groupLabelPresentation, SWT.NONE);
filler75.setText("");
filler75.setLayoutData(gridData20);
Label filler76=new Label(groupLabelPresentation, SWT.NONE);
Label filler77=new Label(groupLabelPresentation, SWT.NONE);
Label filler78=new Label(groupLabelPresentation, SWT.NONE);
Label filler73=new Label(groupLabelPresentation, SWT.NONE);
checkBoxLabelPresentation=new Button(groupLabelPresentation, SWT.CHECK);
checkBoxLabelPresentation.setText(Messages.getString("CompositeLabelPositioning.19"));
checkBoxLabelPresentation.setLayoutData(gridData22);
Label filler6565=new Label(groupLabelPresentation, SWT.NONE);
Label filler67=new Label(groupLabelPresentation, SWT.NONE);
filler72=new Label(groupLabelPresentation, SWT.NONE);
filler72.setText("");
filler72.setLayoutData(gridData19);
labelAdvance=new Label(groupLabelPresentation, SWT.NONE);
labelAdvance.setText(Messages.getString("CompositeLabelPositioning.20"));
labelAdvance.setLayoutData(gridData17);
textAdvance=new Text(groupLabelPresentation, SWT.BORDER);
textAdvance.setLayoutData(gridData36);
buttonLabelPresentation=new Button(groupLabelPresentation, SWT.NONE);
buttonLabelPresentation.setText(Messages.getString("General.0"));
buttonLabelPresentation
.addSelectionListener(new org.eclipse.swt.events.SelectionAdapter()
{
public void widgetSelected(org.eclipse.swt.events.SelectionEvent e)
{
applyLabelPresentation();
}
});
filler70=new Label(groupLabelPresentation, SWT.NONE);
filler70.setText("");
filler70.setLayoutData(gridData18);
Label filler71=new Label(groupLabelPresentation, SWT.NONE);
labelRetract=new Label(groupLabelPresentation, SWT.NONE);
labelRetract.setText(Messages.getString("CompositeLabelPositioning.22"));
labelRetract.setLayoutData(gridData16);
textRetract=new Text(groupLabelPresentation, SWT.BORDER);
textRetract.setLayoutData(gridData38);
Label filler68=new Label(groupLabelPresentation, SWT.NONE);
Label filler64=new Label(groupLabelPresentation, SWT.NONE);
Label filler66=new Label(groupLabelPresentation, SWT.NONE);
labelTime=new Label(groupLabelPresentation, SWT.NONE);
labelTime.setText(Messages.getString("CompositeLabelPositioning.23"));
labelTime.setLayoutData(gridData14);
textTime=new Text(groupLabelPresentation, SWT.BORDER);
textTime.setLayoutData(gridData40);
Label filler79=new Label(groupLabelPresentation, SWT.NONE);
Label filler80=new Label(groupLabelPresentation, SWT.NONE);
Label filler81=new Label(groupLabelPresentation, SWT.NONE);
filler82=new Label(groupLabelPresentation, SWT.NONE);
filler82.setText("");
filler82.setLayoutData(gridData21);
}
private void createCompositeTOF_SL()
{
GridData gridData25=new GridData();
GridData gridData24=new GridData();
GridData gridData23=new GridData();
GridData gridData15=new GridData();
gridData15.horizontalSpan=2;
GridLayout gridLayout3=new GridLayout();
gridLayout3.numColumns=2;
GridData gridData2=new GridData();
gridData2.verticalSpan=9;
gridData2.verticalAlignment=GridData.FILL;
gridData2.horizontalAlignment=GridData.FILL;
compositeTOF_SL=new Composite(this, SWT.NONE);
compositeTOF_SL.setLayoutData(gridData2);
compositeTOF_SL.setLayout(gridLayout3);
labelPrinterImage=new Label(compositeTOF_SL, SWT.NONE);
labelPrinterImage.setText("Label");
labelPrinterImage.setLayoutData(gridData25);
labelPrinterImage.setImage(new Image(Display.getCurrent(), GUIHelper.myShell.getClass().getClassLoader().getResourceAsStream("com/cognitive/brand/LabelPositioningImage.jpg")));
createCompositeTOFOnly();
labelShiftLeftArrow=new Label(compositeTOF_SL, SWT.NONE);
labelShiftLeftArrow.setText("Arrow");
labelShiftLeftArrow.setImage(new Image(Display.getCurrent(), getClass().getResourceAsStream("/com/cognitive/admin/right-arrow.png")));
labelShiftLeftArrow.setLayoutData(gridData24);
Label filler23=new Label(compositeTOF_SL, SWT.NONE);
labelShiftLeftTip=new Label(compositeTOF_SL, SWT.NONE);
labelShiftLeftTip.setText(Messages.getString("CompositeLabelPositioning.24"));
labelShiftLeftTip.setLayoutData(gridData15);
labelShiftLeft=new Label(compositeTOF_SL, SWT.NONE);
labelShiftLeft.setText(Messages.getString("CompositeLabelPositioning.25"));
labelShiftLeft.setLayoutData(gridData23);
Label filler24=new Label(compositeTOF_SL, SWT.NONE);
createCompositeShiftLeft();
}
private void createCompositeTOFOnly()
{
GridData gridData41=new GridData();
gridData41.horizontalAlignment=GridData.FILL;
gridData41.grabExcessHorizontalSpace=true;
gridData41.verticalAlignment=GridData.CENTER;
GridData gridData29=new GridData();
gridData29.horizontalSpan=2;
GridData gridData28=new GridData();
gridData28.horizontalSpan=2;
GridLayout gridLayout4=new GridLayout();
gridLayout4.numColumns=2;
GridData gridData26=new GridData();
gridData26.horizontalAlignment=GridData.FILL;
gridData26.grabExcessHorizontalSpace=false;
gridData26.verticalAlignment=GridData.FILL;
compositeTOFOnly=new Composite(compositeTOF_SL, SWT.NONE);
compositeTOFOnly.setLayoutData(gridData26);
compositeTOFOnly.setLayout(gridLayout4);
labelTOF=new Label(compositeTOFOnly, SWT.NONE);
labelTOF.setText(Messages.getString("CompositeLabelPositioning.26"));
labelTOF.setLayoutData(gridData28);
textTOF=new Text(compositeTOFOnly, SWT.BORDER);
textTOF.setText("XXX");
textTOF.setLayoutData(gridData41);
buttonTOF=new Button(compositeTOFOnly, SWT.NONE);
buttonTOF.setText(Messages.getString("General.0"));
buttonTOF.addSelectionListener(new org.eclipse.swt.events.SelectionAdapter()
{
public void widgetSelected(org.eclipse.swt.events.SelectionEvent e)
{
applyTOF();
}
});
labelTOFTip=new Label(compositeTOFOnly, SWT.NONE);
labelTOFTip.setText(Messages.getString("CompositeLabelPositioning.28"));
labelTOFTip.setLayoutData(gridData29);
labelTOFArrow=new Label(compositeTOFOnly, SWT.NONE);
labelTOFArrow.setText("Arrow");
labelTOFArrow.setImage(new Image(Display.getCurrent(), getClass().getResourceAsStream("/com/cognitive/admin/up-arrow.png")));
}
public void setConnectionState(boolean connected, boolean dumbTerminal)
{
logger=GUIHelper.logger;
logger.trace("");
this.connected=connected;
this.dumbTerminal=dumbTerminal;
firstPaintSinceConnected=true;
GUIHelper.setEnabled(this, connected&&!dumbTerminal);
}
private void refresh()
{
GUIHelper.blankify(this);
update();
refreshPrintWidth();
refreshAutoRecalibration();
refreshAutoTOF();
refreshIndexing();
refreshLabelPresentation();
refreshTOF();
refreshShiftLeft();
}
private void applyPrintWidth()
{
String width=textPrintWidth.getText();
float fWidth=Float.parseFloat(width)*100;
int iWidth=(int)fWidth;
PrinterHelper.setVariable("WIDTH", Integer.toString(iWidth));
refreshPrintWidth();
}
private void refreshPrintWidth()
{
String width=PrinterHelper.getVariable("WIDTH");
if(width==null)
{
return;
}
width=GUIHelper.getMatch(width, "\\d+");
float fWidth=Float.parseFloat(width)/100;
textPrintWidth.setText(Float.toString(fWidth));
}
private void applyAutoRecalibration()
{
GUIHelper.applySimpleCheckBox(checkBoxAutoRecalibration, "RECALIBRATE");
}
private void refreshAutoRecalibration()
{
GUIHelper.refreshSimpleCheckBox(checkBoxAutoRecalibration, "RECALIBRATE");
}
private void applyAutoTOF()
{
GUIHelper.applySimpleCheckBox(checkBoxAutoTOF, "AUTO_TOF");
}
private void refreshAutoTOF()
{
GUIHelper.refreshSimpleCheckBox(checkBoxAutoTOF, "AUTO_TOF");
}
private void applyIndexing()
{
String feedType;
if(radioButtonFeedBar.getSelection())
{
feedType="BAR";
}
else if(radioButtonFeedGap.getSelection())
{
feedType="GAP";
}
else if(radioButtonFeedNotch.getSelection())
{
feedType="NOTCH";
}
else
{
GUIHelper.error(Messages.getString("CompositeLabelPositioning.29"));
logger.error("Invalid feed-type selected.");
return;
}
PrinterHelper.setVariable("FEED_TYPE", feedType);
GUIHelper.applySimpleCheckBox(checkBoxIndexingOn, "INDEX");
}
private void refreshIndexing()
{
GUIHelper.refreshSimpleCheckBox(checkBoxIndexingOn, "INDEX");
labelCalibrate.setText("");
String feedType=PrinterHelper.getVariable("FEED_TYPE");
if(feedType==null)
{
return;
}
if(feedType.equalsIgnoreCase("BAR"))
{
radioButtonFeedBar.setSelection(true);
radioButtonFeedGap.setSelection(false);
radioButtonFeedNotch.setSelection(false);
}
else if(feedType.equalsIgnoreCase("GAP"))
{
radioButtonFeedBar.setSelection(false);
radioButtonFeedGap.setSelection(true);
radioButtonFeedNotch.setSelection(false);
}
else if(feedType.equalsIgnoreCase("NOTCH"))
{
radioButtonFeedBar.setSelection(false);
radioButtonFeedGap.setSelection(false);
radioButtonFeedNotch.setSelection(true);
}
else
{
GUIHelper.error(Messages.getString("CompositeLabelPositioning.31")+feedType);
logger.error("Received invalid feed type from printer:"+feedType);
return;
}
}
private void calibrate()
{
logger.trace("");
PrinterHelper.send("!!0 0 0 0\n!0 0 0 0\nV INDEX SETTING CALIBRATE\nEND");
boolean received=PrinterHelper.waitFor(".*C3P.*", 60);
if(received)
{
labelCalibrate.setText(Messages.getString("CompositeLabelPositioning.32"));
labelCalibrate.setForeground(Display.getCurrent().getSystemColor(SWT.COLOR_DARK_GREEN));
}
else
{
labelCalibrate.setText(Messages.getString("CompositeLabelPositioning.33"));
labelCalibrate.setForeground(Display.getCurrent().getSystemColor(SWT.COLOR_RED));
}
groupIndexing.layout(true);
}
private void applyLabelPresentation()
{
String onOff;
if(checkBoxLabelPresentation.getSelection())
{
onOff="ON";
}
else
{
onOff="OFF";
}
String value=onOff+" "+textAdvance.getText()+" "+textRetract.getText()+" "+textTime.getText();
PrinterHelper.setVariable("PRESENTLABEL", value);
refreshLabelPresentation();
}
private void refreshLabelPresentation()
{
String result=PrinterHelper.getVariable("PRESENTLABEL");
if(result==null)
{
return;
}
String[] params=result.split(", ");
checkBoxLabelPresentation.setSelection(params[0].equals("ON"));
textAdvance.setText(params[1]);
textRetract.setText(params[2]);
textTime.setText(params[3]);
}
private void applyTOF()
{
GUIHelper.applySimpleTextField(textTOF, "TOF");
PrinterHelper.printTestLabel(textTOF.getText(), textShiftLeft.getText(), "");
}
private void refreshTOF()
{
GUIHelper.refreshSimpleTextField(textTOF, "TOF");
}
private void applyShiftLeft()
{
GUIHelper.applySimpleTextField(textShiftLeft, "SHIFT LEFT");
PrinterHelper.printTestLabel(textTOF.getText(), textShiftLeft.getText(), "");
}
private void refreshShiftLeft()
{
GUIHelper.refreshSimpleTextField(textShiftLeft, "SHIFT LEFT");
}
private void createCompositeButtons()
{
GridData gridData35=new GridData();
gridData35.horizontalAlignment=GridData.BEGINNING;
gridData35.grabExcessHorizontalSpace=true;
gridData35.verticalAlignment=GridData.CENTER;
GridData gridData34=new GridData();
gridData34.horizontalAlignment=GridData.BEGINNING;
gridData34.grabExcessHorizontalSpace=true;
gridData34.verticalAlignment=GridData.CENTER;
GridData gridData33=new GridData();
gridData33.horizontalAlignment=GridData.BEGINNING;
gridData33.grabExcessHorizontalSpace=true;
gridData33.verticalAlignment=GridData.CENTER;
GridLayout gridLayout5=new GridLayout();
gridLayout5.numColumns=5;
GridData gridData32=new GridData();
gridData32.horizontalAlignment=GridData.FILL;
gridData32.horizontalSpan=6;
gridData32.verticalAlignment=GridData.CENTER;
compositeButtons=new Composite(this, SWT.NONE);
compositeButtons.setLayoutData(gridData32);
compositeButtons.setLayout(gridLayout5);
filler22=new Label(compositeButtons, SWT.NONE);
filler22.setText("");
filler22.setLayoutData(gridData33);
buttonRefresh=new Button(compositeButtons, SWT.NONE);
buttonRefresh.setText(Messages.getString("General.1"));
filler17=new Label(compositeButtons, SWT.NONE);
filler17.setText("");
filler17.setLayoutData(gridData34);
buttonRefresh.addSelectionListener(new org.eclipse.swt.events.SelectionAdapter()
{
public void widgetSelected(org.eclipse.swt.events.SelectionEvent e)
{
refresh();
}
});
buttonPrint=new Button(compositeButtons, SWT.NONE);
buttonPrint.setText(Messages.getString("CompositeLabelPositioning.35"));
filler15=new Label(compositeButtons, SWT.NONE);
filler15.setText("");
filler15.setLayoutData(gridData35);
buttonPrint.addSelectionListener(new org.eclipse.swt.events.SelectionAdapter()
{
public void widgetSelected(org.eclipse.swt.events.SelectionEvent e)
{
PrinterHelper.printTestLabel(textTOF.getText(), textShiftLeft.getText(), "");
}
});
}
private void createCompositeShiftLeft()
{
GridData gridData42=new GridData();
gridData42.horizontalAlignment=GridData.FILL;
gridData42.grabExcessHorizontalSpace=true;
gridData42.verticalAlignment=GridData.CENTER;
GridLayout gridLayout6=new GridLayout();
gridLayout6.numColumns=2;
GridData gridData37=new GridData();
gridData37.horizontalAlignment=GridData.FILL;
gridData37.verticalAlignment=GridData.CENTER;
compositeShiftLeft=new Composite(compositeTOF_SL, SWT.NONE);
compositeShiftLeft.setLayoutData(gridData37);
compositeShiftLeft.setLayout(gridLayout6);
textShiftLeft=new Text(compositeShiftLeft, SWT.BORDER);
textShiftLeft.setText("XXX");
textShiftLeft.setLayoutData(gridData42);
buttonShiftLeft=new Button(compositeShiftLeft, SWT.NONE);
buttonShiftLeft.setText(Messages.getString("General.0"));
buttonShiftLeft
.addSelectionListener(new org.eclipse.swt.events.SelectionAdapter()
{
public void widgetSelected(org.eclipse.swt.events.SelectionEvent e)
{
applyShiftLeft();
}
});
}
}
```
## File: JAdmin/src/com/cognitive/admin/CompositeManufacturing.java
```java
public class CompositeManufacturing extends Composite
{
private boolean firstPaint=true;
private Label labelFirmwareLoad=null;
private Label labelRTCSetup=null;
private Label labelToneCheck=null;
private Label labelFirmwareLoadStatus=null;
private Label labelRTCSetupStatus=null;
private Label labelToneCheckStatus=null;
static ProgressBar progressBarFirmwareDownload=null;
private Label labelPrinterIdentification=null;
private Label labelPrinterIdentificationStatus=null;
private Label labelCPRDownload=null;
private Label labelCPRDownloadStatus=null;
private Label labelFontLoading=null;
private Label labelFontLoadingStatus=null;
private Label labelCalibration=null;
private Label labelCalibrationStatus=null;
private Label labelPrintHeadUpDown=null;
private Label labelPrintHeadUpDownStatus=null;
private Label labelPrintQuality=null;
private Label labelPrintQualityStatus=null;
private Label labelPrintHead=null;
private Label labelPrintHeadStatus=null;
private Label labelSelfTest=null;
private Label labelSelfTestStatus=null;
private Composite compositeManufacturingSettings=null;
static Text textModelNumber=null;
private Button checkBoxFirmwareAsk=null;
static Text textSerialPort=null;
static Text textParallelPort=null;
static Text textIPAddress=null;
static Text textWindowsPrinterName=null;
static Button checkBoxSerial=null;
static Button checkBoxNetwork=null;
static Button checkBoxUSBB=null;
static Button checkBoxUSBA=null;
static Button checkBoxParallel=null;
private Label labelUUT=null;
private Label labelSeparator=null;
static Button checkBoxScanner=null;
private Label labelPeripherals=null;
static Text textScanner=null;
static Button checkBoxSNLabelPrinter=null;
static Button checkBoxBoxLabelPrinter=null;
static Text textSNLabelPrinter=null;
static Text textBoxLabelPrinter=null;
private Label labelSeparator2=null;
private Label labelFiller=null;
private Label labelFiller1=null;
private Label labelFiller5=null;
static Combo comboPrintHead=null;
private Label labelPrintHeadSelect=null;
private Label labelInterfaceTest=null;
private Label labelInterfaceTestStatus=null;
private Label labelInitialSetup=null;
private Label labelInitialSetupStatus=null;
private Label labelBackupMemory=null;
private Label labelBackupMemoryStatus=null;
private Label labelShippingLabel=null;
private Label labelShippingLabelStatus=null;
private Label labelSerialNumber=null;
private Label labelMacAddress=null;
private Label labelPeeler=null;
private Label labelPeelerStatus=null;
private Label labelFiller2=null;
private Label labelFinalSettings=null;
private Label labelFinalSettingsStatus=null;
private Label labelControlPanel=null;
private Label labelControlPanelStatus=null;
private Label labelRibbonWrinkle=null;
private Label labelRibbonWrinkleStatus=null;
private Composite compositeShippingLabels=null;
private Button buttonSNLabel=null;
private Button buttonBoxLabel=null;
static Text textSerialNumberActual=null;
static Text textMacAddressActual=null;
static Button checkBoxSpecSNMAC=null;
private Button buttonPCL=null;
private Button checkBoxBoardTest=null;
private Composite compositeModelNumber=null;
static Label labelModelNumber=null;
static Button buttonScanModelNumber=null;
private Composite compositeStart=null;
private Button buttonStart=null;
static Button checkBoxTG=null;
static Button checkBoxSkipLoad1=null;
static Button checkBoxSkipLoad2=null;
static Button checkBoxSkipLoad3=null;
private Label labelFeedButton=null;
private Label labelFeedButtonStatus=null;
static Button checkBoxDisableLicenses=null;
private Button buttonAbort=null;
private Button buttonRunNext=null;
private Button buttonRerun=null;
private Button checkBoxAutorun=null;
private static TestStep testStep=null;
static Button checkBoxBT=null;
static Button checkBoxBT1=null;
static Text textBTPort1=null;
public CompositeManufacturing(Composite parent, int style)
{
super(parent, style);
initialize();
}
private void initialize()
{
GridData gridData27=new GridData();
gridData27.horizontalAlignment=GridData.FILL;
gridData27.verticalAlignment=GridData.CENTER;
GridData gridData22=new GridData();
gridData22.horizontalAlignment=GridData.FILL;
gridData22.verticalAlignment=GridData.CENTER;
GridData gridData171=new GridData();
gridData171.grabExcessVerticalSpace=true;
gridData171.grabExcessHorizontalSpace=true;
Label filler113=new Label(this, SWT.NONE);
GridData gridData19=new GridData();
gridData19.horizontalAlignment=GridData.FILL;
gridData19.verticalAlignment=GridData.CENTER;
GridData gridData161=new GridData();
gridData161.horizontalAlignment=GridData.FILL;
gridData161.verticalAlignment=GridData.CENTER;
GridData gridData151=new GridData();
gridData151.horizontalAlignment=GridData.FILL;
gridData151.verticalAlignment=GridData.CENTER;
GridData gridData141=new GridData();
gridData141.horizontalAlignment=GridData.FILL;
gridData141.verticalAlignment=GridData.CENTER;
GridData gridData131=new GridData();
gridData131.horizontalAlignment=GridData.FILL;
gridData131.verticalAlignment=GridData.CENTER;
GridData gridData122=new GridData();
gridData122.horizontalAlignment=GridData.FILL;
gridData122.verticalAlignment=GridData.CENTER;
GridData gridData111=new GridData();
gridData111.horizontalAlignment=GridData.FILL;
gridData111.verticalAlignment=GridData.CENTER;
GridData gridData101=new GridData();
gridData101.horizontalAlignment=GridData.FILL;
gridData101.verticalAlignment=GridData.CENTER;
GridData gridData91=new GridData();
gridData91.horizontalAlignment=GridData.FILL;
gridData91.verticalAlignment=GridData.CENTER;
GridData gridData82=new GridData();
gridData82.horizontalAlignment=GridData.FILL;
gridData82.verticalAlignment=GridData.CENTER;
GridData gridData61=new GridData();
gridData61.horizontalAlignment=GridData.FILL;
gridData61.verticalAlignment=GridData.CENTER;
GridData gridData51=new GridData();
gridData51.horizontalAlignment=GridData.FILL;
gridData51.verticalAlignment=GridData.CENTER;
GridData gridData41=new GridData();
gridData41.horizontalAlignment=GridData.FILL;
gridData41.verticalAlignment=GridData.CENTER;
GridData gridData31=new GridData();
gridData31.horizontalAlignment=GridData.FILL;
gridData31.verticalAlignment=GridData.CENTER;
GridData gridData21=new GridData();
gridData21.horizontalAlignment=GridData.FILL;
gridData21.verticalAlignment=GridData.CENTER;
this.setSize(new Point(662, 665));
GridData gridData120=new GridData();
gridData120.grabExcessVerticalSpace=true;
gridData120.grabExcessHorizontalSpace=true;
GridData gridData81=new GridData();
gridData81.verticalAlignment=GridData.CENTER;
gridData81.horizontalSpan=2;
gridData81.horizontalAlignment=GridData.FILL;
GridData gridData80=new GridData();
gridData80.grabExcessHorizontalSpace=true;
GridData gridData79=new GridData();
gridData79.grabExcessHorizontalSpace=true;
GridData gridData78=new GridData();
gridData78.verticalSpan=23;
gridData78.verticalAlignment=GridData.FILL;
gridData78.horizontalAlignment=GridData.FILL;
GridData gridData3=new GridData();
gridData3.verticalAlignment=GridData.CENTER;
gridData3.horizontalAlignment=GridData.FILL;
GridLayout gridLayout1=new GridLayout();
gridLayout1.numColumns=8;
gridLayout1.verticalSpacing=10;
gridLayout1.marginWidth=10;
gridLayout1.marginHeight=10;
gridLayout1.horizontalSpacing=15;
Label filler121=new Label(this, SWT.NONE);
Label filler13=new Label(this, SWT.NONE);
Label filler14=new Label(this, SWT.NONE);
Label filler151=new Label(this, SWT.NONE);
Label filler161=new Label(this, SWT.NONE);
Label filler371=new Label(this, SWT.NONE);
labelFiller2=new Label(this, SWT.NONE);
labelFiller2.setText("Label");
labelFiller2.setVisible(false);
labelFiller2.setLayoutData(gridData171);
Label filler112=new Label(this, SWT.NONE);
createCompositeManufacturingSettings();
labelFiller1=new Label(this, SWT.NONE);
labelFiller1.setText("");
labelFiller1.setLayoutData(gridData80);
labelSeparator2=new Label(this, SWT.SEPARATOR);
labelSeparator2.setText("Label");
labelSeparator2.setLayoutData(gridData78);
Label filler24=new Label(this, SWT.NONE);
createCompositeStart();
buttonPCL=new Button(this, SWT.NONE);
buttonPCL.setText(Messages.getString("CompositeManufacturing.1"));
buttonPCL.setVisible(true);
buttonPCL.addSelectionListener(new org.eclipse.swt.events.SelectionAdapter()
{
public void widgetSelected(org.eclipse.swt.events.SelectionEvent e)
{
initializeDisplay();
indicateRunning(labelFirmwareLoad);
TestStatus testStatus=TestEngine.enablePCL(true);
indicateDone(labelFirmwareLoad, labelFirmwareLoadStatus, testStatus);
}
});
buttonAbort=new Button(this, SWT.NONE);
buttonAbort.setText("Abort");
buttonAbort.addSelectionListener(new org.eclipse.swt.events.SelectionAdapter()
{
public void widgetSelected(org.eclipse.swt.events.SelectionEvent e)
{
abortTest();
}
});
buttonAbort.setVisible(false);
Label filler19=new Label(this, SWT.NONE);
Label filler22=new Label(this, SWT.NONE);
Label filler38=new Label(this, SWT.NONE);
labelInitialSetup=new Label(this, SWT.NONE);
labelInitialSetup.setText(Messages.getString("CompositeManufacturing.2"));
labelInitialSetup.setFont(new Font(Display.getDefault(), "Tahoma", 8, SWT.NORMAL));
labelInitialSetupStatus=new Label(this, SWT.NONE);
labelInitialSetupStatus.setVisible(false);
labelInitialSetupStatus.setText(TestEngine.TestStatusString[TestStatus.CANCELLED.ordinal()]);
labelInitialSetupStatus.setLayoutData(gridData31);
labelInitialSetupStatus.setFont(new Font(Display.getDefault(), "Tahoma", 8, SWT.NORMAL));
Label filler351=new Label(this, SWT.NONE);
Label filler7=new Label(this, SWT.NONE);
Label filler9=new Label(this, SWT.NONE);
Label filler106=new Label(this, SWT.NONE);
labelFirmwareLoad=new Label(this, SWT.NONE);
labelFirmwareLoadStatus=new Label(this, SWT.NONE);
checkBoxSkipLoad1=new Button(this, SWT.CHECK);
checkBoxSkipLoad1.setText("Skip");
Label filler111=new Label(this, SWT.NONE);
Label filler37=new Label(this, SWT.NONE);
labelFiller=new Label(this, SWT.NONE);
labelFiller.setText("");
labelFiller.setLayoutData(gridData79);
labelFirmwareLoad.setText(Messages.getString("CompositeManufacturing.3"));
labelFirmwareLoad.setFont(new Font(Display.getDefault(), "Tahoma", 8, SWT.NORMAL));
labelFirmwareLoadStatus.setVisible(false);
labelFirmwareLoadStatus.setFont(new Font(Display.getDefault(), "Tahoma", 8, SWT.NORMAL));
labelFirmwareLoadStatus.setLayoutData(gridData21);
labelFirmwareLoadStatus.setText(TestEngine.TestStatusString[TestStatus.CANCELLED.ordinal()]);
progressBarFirmwareDownload=new ProgressBar(this, SWT.INDETERMINATE);
progressBarFirmwareDownload.setVisible(false);
progressBarFirmwareDownload.setLayoutData(gridData81);
Label filler331=new Label(this, SWT.NONE);
Label filler65=new Label(this, SWT.NONE);
Label filler66=new Label(this, SWT.NONE);
Label filler1071=new Label(this, SWT.NONE);
labelPrinterIdentification=new Label(this, SWT.NONE);
labelPrinterIdentificationStatus=new Label(this, SWT.NONE);
Label filler32=new Label(this, SWT.NONE);
Label filler58=new Label(this, SWT.NONE);
Label filler59=new Label(this, SWT.NONE);
Label filler60=new Label(this, SWT.NONE);
labelFontLoading=new Label(this, SWT.NONE);
labelFontLoadingStatus=new Label(this, SWT.NONE);
checkBoxSkipLoad2=new Button(this, SWT.CHECK);
checkBoxSkipLoad2.setText("Skip");
Label filler110=new Label(this, SWT.NONE);
Label filler39=new Label(this, SWT.NONE);
Label filler40=new Label(this, SWT.NONE);
labelCPRDownload=new Label(this, SWT.NONE);
labelCPRDownloadStatus=new Label(this, SWT.NONE);
checkBoxSkipLoad3=new Button(this, SWT.CHECK);
checkBoxSkipLoad3.setText("Skip");
Label filler10=new Label(this, SWT.NONE);
Label filler28=new Label(this, SWT.NONE);
Label filler49=new Label(this, SWT.NONE);
labelControlPanel=new Label(this, SWT.NONE);
labelControlPanel.setText(Messages.getString("CompositeManufacturing.4"));
labelControlPanelStatus=new Label(this, SWT.NONE);
labelControlPanelStatus.setText(TestEngine.TestStatusString[TestStatus.CANCELLED.ordinal()]);
labelControlPanelStatus.setVisible(false);
labelControlPanelStatus.setLayoutData(gridData22);
Label filler55=new Label(this, SWT.NONE);
Label filler12=new Label(this, SWT.NONE);
Label filler25=new Label(this, SWT.NONE);
Label filler26=new Label(this, SWT.NONE);
labelInterfaceTest=new Label(this, SWT.NONE);
labelInterfaceTestStatus=new Label(this, SWT.NONE);
Label filler291=new Label(this, SWT.NONE);
Label filler47=new Label(this, SWT.NONE);
Label filler48=new Label(this, SWT.NONE);
Label filler53=new Label(this, SWT.NONE);
labelInterfaceTest.setText(Messages.getString("CompositeManufacturing.5"));
labelInterfaceTest.setFont(new Font(Display.getDefault(), "Tahoma", 8, SWT.NORMAL));
labelInterfaceTestStatus.setText(TestEngine.TestStatusString[TestStatus.CANCELLED.ordinal()]);
labelInterfaceTestStatus.setLayoutData(gridData61);
labelInterfaceTestStatus.setFont(new Font(Display.getDefault(), "Tahoma", 8, SWT.NORMAL));
labelInterfaceTestStatus.setVisible(false);
labelPrintHeadUpDown=new Label(this, SWT.NONE);
labelPrintHeadUpDownStatus=new Label(this, SWT.NONE);
Label filler281=new Label(this, SWT.NONE);
Label filler2=new Label(this, SWT.NONE);
Label filler4=new Label(this, SWT.NONE);
Label filler6=new Label(this, SWT.NONE);
labelToneCheck=new Label(this, SWT.NONE);
labelToneCheckStatus=new Label(this, SWT.NONE);
Label filler271=new Label(this, SWT.NONE);
Label filler44=new Label(this, SWT.NONE);
Label filler45=new Label(this, SWT.NONE);
Label filler46=new Label(this, SWT.NONE);
labelRTCSetup=new Label(this, SWT.NONE);
labelRTCSetupStatus=new Label(this, SWT.NONE);
Label filler261=new Label(this, SWT.NONE);
Label filler50=new Label(this, SWT.NONE);
Label filler51=new Label(this, SWT.NONE);
Label filler52=new Label(this, SWT.NONE);
labelCalibration=new Label(this, SWT.NONE);
labelCalibrationStatus=new Label(this, SWT.NONE);
Label filler251=new Label(this, SWT.NONE);
Label filler109=new Label(this, SWT.NONE);
Label filler36=new Label(this, SWT.NONE);
Label filler23=new Label(this, SWT.NONE);
labelFeedButton=new Label(this, SWT.NONE);
labelFeedButton.setFont(new Font(Display.getDefault(), "Tahoma", 8, SWT.NORMAL));
labelFeedButton.setText(Messages.getString("CompositeManufacturing.51"));
labelFeedButtonStatus=new Label(this, SWT.NONE);
labelFeedButtonStatus.setFont(new Font(Display.getDefault(), "Tahoma", 8, SWT.NORMAL));
labelFeedButtonStatus.setText(TestEngine.TestStatusString[TestStatus.CANCELLED.ordinal()]);
labelFeedButtonStatus.setLayoutData(gridData27);
labelFeedButtonStatus.setVisible(false);
Label filler241=new Label(this, SWT.NONE);
Label filler41=new Label(this, SWT.NONE);
Label filler42=new Label(this, SWT.NONE);
Label filler43=new Label(this, SWT.NONE);
labelPeeler=new Label(this, SWT.NONE);
labelPeeler.setText(Messages.getString("CompositeManufacturing.7"));
labelPeelerStatus=new Label(this, SWT.NONE);
labelPeelerStatus.setVisible(false);
labelPeelerStatus.setLayoutData(gridData19);
labelPeelerStatus.setText(TestEngine.TestStatusString[TestStatus.CANCELLED.ordinal()]);
Label filler231=new Label(this, SWT.NONE);
Label filler108=new Label(this, SWT.NONE);
Label filler35=new Label(this, SWT.NONE);
Label filler20=new Label(this, SWT.NONE);
labelRTCSetup.setText(Messages.getString("CompositeManufacturing.8"));
labelRTCSetup.setFont(new Font(Display.getDefault(), "Tahoma", 8, SWT.NORMAL));
labelRTCSetupStatus.setLayoutData(gridData101);
labelRTCSetupStatus.setText(TestEngine.TestStatusString[TestStatus.CANCELLED.ordinal()]);
labelRTCSetupStatus.setVisible(false);
labelRTCSetupStatus.setFont(new Font(Display.getDefault(), "Tahoma", 8, SWT.NORMAL));
labelToneCheck.setText(Messages.getString("CompositeManufacturing.9"));
labelToneCheck.setFont(new Font(Display.getDefault(), "Tahoma", 8, SWT.NORMAL));
labelToneCheckStatus.setLayoutData(gridData91);
labelToneCheckStatus.setText(TestEngine.TestStatusString[TestStatus.CANCELLED.ordinal()]);
labelToneCheckStatus.setVisible(false);
labelToneCheckStatus.setFont(new Font(Display.getDefault(), "Tahoma", 8, SWT.NORMAL));
labelPrintHead=new Label(this, SWT.NONE);
labelPrintHeadStatus=new Label(this, SWT.NONE);
Label filler221=new Label(this, SWT.NONE);
Label filler11=new Label(this, SWT.NONE);
Label filler15=new Label(this, SWT.NONE);
Label filler16=new Label(this, SWT.NONE);
labelBackupMemory=new Label(this, SWT.NONE);
labelBackupMemory.setText(Messages.getString("CompositeManufacturing.10"));
labelBackupMemoryStatus=new Label(this, SWT.NONE);
labelBackupMemoryStatus.setVisible(false);
labelBackupMemoryStatus.setLayoutData(gridData151);
labelBackupMemoryStatus.setText(TestEngine.TestStatusString[TestStatus.CANCELLED.ordinal()]);
Label filler211=new Label(this, SWT.NONE);
Label filler107=new Label(this, SWT.NONE);
Label filler34=new Label(this, SWT.NONE);
Label filler18=new Label(this, SWT.NONE);
labelPrinterIdentification.setText(Messages.getString("CompositeManufacturing.11"));
labelPrinterIdentification.setFont(new Font(Display.getDefault(), "Tahoma", 8, SWT.NORMAL));
labelPrinterIdentificationStatus.setLayoutData(gridData3);
labelPrinterIdentificationStatus.setFont(new Font(Display.getDefault(), "Tahoma", 8, SWT.NORMAL));
labelPrinterIdentificationStatus.setVisible(false);
labelPrinterIdentificationStatus.setText(TestEngine.TestStatusString[TestStatus.CANCELLED.ordinal()]);
labelPrintQuality=new Label(this, SWT.NONE);
labelPrintQualityStatus=new Label(this, SWT.NONE);
Label filler201=new Label(this, SWT.NONE);
Label filler54=new Label(this, SWT.NONE);
Label filler56=new Label(this, SWT.NONE);
Label filler57=new Label(this, SWT.NONE);
labelRibbonWrinkle=new Label(this, SWT.NONE);
labelRibbonWrinkle.setText(Messages.getString("CompositeManufacturing.12"));
labelRibbonWrinkleStatus=new Label(this, SWT.NONE);
labelRibbonWrinkleStatus.setText(TestEngine.TestStatusString[TestStatus.CANCELLED.ordinal()]);
labelRibbonWrinkleStatus.setVisible(false);
Label filler62=new Label(this, SWT.NONE);
Label filler=new Label(this, SWT.NONE);
Label filler1=new Label(this, SWT.NONE);
Label filler8=new Label(this, SWT.NONE);
labelFinalSettings=new Label(this, SWT.NONE);
labelFinalSettings.setText(Messages.getString("CompositeManufacturing.13"));
labelFinalSettingsStatus=new Label(this, SWT.NONE);
labelFinalSettingsStatus.setText(TestEngine.TestStatusString[TestStatus.CANCELLED.ordinal()]);
labelFinalSettingsStatus.setVisible(false);
Label filler2811=new Label(this, SWT.NONE);
Label filler1081=new Label(this, SWT.NONE);
Label filler33=new Label(this, SWT.NONE);
Label filler17=new Label(this, SWT.NONE);
labelCPRDownload.setText(Messages.getString("CompositeManufacturing.14"));
labelCPRDownload.setFont(new Font(Display.getDefault(), "Tahoma", 8, SWT.NORMAL));
labelCPRDownloadStatus.setText(TestEngine.TestStatusString[TestStatus.CANCELLED.ordinal()]);
labelCPRDownloadStatus.setLayoutData(gridData51);
labelCPRDownloadStatus.setFont(new Font(Display.getDefault(), "Tahoma", 8, SWT.NORMAL));
labelCPRDownloadStatus.setVisible(false);
labelSelfTest=new Label(this, SWT.NONE);
labelSelfTestStatus=new Label(this, SWT.NONE);
labelFontLoading.setText(Messages.getString("CompositeManufacturing.15"));
labelFontLoading.setFont(new Font(Display.getDefault(), "Tahoma", 8, SWT.NORMAL));
labelFontLoadingStatus.setText(TestEngine.TestStatusString[TestStatus.CANCELLED.ordinal()]);
labelFontLoadingStatus.setLayoutData(gridData41);
labelFontLoadingStatus.setFont(new Font(Display.getDefault(), "Tahoma", 8, SWT.NORMAL));
labelFontLoadingStatus.setVisible(false);
labelCalibration.setText(Messages.getString("CompositeManufacturing.16"));
labelCalibration.setFont(new Font(Display.getDefault(), "Tahoma", 8, SWT.NORMAL));
labelCalibrationStatus.setLayoutData(gridData111);
labelCalibrationStatus.setText(TestEngine.TestStatusString[TestStatus.CANCELLED.ordinal()]);
labelCalibrationStatus.setVisible(false);
labelCalibrationStatus.setFont(new Font(Display.getDefault(), "Tahoma", 8, SWT.NORMAL));
labelPrintHeadUpDown.setText(Messages.getString("CompositeManufacturing.17"));
labelPrintHeadUpDown.setFont(new Font(Display.getDefault(), "Tahoma", 8, SWT.NORMAL));
labelPrintHeadUpDownStatus.setLayoutData(gridData82);
labelPrintHeadUpDownStatus.setText(TestEngine.TestStatusString[TestStatus.CANCELLED.ordinal()]);
labelPrintHeadUpDownStatus.setVisible(false);
labelPrintHeadUpDownStatus.setFont(new Font(Display.getDefault(), "Tahoma", 8, SWT.NORMAL));
labelPrintQuality.setText(Messages.getString("CompositeManufacturing.18"));
labelPrintQuality.setFont(new Font(Display.getDefault(), "Tahoma", 8, SWT.NORMAL));
labelPrintQualityStatus.setText(TestEngine.TestStatusString[TestStatus.CANCELLED.ordinal()]);
labelPrintQualityStatus.setLayoutData(gridData131);
labelPrintQualityStatus.setFont(new Font(Display.getDefault(), "Tahoma", 8, SWT.NORMAL));
labelPrintQualityStatus.setVisible(false);
labelPrintHead.setText(Messages.getString("CompositeManufacturing.19"));
labelPrintHead.setFont(new Font(Display.getDefault(), "Tahoma", 8, SWT.NORMAL));
labelPrintHeadStatus.setText(TestEngine.TestStatusString[TestStatus.CANCELLED.ordinal()]);
labelPrintHeadStatus.setLayoutData(gridData122);
labelPrintHeadStatus.setFont(new Font(Display.getDefault(), "Tahoma", 8, SWT.NORMAL));
labelPrintHeadStatus.setVisible(false);
labelSelfTest.setText(Messages.getString("CompositeManufacturing.20"));
labelSelfTest.setFont(new Font(Display.getDefault(), "Tahoma", 8, SWT.NORMAL));
labelSelfTestStatus.setText(TestEngine.TestStatusString[TestStatus.CANCELLED.ordinal()]);
labelSelfTestStatus.setLayoutData(gridData141);
labelSelfTestStatus.setFont(new Font(Display.getDefault(), "Tahoma", 8, SWT.NORMAL));
labelSelfTestStatus.setVisible(false);
Label filler191=new Label(this, SWT.NONE);
Label filler71=new Label(this, SWT.NONE);
Label filler72=new Label(this, SWT.NONE);
Label filler73=new Label(this, SWT.NONE);
labelShippingLabel=new Label(this, SWT.NONE);
labelShippingLabel.setText(Messages.getString("CompositeManufacturing.21"));
labelShippingLabelStatus=new Label(this, SWT.NONE);
Label filler70=new Label(this, SWT.NONE);
Label filler21=new Label(this, SWT.NONE);
Label filler29=new Label(this, SWT.NONE);
Label filler31=new Label(this, SWT.NONE);
labelShippingLabelStatus.setVisible(false);
labelShippingLabelStatus.setLayoutData(gridData161);
labelShippingLabelStatus.setText(TestEngine.TestStatusString[TestStatus.CANCELLED.ordinal()]);
buttonRerun=new Button(this, SWT.NONE);
Label filler74=new Label(this, SWT.NONE);
Label filler181=new Label(this, SWT.NONE);
Label filler3=new Label(this, SWT.NONE);
Label filler5=new Label(this, SWT.NONE);
Label filler30=new Label(this, SWT.NONE);
Label filler61=new Label(this, SWT.NONE);
Label filler63=new Label(this, SWT.NONE);
buttonRerun.addSelectionListener(new org.eclipse.swt.events.SelectionAdapter()
{
public void widgetSelected(org.eclipse.swt.events.SelectionEvent e)
{
rerunTest();
}
});
buttonRerun.setText("Re-run");
buttonRerun.setVisible(true);
Label filler69=new Label(this, SWT.NONE);
Label filler67=new Label(this, SWT.NONE);
buttonRunNext=new Button(this, SWT.NONE);
buttonRunNext.setText("Run Next");
buttonRunNext
.addSelectionListener(new org.eclipse.swt.events.SelectionAdapter()
{
public void widgetSelected(org.eclipse.swt.events.SelectionEvent e)
{
runNextTest();
}
});
buttonRunNext.setVisible(false);
labelFiller5=new Label(this, SWT.NONE);
labelFiller5.setText("Label");
labelFiller5.setLayoutData(gridData120);
labelFiller5.setVisible(false);
GridLayout gridLayout=new GridLayout();
this.setLayout(gridLayout1);
this.addPaintListener(new org.eclipse.swt.events.PaintListener()
{
public void paintControl(org.eclipse.swt.events.PaintEvent e)
{
if(firstPaint)
{
displayPreferences();
}
}
});
this.setSize(new Point(723, 622));
}
private void createCompositeManufacturingSettings()
{
GridData gridData30=new GridData();
gridData30.horizontalAlignment=GridData.FILL;
gridData30.verticalAlignment=GridData.CENTER;
GridData gridData24=new GridData();
gridData24.horizontalAlignment=GridData.BEGINNING;
gridData24.verticalAlignment=GridData.CENTER;
GridData gridData18=new GridData();
gridData18.horizontalAlignment=GridData.FILL;
gridData18.verticalAlignment=GridData.CENTER;
GridData gridData17=new GridData();
gridData17.horizontalAlignment=GridData.FILL;
gridData17.verticalAlignment=GridData.CENTER;
GridData gridData15=new GridData();
gridData15.horizontalAlignment=GridData.FILL;
gridData15.verticalAlignment=GridData.CENTER;
GridData gridData14=new GridData();
gridData14.horizontalAlignment=GridData.FILL;
gridData14.verticalAlignment=GridData.CENTER;
GridData gridData13=new GridData();
gridData13.horizontalAlignment=GridData.FILL;
gridData13.verticalAlignment=GridData.CENTER;
GridData gridData12=new GridData();
gridData12.horizontalSpan=2;
gridData12.verticalAlignment=GridData.CENTER;
gridData12.horizontalAlignment=GridData.CENTER;
GridData gridData11=new GridData();
gridData11.verticalAlignment=GridData.CENTER;
gridData11.horizontalSpan=2;
gridData11.horizontalAlignment=GridData.FILL;
GridData gridData10=new GridData();
gridData10.verticalAlignment=GridData.CENTER;
gridData10.horizontalAlignment=GridData.BEGINNING;
GridData gridData9=new GridData();
gridData9.horizontalAlignment=GridData.FILL;
gridData9.verticalAlignment=GridData.CENTER;
GridData gridData8=new GridData();
gridData8.horizontalAlignment=GridData.FILL;
gridData8.verticalAlignment=GridData.CENTER;
GridData gridData7=new GridData();
gridData7.horizontalAlignment=GridData.FILL;
gridData7.verticalAlignment=GridData.CENTER;
GridData gridData6=new GridData();
gridData6.horizontalAlignment=GridData.FILL;
gridData6.verticalAlignment=GridData.CENTER;
GridData gridData5=new GridData();
gridData5.horizontalAlignment=GridData.FILL;
gridData5.verticalAlignment=GridData.CENTER;
GridData gridData2=new GridData();
GridLayout gridLayout2=new GridLayout();
gridLayout2.numColumns=2;
gridLayout2.verticalSpacing=11;
gridLayout2.horizontalSpacing=12;
GridData gridData1=new GridData();
gridData1.horizontalAlignment=GridData.FILL;
gridData1.grabExcessVerticalSpace=false;
gridData1.grabExcessHorizontalSpace=false;
gridData1.verticalSpan=23;
gridData1.verticalAlignment=GridData.FILL;
compositeManufacturingSettings=new Composite(this, SWT.NONE);
compositeManufacturingSettings.setLayoutData(gridData1);
compositeManufacturingSettings.setLayout(gridLayout2);
labelUUT=new Label(compositeManufacturingSettings, SWT.NONE);
labelUUT.setFont(new Font(Display.getDefault(), "Tahoma", 8, SWT.BOLD));
labelUUT.setText(Messages.getString("CompositeManufacturing.22"));
labelUUT.setLayoutData(gridData10);
Label filler64=new Label(compositeManufacturingSettings, SWT.NONE);
checkBoxBT=new Button(compositeManufacturingSettings, SWT.CHECK);
checkBoxBT.setVisible(false);
checkBoxBT.setText(Messages.getString("CompositeManufacturing.56"));
checkBoxBT.addSelectionListener(new org.eclipse.swt.events.SelectionAdapter()
{
public void widgetSelected(org.eclipse.swt.events.SelectionEvent e)
{
displayBTText();
}
});
checkBoxBoardTest=new Button(compositeManufacturingSettings, SWT.CHECK);
checkBoxBoardTest.setText(Messages.getString("CompositeManufacturing.23"));
checkBoxBoardTest.setLayoutData(gridData24);
checkBoxTG=new Button(compositeManufacturingSettings, SWT.CHECK);
checkBoxTG.setText(Messages.getString("CompositeManufacturing.50"));
checkBoxTG.setVisible(true);
checkBoxDisableLicenses=new Button(compositeManufacturingSettings, SWT.CHECK);
checkBoxDisableLicenses.setText(Messages.getString("CompositeManufacturing.54"));
checkBoxBoardTest
.addSelectionListener(new org.eclipse.swt.events.SelectionAdapter()
{
public void widgetSelected(org.eclipse.swt.events.SelectionEvent e)
{
displayBoardTest();
}
});
createCompositeModelNumber();
textModelNumber=new Text(compositeManufacturingSettings, SWT.BORDER);
textModelNumber.setText("");
textModelNumber.setLayoutData(gridData9);
labelSerialNumber=new Label(compositeManufacturingSettings, SWT.NONE);
labelSerialNumber.setText(Messages.getString("CompositeManufacturing.24"));
textSerialNumberActual=new Text(compositeManufacturingSettings, SWT.BORDER);
textSerialNumberActual.setEditable(false);
textSerialNumberActual.setLayoutData(gridData18);
labelMacAddress=new Label(compositeManufacturingSettings, SWT.NONE);
labelMacAddress.setText(Messages.getString("CompositeManufacturing.25"));
textMacAddressActual=new Text(compositeManufacturingSettings, SWT.BORDER);
textMacAddressActual.setEditable(false);
textMacAddressActual.setLayoutData(gridData17);
checkBoxFirmwareAsk=new Button(compositeManufacturingSettings, SWT.CHECK);
checkBoxFirmwareAsk.setSelection(false);
checkBoxFirmwareAsk.setLayoutData(gridData2);
checkBoxFirmwareAsk.setText(Messages.getString("CompositeManufacturing.26"));
checkBoxSpecSNMAC=new Button(compositeManufacturingSettings, SWT.CHECK);
checkBoxSpecSNMAC.setText(Messages.getString("CompositeManufacturing.27"));
checkBoxSpecSNMAC
.addSelectionListener(new org.eclipse.swt.events.SelectionAdapter()
{
public void widgetSelected(org.eclipse.swt.events.SelectionEvent e)
{
displaySpecifySNMAC();
}
});
checkBoxSerial=new Button(compositeManufacturingSettings, SWT.CHECK);
checkBoxSerial.setText(Messages.getString("CompositeManufacturing.28"));
checkBoxSerial.setSelection(true);
textSerialPort=new Text(compositeManufacturingSettings, SWT.BORDER);
textSerialPort.setText("");
textSerialPort.setLayoutData(gridData5);
checkBoxBT1=new Button(compositeManufacturingSettings, SWT.CHECK);
checkBoxBT1.setSelection(true);
checkBoxBT1.setText(Messages.getString("CompositeManufacturing.55"));
textBTPort1=new Text(compositeManufacturingSettings, SWT.BORDER);
textBTPort1.setText("");
textBTPort1.setLayoutData(gridData30);
checkBoxParallel=new Button(compositeManufacturingSettings, SWT.CHECK);
checkBoxParallel.setText(Messages.getString("CompositeManufacturing.29"));
checkBoxParallel.setSelection(false);
checkBoxParallel.setEnabled(true);
textParallelPort=new Text(compositeManufacturingSettings, SWT.BORDER);
textParallelPort.setText("");
textParallelPort.setLayoutData(gridData6);
textParallelPort.setEnabled(true);
checkBoxNetwork=new Button(compositeManufacturingSettings, SWT.CHECK);
checkBoxNetwork.setText(Messages.getString("CompositeManufacturing.30"));
checkBoxNetwork.setSelection(true);
textIPAddress=new Text(compositeManufacturingSettings, SWT.BORDER);
textIPAddress.setText("");
textIPAddress.setLayoutData(gridData7);
checkBoxUSBB=new Button(compositeManufacturingSettings, SWT.CHECK);
checkBoxUSBB.setText(Messages.getString("CompositeManufacturing.53"));
checkBoxUSBB.setSelection(true);
textWindowsPrinterName=new Text(compositeManufacturingSettings, SWT.BORDER);
textWindowsPrinterName.setText("");
textWindowsPrinterName.setLayoutData(gridData8);
textWindowsPrinterName.setEditable(false);
textWindowsPrinterName.setVisible(false);
checkBoxUSBA=new Button(compositeManufacturingSettings, SWT.CHECK);
checkBoxUSBA.setText("USB-A");
checkBoxUSBA.setSelection(true);
Label filler27=new Label(compositeManufacturingSettings, SWT.NONE);
labelPrintHeadSelect=new Label(compositeManufacturingSettings, SWT.NONE);
labelPrintHeadSelect.setText(Messages.getString("CompositeManufacturing.32"));
createComboPrintHead();
labelSeparator=new Label(compositeManufacturingSettings, SWT.SEPARATOR|SWT.HORIZONTAL);
labelSeparator.setText("");
labelSeparator.setLayoutData(gridData11);
labelPeripherals=new Label(compositeManufacturingSettings, SWT.NONE);
labelPeripherals.setText(Messages.getString("CompositeManufacturing.33"));
labelPeripherals.setLayoutData(gridData12);
labelPeripherals.setFont(new Font(Display.getDefault(), "Tahoma", 8, SWT.BOLD));
checkBoxScanner=new Button(compositeManufacturingSettings, SWT.CHECK);
checkBoxScanner.setText(Messages.getString("CompositeManufacturing.34"));
checkBoxScanner.setSelection(true);
checkBoxScanner.setEnabled(true);
textScanner=new Text(compositeManufacturingSettings, SWT.BORDER);
textScanner.setEnabled(true);
textScanner.setLayoutData(gridData13);
checkBoxSNLabelPrinter=new Button(compositeManufacturingSettings, SWT.CHECK);
checkBoxSNLabelPrinter.setText(Messages.getString("CompositeManufacturing.35"));
checkBoxSNLabelPrinter.setSelection(true);
textSNLabelPrinter=new Text(compositeManufacturingSettings, SWT.BORDER);
textSNLabelPrinter.setLayoutData(gridData14);
checkBoxBoxLabelPrinter=new Button(compositeManufacturingSettings, SWT.CHECK);
checkBoxBoxLabelPrinter.setText(Messages.getString("CompositeManufacturing.36"));
checkBoxBoxLabelPrinter.setSelection(true);
checkBoxBoxLabelPrinter.setEnabled(true);
textBoxLabelPrinter=new Text(compositeManufacturingSettings, SWT.BORDER);
textBoxLabelPrinter.setEnabled(true);
textBoxLabelPrinter.setLayoutData(gridData15);
createCompositeShippingLabels();
}
private void createComboPrintHead()
{
GridData gridData29=new GridData();
gridData29.horizontalAlignment=GridData.FILL;
gridData29.verticalAlignment=GridData.CENTER;
comboPrintHead=new Combo(compositeManufacturingSettings, SWT.READ_ONLY);
comboPrintHead.setLayoutData(gridData29);
for(PrintHead ph : PrintHead.values())
{
comboPrintHead.add(ph.toString());
}
comboPrintHead.select(0);
}
private void displayAutorunOptions()
{
}
private void abortTest()
{
GUIHelper.logger.info("");
try
{
PrinterHelper.printer.closeConnection();
}
catch(Exception e)
{
GUIHelper.error(Messages.getString("CompositeManufacturing.41")+e);
GUIHelper.logger.error(e, e);
}
buttonRerun.setEnabled(true);
buttonRunNext.setEnabled(false);
TestEngine.isTestAborted=true;
}
private void runNextTest()
{
GUIHelper.logger.info("");
GUIHelper.setEnabled(compositeManufacturingSettings, false);
TestEngine.isTestAborted=false;
TestStatus testStatus;
if(checkBoxBoardTest.getSelection())
{
testStatus=executeBoardTestProcedure();
}
else
{
testStatus=executePrinterTestProcedure();
if(GUIHelper.prefs.getBoolean("MAN_BLANKIFY_MODEL_NUMBER", true))
{
textModelNumber.setText("");
}
}
String msg=null;
switch(testStatus)
{
case PASSED:
msg=Messages.getString("CompositeManufacturing.38");
GUIHelper.logger.info(msg);
GUIHelper.message(msg, SWT.OK|SWT.ICON_INFORMATION);
GUIHelper.setEnabled(compositeManufacturingSettings, true);
buttonRerun.setVisible(true);
buttonRunNext.setVisible(false);
buttonRerun.setEnabled(false);
buttonRunNext.setEnabled(false);
break;
case FAILED:
TestEngine.runningManufacturing=false;
msg=Messages.getString("CompositeManufacturing.39");
GUIHelper.logger.info(msg);
GUIHelper.error(msg);
buttonRerun.setVisible(true);
buttonRunNext.setVisible(false);
buttonRerun.setEnabled(true);
buttonRunNext.setEnabled(false);
break;
case CANCELLED:
TestEngine.runningManufacturing=false;
msg=Messages.getString("CompositeManufacturing.40");
GUIHelper.logger.info(msg);
GUIHelper.error(msg);
buttonRerun.setVisible(true);
buttonRunNext.setVisible(false);
buttonRerun.setEnabled(true);
buttonRunNext.setEnabled(false);
break;
}
try
{
PrinterHelper.printer.closeConnection();
}
catch(Exception e)
{
GUIHelper.error(Messages.getString("CompositeManufacturing.41")+e);
GUIHelper.logger.error(e, e);
}
}
private void rerunTest()
{
GUIHelper.logger.info("");
GUIHelper.setEnabled(compositeManufacturingSettings, false);
TestEngine.isTestAborted=false;
TestStatus testStatus;
boolean success=TestEngine.establishPrimaryConnection(115200);
if(!success)
{
testStatus=TestStatus.FAILED;
}
if(checkBoxBoardTest.getSelection())
{
testStatus=executeBoardTestProcedure();
}
else
{
testStatus=executePrinterTestProcedure();
}
String msg=null;
switch(testStatus)
{
case PASSED:
msg=Messages.getString("CompositeManufacturing.38");
GUIHelper.logger.info(msg);
GUIHelper.message(msg, SWT.OK|SWT.ICON_INFORMATION);
GUIHelper.setEnabled(compositeManufacturingSettings, true);
buttonRerun.setVisible(true);
buttonRunNext.setVisible(false);
buttonRerun.setEnabled(false);
buttonRunNext.setEnabled(false);
if(GUIHelper.prefs.getBoolean("MAN_BLANKIFY_MODEL_NUMBER", true))
{
textModelNumber.setText("");
}
break;
case FAILED:
TestEngine.runningManufacturing=false;
msg=Messages.getString("CompositeManufacturing.39");
GUIHelper.logger.info(msg);
GUIHelper.error(msg);
buttonRerun.setVisible(true);
buttonRunNext.setVisible(false);
buttonRerun.setEnabled(true);
buttonRunNext.setEnabled(false);
break;
case CANCELLED:
TestEngine.runningManufacturing=false;
msg=Messages.getString("CompositeManufacturing.40");
GUIHelper.logger.info(msg);
GUIHelper.error(msg);
buttonRerun.setVisible(true);
buttonRunNext.setVisible(false);
buttonRerun.setEnabled(true);
buttonRunNext.setEnabled(false);
break;
}
try
{
PrinterHelper.printer.closeConnection();
}
catch(Exception e)
{
GUIHelper.error(Messages.getString("CompositeManufacturing.41")+e);
GUIHelper.logger.error(e, e);
}
GUIHelper.setEnabled(compositeManufacturingSettings, true);
}
private boolean requiresSecurityTest(final String modelNumber)
{
return modelNumber.length()>=11&&modelNumber.startsWith("CXD4-1300-S");
}
private TestStatus startSecurityTest(final String sModel, final boolean bCustomTest, final boolean bCustomType, final boolean bSkipLabel)
{
TestStatus testResult;
textModelNumber.setText(sModel);
if(bCustomTest)
testResult=executeSecurityTestProcedure(bCustomType, bSkipLabel);
else
testResult=executePrinterTestProcedure();
return testResult;
}
private TestStatus startAutomatedSecurityTest(final String sInputType, final String sCurrentModel)
{
String sModel=sCurrentModel;
TestStatus testResult=TestStatus.FAILED;
if(sModel==null||!sModel.startsWith("CXD4-1300"))
{
sModel="CXD4-1300";
testResult=startSecurityTest(sModel, false, false, true);
if(!testResult.equals(TestStatus.PASSED))
return testResult;
}
if(SecurityConfig.isValidSetting(sInputType))
{
if(!sModel.equals("CXD4-1300-S00"))
{
sModel="CXD4-1300-S00";
testResult=startSecurityTest(sModel, true, false,!sInputType.equals("S00"));
if(!testResult.equals(TestStatus.PASSED))
return testResult;
}
if(sModel.equals("CXD4-1300-S00")&&!sInputType.equals("S00"))
{
sModel="CXD4-1300-"+sInputType;
testResult=startSecurityTest(sModel, true, true, false);
}
}
return testResult;
}
private void startTest()
{
GUIHelper.logger.info("");
rememberPreferences();
GUIHelper.setEnabled(compositeManufacturingSettings, false);
initializeDisplay();
TestEngine.isTestAborted=false;
TestStatus testStatus=TestStatus.FAILED;
String msg=null;
testStep=null;
if(requiresSecurityTest(textModelNumber.getText()))
{
String sInputType=textModelNumber.getText().substring(10);
String sCurrentModel=null;
if(TestEngine.establishPrimaryConnection(115200))
sCurrentModel=GUIHelper.clean(PrinterHelper.commandWaitResponse("!SHOW MODELNUMBER"));
testStatus=startAutomatedSecurityTest(sInputType, sCurrentModel);
}
else
{
if(checkBoxBoardTest.getSelection())
testStatus=executeBoardTestProcedure();
else
testStatus=executePrinterTestProcedure();
}
switch(testStatus)
{
case PASSED:
msg=Messages.getString("CompositeManufacturing.38");
GUIHelper.logger.info(msg);
GUIHelper.message(msg, SWT.OK|SWT.ICON_INFORMATION);
buttonRerun.setVisible(true);
buttonRunNext.setVisible(false);
buttonRerun.setEnabled(false);
buttonRunNext.setEnabled(false);
comboPrintHead.select(0);
if(GUIHelper.prefs.getBoolean("MAN_BLANKIFY_MODEL_NUMBER", true))
{
textModelNumber.setText("");
}
break;
case FAILED:
TestEngine.runningManufacturing=false;
msg=Messages.getString("CompositeManufacturing.39");
GUIHelper.logger.info(msg);
GUIHelper.error(msg);
buttonRerun.setVisible(true);
buttonRunNext.setVisible(false);
if(!(testStep==null||testStep==TestStep.INITIAL_SETUP||testStep==TestStep.FIRMWARE_DOWNLOAD))
{
buttonRerun.setEnabled(true);
}
else
{
buttonRerun.setEnabled(false);
}
buttonRunNext.setEnabled(false);
break;
case ABORTED:
case CANCELLED:
TestEngine.runningManufacturing=false;
msg=Messages.getString("CompositeManufacturing.40");
GUIHelper.logger.info(msg);
GUIHelper.error(msg);
buttonRerun.setVisible(true);
buttonRunNext.setVisible(false);
if(!(testStep==null||testStep==TestStep.INITIAL_SETUP||testStep==TestStep.FIRMWARE_DOWNLOAD))
{
buttonRerun.setEnabled(true);
}
else
{
buttonRerun.setEnabled(false);
}
buttonRunNext.setEnabled(false);
break;
}
try
{
PrinterHelper.printer.closeConnection();
}
catch(Exception e)
{
GUIHelper.error(Messages.getString("CompositeManufacturing.41")+e);
GUIHelper.logger.error(e, e);
}
GUIHelper.setEnabled(compositeManufacturingSettings, true);
}
private TestStatus executePrinterTestProcedure()
{
GUIHelper.logger.info("");
TestEngine.isTestAborted=false;
TestStatus testStatus;
buttonRerun.setEnabled(false);
buttonRunNext.setEnabled(false);
if(testStep==null||testStep==TestStep.INITIAL_SETUP)
{
String message=Messages.getString("CompositeManufacturing.47");
indicateRunning(labelInitialSetup);
TestEngine.runningManufacturing=true;
testStep=TestStep.INITIAL_SETUP;
testStatus=TestEngine.doInitialSetup(message);
if(TestEngine.isTestAborted)
{
testStatus=TestStatus.ABORTED;
}
indicateDone(labelInitialSetup, labelInitialSetupStatus, testStatus);
if(testStatus==TestStatus.FAILED||testStatus==TestStatus.CANCELLED||testStatus==TestStatus.ABORTED)
{
return testStatus;
}
indicateRunning(labelInitialSetup);
testStatus=TestEngine.getHeadType();
if(TestEngine.isTestAborted)
{
testStatus=TestStatus.ABORTED;
}
indicateDone(labelInitialSetup, labelInitialSetupStatus, testStatus);
if(testStatus==TestStatus.FAILED||testStatus==TestStatus.CANCELLED||testStatus==TestStatus.ABORTED)
{
return testStatus;
}
}
if(testStep==TestStep.INITIAL_SETUP||testStep==TestStep.FIRMWARE_DOWNLOAD||testStep==null)
{
indicateRunning(labelFirmwareLoad);
testStep=TestStep.FIRMWARE_DOWNLOAD;
buttonAbort.setEnabled(false);
testStatus=TestEngine.doFirmwareDownload(false, progressBarFirmwareDownload, true);
if(TestEngine.isTestAborted)
{
testStatus=TestStatus.ABORTED;
}
indicateDone(labelFirmwareLoad, labelFirmwareLoadStatus, testStatus);
if(GUIHelper.prefs.getBoolean("ACTIVATE_CUSTOM_FIRMWARE", false))
{
labelFirmwareLoad.setForeground(Display.getCurrent().getSystemColor(SWT.COLOR_RED));
}
if(testStatus==TestStatus.FAILED||testStatus==TestStatus.CANCELLED||testStatus==TestStatus.ABORTED)
{
return testStatus;
}
buttonAbort.setEnabled(true);
}
if(testStep==TestStep.FIRMWARE_DOWNLOAD||testStep==TestStep.PRINTER_IDENTIFICATION||testStep==null)
{
indicateRunning(labelPrinterIdentification);
testStep=TestStep.PRINTER_IDENTIFICATION;
testStatus=TestEngine.doPrinterIdentification(true);
if(TestEngine.isTestAborted)
{
testStatus=TestStatus.ABORTED;
}
indicateDone(labelPrinterIdentification, labelPrinterIdentificationStatus, testStatus);
if(testStatus==TestStatus.FAILED||testStatus==TestStatus.CANCELLED||testStatus==TestStatus.ABORTED)
{
return testStatus;
}
TestEngine.displayPrinterID();
}
if(testStep==TestStep.PRINTER_IDENTIFICATION||testStep==TestStep.FONT_DOWNLOAD||testStep==null)
{
indicateRunning(labelFontLoading);
testStep=TestStep.FONT_DOWNLOAD;
testStatus=TestEngine.doLoadFonts(TestEngine.printDensity);
if(TestEngine.isTestAborted)
{
testStatus=TestStatus.ABORTED;
}
indicateDone(labelFontLoading, labelFontLoadingStatus, testStatus);
if(testStatus==TestStatus.FAILED||testStatus==TestStatus.CANCELLED||testStatus==TestStatus.ABORTED)
{
return testStatus;
}
}
if(testStep==TestStep.FONT_DOWNLOAD||testStep==TestStep.CPR_DOWNLOAD||testStep==null)
{
indicateRunning(labelCPRDownload);
testStep=TestStep.CPR_DOWNLOAD;
buttonAbort.setEnabled(false);
testStatus=TestEngine.doLoadCPRs();
if(TestEngine.isTestAborted)
{
testStatus=TestStatus.ABORTED;
}
indicateDone(labelCPRDownload, labelCPRDownloadStatus, testStatus);
if(testStatus==TestStatus.FAILED||testStatus==TestStatus.CANCELLED||testStatus==TestStatus.ABORTED)
{
return testStatus;
}
buttonAbort.setEnabled(true);
}
if(testStep==TestStep.CPR_DOWNLOAD||testStep==TestStep.CONTROL_PANEL||testStep==null)
{
indicateRunning(labelControlPanel);
testStep=TestStep.CONTROL_PANEL;
testStatus=TestEngine.doControlPanel();
if(TestEngine.isTestAborted)
{
testStatus=TestStatus.ABORTED;
}
indicateDone(labelControlPanel, labelControlPanelStatus, testStatus);
if(testStatus==TestStatus.FAILED||testStatus==TestStatus.CANCELLED||testStatus==TestStatus.ABORTED)
{
return testStatus;
}
}
if(testStep==TestStep.CONTROL_PANEL||testStep==TestStep.CONNECTION_TYPES||testStep==null)
{
indicateRunning(labelInterfaceTest);
testStep=TestStep.CONNECTION_TYPES;
testStatus=TestEngine.doConnectionTypes();
if(TestEngine.isTestAborted)
{
testStatus=TestStatus.ABORTED;
}
indicateDone(labelInterfaceTest, labelInterfaceTestStatus, testStatus);
if(testStatus==TestStatus.FAILED||testStatus==TestStatus.CANCELLED||testStatus==TestStatus.ABORTED)
{
return testStatus;
}
}
if(testStep==TestStep.CONNECTION_TYPES||testStep==TestStep.PRINTHEAD_UP_DOWN||testStep==null)
{
indicateRunning(labelPrintHeadUpDown);
testStep=TestStep.PRINTHEAD_UP_DOWN;
testStatus=TestEngine.doPrintHeadUpDown();
if(TestEngine.isTestAborted)
{
testStatus=TestStatus.ABORTED;
}
indicateDone(labelPrintHeadUpDown, labelPrintHeadUpDownStatus, testStatus);
if(testStatus==TestStatus.FAILED||testStatus==TestStatus.CANCELLED||testStatus==TestStatus.ABORTED)
{
return testStatus;
}
}
if(testStep==TestStep.PRINTHEAD_UP_DOWN||testStep==TestStep.TONE_CHECK||testStep==null)
{
indicateRunning(labelToneCheck);
testStep=TestStep.TONE_CHECK;
testStatus=TestEngine.doToneCheck();
if(TestEngine.isTestAborted)
{
testStatus=TestStatus.ABORTED;
}
indicateDone(labelToneCheck, labelToneCheckStatus, testStatus);
if(testStatus==TestStatus.FAILED||testStatus==TestStatus.CANCELLED||testStatus==TestStatus.ABORTED)
{
return testStatus;
}
}
if(testStep==TestStep.TONE_CHECK||testStep==TestStep.RTC_SETUP||testStep==null)
{
indicateRunning(labelRTCSetup);
testStep=TestStep.RTC_SETUP;
testStatus=TestEngine.doRTCSetup();
if(TestEngine.isTestAborted)
{
testStatus=TestStatus.ABORTED;
}
indicateDone(labelRTCSetup, labelRTCSetupStatus, testStatus);
if(testStatus==TestStatus.FAILED||testStatus==TestStatus.CANCELLED||testStatus==TestStatus.ABORTED)
{
return testStatus;
}
}
if(testStep==TestStep.RTC_SETUP||testStep==TestStep.CALIBRATION||testStep==null)
{
indicateRunning(labelCalibration);
testStep=TestStep.CALIBRATION;
testStatus=TestEngine.doCalibration(TestEngine.printMethod, false);
if(TestEngine.isTestAborted)
{
testStatus=TestStatus.ABORTED;
}
indicateDone(labelCalibration, labelCalibrationStatus, testStatus);
if(testStatus==TestStatus.FAILED||testStatus==TestStatus.CANCELLED||testStatus==TestStatus.ABORTED)
{
return testStatus;
}
}
if(testStep==TestStep.CALIBRATION||testStep==TestStep.FEED_BUTTON_TEST||testStep==null)
{
indicateRunning(labelFeedButton);
testStep=TestStep.FEED_BUTTON_TEST;
testStatus=TestEngine.doFeedButtonTest();
if(TestEngine.isTestAborted)
{
testStatus=TestStatus.ABORTED;
}
indicateDone(labelFeedButton, labelFeedButtonStatus, testStatus);
if(testStatus==TestStatus.FAILED||testStatus==TestStatus.CANCELLED||testStatus==TestStatus.ABORTED)
{
return testStatus;
}
}
if(testStep==TestStep.FEED_BUTTON_TEST||testStep==TestStep.PEELER_TEST||testStep==null)
{
indicateRunning(labelPeeler);
testStep=TestStep.PEELER_TEST;
testStatus=TestEngine.doPeelerTest();
if(TestEngine.isTestAborted)
{
testStatus=TestStatus.ABORTED;
}
indicateDone(labelPeeler, labelPeelerStatus, testStatus);
if(testStatus==TestStatus.FAILED||testStatus==TestStatus.CANCELLED||testStatus==TestStatus.ABORTED)
{
return testStatus;
}
}
if(testStep==TestStep.PEELER_TEST||testStep==TestStep.PRINTHEAD_TEST||testStep==null)
{
indicateRunning(labelPrintHead);
testStep=TestStep.PRINTHEAD_TEST;
testStatus=TestEngine.doPrintHeadTest();
if(TestEngine.isTestAborted)
{
testStatus=TestStatus.ABORTED;
}
indicateDone(labelPrintHead, labelPrintHeadStatus, testStatus);
if(testStatus==TestStatus.FAILED||testStatus==TestStatus.CANCELLED||testStatus==TestStatus.ABORTED)
{
return testStatus;
}
}
if(testStep==TestStep.PRINTHEAD_TEST||testStep==TestStep.BACKUP_MEMORY_TEST||testStep==null)
{
indicateRunning(labelBackupMemory);
testStep=TestStep.BACKUP_MEMORY_TEST;
testStatus=TestEngine.doBackupMemoryTest(true);
if(TestEngine.isTestAborted)
{
testStatus=TestStatus.ABORTED;
}
indicateDone(labelBackupMemory, labelBackupMemoryStatus, testStatus);
if(testStatus==TestStatus.FAILED||testStatus==TestStatus.CANCELLED||testStatus==TestStatus.ABORTED)
{
return testStatus;
}
}
if(testStep==TestStep.BACKUP_MEMORY_TEST||testStep==TestStep.PRINT_QUALITY_TEST||testStep==null)
{
indicateRunning(labelPrintQuality);
testStep=TestStep.PRINT_QUALITY_TEST;
testStatus=TestEngine.doPrintQuality(TestEngine.mediaWidth, TestEngine.printDensity);
if(TestEngine.isTestAborted)
{
testStatus=TestStatus.ABORTED;
}
indicateDone(labelPrintQuality, labelPrintQualityStatus, testStatus);
if(testStatus==TestStatus.FAILED||testStatus==TestStatus.CANCELLED||testStatus==TestStatus.ABORTED)
{
return testStatus;
}
}
if(testStep==TestStep.PRINT_QUALITY_TEST||testStep==TestStep.RIBBON_WRINKLE_TEST||testStep==null)
{
indicateRunning(labelRibbonWrinkle);
testStep=TestStep.RIBBON_WRINKLE_TEST;
testStatus=TestEngine.doRibbonWrinkle(TestEngine.mediaWidth, TestEngine.printDensity);
if(TestEngine.isTestAborted)
{
testStatus=TestStatus.ABORTED;
}
indicateDone(labelRibbonWrinkle, labelRibbonWrinkleStatus, testStatus);
if(testStatus==TestStatus.FAILED||testStatus==TestStatus.CANCELLED||testStatus==TestStatus.ABORTED)
{
return testStatus;
}
}
if(testStep==TestStep.RIBBON_WRINKLE_TEST||testStep==TestStep.FINAL_SETTINGS||testStep==null)
{
indicateRunning(labelFinalSettings);
testStep=TestStep.FINAL_SETTINGS;
testStatus=TestEngine.doFinalSettings();
if(TestEngine.isTestAborted)
{
testStatus=TestStatus.ABORTED;
}
indicateDone(labelFinalSettings, labelFinalSettingsStatus, testStatus);
if(testStatus==TestStatus.FAILED||testStatus==TestStatus.CANCELLED||testStatus==TestStatus.ABORTED)
{
return testStatus;
}
}
if(testStep==TestStep.FINAL_SETTINGS||testStep==TestStep.SELF_TEST||testStep==null)
{
indicateRunning(labelSelfTest);
testStep=TestStep.SELF_TEST;
testStatus=TestEngine.doSelfTest();
if(TestEngine.isTestAborted)
{
testStatus=TestStatus.ABORTED;
}
indicateDone(labelSelfTest, labelSelfTestStatus, testStatus);
if(testStatus==TestStatus.FAILED||testStatus==TestStatus.CANCELLED||testStatus==TestStatus.ABORTED)
{
return testStatus;
}
}
if(testStep==TestStep.SELF_TEST||testStep==TestStep.SERIAL_NUMBER_LABEL||testStep==null||TestEngine.isCustomLabel_K542)
{
indicateRunning(labelShippingLabel);
testStep=TestStep.SERIAL_NUMBER_LABEL;
if (TestEngine.isCustomLabel_K542) { TestEngine.printCustom_K542=true; }
testStatus=TestEngine.doSerialNumberLabel();
if (TestEngine.isCustomLabel_K542) { TestEngine.printCustom_K542=false; }
if(TestEngine.isTestAborted)
{
testStatus=TestStatus.ABORTED;
}
indicateDone(labelShippingLabel, labelShippingLabelStatus, testStatus);
if(testStatus==TestStatus.FAILED||testStatus==TestStatus.CANCELLED||testStatus==TestStatus.ABORTED)
{
return testStatus;
}
}
if(testStep==TestStep.SERIAL_NUMBER_LABEL||testStep==TestStep.BOX_LABEL||testStep==null)
{
indicateRunning(labelShippingLabel);
testStep=TestStep.BOX_LABEL;
testStatus=TestEngine.doBoxLabel();
if(TestEngine.isTestAborted)
{
testStatus=TestStatus.ABORTED;
}
indicateDone(labelShippingLabel, labelShippingLabelStatus, testStatus);
if(testStatus==TestStatus.FAILED||testStatus==TestStatus.CANCELLED||testStatus==TestStatus.ABORTED)
{
return testStatus;
}
}
testStep=null;
TestEngine.runningManufacturing=false;
return TestStatus.PASSED;
}
private TestStatus executeBoardTestProcedure()
{
GUIHelper.logger.info("");
TestStatus testStatus;
String message=Messages.getString("CompositeManufacturing.48");
indicateRunning(labelInitialSetup);
TestEngine.runningManufacturing=true;
testStatus=TestEngine.doInitialSetup(message);
indicateDone(labelInitialSetup, labelInitialSetupStatus, testStatus);
if(testStatus==TestStatus.FAILED||testStatus==TestStatus.CANCELLED)
{
return testStatus;
}
GUIHelper.message(Messages.getString("CompositeManufacturing.52"), SWT.OK|SWT.ICON_WORKING);
indicateRunning(labelInitialSetup);
testStatus=TestEngine.getHeadType();
indicateDone(labelInitialSetup, labelInitialSetupStatus, testStatus);
if(testStatus==TestStatus.FAILED||testStatus==TestStatus.CANCELLED)
{
return testStatus;
}
indicateRunning(labelFirmwareLoad);
testStatus=TestEngine.doFirmwareDownload(false, progressBarFirmwareDownload, true);
indicateDone(labelFirmwareLoad, labelFirmwareLoadStatus, testStatus);
if(testStatus==TestStatus.FAILED||testStatus==TestStatus.CANCELLED)
{
return testStatus;
}
indicateRunning(labelPrinterIdentification);
testStatus=TestEngine.doPrinterIdentification(false);
indicateDone(labelPrinterIdentification, labelPrinterIdentificationStatus, testStatus);
if(testStatus==TestStatus.FAILED||testStatus==TestStatus.CANCELLED)
{
return testStatus;
}
TestEngine.displayPrinterID();
indicateRunning(labelFontLoading);
testStatus=TestEngine.doLoadFonts(TestEngine.printDensity);
indicateDone(labelFontLoading, labelFontLoadingStatus, testStatus);
if(testStatus==TestStatus.FAILED||testStatus==TestStatus.CANCELLED)
{
return testStatus;
}
indicateRunning(labelCPRDownload);
testStatus=TestEngine.doLoadCPRs();
indicateDone(labelCPRDownload, labelCPRDownloadStatus, testStatus);
if(testStatus==TestStatus.FAILED||testStatus==TestStatus.CANCELLED)
{
return testStatus;
}
indicateDone(labelControlPanel, labelControlPanelStatus, TestStatus.SKIPPED);
indicateRunning(labelInterfaceTest);
testStatus=TestEngine.doConnectionTypes();
indicateDone(labelInterfaceTest, labelInterfaceTestStatus, testStatus);
if(testStatus==TestStatus.FAILED||testStatus==TestStatus.CANCELLED)
{
return testStatus;
}
indicateRunning(labelPrintHeadUpDown);
testStatus=TestEngine.doPrintHeadUpDown();
indicateDone(labelPrintHeadUpDown, labelPrintHeadUpDownStatus, testStatus);
if(testStatus==TestStatus.FAILED||testStatus==TestStatus.CANCELLED)
{
return testStatus;
}
indicateRunning(labelToneCheck);
testStatus=TestEngine.doToneCheck();
indicateDone(labelToneCheck, labelToneCheckStatus, testStatus);
if(testStatus==TestStatus.FAILED||testStatus==TestStatus.CANCELLED)
{
return testStatus;
}
indicateDone(labelRTCSetup, labelRTCSetupStatus, TestStatus.SKIPPED);
indicateRunning(labelCalibration);
testStatus=TestEngine.doCalibration(TestEngine.printMethod, true);
indicateDone(labelCalibration, labelCalibrationStatus, testStatus);
if(testStatus==TestStatus.FAILED||testStatus==TestStatus.CANCELLED)
{
return testStatus;
}
indicateDone(labelFeedButton, labelFeedButtonStatus, TestStatus.SKIPPED);
indicateDone(labelPeeler, labelPeelerStatus, TestStatus.SKIPPED);
indicateRunning(labelPrintHead);
testStatus=TestEngine.doPrintHeadTest();
indicateDone(labelPrintHead, labelPrintHeadStatus, testStatus);
if(testStatus==TestStatus.FAILED||testStatus==TestStatus.CANCELLED)
{
return testStatus;
}
indicateRunning(labelBackupMemory);
testStatus=TestEngine.doBackupMemoryTest(false);
indicateDone(labelBackupMemory, labelBackupMemoryStatus, testStatus);
if(testStatus==TestStatus.FAILED||testStatus==TestStatus.CANCELLED)
{
return testStatus;
}
indicateDone(labelPrintQuality, labelPrintQualityStatus, TestStatus.SKIPPED);
indicateDone(labelRibbonWrinkle, labelRibbonWrinkleStatus, TestStatus.SKIPPED);
indicateDone(labelFinalSettings, labelFinalSettingsStatus, TestStatus.SKIPPED);
indicateDone(labelSelfTest, labelSelfTestStatus, TestStatus.SKIPPED);
indicateDone(labelShippingLabel, labelShippingLabelStatus, TestStatus.SKIPPED);
TestEngine.runningManufacturing=false;
return TestStatus.PASSED;
}
private TestStatus executeSecurityTestProcedure(final boolean bQuickTest, final boolean bSkipLabel)
{
GUIHelper.logger.info("");
initializeDisplay();
TestEngine.isTestAborted=false;
TestStatus testStatus;
buttonRerun.setEnabled(false);
buttonRunNext.setEnabled(false);
testStep=TestStep.INITIAL_SETUP;
if(testStep==TestStep.INITIAL_SETUP)
{
String message=Messages.getString("CompositeManufacturing.47");
indicateRunning(labelInitialSetup);
TestEngine.runningManufacturing=true;
testStatus=TestEngine.doInitialSetup(message);
if(TestEngine.isTestAborted)
testStatus=TestStatus.ABORTED;
indicateDone(labelInitialSetup, labelInitialSetupStatus, testStatus);
if(testStatus==TestStatus.FAILED||testStatus==TestStatus.CANCELLED||testStatus==TestStatus.ABORTED)
return testStatus;
indicateRunning(labelInitialSetup);
testStatus=TestEngine.getHeadType();
if(TestEngine.isTestAborted)
testStatus=TestStatus.ABORTED;
indicateDone(labelInitialSetup, labelInitialSetupStatus, testStatus);
if(testStatus==TestStatus.FAILED||testStatus==TestStatus.CANCELLED||testStatus==TestStatus.ABORTED)
return testStatus;
testStep=TestStep.FIRMWARE_DOWNLOAD;
}
if(testStep==TestStep.FIRMWARE_DOWNLOAD)
{
indicateRunning(labelFirmwareLoad);
buttonAbort.setEnabled(false);
testStatus=TestEngine.doFirmwareDownload(checkBoxFirmwareAsk.getSelection(), progressBarFirmwareDownload, true);
if(TestEngine.isTestAborted)
testStatus=TestStatus.ABORTED;
indicateDone(labelFirmwareLoad, labelFirmwareLoadStatus, testStatus);
if(GUIHelper.prefs.getBoolean("ACTIVATE_CUSTOM_FIRMWARE", false))
labelFirmwareLoad.setForeground(Display.getCurrent().getSystemColor(SWT.COLOR_RED));
if(testStatus==TestStatus.FAILED||testStatus==TestStatus.CANCELLED||testStatus==TestStatus.ABORTED)
return testStatus;
buttonAbort.setEnabled(true);
testStep=TestStep.PRINTER_IDENTIFICATION;
}
if(testStep==TestStep.PRINTER_IDENTIFICATION)
{
indicateRunning(labelPrinterIdentification);
testStatus=TestEngine.doPrinterIdentification(true);
if(TestEngine.isTestAborted)
testStatus=TestStatus.ABORTED;
indicateDone(labelPrinterIdentification, labelPrinterIdentificationStatus, testStatus);
if(testStatus==TestStatus.FAILED||testStatus==TestStatus.CANCELLED||testStatus==TestStatus.ABORTED)
return testStatus;
TestEngine.displayPrinterID();
testStep=TestStep.CALIBRATION;
}
if(testStep==TestStep.CALIBRATION)
{
indicateRunning(labelCalibration);
testStatus=TestEngine.doCalibration(TestEngine.printMethod, false);
if(TestEngine.isTestAborted)
testStatus=TestStatus.ABORTED;
indicateDone(labelCalibration, labelCalibrationStatus, testStatus);
if(testStatus==TestStatus.FAILED||testStatus==TestStatus.CANCELLED||testStatus==TestStatus.ABORTED)
return testStatus;
testStep=TestStep.CPR_DOWNLOAD;
}
if(testStep==TestStep.CPR_DOWNLOAD)
{
if(bQuickTest)
indicateDone(labelCPRDownload, labelCPRDownloadStatus, TestStatus.SKIPPED);
else
{
indicateRunning(labelCPRDownload);
buttonAbort.setEnabled(false);
testStatus=TestEngine.doLoadCPRs();
if(TestEngine.isTestAborted)
testStatus=TestStatus.ABORTED;
indicateDone(labelCPRDownload, labelCPRDownloadStatus, testStatus);
if(testStatus==TestStatus.FAILED||testStatus==TestStatus.CANCELLED||testStatus==TestStatus.ABORTED)
return testStatus;
buttonAbort.setEnabled(true);
}
testStep=TestStep.FONT_DOWNLOAD;
}
if(testStep==TestStep.FONT_DOWNLOAD)
{
indicateRunning(labelFontLoading);
testStatus=TestEngine.doLoadFonts(TestEngine.printDensity);
if(TestEngine.isTestAborted)
testStatus=TestStatus.ABORTED;
indicateDone(labelFontLoading, labelFontLoadingStatus, testStatus);
if(testStatus==TestStatus.FAILED||testStatus==TestStatus.CANCELLED||testStatus==TestStatus.ABORTED)
return testStatus;
testStep=TestStep.CONTROL_PANEL;
}
if(testStep==TestStep.CONTROL_PANEL)
{
if(bQuickTest)
indicateDone(labelControlPanel, labelControlPanelStatus, TestStatus.SKIPPED);
else
{
indicateRunning(labelControlPanel);
testStatus=TestEngine.doControlPanel();
if(TestEngine.isTestAborted)
testStatus=TestStatus.ABORTED;
indicateDone(labelControlPanel, labelControlPanelStatus, testStatus);
if(testStatus==TestStatus.FAILED||testStatus==TestStatus.CANCELLED||testStatus==TestStatus.ABORTED)
return testStatus;
}
testStep=TestStep.CONNECTION_TYPES;
}
if(testStep==TestStep.CONNECTION_TYPES)
{
if(bQuickTest)
indicateDone(labelInterfaceTest, labelInterfaceTestStatus, TestStatus.SKIPPED);
else
{
indicateRunning(labelInterfaceTest);
testStatus=TestEngine.doConnectionTypes();
if(TestEngine.isTestAborted)
testStatus=TestStatus.ABORTED;
indicateDone(labelInterfaceTest, labelInterfaceTestStatus, testStatus);
if(testStatus==TestStatus.FAILED||testStatus==TestStatus.CANCELLED||testStatus==TestStatus.ABORTED)
return testStatus;
}
testStep=TestStep.PRINTHEAD_UP_DOWN;
}
if(testStep==TestStep.PRINTHEAD_UP_DOWN)
{
indicateDone(labelPrintHeadUpDown, labelPrintHeadUpDownStatus, TestStatus.SKIPPED);
testStep=TestStep.TONE_CHECK;
}
if(testStep==TestStep.TONE_CHECK)
{
indicateDone(labelToneCheck, labelToneCheckStatus, TestStatus.SKIPPED);
testStep=TestStep.RTC_SETUP;
}
if(testStep==TestStep.RTC_SETUP)
{
if(bQuickTest)
indicateDone(labelRTCSetup, labelRTCSetupStatus, TestStatus.SKIPPED);
else
{
indicateRunning(labelRTCSetup);
testStatus=TestEngine.doRTCSetup();
if(TestEngine.isTestAborted)
testStatus=TestStatus.ABORTED;
indicateDone(labelRTCSetup, labelRTCSetupStatus, testStatus);
if(testStatus==TestStatus.FAILED||testStatus==TestStatus.CANCELLED||testStatus==TestStatus.ABORTED)
return testStatus;
}
testStep=TestStep.FEED_BUTTON_TEST;
}
if(testStep==TestStep.FEED_BUTTON_TEST)
{
if(bQuickTest)
indicateDone(labelFeedButton, labelFeedButtonStatus, TestStatus.SKIPPED);
else
{
indicateRunning(labelFeedButton);
testStatus=TestEngine.doFeedButtonTest();
if(TestEngine.isTestAborted)
testStatus=TestStatus.ABORTED;
indicateDone(labelFeedButton, labelFeedButtonStatus, testStatus);
if(testStatus==TestStatus.FAILED||testStatus==TestStatus.CANCELLED||testStatus==TestStatus.ABORTED)
return testStatus;
}
testStep=TestStep.PRINTHEAD_TEST;
}
indicateDone(labelPeeler, labelPeelerStatus, TestStatus.SKIPPED);
if(testStep==TestStep.PRINTHEAD_TEST)
{
if(bQuickTest)
indicateDone(labelPrintHead, labelPrintHeadStatus, TestStatus.SKIPPED);
else
{
indicateRunning(labelPrintHead);
testStatus=TestEngine.doPrintHeadTest();
if(TestEngine.isTestAborted)
testStatus=TestStatus.ABORTED;
indicateDone(labelPrintHead, labelPrintHeadStatus, testStatus);
if(testStatus==TestStatus.FAILED||testStatus==TestStatus.CANCELLED||testStatus==TestStatus.ABORTED)
return testStatus;
}
testStep=TestStep.BACKUP_MEMORY_TEST;
}
if(testStep==TestStep.BACKUP_MEMORY_TEST)
{
indicateRunning(labelBackupMemory);
testStatus=TestEngine.doBackupMemoryTest(true);
if(TestEngine.isTestAborted)
testStatus=TestStatus.ABORTED;
indicateDone(labelBackupMemory, labelBackupMemoryStatus, testStatus);
if(testStatus==TestStatus.FAILED||testStatus==TestStatus.CANCELLED||testStatus==TestStatus.ABORTED)
return testStatus;
testStep=TestStep.PRINT_QUALITY_TEST;
}
if(testStep==TestStep.PRINT_QUALITY_TEST)
{
if(bQuickTest)
indicateDone(labelPrintQuality, labelPrintQualityStatus, TestStatus.SKIPPED);
else
{
indicateRunning(labelPrintQuality);
testStep=TestStep.PRINT_QUALITY_TEST;
testStatus=TestEngine.doPrintQuality(TestEngine.mediaWidth, TestEngine.printDensity);
if(TestEngine.isTestAborted)
testStatus=TestStatus.ABORTED;
indicateDone(labelPrintQuality, labelPrintQualityStatus, testStatus);
if(testStatus==TestStatus.FAILED||testStatus==TestStatus.CANCELLED||testStatus==TestStatus.ABORTED)
return testStatus;
}
testStep=TestStep.FINAL_SETTINGS;
}
indicateDone(labelRibbonWrinkle, labelRibbonWrinkleStatus, TestStatus.SKIPPED);
if(testStep==TestStep.FINAL_SETTINGS)
{
indicateRunning(labelFinalSettings);
testStatus=TestEngine.doFinalSettings();
if(TestEngine.isTestAborted)
testStatus=TestStatus.ABORTED;
indicateDone(labelFinalSettings, labelFinalSettingsStatus, testStatus);
if(testStatus==TestStatus.FAILED||testStatus==TestStatus.CANCELLED||testStatus==TestStatus.ABORTED)
return testStatus;
testStep=TestStep.SELF_TEST;
}
if(testStep==TestStep.SELF_TEST)
{
indicateRunning(labelSelfTest);
testStatus=TestEngine.doSelfTest();
if(TestEngine.isTestAborted)
testStatus=TestStatus.ABORTED;
indicateDone(labelSelfTest, labelSelfTestStatus, testStatus);
if(testStatus==TestStatus.FAILED||testStatus==TestStatus.CANCELLED||testStatus==TestStatus.ABORTED)
return testStatus;
testStep=TestStep.SERIAL_NUMBER_LABEL;
}
if(testStep==TestStep.SERIAL_NUMBER_LABEL||TestEngine.isCustomLabel_K542)
{
if(bSkipLabel)
indicateDone(labelShippingLabel, labelShippingLabelStatus, TestStatus.SKIPPED);
else
{
indicateRunning(labelShippingLabel);
if (TestEngine.isCustomLabel_K542) { TestEngine.printCustom_K542=true; }
testStatus=TestEngine.doSerialNumberLabel();
if (TestEngine.isCustomLabel_K542) { TestEngine.isCustomLabel_K542=false; TestEngine.printCustom_K542=false; }
if(TestEngine.isTestAborted)
testStatus=TestStatus.ABORTED;
indicateDone(labelShippingLabel, labelShippingLabelStatus, testStatus);
if(testStatus==TestStatus.FAILED||testStatus==TestStatus.CANCELLED||testStatus==TestStatus.ABORTED)
return testStatus;
}
testStep=TestStep.BOX_LABEL;
}
if(testStep==TestStep.BOX_LABEL)
{
if(bSkipLabel)
indicateDone(labelShippingLabel, labelShippingLabelStatus, TestStatus.SKIPPED);
else
{
indicateRunning(labelShippingLabel);
testStatus=TestEngine.doBoxLabel();
if(TestEngine.isTestAborted)
testStatus=TestStatus.ABORTED;
indicateDone(labelShippingLabel, labelShippingLabelStatus, testStatus);
if(testStatus==TestStatus.FAILED||testStatus==TestStatus.CANCELLED||testStatus==TestStatus.ABORTED)
return testStatus;
}
}
testStep=null;
TestEngine.runningManufacturing=false;
return TestStatus.PASSED;
}
private void initializeDisplay()
{
GUIHelper.logger.trace("");
progressBarFirmwareDownload.setEnabled(false);
progressBarFirmwareDownload.setVisible(false);
Control[] children=getChildren();
for(Control c : children)
{
String className=c.getClass().getName();
if(className.equals("org.eclipse.swt.widgets.Label"))
{
Label l=(Label)c;
l.setForeground(Display.getCurrent().getSystemColor(SWT.COLOR_BLACK));
for(String s : TestEngine.TestStatusString)
{
if(l.getText().equals(s))
{
l.setVisible(false);
break;
}
}
}
}
if(!checkBoxSpecSNMAC.getSelection())
{
textSerialNumberActual.setText("");
textMacAddressActual.setText("");
}
}
private void indicateRunning(Label stepLabel)
{
GUIHelper.logger.trace("");
stepLabel.setForeground(Display.getCurrent().getSystemColor(SWT.COLOR_DARK_BLUE));
stepLabel.update();
}
private void indicateDone(Label stepLabel, Label statusLabel, TestStatus testStatus)
{
GUIHelper.logger.trace("");
stepLabel.setForeground(Display.getCurrent().getSystemColor(SWT.COLOR_BLACK));
statusLabel.setText(TestEngine.TestStatusString[testStatus.ordinal()]);
if(testStatus==TestStatus.FAILED||testStatus==TestStatus.CANCELLED)
{
statusLabel.setForeground(Display.getCurrent().getSystemColor(SWT.COLOR_RED));
}
else
{
statusLabel.setForeground(Display.getCurrent().getSystemColor(SWT.COLOR_DARK_GREEN));
}
statusLabel.setVisible(true);
statusLabel.update();
}
private void rememberPreferences()
{
GUIHelper.prefs.put("MAN_MODEL_NUMBER", textModelNumber.getText());
GUIHelper.prefs.put("MAN_PRINT_HEAD", comboPrintHead.getText());
GUIHelper.prefs.putBoolean("MAN_FIRMWARE_ASK", checkBoxFirmwareAsk.getSelection());
GUIHelper.prefs.putBoolean("MAN_USB_A", checkBoxUSBA.getSelection());
GUIHelper.prefs.putBoolean("MAN_BOARD_TEST", checkBoxBoardTest.getSelection());
rememberOptionalPeripheral(checkBoxBT1, textBTPort1, "MAN_BT_PORT");
rememberOptionalPeripheral(checkBoxSerial, textSerialPort, "MAN_SERIAL_PORT");
rememberOptionalPeripheral(checkBoxParallel, textParallelPort, "MAN_PARALLEL_PORT");
rememberOptionalPeripheral(checkBoxUSBB, textWindowsPrinterName, "MAN_PRINTER_NAME");
rememberOptionalPeripheral(checkBoxNetwork, textIPAddress, "MAN_IP_ADDRESS");
rememberOptionalPeripheral(checkBoxScanner, textScanner, "MAN_SCANNER");
rememberOptionalPeripheral(checkBoxSNLabelPrinter, textSNLabelPrinter, "MAN_SN_PRINTER");
rememberOptionalPeripheral(checkBoxBoxLabelPrinter, textBoxLabelPrinter, "MAN_BOX_PRINTER");
GUIHelper.prefs.putBoolean("MAN_AUTORUN", checkBoxAutorun.getSelection());
}
private void displayPreferences()
{
firstPaint=false;
if(GUIHelper.prefs.getBoolean("MAN_BLANKIFY_MODEL_NUMBER", true))
{
textModelNumber.setText("");
}
else
{
textModelNumber.setText(GUIHelper.prefs.get("MAN_MODEL_NUMBER", "DBD24-2085-00L"));
}
buttonPCL.setVisible(GUIHelper.prefs.getBoolean("ACTIVATE_REPAIR", false));
checkBoxTG.setVisible(GUIHelper.prefs.getBoolean("ACTIVATE_REPAIR", false));
checkBoxDisableLicenses.setVisible(GUIHelper.prefs.getBoolean("ACTIVATE_REPAIR", false));
checkBoxSkipLoad3.setVisible(GUIHelper.prefs.getBoolean("SHOW_SKIP_LOAD", false));
String defaultPrintHead=GUIHelper.prefs.get("MAN_PRINT_HEAD", "Automatic");
comboPrintHead.select(0);
checkBoxFirmwareAsk.setSelection(GUIHelper.prefs.getBoolean("MAN_FIRMWARE_ASK", false));
checkBoxUSBA.setSelection(GUIHelper.prefs.getBoolean("MAN_USB_A", true));
displayOptionalPeripheral(checkBoxBT1, textBTPort1, "MAN_BT_PORT", "COM7");
displayOptionalPeripheral(checkBoxSerial, textSerialPort, "MAN_SERIAL_PORT", "COM1");
if (checkBoxParallel.isEnabled()&&textParallelPort.isEnabled())
{
displayOptionalPeripheral(checkBoxParallel, textParallelPort, "MAN_PARALLEL_PORT", "LPT1");
}
displayOptionalPeripheral(checkBoxUSBB, textWindowsPrinterName, "MAN_PRINTER_NAME", "CSeriesUSBptr");
displayOptionalPeripheral(checkBoxNetwork, textIPAddress, "MAN_IP_ADDRESS", "192.168.1.0");
displayOptionalPeripheral(checkBoxScanner, textScanner, "MAN_SCANNER", "COM3");
displayOptionalPeripheral(checkBoxSNLabelPrinter, textSNLabelPrinter, "MAN_SN_PRINTER", "COM4");
displayOptionalPeripheral(checkBoxBoxLabelPrinter, textBoxLabelPrinter, "MAN_BOX_PRINTER", "COM5");
boolean allowSpecify=GUIHelper.prefs.getBoolean("ACTIVATE_REPAIR", false);
checkBoxSpecSNMAC.setVisible(allowSpecify);
checkBoxSpecSNMAC.setSelection(false);
displaySpecifySNMAC();
try
{
TestEngine.isMadeByEnnoconnMalaysia=false;
TestEngine.locationCode=LocationCode.valueOf(GUIHelper.prefs.get("MAN_LOCATION_CODE", ""));
if(TestEngine.locationCode==LocationCode.E)
TestEngine.isMadeByEnnoconnMalaysia=true;
}
catch(IllegalArgumentException e)
{
String msg=Messages.getString("CompositeManufacturing.42");
GUIHelper.logger.error(msg);
GUIHelper.error(msg);
buttonStart.setEnabled(false);
}
if((TestEngine.locationCode==LocationCode.T)||(TestEngine.locationCode==LocationCode.D)||(TestEngine.locationCode==LocationCode.V)||(TestEngine.locationCode==LocationCode.E))
{
checkBoxBoardTest.setVisible(true);
checkBoxBoardTest.setSelection(GUIHelper.prefs.getBoolean("MAN_BOARD_TEST", false));
displayBoardTest();
}
else
{
checkBoxBoardTest.setVisible(false);
checkBoxBoardTest.setSelection(false);
}
if(GUIHelper.prefs.getBoolean("ACTIVATE_CUSTOM_FIRMWARE", false))
{
labelFirmwareLoad.setForeground(Display.getCurrent().getSystemColor(SWT.COLOR_RED));
}
checkBoxAutorun.setSelection(GUIHelper.prefs.getBoolean("MAN_AUTORUN", true));
buttonRerun.setEnabled(false);
buttonRunNext.setEnabled(false);
}
private void displaySpecifySNMAC()
{
boolean specify=checkBoxSpecSNMAC.getSelection();
textSerialNumberActual.setEditable(specify);
textMacAddressActual.setEditable(specify);
textSerialNumberActual.setText("");
textMacAddressActual.setText("");
if(specify)
{
checkBoxBoardTest.setSelection(false);
displayBoardTest();
}
}
private void displayBTText()
{
}
private void displayBoardTest()
{
boolean bBoardTest=checkBoxBoardTest.getSelection();
boolean bFirmwareAsk=checkBoxFirmwareAsk.getSelection();
boolean bSpecSNMAC=checkBoxSpecSNMAC.getSelection();
boolean bScanner=checkBoxScanner.getSelection();
boolean bBoxLabelPrinter=checkBoxBoxLabelPrinter.getSelection();
boolean bSNLabelPrinter=checkBoxSNLabelPrinter.getSelection();
boolean bSkipLoad1=checkBoxSkipLoad1.getSelection();
boolean bSkipLoad2=checkBoxSkipLoad2.getSelection();
boolean bSkipLoad3=checkBoxSkipLoad3.getSelection();
boolean b2FirmwareAsk=checkBoxFirmwareAsk.isEnabled();
boolean b2SpecSNMAC=checkBoxSpecSNMAC.isEnabled();
boolean b2Scanner=checkBoxScanner.isEnabled();
boolean b2BoxLabelPrinter=checkBoxBoxLabelPrinter.isEnabled();
boolean b2SNLabelPrinter=checkBoxSNLabelPrinter.isEnabled();
boolean b2SkipLoad1=checkBoxSkipLoad1.isEnabled();
boolean b2SkipLoad2=checkBoxSkipLoad2.isEnabled();
boolean b2SkipLoad3=checkBoxSkipLoad3.isEnabled();
if(TestEngine.locationCode==LocationCode.T)
{
if(bBoardTest)
{
textModelNumber.setText("CXT2-1000");
textModelNumber.setEnabled(false);
checkBoxFirmwareAsk.setSelection(false);
checkBoxSpecSNMAC.setSelection(false);
displaySpecifySNMAC();
int index=comboPrintHead.indexOf("HEC");
comboPrintHead.select(index);
checkBoxScanner.setSelection(false);
checkBoxBoxLabelPrinter.setSelection(false);
checkBoxSNLabelPrinter.setSelection(false);
}
else
{
textModelNumber.setEnabled(true);
}
}
else
{
if(bBoardTest)
{
textModelNumber.setText("");
textModelNumber.setEnabled(true);
checkBoxFirmwareAsk.setSelection(false);
checkBoxFirmwareAsk.setEnabled(false);
checkBoxSpecSNMAC.setSelection(false);
checkBoxSpecSNMAC.setEnabled(false);
displaySpecifySNMAC();
checkBoxSkipLoad1.setSelection(false);
checkBoxSkipLoad1.setEnabled(false);
checkBoxSkipLoad2.setSelection(false);
checkBoxSkipLoad2.setEnabled(false);
checkBoxSkipLoad3.setSelection(false);
checkBoxSkipLoad3.setEnabled(false);
checkBoxScanner.setSelection(false);
checkBoxScanner.setEnabled(false);
checkBoxBoxLabelPrinter.setSelection(false);
checkBoxBoxLabelPrinter.setEnabled(false);
checkBoxSNLabelPrinter.setSelection(false);
checkBoxSNLabelPrinter.setEnabled(false);
buttonSNLabel.setEnabled(false);
buttonBoxLabel.setEnabled(false);
}
else
{
textModelNumber.setText("");
textModelNumber.setEnabled(true);
checkBoxFirmwareAsk.setEnabled(true);
checkBoxSpecSNMAC.setEnabled(b2SpecSNMAC);
checkBoxSkipLoad1.setEnabled(true);
checkBoxSkipLoad2.setEnabled(true);
checkBoxSkipLoad3.setEnabled(true);
checkBoxScanner.setEnabled(true);
checkBoxBoxLabelPrinter.setEnabled(true);
checkBoxSNLabelPrinter.setEnabled(true);
buttonSNLabel.setEnabled(true);
buttonBoxLabel.setEnabled(true);
}
}
}
private void rememberOptionalPeripheral(Button checkBox, Text text, String prefName)
{
String prefValue;
if(checkBox.getSelection())
{
prefValue=text.getText();
}
else
{
prefValue="NONE";
}
GUIHelper.prefs.put(prefName, prefValue);
}
private void displayOptionalPeripheral(Button checkBox, Text text, String prefName, String def)
{
String tmp=null;
tmp=GUIHelper.prefs.get(prefName, def);
if(tmp.equals("NONE"))
{
checkBox.setSelection(false);
text.setText("");
}
else
{
checkBox.setSelection(true);
text.setText(tmp);
}
}
private void createCompositeShippingLabels()
{
GridData gridData23=new GridData();
gridData23.horizontalAlignment=GridData.FILL;
gridData23.grabExcessHorizontalSpace=true;
gridData23.grabExcessVerticalSpace=true;
gridData23.verticalAlignment=GridData.FILL;
GridData gridData20=new GridData();
gridData20.horizontalAlignment=GridData.FILL;
gridData20.grabExcessHorizontalSpace=true;
gridData20.grabExcessVerticalSpace=true;
gridData20.verticalAlignment=GridData.FILL;
GridLayout gridLayout3=new GridLayout();
gridLayout3.numColumns=2;
GridData gridData16=new GridData();
gridData16.horizontalAlignment=GridData.FILL;
gridData16.grabExcessHorizontalSpace=true;
gridData16.grabExcessVerticalSpace=true;
gridData16.horizontalSpan=2;
gridData16.verticalAlignment=GridData.FILL;
compositeShippingLabels=new Composite(compositeManufacturingSettings,
SWT.NONE);
compositeShippingLabels.setLayoutData(gridData16);
compositeShippingLabels.setLayout(gridLayout3);
buttonSNLabel=new Button(compositeShippingLabels, SWT.NONE);
buttonSNLabel.setText(Messages.getString("CompositeManufacturing.43"));
buttonSNLabel.setLayoutData(gridData20);
buttonSNLabel.addSelectionListener(new org.eclipse.swt.events.SelectionAdapter()
{
public void widgetSelected(org.eclipse.swt.events.SelectionEvent e)
{
if(textModelNumber.getText().equalsIgnoreCase("DLX-K542"))
{
TestEngine.printCustom_K542=true;
TestEngine.isCustomLabel_K542=true;
TestEngine.printSNLabel();
TestEngine.printCustom_K542=false;
TestEngine.isCustomLabel_K542=false;
}
else
{
TestEngine.printSNLabel();
}
}
});
buttonBoxLabel=new Button(compositeShippingLabels, SWT.NONE);
buttonBoxLabel.setText(Messages.getString("CompositeManufacturing.44"));
buttonBoxLabel.setEnabled(true);
buttonBoxLabel.setLayoutData(gridData23);
buttonBoxLabel
.addSelectionListener(new org.eclipse.swt.events.SelectionAdapter()
{
public void widgetSelected(org.eclipse.swt.events.SelectionEvent e)
{
TestEngine.printBoxLabel();
}
});
}
private void createCompositeModelNumber()
{
GridData gridData26=new GridData();
gridData26.grabExcessHorizontalSpace=true;
GridData gridData25=new GridData();
gridData25.horizontalAlignment=GridData.END;
gridData25.verticalAlignment=GridData.CENTER;
GridLayout gridLayout4=new GridLayout();
gridLayout4.numColumns=2;
gridLayout4.marginHeight=0;
gridLayout4.horizontalSpacing=0;
gridLayout4.verticalSpacing=0;
gridLayout4.marginWidth=0;
GridData gridData4=new GridData();
gridData4.horizontalAlignment=GridData.FILL;
gridData4.verticalAlignment=GridData.FILL;
compositeModelNumber=new Composite(compositeManufacturingSettings,
SWT.NONE);
compositeModelNumber.setLayoutData(gridData4);
compositeModelNumber.setLayout(gridLayout4);
labelModelNumber=new Label(compositeModelNumber, SWT.NONE);
labelModelNumber.setText(Messages.getString("CompositeManufacturing.45"));
labelModelNumber.setLayoutData(gridData26);
buttonScanModelNumber=new Button(compositeModelNumber, SWT.NONE);
buttonScanModelNumber.setText(Messages.getString("CompositeManufacturing.46"));
buttonScanModelNumber.setLayoutData(gridData25);
buttonScanModelNumber
.addSelectionListener(new org.eclipse.swt.events.SelectionAdapter()
{
public void widgetSelected(org.eclipse.swt.events.SelectionEvent e)
{
TestEngine.scanModelNumber();
}
});
}
private void createCompositeStart()
{
GridData gridData110=new GridData();
gridData110.horizontalAlignment=GridData.END;
gridData110.grabExcessHorizontalSpace=true;
gridData110.verticalAlignment=GridData.CENTER;
GridData gridData28=new GridData();
gridData28.grabExcessHorizontalSpace=false;
GridData gridData=new GridData();
gridData.horizontalAlignment=GridData.FILL;
gridData.verticalAlignment=GridData.FILL;
GridLayout gridLayout5=new GridLayout();
gridLayout5.numColumns=2;
gridLayout5.verticalSpacing=0;
gridLayout5.marginWidth=0;
gridLayout5.marginHeight=0;
gridLayout5.horizontalSpacing=0;
compositeStart=new Composite(this, SWT.NONE);
compositeStart.setLayout(gridLayout5);
compositeStart.setLayoutData(gridData);
buttonStart=new Button(compositeStart, SWT.NONE);
buttonStart.setText(Messages.getString("CompositeManufacturing.0"));
buttonStart.setLayoutData(gridData28);
checkBoxAutorun=new Button(compositeStart, SWT.CHECK);
checkBoxAutorun.setSelection(true);
checkBoxAutorun.setLayoutData(gridData110);
checkBoxAutorun.setText("Autorun");
checkBoxAutorun
.addSelectionListener(new org.eclipse.swt.events.SelectionAdapter()
{
public void widgetSelected(org.eclipse.swt.events.SelectionEvent e)
{
displayAutorunOptions();
}
});
checkBoxAutorun.setVisible(false);
buttonStart.addSelectionListener(new org.eclipse.swt.events.SelectionAdapter()
{
public void widgetSelected(org.eclipse.swt.events.SelectionEvent e)
{
startTest();
}
});
}
}
```
## File: JAdmin/src/com/cognitive/admin/CompositePCLWindowing.java
```java
public class CompositePCLWindowing extends Composite
{
Logger logger=null;
String pathPJL=null;
String pathPCL=null;
private Group groupDiagram=null;
private Group groupPJLParameters=null;
private Label labelOrigin=null;
private Label labelDiagram=null;
private Label labelInstructions=null;
private Label labelPJLOrigin=null;
private Text textPJLX=null;
private Text textPJLY=null;
private Label labelActualOrigin=null;
private Label labelPJLLength=null;
private Label labelActualLength=null;
private Label labelPJLWidth=null;
private Label labelActualWidth=null;
private Text textPJLLength=null;
private Text textPJLWidth=null;
private Composite compositePJLButtons=null;
private Button buttonSavePJL=null;
private Button buttonLoadPJL=null;
private Button buttonSendPJL=null;
private Group groupPrintPCL=null;
private Button buttonSelectFile=null;
private Button buttonSendFile=null;
private Text textPCLFile=null;
private Label labelActualX=null;
private Label labelActualY=null;
private Label labelActualLengthNumber=null;
private Label labelActualWidthNumber=null;
private Label filler2=null;
private Label filler6=null;
private Label filler12=null;
private Label filler16=null;
public CompositePCLWindowing(Composite parent, int style)
{
super(parent, style);
initialize();
}
private void initialize()
{
GridData gridData16=new GridData();
gridData16.grabExcessHorizontalSpace=true;
GridData gridData15=new GridData();
gridData15.grabExcessHorizontalSpace=true;
Label filler13=new Label(this, SWT.NONE);
GridData gridData14=new GridData();
gridData14.grabExcessVerticalSpace=true;
GridData gridData13=new GridData();
gridData13.grabExcessVerticalSpace=true;
filler2=new Label(this, SWT.NONE);
filler2.setText("");
filler2.setLayoutData(gridData13);
GridLayout gridLayout=new GridLayout();
gridLayout.numColumns=4;
Label filler3=new Label(this, SWT.NONE);
Label filler17=new Label(this, SWT.NONE);
filler12=new Label(this, SWT.NONE);
filler12.setText("");
filler12.setLayoutData(gridData15);
createGroupDiagram();
this.setLayout(gridLayout);
setSize(new Point(683, 497));
createGroupPJLParameters();
filler16=new Label(this, SWT.NONE);
filler16.setText("");
filler16.setLayoutData(gridData16);
Label filler10=new Label(this, SWT.NONE);
createGroupPrintPCL();
Label filler15=new Label(this, SWT.NONE);
Label filler9=new Label(this, SWT.NONE);
Label filler4=new Label(this, SWT.NONE);
Label filler14=new Label(this, SWT.NONE);
Label filler7=new Label(this, SWT.NONE);
filler6=new Label(this, SWT.NONE);
filler6.setText("");
filler6.setLayoutData(gridData14);
}
private void createGroupDiagram()
{
GridData gridData269=new GridData();
gridData269.horizontalAlignment=GridData.FILL;
gridData269.verticalAlignment=GridData.CENTER;
GridData gridData266=new GridData();
GridLayout gridLayout1=new GridLayout();
gridLayout1.numColumns=2;
gridLayout1.marginHeight=15;
gridLayout1.horizontalSpacing=5;
gridLayout1.marginWidth=8;
GridData gridData=new GridData();
gridData.verticalSpan=3;
gridData.verticalAlignment=GridData.FILL;
gridData.horizontalAlignment=GridData.FILL;
groupDiagram=new Group(this, SWT.NONE);
groupDiagram.setLayoutData(gridData);
groupDiagram.setLayout(gridLayout1);
groupDiagram.setText("Label Window Within Standard Page");
labelOrigin=new Label(groupDiagram, SWT.NONE);
labelOrigin.setText("(0,0)");
labelOrigin.setLayoutData(gridData269);
labelOrigin.setFont(new Font(Display.getDefault(), "Tahoma", 8, SWT.ITALIC));
Label filler270=new Label(groupDiagram, SWT.NONE);
Label filler1=new Label(groupDiagram, SWT.NONE);
labelDiagram=new Label(groupDiagram, SWT.NONE);
labelDiagram.setText("Label");
labelDiagram.setLayoutData(gridData266);
labelDiagram.setImage(new Image(Display.getCurrent(), getClass().getResourceAsStream("/com/cognitive/admin/PCLPaper.png")));
}
private void createGroupPJLParameters()
{
GridData gridData24=new GridData();
gridData24.horizontalAlignment=GridData.FILL;
gridData24.verticalAlignment=GridData.CENTER;
GridData gridData23=new GridData();
gridData23.horizontalAlignment=GridData.FILL;
gridData23.verticalAlignment=GridData.CENTER;
GridData gridData22=new GridData();
gridData22.horizontalAlignment=GridData.FILL;
gridData22.grabExcessHorizontalSpace=true;
gridData22.verticalAlignment=GridData.CENTER;
GridData gridData21=new GridData();
gridData21.horizontalAlignment=GridData.FILL;
gridData21.grabExcessHorizontalSpace=true;
gridData21.verticalAlignment=GridData.CENTER;
GridData gridData20=new GridData();
gridData20.horizontalAlignment=GridData.FILL;
gridData20.verticalAlignment=GridData.CENTER;
GridData gridData19=new GridData();
gridData19.horizontalAlignment=GridData.FILL;
gridData19.verticalAlignment=GridData.CENTER;
GridData gridData18=new GridData();
gridData18.horizontalAlignment=GridData.FILL;
gridData18.verticalAlignment=GridData.CENTER;
GridData gridData17=new GridData();
gridData17.horizontalAlignment=GridData.FILL;
gridData17.verticalAlignment=GridData.CENTER;
GridData gridData6=new GridData();
gridData6.horizontalAlignment=GridData.END;
gridData6.verticalAlignment=GridData.CENTER;
GridData gridData5=new GridData();
gridData5.horizontalAlignment=GridData.END;
gridData5.verticalAlignment=GridData.CENTER;
GridData gridData4=new GridData();
gridData4.horizontalAlignment=GridData.END;
gridData4.verticalAlignment=GridData.CENTER;
GridData gridData3=new GridData();
gridData3.horizontalSpan=4;
GridLayout gridLayout2=new GridLayout();
gridLayout2.numColumns=4;
gridLayout2.marginHeight=13;
gridLayout2.verticalSpacing=15;
GridData gridData2=new GridData();
gridData2.horizontalAlignment=GridData.FILL;
gridData2.verticalAlignment=GridData.FILL;
groupPJLParameters=new Group(this, SWT.NONE);
groupPJLParameters.setLayoutData(gridData2);
groupPJLParameters.setLayout(gridLayout2);
groupPJLParameters.setText(Messages.getString("CompositePCLWindowing.15"));
labelInstructions=new Label(groupPJLParameters, SWT.NONE);
labelInstructions.setText(Messages.getString("CompositePCLWindowing.16"));
labelInstructions.setLayoutData(gridData3);
labelPJLOrigin=new Label(groupPJLParameters, SWT.NONE);
labelPJLOrigin.setText(Messages.getString("CompositePCLWindowing.17"));
textPJLX=new Text(groupPJLParameters, SWT.BORDER);
textPJLX.setLayoutData(gridData21);
textPJLX.addFocusListener(new org.eclipse.swt.events.FocusAdapter()
{
public void focusGained(org.eclipse.swt.events.FocusEvent e)
{
labelActualX.setText("");
}
public void focusLost(org.eclipse.swt.events.FocusEvent e)
{
displayActual(textPJLX, labelActualX);
}
});
textPJLY=new Text(groupPJLParameters, SWT.BORDER);
textPJLY.setLayoutData(gridData22);
textPJLY.addFocusListener(new org.eclipse.swt.events.FocusAdapter()
{
public void focusGained(org.eclipse.swt.events.FocusEvent e)
{
labelActualY.setText("");
}
public void focusLost(org.eclipse.swt.events.FocusEvent e)
{
displayActual(textPJLY, labelActualY);
}
});
Label filler2264=new Label(groupPJLParameters, SWT.NONE);
labelActualOrigin=new Label(groupPJLParameters, SWT.RIGHT);
labelActualOrigin.setText(Messages.getString("CompositePCLWindowing.4"));
labelActualOrigin.setLayoutData(gridData4);
labelActualOrigin.setFont(new Font(Display.getDefault(), "Tahoma", 8, SWT.ITALIC));
labelActualX=new Label(groupPJLParameters, SWT.CENTER);
labelActualX.setText("");
labelActualX.setLayoutData(gridData17);
labelActualX.setFont(new Font(Display.getDefault(), "Tahoma", 8, SWT.ITALIC));
labelActualY=new Label(groupPJLParameters, SWT.CENTER);
labelActualY.setText("");
labelActualY.setLayoutData(gridData18);
labelActualY.setFont(new Font(Display.getDefault(), "Tahoma", 8, SWT.ITALIC));
Label filler=new Label(groupPJLParameters, SWT.NONE);
labelPJLLength=new Label(groupPJLParameters, SWT.NONE);
labelPJLLength.setText(Messages.getString("CompositePCLWindowing.7"));
textPJLLength=new Text(groupPJLParameters, SWT.BORDER);
textPJLLength.setLayoutData(gridData23);
textPJLLength.addFocusListener(new org.eclipse.swt.events.FocusAdapter()
{
public void focusGained(org.eclipse.swt.events.FocusEvent e)
{
labelActualLengthNumber.setText("");
}
public void focusLost(org.eclipse.swt.events.FocusEvent e)
{
displayActual(textPJLLength, labelActualLengthNumber);
}
});
Label filler5=new Label(groupPJLParameters, SWT.NONE);
Label filler2263=new Label(groupPJLParameters, SWT.NONE);
labelActualLength=new Label(groupPJLParameters, SWT.RIGHT);
labelActualLength.setText(Messages.getString("CompositePCLWindowing.4"));
labelActualLength.setLayoutData(gridData5);
labelActualLength.setFont(new Font(Display.getDefault(), "Tahoma", 8, SWT.ITALIC));
labelActualLengthNumber=new Label(groupPJLParameters, SWT.CENTER);
labelActualLengthNumber.setText("");
labelActualLengthNumber.setLayoutData(gridData19);
labelActualLengthNumber.setFont(new Font(Display.getDefault(), "Tahoma", 8, SWT.ITALIC));
Label filler8=new Label(groupPJLParameters, SWT.NONE);
Label filler2262=new Label(groupPJLParameters, SWT.NONE);
labelPJLWidth=new Label(groupPJLParameters, SWT.NONE);
labelPJLWidth.setText(Messages.getString("CompositePCLWindowing.5"));
textPJLWidth=new Text(groupPJLParameters, SWT.BORDER);
textPJLWidth.setLayoutData(gridData24);
textPJLWidth.addFocusListener(new org.eclipse.swt.events.FocusAdapter()
{
public void focusGained(org.eclipse.swt.events.FocusEvent e)
{
labelActualWidthNumber.setText("");
}
public void focusLost(org.eclipse.swt.events.FocusEvent e)
{
displayActual(textPJLWidth, labelActualWidthNumber);
}
});
Label filler11=new Label(groupPJLParameters, SWT.NONE);
Label filler2261=new Label(groupPJLParameters, SWT.NONE);
labelActualWidth=new Label(groupPJLParameters, SWT.RIGHT);
labelActualWidth.setText(Messages.getString("CompositePCLWindowing.4"));
labelActualWidth.setLayoutData(gridData6);
labelActualWidth.setFont(new Font(Display.getDefault(), "Tahoma", 8, SWT.ITALIC));
labelActualWidthNumber=new Label(groupPJLParameters, SWT.CENTER);
labelActualWidthNumber.setText("");
labelActualWidthNumber.setLayoutData(gridData20);
labelActualWidthNumber.setFont(new Font(Display.getDefault(), "Tahoma", 8, SWT.ITALIC));
Label filler2259=new Label(groupPJLParameters, SWT.NONE);
Label filler2260=new Label(groupPJLParameters, SWT.NONE);
createCompositePJLButtons();
}
private void createCompositePJLButtons()
{
GridData gridData9=new GridData();
gridData9.horizontalAlignment=GridData.CENTER;
gridData9.grabExcessHorizontalSpace=true;
gridData9.verticalAlignment=GridData.CENTER;
GridData gridData8=new GridData();
gridData8.horizontalAlignment=GridData.CENTER;
gridData8.grabExcessHorizontalSpace=true;
gridData8.verticalAlignment=GridData.CENTER;
GridData gridData7=new GridData();
gridData7.horizontalAlignment=GridData.CENTER;
gridData7.grabExcessHorizontalSpace=true;
gridData7.verticalAlignment=GridData.CENTER;
GridLayout gridLayout3=new GridLayout();
gridLayout3.numColumns=3;
GridData gridData1=new GridData();
gridData1.horizontalSpan=4;
gridData1.verticalAlignment=GridData.FILL;
gridData1.horizontalAlignment=GridData.FILL;
compositePJLButtons=new Composite(groupPJLParameters, SWT.NONE);
compositePJLButtons.setLayoutData(gridData1);
compositePJLButtons.setLayout(gridLayout3);
buttonSavePJL=new Button(compositePJLButtons, SWT.NONE);
buttonSavePJL.setText(Messages.getString("CompositePCLWindowing.3"));
buttonSavePJL.setLayoutData(gridData9);
buttonSavePJL
.addSelectionListener(new org.eclipse.swt.events.SelectionAdapter()
{
public void widgetSelected(org.eclipse.swt.events.SelectionEvent e)
{
savePJLFile();
}
});
buttonLoadPJL=new Button(compositePJLButtons, SWT.NONE);
buttonLoadPJL.setText(Messages.getString("CompositePCLWindowing.2"));
buttonLoadPJL.setLayoutData(gridData8);
buttonLoadPJL
.addSelectionListener(new org.eclipse.swt.events.SelectionAdapter()
{
public void widgetSelected(org.eclipse.swt.events.SelectionEvent e)
{
openPJLFile();
}
});
buttonSendPJL=new Button(compositePJLButtons, SWT.NONE);
buttonSendPJL.setText(Messages.getString("CompositePCLWindowing.1"));
buttonSendPJL.setLayoutData(gridData7);
buttonSendPJL
.addSelectionListener(new org.eclipse.swt.events.SelectionAdapter()
{
public void widgetSelected(org.eclipse.swt.events.SelectionEvent e)
{
sendPJLToPrinter();
}
});
}
private void createGroupPrintPCL()
{
GridData gridData12=new GridData();
gridData12.horizontalAlignment=GridData.END;
gridData12.verticalAlignment=GridData.CENTER;
GridData gridData11=new GridData();
gridData11.horizontalSpan=2;
gridData11.verticalAlignment=GridData.CENTER;
gridData11.grabExcessHorizontalSpace=true;
gridData11.horizontalAlignment=GridData.FILL;
GridLayout gridLayout4=new GridLayout();
gridLayout4.numColumns=2;
gridLayout4.marginHeight=17;
gridLayout4.verticalSpacing=15;
gridLayout4.marginWidth=5;
GridData gridData10=new GridData();
gridData10.horizontalAlignment=GridData.FILL;
gridData10.verticalAlignment=GridData.FILL;
groupPrintPCL=new Group(this, SWT.NONE);
groupPrintPCL.setText(Messages.getString("CompositePCLWindowing.0"));
groupPrintPCL.setLayout(gridLayout4);
groupPrintPCL.setLayoutData(gridData10);
buttonSelectFile=new Button(groupPrintPCL, SWT.NONE);
buttonSelectFile.setText(Messages.getString("CompositePCLWindowing.18"));
buttonSelectFile
.addSelectionListener(new org.eclipse.swt.events.SelectionAdapter()
{
public void widgetSelected(org.eclipse.swt.events.SelectionEvent e)
{
selectPCLFile();
}
});
buttonSendFile=new Button(groupPrintPCL, SWT.NONE);
buttonSendFile.setText(Messages.getString("CompositePCLWindowing.19"));
buttonSendFile.setLayoutData(gridData12);
buttonSendFile
.addSelectionListener(new org.eclipse.swt.events.SelectionAdapter()
{
public void widgetSelected(org.eclipse.swt.events.SelectionEvent e)
{
sendPCLFile();
}
});
textPCLFile=new Text(groupPrintPCL, SWT.BORDER);
textPCLFile.setLayoutData(gridData11);
}
final float DECIPOINTS_PER_INCH=720;
private String parsePJLLine(String line)
{
String val;
int tmpInt;
float tmpFloat;
val=line.substring(line.indexOf("=")+1);
tmpInt=Integer.parseInt(val);
tmpFloat=((float)(tmpInt))/DECIPOINTS_PER_INCH;
return Float.toString(tmpFloat);
}
private void parsePJLFile(BufferedReader br)
{
String line;
try
{
while((line=br.readLine())!=null)
{
if(line.contains("PAGECLIPX"))
{
textPJLX.setText(parsePJLLine(line));
labelActualX.setText(textPJLX.getText());
}
else if(line.contains("PAGECLIPY"))
{
textPJLY.setText(parsePJLLine(line));
labelActualY.setText(textPJLY.getText());
}
else if(line.contains("PAGECLIPWIDTH"))
{
textPJLWidth.setText(parsePJLLine(line));
labelActualWidthNumber.setText(textPJLWidth.getText());
}
else if(line.contains("PAGECLIPLENGTH"))
{
textPJLLength.setText(parsePJLLine(line));
labelActualLengthNumber.setText(textPJLLength.getText());
}
else
{
}
}
}
catch(Exception e)
{
}
}
private void openPJLFile()
{
if(pathPJL==null)
{
pathPJL=GUIHelper.prefs.get("PATH_PJL", ".");
}
StringBuffer pathUsed=new StringBuffer("");
BufferedReader br=GUIHelper.openTextFile(pathPJL, pathUsed);
if(br==null)
{
return;
}
pathPJL=pathUsed.toString();
GUIHelper.prefs.put("PATH_PJL", pathPJL);
parsePJLFile(br);
try
{
br.close();
}
catch(Exception e)
{
}
}
private String strInchesToStrDecipoints(String inches) throws Exception
{
int decipoints=(int)(Float.parseFloat(inches)*DECIPOINTS_PER_INCH);
return Integer.toString(decipoints);
}
private String strInchesToStrDecipointsAndBack(String inches)
{
int decipoints=(int)(Float.parseFloat(inches)*DECIPOINTS_PER_INCH);
float actual=decipoints/DECIPOINTS_PER_INCH;
return Float.toString(actual);
}
private String generatePJL()
{
StringBuffer script=new StringBuffer("");
char escape=27;
try
{
script.append(escape);
script.append("%-12345X@PJL\r\n");
script.append("@PJL COMMENT \"Generated by JAdmin\"\r\n");
script.append("@PJL DEFAULT PAPER=LETTER\r\n");
script.append("@PJL DEFAULT PAPERSIZEOVERRIDE=OFF\r\n");
script.append("@PJL DEFAULT PAGECLIPPING=ON\r\n");
script.append("@PJL DEFAULT PAGECLIPX="+strInchesToStrDecipoints(textPJLX.getText())+"\r\n");
script.append("@PJL DEFAULT PAGECLIPY="+strInchesToStrDecipoints(textPJLY.getText())+"\r\n");
script.append("@PJL DEFAULT PAGECLIPWIDTH="+strInchesToStrDecipoints(textPJLWidth.getText())+"\r\n");
script.append("@PJL DEFAULT PAGECLIPLENGTH="+strInchesToStrDecipoints(textPJLLength.getText())+"\r\n");
script.append("@PJL RESET\r\n");
script.append(escape);
script.append("%-12345X\r\n");
}
catch(Exception e)
{
return null;
}
return script.toString();
}
private void savePJLFile()
{
if(pathPJL==null)
{
pathPJL=GUIHelper.prefs.get("PATH_PJL", ".");
}
StringBuffer pathUsed=new StringBuffer("");
String pjl=generatePJL();
if(pjl==null)
{
GUIHelper.error(Messages.getString("CompositePCLWindowing.20"));
return;
}
pathPJL=GUIHelper.saveTextFile(pjl, pathPJL);
GUIHelper.prefs.put("PATH_PJL", pathPJL);
}
private void displayActual(Text text, Label label)
{
try
{
String given=text.getText();
String actual=strInchesToStrDecipointsAndBack(given);
String formatted=String.format("%6.3f", Float.parseFloat(actual));
label.setText(formatted);
label.setForeground(Display.getCurrent().getSystemColor(SWT.DEFAULT));
}
catch(Exception e)
{
label.setText("???");
label.setForeground(Display.getCurrent().getSystemColor(SWT.COLOR_RED));
}
}
private void printPCLWindowBox()
{
String pitch=PrinterHelper.getVariable("PITCH");
if(pitch==null)
{
return;
}
int iPitch=Integer.parseInt(pitch);
int widthDots=(int)(Float.parseFloat(textPJLWidth.getText())*iPitch);
int lengthDots=(int)(Float.parseFloat(textPJLLength.getText())*iPitch);
StringBuffer boxLabel=new StringBuffer();
boxLabel.append("!0 100 "+lengthDots+" 1\n");
boxLabel.append("DRAW_BOX 0 0 ");
boxLabel.append(widthDots+" ");
boxLabel.append(lengthDots+" 3 \n");
boxLabel.append("U B24 (3,0,0) 20 20 Box length="+textPJLLength.getText()+" inches.\n");
boxLabel.append("U B24 (3,0,0) 20 60 Box width="+textPJLWidth.getText()+" inches.\n");
boxLabel.append("END\n");
PrinterHelper.send(boxLabel.toString());
}
private void sendPJLToPrinter()
{
String pjl=generatePJL();
if(pjl==null)
{
GUIHelper.error(Messages.getString("CompositePCLWindowing.20"));
return;
}
printPCLWindowBox();
PrinterHelper.send(pjl);
}
private void selectPCLFile()
{
if(pathPCL==null)
{
pathPCL=GUIHelper.prefs.get("PATH_PCL", ".");
}
FileDialog fd=new FileDialog(GUIHelper.myShell, SWT.OPEN);
fd.setFilterPath(pathPJL);
String pclFileName=fd.open();
if(pclFileName==null)
{
return;
}
pathPCL=fd.getFilterPath();
GUIHelper.prefs.put("PATH_PCL", pathPCL);
textPCLFile.setText(pclFileName);
}
private void sendPCLFile()
{
String fileName=textPCLFile.getText();
byte[] data;
try
{
data=GUIHelper.readBinaryFile(fileName);
}
catch(Exception e)
{
GUIHelper.error(Messages.getString("CompositePCLWindowing.22")+fileName);
return;
}
PrinterHelper.send(data);
}
public void setConnectionState(boolean connected, boolean dumbTerminal)
{
logger=GUIHelper.logger;
logger.trace("");
GUIHelper.setEnabled(this, connected);
GUIHelper.setEnabled(groupPJLParameters, true);
buttonSendPJL.setEnabled(connected);
}
}
```
## File: JAdmin/src/com/cognitive/admin/CompositePrinterSettings.java
```java
public class CompositePrinterSettings extends Composite
{
private static boolean hasPCLFirmware=false;
private static String currentFirmwarePartNumber="";
private static boolean showAuto=false;
private boolean connected=false;
private boolean firstPaintSinceConnected=true;
private boolean dumbTerminal=true;
private Logger logger=null;
private String modelNumber="";
private Label labelPrintSpeed=null;
private Combo comboPrintSpeed=null;
private Button buttonPrintSpeed=null;
private Label labelNoMediaOut=null;
private Text textNoMediaOut=null;
private Button buttonNoMediaOut=null;
private Button checkBoxAuxPower=null;
private Button buttonAuxPower=null;
private Label labelDebugReportLevel=null;
private Combo comboDebugReportLevel=null;
private Button buttonDebugReportLevel=null;
private Button checkBoxAutoReprint=null;
private Button buttonAutoReprint=null;
private Label labelMediaAdjust=null;
private Text textMediaAdjust=null;
private Button buttonMediaAdjust=null;
private Label labelPitch=null;
private Combo comboPitch=null;
private Button buttonPitch=null;
private Group groupPrimaryLanguage=null;
private Button radioButtonPL_PCL=null;
private Button radioButtonPL_ZPL=null;
private Button radioButtonPL_EPL=null;
private Button radioButtonPL_CPL=null;
private Button buttonPrimaryLanguage=null;
private Group groupThermalMode=null;
private Button radioButtonTM_DT=null;
private Button radioButtonTM_TT=null;
private Button buttonTM=null;
private Label filler5=null;
private Label separator=null;
private Label separator1=null;
private Label separator2=null;
private Label separator3=null;
private Label separator4=null;
private Label separator5=null;
private Label separator6=null;
private Label separator7=null;
private Label labelTime=null;
private Text textTime=null;
private Label labelDate=null;
private Text textDate=null;
private Button buttonTDRefresh=null;
private Button buttonTDApply=null;
private Button buttonTestLabel=null;
private Button buttonRefresh=null;
private Label filler8=null;
private Label filler14=null;
private Label filler15=null;
private Label filler16=null;
private Label separator8=null;
private Group groupDarkness=null;
private Text textDarkness=null;
private Slider sliderDarkness=null;
private Button buttonDarkness=null;
private Label filler6=null;
private Label labelCustomSpeed=null;
private Label filler51=null;
public CompositePrinterSettings(Composite parent, int style)
{
super(parent, style);
initialize();
}
private void initialize()
{
GridData gridData48=new GridData();
gridData48.horizontalAlignment=GridData.BEGINNING;
gridData48.verticalAlignment=GridData.CENTER;
GridData gridData47=new GridData();
gridData47.horizontalSpan=2;
GridData gridData46=new GridData();
gridData46.horizontalSpan=2;
GridData gridData45=new GridData();
gridData45.horizontalSpan=2;
GridData gridData44=new GridData();
gridData44.horizontalSpan=2;
GridData gridData43=new GridData();
gridData43.horizontalSpan=2;
GridData gridData42=new GridData();
gridData42.horizontalSpan=2;
GridData gridData38=new GridData();
gridData38.horizontalAlignment=GridData.FILL;
gridData38.verticalAlignment=GridData.CENTER;
GridData gridData37=new GridData();
gridData37.horizontalAlignment=GridData.FILL;
gridData37.verticalAlignment=GridData.CENTER;
GridData gridData36=new GridData();
gridData36.horizontalAlignment=GridData.FILL;
gridData36.verticalAlignment=GridData.CENTER;
GridData gridData35=new GridData();
gridData35.horizontalAlignment=GridData.FILL;
gridData35.verticalAlignment=GridData.CENTER;
GridData gridData34=new GridData();
gridData34.horizontalAlignment=GridData.FILL;
gridData34.verticalAlignment=GridData.CENTER;
GridData gridData33=new GridData();
gridData33.horizontalAlignment=GridData.FILL;
gridData33.verticalAlignment=GridData.CENTER;
GridData gridData32=new GridData();
gridData32.horizontalAlignment=GridData.FILL;
gridData32.verticalAlignment=GridData.CENTER;
GridData gridData31=new GridData();
gridData31.horizontalAlignment=GridData.FILL;
gridData31.verticalAlignment=GridData.CENTER;
GridData gridData30=new GridData();
gridData30.horizontalAlignment=GridData.FILL;
gridData30.verticalAlignment=GridData.CENTER;
GridData gridData29=new GridData();
gridData29.horizontalAlignment=GridData.FILL;
gridData29.verticalAlignment=GridData.CENTER;
GridData gridData28=new GridData();
gridData28.horizontalAlignment=GridData.FILL;
gridData28.verticalAlignment=GridData.CENTER;
GridData gridData27=new GridData();
gridData27.horizontalAlignment=GridData.FILL;
gridData27.verticalAlignment=GridData.CENTER;
GridData gridData26=new GridData();
gridData26.horizontalAlignment=GridData.FILL;
gridData26.verticalAlignment=GridData.CENTER;
GridData gridData20=new GridData();
gridData20.horizontalSpan=6;
gridData20.verticalAlignment=GridData.CENTER;
gridData20.horizontalAlignment=GridData.FILL;
GridData gridData19=new GridData();
gridData19.grabExcessHorizontalSpace=true;
Label filler18=new Label(this, SWT.NONE);
GridData gridData17=new GridData();
gridData17.grabExcessHorizontalSpace=true;
GridData gridData16=new GridData();
gridData16.grabExcessVerticalSpace=true;
GridData gridData15=new GridData();
gridData15.grabExcessVerticalSpace=true;
Label filler7=new Label(this, SWT.NONE);
GridData gridData13=new GridData();
gridData13.horizontalSpan=6;
gridData13.verticalAlignment=GridData.CENTER;
gridData13.horizontalAlignment=GridData.CENTER;
GridData gridData12=new GridData();
gridData12.horizontalSpan=6;
gridData12.verticalAlignment=GridData.CENTER;
gridData12.horizontalAlignment=GridData.CENTER;
GridData gridData11=new GridData();
gridData11.horizontalSpan=4;
gridData11.verticalAlignment=GridData.CENTER;
gridData11.horizontalAlignment=GridData.FILL;
GridData gridData10=new GridData();
gridData10.horizontalAlignment=GridData.FILL;
gridData10.horizontalSpan=4;
gridData10.verticalAlignment=GridData.CENTER;
GridData gridData9=new GridData();
gridData9.horizontalAlignment=GridData.FILL;
gridData9.horizontalSpan=4;
gridData9.verticalAlignment=GridData.CENTER;
GridData gridData8=new GridData();
gridData8.horizontalAlignment=GridData.FILL;
gridData8.horizontalSpan=4;
gridData8.verticalAlignment=GridData.CENTER;
GridData gridData7=new GridData();
gridData7.horizontalAlignment=GridData.FILL;
gridData7.horizontalSpan=4;
gridData7.verticalAlignment=GridData.CENTER;
GridData gridData6=new GridData();
gridData6.horizontalAlignment=GridData.FILL;
gridData6.horizontalSpan=4;
gridData6.verticalAlignment=GridData.CENTER;
GridData gridData5=new GridData();
gridData5.horizontalAlignment=GridData.FILL;
gridData5.horizontalSpan=4;
gridData5.verticalAlignment=GridData.CENTER;
GridData gridData56=new GridData();
gridData56.horizontalAlignment=GridData.CENTER;
gridData56.verticalSpan=18;
gridData56.widthHint=-1;
gridData56.grabExcessHorizontalSpace=true;
gridData56.verticalAlignment=GridData.FILL;
GridData gridData18=new GridData();
gridData18.horizontalSpan=2;
GridData gridData14=new GridData();
gridData14.horizontalSpan=3;
Label filler36=new Label(this, SWT.NONE);
filler8=new Label(this, SWT.NONE);
filler8.setText("");
filler8.setLayoutData(gridData15);
Label filler9=new Label(this, SWT.NONE);
Label filler10=new Label(this, SWT.NONE);
Label filler11=new Label(this, SWT.NONE);
Label filler16207=new Label(this, SWT.NONE);
Label filler17=new Label(this, SWT.NONE);
labelPrintSpeed=new Label(this, SWT.NONE);
labelPrintSpeed.setText(Messages.getString("CompositePrinterSettings.0"));
labelCustomSpeed=new Label(this, SWT.NONE);
labelCustomSpeed.setVisible(false);
labelCustomSpeed.setText("(0000)");
labelCustomSpeed.setLayoutData(gridData48);
createComboPrintSpeed();
buttonPrintSpeed=new Button(this, SWT.NONE);
buttonPrintSpeed.setText(Messages.getString("General.0"));
buttonPrintSpeed.setLayoutData(gridData26);
buttonPrintSpeed
.addSelectionListener(new org.eclipse.swt.events.SelectionAdapter()
{
public void widgetSelected(org.eclipse.swt.events.SelectionEvent e)
{
applyPrintSpeed();
}
});
separator=new Label(this, SWT.SEPARATOR);
separator.setText("");
separator.setLayoutData(gridData56);
createGroupDarkness();
Label filler16206=new Label(this, SWT.NONE);
filler16=new Label(this, SWT.NONE);
filler16.setText("");
filler16.setLayoutData(gridData19);
separator1=new Label(this, SWT.SEPARATOR|SWT.HORIZONTAL);
separator1.setText("");
separator1.setLayoutData(gridData9);
Label filler16205=new Label(this, SWT.NONE);
Label filler16225=new Label(this, SWT.NONE);
labelNoMediaOut=new Label(this, SWT.NONE);
labelNoMediaOut.setText(Messages.getString("CompositePrinterSettings.2"));
labelNoMediaOut.setLayoutData(gridData42);
textNoMediaOut=new Text(this, SWT.BORDER);
textNoMediaOut.setLayoutData(gridData35);
buttonNoMediaOut=new Button(this, SWT.NONE);
buttonNoMediaOut.setText(Messages.getString("General.0"));
buttonNoMediaOut.setLayoutData(gridData27);
buttonNoMediaOut
.addSelectionListener(new org.eclipse.swt.events.SelectionAdapter()
{
public void widgetSelected(org.eclipse.swt.events.SelectionEvent e)
{
applyNoMediaOut();
}
});
filler15=new Label(this, SWT.NONE);
filler15.setText("");
filler15.setLayoutData(gridData17);
Label filler16224=new Label(this, SWT.NONE);
separator2=new Label(this, SWT.SEPARATOR|SWT.HORIZONTAL);
separator2.setText("Label");
separator2.setLayoutData(gridData8);
Label filler1916=new Label(this, SWT.NONE);
Label filler15204=new Label(this, SWT.NONE);
Label filler16223=new Label(this, SWT.NONE);
labelDebugReportLevel=new Label(this, SWT.NONE);
labelDebugReportLevel.setText(Messages.getString("CompositePrinterSettings.4"));
labelDebugReportLevel.setLayoutData(gridData43);
createComboDebugReportLevel();
buttonDebugReportLevel=new Button(this, SWT.NONE);
buttonDebugReportLevel.setText(Messages.getString("General.0"));
buttonDebugReportLevel.setLayoutData(gridData28);
createGroupPrimaryLanguage();
buttonDebugReportLevel
.addSelectionListener(new org.eclipse.swt.events.SelectionAdapter()
{
public void widgetSelected(org.eclipse.swt.events.SelectionEvent e)
{
applyReportLevel();
}
});
Label filler15203=new Label(this, SWT.NONE);
Label filler28=new Label(this, SWT.NONE);
Label filler29=new Label(this, SWT.NONE);
Label filler33=new Label(this, SWT.NONE);
Label filler30=new Label(this, SWT.NONE);
Label filler31=new Label(this, SWT.NONE);
Label filler27=new Label(this, SWT.NONE);
Label filler16222=new Label(this, SWT.NONE);
separator6=new Label(this, SWT.SEPARATOR|SWT.HORIZONTAL);
separator6.setText("Label");
separator6.setLayoutData(gridData10);
Label filler15202=new Label(this, SWT.NONE);
Label filler16221=new Label(this, SWT.NONE);
checkBoxAuxPower=new Button(this, SWT.CHECK);
checkBoxAuxPower.setText(Messages.getString("CompositePrinterSettings.6"));
checkBoxAuxPower.setLayoutData(gridData14);
buttonAuxPower=new Button(this, SWT.NONE);
buttonAuxPower.setText(Messages.getString("General.0"));
buttonAuxPower.setLayoutData(gridData29);
buttonAuxPower
.addSelectionListener(new org.eclipse.swt.events.SelectionAdapter()
{
public void widgetSelected(org.eclipse.swt.events.SelectionEvent e)
{
applyAuxPower();
}
});
Label filler15201=new Label(this, SWT.NONE);
Label filler16220=new Label(this, SWT.NONE);
separator3=new Label(this, SWT.SEPARATOR|SWT.HORIZONTAL);
separator3.setText("Label");
separator3.setLayoutData(gridData7);
Label filler15200=new Label(this, SWT.NONE);
Label filler16219=new Label(this, SWT.NONE);
checkBoxAutoReprint=new Button(this, SWT.CHECK);
checkBoxAutoReprint.setText(Messages.getString("CompositePrinterSettings.8"));
checkBoxAutoReprint.setLayoutData(gridData18);
Label filler733=new Label(this, SWT.NONE);
buttonAutoReprint=new Button(this, SWT.NONE);
buttonAutoReprint.setText(Messages.getString("General.0"));
buttonAutoReprint.setLayoutData(gridData30);
buttonAutoReprint
.addSelectionListener(new org.eclipse.swt.events.SelectionAdapter()
{
public void widgetSelected(org.eclipse.swt.events.SelectionEvent e)
{
applyAutoReprint();
}
});
Label filler15199=new Label(this, SWT.NONE);
Label filler16218=new Label(this, SWT.NONE);
separator4=new Label(this, SWT.SEPARATOR|SWT.HORIZONTAL);
separator4.setText("Label");
separator4.setLayoutData(gridData6);
Label filler15198=new Label(this, SWT.NONE);
Label filler16217=new Label(this, SWT.NONE);
labelMediaAdjust=new Label(this, SWT.NONE);
labelMediaAdjust.setText(Messages.getString("CompositePrinterSettings.10"));
labelMediaAdjust.setLayoutData(gridData44);
textMediaAdjust=new Text(this, SWT.BORDER);
textMediaAdjust.setLayoutData(gridData36);
buttonMediaAdjust=new Button(this, SWT.NONE);
buttonMediaAdjust.setText(Messages.getString("General.0"));
buttonMediaAdjust.setLayoutData(gridData31);
createGroupThermalMode();
buttonMediaAdjust
.addSelectionListener(new org.eclipse.swt.events.SelectionAdapter()
{
public void widgetSelected(org.eclipse.swt.events.SelectionEvent e)
{
applyMediaAdjust();
}
});
Label filler15197=new Label(this, SWT.NONE);
Label filler16216=new Label(this, SWT.NONE);
separator5=new Label(this, SWT.SEPARATOR|SWT.HORIZONTAL);
separator5.setText("Label");
separator5.setLayoutData(gridData5);
Label filler15196=new Label(this, SWT.NONE);
Label filler16215=new Label(this, SWT.NONE);
labelPitch=new Label(this, SWT.NONE);
labelPitch.setText(Messages.getString("CompositePrinterSettings.12"));
labelPitch.setLayoutData(gridData45);
createComboPitch();
buttonPitch=new Button(this, SWT.NONE);
buttonPitch.setText(Messages.getString("General.0"));
buttonPitch.setLayoutData(gridData32);
buttonPitch.addSelectionListener(new org.eclipse.swt.events.SelectionAdapter()
{
public void widgetSelected(org.eclipse.swt.events.SelectionEvent e)
{
applyPitch();
}
});
Label filler15195=new Label(this, SWT.NONE);
Label filler16214=new Label(this, SWT.NONE);
separator7=new Label(this, SWT.SEPARATOR|SWT.HORIZONTAL);
separator7.setText("Label");
separator7.setLayoutData(gridData11);
Label filler15194=new Label(this, SWT.NONE);
Label filler16213=new Label(this, SWT.NONE);
labelTime=new Label(this, SWT.NONE);
labelTime.setText(Messages.getString("CompositePrinterSettings.14"));
labelTime.setLayoutData(gridData46);
textTime=new Text(this, SWT.BORDER);
textTime.setLayoutData(gridData37);
buttonTDRefresh=new Button(this, SWT.NONE);
buttonTDRefresh.setText(Messages.getString("General.1"));
buttonTDRefresh.setLayoutData(gridData33);
buttonTDRefresh
.addSelectionListener(new org.eclipse.swt.events.SelectionAdapter()
{
public void widgetSelected(org.eclipse.swt.events.SelectionEvent e)
{
refreshDateTime();
}
});
Label filler15193=new Label(this, SWT.NONE);
Label filler16212=new Label(this, SWT.NONE);
labelDate=new Label(this, SWT.NONE);
labelDate.setText("Date (mm/dd/yy or dd.mm.yy):");
labelDate.setLayoutData(gridData47);
labelDate.setToolTipText(Messages.getString("CompositePrinterSettings.68"));
textDate=new Text(this, SWT.BORDER);
textDate.setToolTipText(Messages.getString("CompositePrinterSettings.68"));
textDate.setLayoutData(gridData38);
buttonTDApply=new Button(this, SWT.NONE);
buttonTDApply.setText(Messages.getString("General.0"));
buttonTDApply.setLayoutData(gridData34);
buttonTDApply
.addSelectionListener(new org.eclipse.swt.events.SelectionAdapter()
{
public void widgetSelected(org.eclipse.swt.events.SelectionEvent e)
{
applyDateTime();
}
});
Label filler15192=new Label(this, SWT.NONE);
Label filler16211=new Label(this, SWT.NONE);
Label filler15106=new Label(this, SWT.NONE);
Label filler20=new Label(this, SWT.NONE);
Label filler15107=new Label(this, SWT.NONE);
Label filler15108=new Label(this, SWT.NONE);
Label filler1911=new Label(this, SWT.NONE);
Label filler15191=new Label(this, SWT.NONE);
Label filler21=new Label(this, SWT.NONE);
separator8=new Label(this, SWT.SEPARATOR|SWT.HORIZONTAL);
separator8.setText("");
separator8.setLayoutData(gridData20);
Label filler26=new Label(this, SWT.NONE);
Label filler16210=new Label(this, SWT.NONE);
buttonRefresh=new Button(this, SWT.NONE);
buttonRefresh.setText(Messages.getString("General.1"));
buttonRefresh.setLayoutData(gridData13);
buttonRefresh
.addSelectionListener(new org.eclipse.swt.events.SelectionAdapter()
{
public void widgetSelected(org.eclipse.swt.events.SelectionEvent e)
{
refresh();
}
});
Label filler15190=new Label(this, SWT.NONE);
Label filler16209=new Label(this, SWT.NONE);
buttonTestLabel=new Button(this, SWT.NONE);
buttonTestLabel.setText(Messages.getString("CompositePrinterSettings.19"));
buttonTestLabel.setLayoutData(gridData12);
buttonTestLabel
.addSelectionListener(new org.eclipse.swt.events.SelectionAdapter()
{
public void widgetSelected(org.eclipse.swt.events.SelectionEvent e)
{
PrinterHelper.printSelfTestLabel();
}
});
Label filler15189=new Label(this, SWT.NONE);
Label filler16208=new Label(this, SWT.NONE);
Label filler12=new Label(this, SWT.NONE);
Label filler19=new Label(this, SWT.NONE);
Label filler13=new Label(this, SWT.NONE);
filler14=new Label(this, SWT.NONE);
filler14.setText("");
filler14.setLayoutData(gridData16);
GridLayout gridLayout=new GridLayout();
gridLayout.numColumns=8;
gridLayout.marginWidth=0;
gridLayout.horizontalSpacing=10;
gridLayout.verticalSpacing=3;
gridLayout.marginHeight=5;
this.setLayout(gridLayout);
this.setSize(new Point(526, 480));
this.addPaintListener(new org.eclipse.swt.events.PaintListener()
{
public void paintControl(org.eclipse.swt.events.PaintEvent e)
{
if(connected&&firstPaintSinceConnected&&!dumbTerminal)
{
firstPaintSinceConnected=false;
refresh();
}
}
});
}
private void createComboPrintSpeed()
{
GridData gridData41=new GridData();
gridData41.horizontalAlignment=GridData.FILL;
gridData41.verticalAlignment=GridData.CENTER;
comboPrintSpeed=new Combo(this, SWT.READ_ONLY);
comboPrintSpeed.setLayoutData(gridData41);
comboPrintSpeed
.addSelectionListener(new org.eclipse.swt.events.SelectionListener()
{
public void widgetSelected(org.eclipse.swt.events.SelectionEvent e)
{
if(comboPrintSpeed.getSelectionIndex()==3)
{
buttonPrintSpeed.setEnabled(false);
}
else
{
buttonPrintSpeed.setEnabled(true);
}
}
public void widgetDefaultSelected(
org.eclipse.swt.events.SelectionEvent e)
{
}
});
}
private void createComboDebugReportLevel()
{
GridData gridData40=new GridData();
gridData40.horizontalAlignment=GridData.FILL;
gridData40.verticalAlignment=GridData.CENTER;
comboDebugReportLevel=new Combo(this, SWT.READ_ONLY);
comboDebugReportLevel.setLayoutData(gridData40);
}
private void createComboPitch()
{
GridData gridData39=new GridData();
gridData39.horizontalAlignment=GridData.FILL;
gridData39.verticalAlignment=GridData.CENTER;
comboPitch=new Combo(this, SWT.READ_ONLY);
comboPitch.setLayoutData(gridData39);
}
private void createGroupPrimaryLanguage()
{
GridData gridData71=new GridData();
gridData71.horizontalSpan=2;
gridData71.verticalAlignment=GridData.CENTER;
gridData71.grabExcessHorizontalSpace=true;
gridData71.horizontalAlignment=GridData.BEGINNING;
GridData gridData1=new GridData();
gridData1.horizontalSpan=3;
gridData1.verticalAlignment=GridData.CENTER;
gridData1.horizontalAlignment=GridData.CENTER;
GridLayout gridLayout1=new GridLayout();
gridLayout1.numColumns=3;
gridLayout1.marginWidth=10;
gridLayout1.marginHeight=15;
GridData gridData=new GridData();
gridData.verticalAlignment=GridData.FILL;
gridData.verticalSpan=7;
gridData.horizontalAlignment=GridData.FILL;
groupPrimaryLanguage=new Group(this, SWT.NONE);
groupPrimaryLanguage.setLayoutData(gridData);
groupPrimaryLanguage.setLayout(gridLayout1);
groupPrimaryLanguage.setText(Messages.getString("CompositePrinterSettings.20"));
radioButtonPL_PCL=new Button(groupPrimaryLanguage, SWT.RADIO);
radioButtonPL_PCL.setText("Auto (EcPL/ZcPL)");
radioButtonPL_PCL.setLayoutData(gridData71);
radioButtonPL_PCL.setToolTipText(Messages.getString("CompositePrinterSettings.21"));
radioButtonPL_EPL=new Button(groupPrimaryLanguage, SWT.RADIO);
radioButtonPL_EPL.setText("EcPL");
radioButtonPL_EPL.setToolTipText(Messages.getString("CompositePrinterSettings.22"));
radioButtonPL_ZPL=new Button(groupPrimaryLanguage, SWT.RADIO);
radioButtonPL_ZPL.setText("ZcPL");
radioButtonPL_ZPL.setToolTipText(Messages.getString("CompositePrinterSettings.23"));
Label filler=new Label(groupPrimaryLanguage, SWT.NONE);
radioButtonPL_CPL=new Button(groupPrimaryLanguage, SWT.RADIO);
radioButtonPL_CPL.setText("CPL");
radioButtonPL_CPL.setToolTipText(Messages.getString("CompositePrinterSettings.24"));
Label filler1=new Label(groupPrimaryLanguage, SWT.NONE);
filler51=new Label(groupPrimaryLanguage, SWT.NONE);
filler51.setText("");
Label filler281=new Label(groupPrimaryLanguage, SWT.NONE);
buttonPrimaryLanguage=new Button(groupPrimaryLanguage, SWT.NONE);
buttonPrimaryLanguage.setText(Messages.getString("General.0"));
buttonPrimaryLanguage.setLayoutData(gridData1);
buttonPrimaryLanguage
.addSelectionListener(new org.eclipse.swt.events.SelectionAdapter()
{
public void widgetSelected(org.eclipse.swt.events.SelectionEvent e)
{
applyPrimaryLanguage();
}
});
}
private void createGroupThermalMode()
{
GridData gridData3=new GridData();
gridData3.horizontalAlignment=GridData.CENTER;
gridData3.verticalAlignment=GridData.CENTER;
GridData gridData2=new GridData();
gridData2.grabExcessVerticalSpace=false;
gridData2.horizontalAlignment=GridData.FILL;
gridData2.verticalAlignment=GridData.FILL;
gridData2.verticalSpan=6;
gridData2.grabExcessHorizontalSpace=false;
GridLayout gridLayout2=new GridLayout();
gridLayout2.marginWidth=10;
gridLayout2.marginHeight=15;
groupThermalMode=new Group(this, SWT.NONE);
groupThermalMode.setText(Messages.getString("CompositePrinterSettings.26"));
groupThermalMode.setLayoutData(gridData2);
groupThermalMode.setLayout(gridLayout2);
radioButtonTM_DT=new Button(groupThermalMode, SWT.RADIO);
radioButtonTM_DT.setText(Messages.getString("CompositePrinterSettings.27"));
radioButtonTM_TT=new Button(groupThermalMode, SWT.RADIO);
radioButtonTM_TT.setText(Messages.getString("CompositePrinterSettings.28"));
filler5=new Label(groupThermalMode, SWT.NONE);
filler5.setText("");
buttonTM=new Button(groupThermalMode, SWT.NONE);
buttonTM.setText(Messages.getString("General.0"));
buttonTM.setLayoutData(gridData3);
buttonTM.addSelectionListener(new org.eclipse.swt.events.SelectionAdapter()
{
public void widgetSelected(org.eclipse.swt.events.SelectionEvent e)
{
applyThermalMode();
}
});
}
public void setConnectionState(boolean connected, boolean dumbTerminal)
{
logger=GUIHelper.logger;
logger.trace("");
this.connected=connected;
this.dumbTerminal=dumbTerminal;
firstPaintSinceConnected=true;
GUIHelper.setEnabled(this, connected&&!dumbTerminal);
layout(true, true);
}
private void applyMediaAdjust()
{
GUIHelper.applySimpleTextField(textMediaAdjust, "MEDIA_ADJUST");
}
private void applyNoMediaOut()
{
GUIHelper.applySimpleTextField(textNoMediaOut, "NO_MEDIA");
}
private void applyAuxPower()
{
GUIHelper.applySimpleCheckBox(checkBoxAuxPower, "AUX_POWER");
}
private void applyAutoReprint()
{
GUIHelper.applySimpleCheckBox(checkBoxAutoReprint, "REPRINT");
}
private void refresh()
{
logger.trace("");
GUIHelper.blankify(this);
update();
try
{
hasPCLFirmware();
refreshPrintSpeed();
refreshReportLevel();
refreshPitch();
refreshDateTime();
refreshPrimaryLanguage();
refreshThermalMode();
refreshDarkness();
GUIHelper.refreshSimpleTextField(textNoMediaOut, "NO_MEDIA");
GUIHelper.refreshSimpleCheckBox(checkBoxAuxPower, "AUX_POWER");
GUIHelper.refreshSimpleCheckBox(checkBoxAutoReprint, "REPRINT");
GUIHelper.refreshSimpleTextField(textMediaAdjust, "MEDIA_ADJUST");
}
finally
{
GUIHelper.setCursor(0);
}
}
private void applyReportLevel()
{
int selectedReportLevel=comboDebugReportLevel.getSelectionIndex();
String newReportLevel=null;
switch(selectedReportLevel)
{
case 0:
newReportLevel="0";
break;
case 1:
newReportLevel="1";
break;
case 2:
newReportLevel="2";
break;
default:
GUIHelper.error(Messages.getString("CompositePrinterSettings.35")+selectedReportLevel);
logger.error("Invalid reporting level: "+selectedReportLevel);
return;
}
PrinterHelper.setVariable("REPORT_LEVEL", newReportLevel);
refreshReportLevel();
}
private void refreshReportLevel()
{
comboDebugReportLevel.removeAll();
comboDebugReportLevel.add(Messages.getString("CompositePrinterSettings.32"));
comboDebugReportLevel.add(Messages.getString("CompositePrinterSettings.33"));
comboDebugReportLevel.add(Messages.getString("CompositePrinterSettings.34"));
String reportLevel=null;
reportLevel=PrinterHelper.getVariable("REPORT_LEVEL");
if(reportLevel==null)
{
return;
}
switch(Integer.parseInt(reportLevel))
{
case 0:
comboDebugReportLevel.select(0);
break;
case 1:
comboDebugReportLevel.select(1);
break;
case 2:
comboDebugReportLevel.select(2);
break;
default:
logger.error(Messages.getString("CompositePrinterSettings.43")+reportLevel);
GUIHelper.error("Can't translate debug report level."+reportLevel);
}
}
private void applyPrintSpeed()
{
int selected=comboPrintSpeed.getSelectionIndex();
String newSpeed=null;
switch(selected)
{
case 0:
newSpeed="LOWSPEED";
break;
case 1:
newSpeed="NORMAL";
break;
case 2:
newSpeed="HIGHSPEED";
break;
case 3:
buttonPrintSpeed.setEnabled(false);
break;
default:
GUIHelper.error(Messages.getString("CompositePrinterSettings.48"));
logger.error("Invalid speed selected");
return;
}
PrinterHelper.setVariable("", newSpeed);
refreshPrintSpeed();
}
private void refreshPrintSpeed()
{
logger.trace("");
comboPrintSpeed.removeAll();
comboPrintSpeed.add(Messages.getString("CompositePrinterSettings.45"));
comboPrintSpeed.add(Messages.getString("CompositePrinterSettings.46"));
comboPrintSpeed.add(Messages.getString("CompositePrinterSettings.47"));
comboPrintSpeed.add(Messages.getString("CompositePrinterSettings.49"));
buttonPrintSpeed.setEnabled(true);
String pitch=PrinterHelper.getVariable("PITCH");
modelNumber=com.cognitive.printer.Printer.modelNumber;
boolean isCI=false;
boolean isDLX=false;
if(modelNumber.startsWith("CI")||modelNumber.startsWith("7006"))
{
isCI=true;
}
else if(modelNumber.startsWith("DB")||modelNumber.startsWith("7005"))
{
isDLX=true;
}
String speed="";
if(!hasPCLFirmware)
{
speed=PrinterHelper.getVariable("PRINT_SPEED");
}
else
{
speed="NORMAL";
if(isDLX)
{
speed="HIGHSPEED";
}
}
labelCustomSpeed.setVisible(false);
labelCustomSpeed.setText("("+speed+")");
if(pitch==null||speed==null)
{
return;
}
int iPitch=Integer.parseInt(pitch);
if(speed.equalsIgnoreCase("LOWSPEED"))
{
comboPrintSpeed.select(0);
}
else if(speed.equalsIgnoreCase("NORMAL"))
{
comboPrintSpeed.select(1);
}
else if(speed.equalsIgnoreCase("HIGHSPEED"))
{
comboPrintSpeed.select(2);
}
else
{
int iSpeed=Integer.parseInt(speed);
switch(iPitch)
{
case 200:
case 100:
switch(iSpeed)
{
case 4000:
if(isCI)
{
comboPrintSpeed.select(1);
}
else
{
comboPrintSpeed.select(0);
}
break;
case 2000:
comboPrintSpeed.select(0);
break;
case 3950:
comboPrintSpeed.select(0);
break;
case 6000:
if(isCI)
{
comboPrintSpeed.select(2);
}
else
{
comboPrintSpeed.select(1);
}
break;
case 3000:
comboPrintSpeed.select(1);
break;
case 8000:
case 5000:
comboPrintSpeed.select(2);
break;
default:
comboPrintSpeed.select(3);
labelCustomSpeed.setVisible(true);
buttonPrintSpeed.setEnabled(false);
logger.info("Custom speed received from printer: "+iSpeed);
break;
}
break;
case 300:
case 150:
switch(iSpeed)
{
case 2000:
comboPrintSpeed.select(0);
break;
case 3950:
comboPrintSpeed.select(0);
break;
case 4000:
case 3000:
comboPrintSpeed.select(1);
break;
case 6000:
case 5000:
comboPrintSpeed.select(2);
break;
default:
comboPrintSpeed.select(3);
labelCustomSpeed.setVisible(true);
buttonPrintSpeed.setEnabled(false);
logger.info("Custom speed received from printer: "+iSpeed);
break;
}
break;
default:
GUIHelper.error(Messages.getString("CompositePrinterSettings.61")+iPitch);
logger.error("Invalid pitch received from printer: "+iPitch);
break;
}
}
}
private void applyPitch()
{
PrinterHelper.setVariable("PITCH", comboPitch.getText());
refreshPitch();
}
private void refreshPitch()
{
logger.trace("");
String pitch=null;
pitch=PrinterHelper.getVariable("PITCH");
if(null==pitch)
{
return;
}
comboPitch.removeAll();
if(pitch.equals("300")||pitch.equals("150"))
{
comboPitch.add("150");
comboPitch.add("300");
}
else
{
comboPitch.add("100");
comboPitch.add("200");
}
comboPitch.setText(pitch);
}
private void applyDateTime()
{
String data;
String time=textTime.getText();
if(!time.matches("\\d{1,2}:\\d{1,2}:\\d{1,2}"))
{
GUIHelper.error(Messages.getString("CompositePrinterSettings.62"));
return;
}
DateFormat dateFormat=DateFormat.getDateInstance(3);
Date date=null;
try
{
date=dateFormat.parse(textDate.getText());
}
catch(Exception e)
{
GUIHelper.error(Messages.getString("CompositePrinterSettings.69"));
logger.error(e, e);
return;
}
Calendar calendar=new GregorianCalendar();
calendar.setTime(date);
int year=calendar.get(Calendar.YEAR);
int month=calendar.get(Calendar.MONTH)+1;
int dom=calendar.get(Calendar.DAY_OF_MONTH);
String[] dateParts=textDate.getText().split("/");
String timeParts=time.replaceAll(":", " ");
data="!!0 0 0 0\n!0 0 0 0\nTIME SET "+year+" "+month+" "+dom+" "+timeParts+"\nEND\n";
PrinterHelper.send(data);
refreshDateTime();
}
private void refreshDateTime()
{
logger.trace("");
modelNumber=com.cognitive.printer.Printer.modelNumber;
boolean hasRTC=!(modelNumber.charAt(0)=='D'&&modelNumber.charAt(8)=='8');
labelDate.setEnabled(hasRTC);
textDate.setEnabled(hasRTC);
labelTime.setEnabled(hasRTC);
textTime.setEnabled(hasRTC);
buttonTDRefresh.setEnabled(hasRTC);
buttonTDApply.setEnabled(hasRTC);
if(!hasRTC)
{
return;
}
String[] tokens=null;
String dateTime=PrinterHelper.getVariable("TIME");
if(dateTime==null)
{
return;
}
tokens=dateTime.split(" ");
String time=tokens[2];
textTime.setText(time.trim());
String dateString=tokens[1];
String[] dateParts=dateString.split("/");
int month=Integer.parseInt(dateParts[0])-1;
int date=Integer.parseInt(dateParts[1]);
int year=Integer.parseInt(dateParts[2]);
Calendar calendar=new GregorianCalendar();
calendar.clear();
calendar.setLenient(true);
calendar.set(Calendar.YEAR, year);
calendar.set(Calendar.MONTH, month);
calendar.set(Calendar.DATE, date);
Date d=calendar.getTime();
DateFormat dateFormat=DateFormat.getDateInstance(3);
dateFormat.setCalendar(calendar);
textDate.setText(dateFormat.format(d));
}
private void applyPrimaryLanguage()
{
String language=null;
if(radioButtonPL_PCL.getSelection())
{
if(showAuto)
{
language="AUTO";
}
else
{
language="PCL";
int ret=GUIHelper.message(Messages.getString("CompositePrinterSettings.65"), SWT.OK|SWT.CANCEL|SWT.ICON_INFORMATION);
if(ret==SWT.CANCEL)
{
refreshPrimaryLanguage();
return;
}
}
}
else if(radioButtonPL_EPL.getSelection())
{
language="EPL";
}
else if(radioButtonPL_ZPL.getSelection())
{
language="ZPL";
}
else if(radioButtonPL_CPL.getSelection())
{
language="NONE";
}
else
{
GUIHelper.error(Messages.getString("CompositePrinterSettings.64"));
logger.error("Invalid language selected");
refreshPrimaryLanguage();
return;
}
PrinterHelper.setVariable("LANGUAGE", language);
refreshPrimaryLanguage();
}
private void hasPCLFirmware()
{
currentFirmwarePartNumber=TestEngine.getCurrentFirmwarePartNumber();
if(currentFirmwarePartNumber!=null)
{
hasPCLFirmware=currentFirmwarePartNumber.split("-")[1].equals("176");
}
}
private void setScreenProperties()
{
if(!hasPCLFirmware)
{
showAuto=Integer.parseInt(currentFirmwarePartNumber.split("-")[2])>155;
}
else
{
showAuto=false;
}
if(showAuto)
{
radioButtonPL_PCL.setText("Auto (EcPL/ZcPL)");
radioButtonPL_PCL.setToolTipText("Auto (EcPL/ZcPL)");
}
else
{
radioButtonPL_PCL.setText("TPCL                    ");
radioButtonPL_PCL.setToolTipText(Messages.getString("CompositePrinterSettings.21"));
}
}
private void refreshPrimaryLanguage()
{
setScreenProperties();
radioButtonPL_PCL.setEnabled(hasPCLFirmware||showAuto);
if(hasPCLFirmware)
{
radioButtonPL_EPL.setEnabled(false);
radioButtonPL_ZPL.setEnabled(false);
}
String language=PrinterHelper.getVariable("LANGUAGE");
if(language==null)
{
return;
}
if(language.equals("PCL"))
{
radioButtonPL_PCL.setSelection(true);
radioButtonPL_EPL.setSelection(false);
radioButtonPL_ZPL.setSelection(false);
radioButtonPL_CPL.setSelection(false);
}
else if(language.equals("EPL"))
{
radioButtonPL_PCL.setSelection(false);
radioButtonPL_EPL.setSelection(true);
radioButtonPL_ZPL.setSelection(false);
radioButtonPL_CPL.setSelection(false);
}
else if(language.equals("ZPL"))
{
radioButtonPL_PCL.setSelection(false);
radioButtonPL_EPL.setSelection(false);
radioButtonPL_ZPL.setSelection(true);
radioButtonPL_CPL.setSelection(false);
}
else if(language.equals("AUTO"))
{
radioButtonPL_PCL.setSelection(true);
radioButtonPL_EPL.setSelection(false);
radioButtonPL_ZPL.setSelection(false);
radioButtonPL_CPL.setSelection(false);
}
else
{
radioButtonPL_PCL.setSelection(false);
radioButtonPL_EPL.setSelection(false);
radioButtonPL_ZPL.setSelection(false);
radioButtonPL_CPL.setSelection(true);
}
}
void applyThermalMode()
{
String mode;
if(radioButtonTM_DT.getSelection())
{
mode="DT";
}
else if(radioButtonTM_TT.getSelection())
{
mode="TT";
}
else
{
GUIHelper.error(Messages.getString("CompositePrinterSettings.66"));
logger.error("Invalid mode selected");
refreshThermalMode();
return;
}
PrinterHelper.setVariable("PRINT_MODE", mode);
refreshThermalMode();
}
void refreshThermalMode()
{
String mode=PrinterHelper.getVariable("PRINT_MODE");
if(mode==null)
{
return;
}
if(mode.equals("0"))
{
radioButtonTM_DT.setSelection(true);
radioButtonTM_TT.setSelection(false);
}
else
{
radioButtonTM_DT.setSelection(false);
radioButtonTM_TT.setSelection(true);
}
}
private void createGroupDarkness()
{
GridData gridData25=new GridData();
gridData25.horizontalAlignment=GridData.CENTER;
gridData25.grabExcessHorizontalSpace=true;
gridData25.verticalAlignment=GridData.CENTER;
GridData gridData24=new GridData();
gridData24.horizontalSpan=2;
gridData24.verticalAlignment=GridData.CENTER;
gridData24.grabExcessHorizontalSpace=true;
gridData24.horizontalAlignment=GridData.FILL;
GridData gridData23=new GridData();
gridData23.horizontalSpan=4;
GridData gridData22=new GridData();
gridData22.horizontalAlignment=GridData.CENTER;
gridData22.grabExcessHorizontalSpace=true;
gridData22.verticalAlignment=GridData.CENTER;
GridLayout gridLayout3=new GridLayout();
gridLayout3.numColumns=4;
GridData gridData21=new GridData();
gridData21.verticalAlignment=GridData.CENTER;
gridData21.verticalSpan=3;
gridData21.horizontalAlignment=GridData.CENTER;
groupDarkness=new Group(this, SWT.NONE);
groupDarkness.setLayoutData(gridData21);
groupDarkness.setLayout(gridLayout3);
groupDarkness.setText(Messages.getString("CompositePrinterSettings.67"));
textDarkness=new Text(groupDarkness, SWT.BORDER);
textDarkness.setText("-200");
textDarkness.setLayoutData(gridData24);
filler6=new Label(groupDarkness, SWT.NONE);
filler6.setText("");
filler6.setLayoutData(gridData25);
buttonDarkness=new Button(groupDarkness, SWT.NONE);
buttonDarkness.setText(Messages.getString("General.0"));
buttonDarkness.setLayoutData(gridData22);
textDarkness.addModifyListener(new org.eclipse.swt.events.ModifyListener()
{
public void modifyText(org.eclipse.swt.events.ModifyEvent e)
{
darknessTextModified();
}
});
buttonDarkness
.addSelectionListener(new org.eclipse.swt.events.SelectionAdapter()
{
public void widgetSelected(org.eclipse.swt.events.SelectionEvent e)
{
applyDarkness();
}
});
sliderDarkness=new Slider(groupDarkness, SWT.HORIZONTAL);
sliderDarkness.setMaximum(1023);
sliderDarkness.setMinimum(0);
sliderDarkness.setIncrement(50);
sliderDarkness.setSelection(0);
sliderDarkness.setLayoutData(gridData23);
sliderDarkness
.addSelectionListener(new org.eclipse.swt.events.SelectionAdapter()
{
public void widgetSelected(org.eclipse.swt.events.SelectionEvent e)
{
darknessSliderModified();
}
});
}
private void refreshDarkness()
{
String darkness=PrinterHelper.getVariable("DARKNESS");
textDarkness.setText(darkness);
sliderDarkness.setSelection(Integer.parseInt(darkness)+200);
}
private void applyDarkness()
{
PrinterHelper.setVariable("DARKNESS", textDarkness.getText());
refreshDarkness();
}
private void darknessTextModified()
{
try
{
sliderDarkness.setSelection(Integer.parseInt(textDarkness.getText())+200);
}
catch(NumberFormatException e)
{
sliderDarkness.setSelection(sliderDarkness.getMinimum());
}
}
private void darknessSliderModified()
{
textDarkness.setText(Integer.toString(sliderDarkness.getSelection()-200));
}
}
```
## File: JAdmin/src/com/cognitive/admin/CompositeProfileManagement.java
```java
public class CompositeProfileManagement extends Composite
{
private static boolean hasPCLFirmware=false;
String pathProfiles=null;
private boolean connected=false;
private boolean firstPaintSinceConnected=true;
private boolean dumbTerminal=true;
private Logger logger=null;
private Text textAreaProfile=null;
private Button buttonOpenProfile=null;
private Button buttonGetProfile=null;
private Button buttonSaveProfile=null;
private Button buttonApplyProfile=null;
public CompositeProfileManagement(Composite parent, int style)
{
super(parent, style);
initialize();
}
private void initialize()
{
GridData gridData4=new GridData();
gridData4.horizontalAlignment=GridData.BEGINNING;
gridData4.verticalAlignment=GridData.CENTER;
GridData gridData3=new GridData();
gridData3.horizontalAlignment=GridData.BEGINNING;
gridData3.verticalAlignment=GridData.CENTER;
GridData gridData2=new GridData();
gridData2.horizontalAlignment=GridData.BEGINNING;
gridData2.verticalAlignment=GridData.CENTER;
GridData gridData1=new GridData();
gridData1.horizontalAlignment=GridData.BEGINNING;
gridData1.verticalAlignment=GridData.CENTER;
GridLayout gridLayout=new GridLayout();
gridLayout.numColumns=4;
GridData gridData=new GridData();
gridData.horizontalAlignment=GridData.FILL;
gridData.grabExcessHorizontalSpace=true;
gridData.grabExcessVerticalSpace=true;
gridData.horizontalSpan=4;
gridData.verticalAlignment=GridData.FILL;
textAreaProfile=new Text(this, SWT.MULTI|SWT.WRAP|SWT.V_SCROLL);
textAreaProfile.setLayoutData(gridData);
buttonOpenProfile=new Button(this, SWT.NONE);
buttonOpenProfile.setText(Messages.getString("CompositeProfileManagement.2"));
buttonOpenProfile.setLayoutData(gridData4);
buttonOpenProfile
.addSelectionListener(new org.eclipse.swt.events.SelectionAdapter()
{
public void widgetSelected(org.eclipse.swt.events.SelectionEvent e)
{
openStoredProfile();
}
});
buttonGetProfile=new Button(this, SWT.NONE);
buttonGetProfile.setText(Messages.getString("CompositeProfileManagement.3"));
buttonGetProfile.setLayoutData(gridData3);
buttonGetProfile
.addSelectionListener(new org.eclipse.swt.events.SelectionAdapter()
{
public void widgetSelected(org.eclipse.swt.events.SelectionEvent e)
{
getProfile();
}
});
buttonSaveProfile=new Button(this, SWT.NONE);
buttonSaveProfile.setText(Messages.getString("CompositeProfileManagement.4"));
buttonSaveProfile.setLayoutData(gridData2);
buttonSaveProfile
.addSelectionListener(new org.eclipse.swt.events.SelectionAdapter()
{
public void widgetSelected(org.eclipse.swt.events.SelectionEvent e)
{
saveProfile();
}
});
buttonApplyProfile=new Button(this, SWT.NONE);
buttonApplyProfile.setText(Messages.getString("CompositeProfileManagement.5"));
buttonApplyProfile.setLayoutData(gridData1);
buttonApplyProfile
.addSelectionListener(new org.eclipse.swt.events.SelectionAdapter()
{
public void widgetSelected(org.eclipse.swt.events.SelectionEvent e)
{
applyProfile();
}
});
this.setLayout(gridLayout);
this.setSize(new Point(499, 200));
this.addPaintListener(new org.eclipse.swt.events.PaintListener()
{
public void paintControl(org.eclipse.swt.events.PaintEvent e)
{
if(connected&&firstPaintSinceConnected&&!dumbTerminal)
{
firstPaintSinceConnected=false;
}
}
});
}
public void setConnectionState(boolean connected, boolean dumbTerminal)
{
logger=GUIHelper.logger;
logger.trace("");
this.connected=connected;
this.dumbTerminal=dumbTerminal;
firstPaintSinceConnected=true;
GUIHelper.setEnabled(this, connected&&!dumbTerminal);
}
private void openStoredProfile()
{
logger.trace("");
if(pathProfiles==null)
{
pathProfiles=GUIHelper.prefs.get("PATH_PROFILES", ".");
}
StringBuffer pathUsed=new StringBuffer("");
BufferedReader brd=GUIHelper.openTextFile(pathProfiles, pathUsed);
if(brd==null)
{
return;
}
textAreaProfile.selectAll();
textAreaProfile.clearSelection();
pathProfiles=pathUsed.toString();
GUIHelper.prefs.put("PATH_PROFILES", pathProfiles);
try
{
String line;
while((line=brd.readLine())!=null)
{
textAreaProfile.append(line+'\n');
}
}
catch(IOException e)
{
GUIHelper.message(Messages.getString("CompositeProfileManagement.6"), SWT.OK|SWT.ICON_ERROR);
return;
}
}
private void saveProfile()
{
logger.trace("");
pathProfiles=GUIHelper.saveTextFile(textAreaProfile.getText(), pathProfiles);
}
private void getProfile()
{
String currentFirmwarePartNumber=TestEngine.getCurrentFirmwarePartNumber();
if(currentFirmwarePartNumber!=null)
{
hasPCLFirmware=currentFirmwarePartNumber.split("-")[1].equals("176");
}
String[] varsnormal={
"COMM",
"TXTBFR",
"ETHERNET IP",
"ETHERNET NETMASK",
"ETHERNET GATEWAY",
"ETHERNET LPD",
"ETHERNET DHCP",
"ETHERNET RTEL",
"ETHERNET TXTBFR",
"DARKNESS",
"FEED_TYPE",
"TOF",
"PITCH",
"PRINT_SPEED",
"PRINT_MODE",
"PRESENTLABEL",
"RECALIBRATE",
"WIDTH",
"NO_MEDIA",
"OFF_AFTER",
"AUX_POWER",
"ERROR_LEVEL",
"REPORT_LEVEL",
"SHIFT LEFT",
"REPRINT",
"AUTO_TOF",
"MEDIA_ADJUST",
"LANGUAGE"
};
String[] varspcl={
"COMM",
"TXTBFR",
"ETHERNET IP",
"ETHERNET NETMASK",
"ETHERNET GATEWAY",
"ETHERNET LPD",
"ETHERNET DHCP",
"ETHERNET RTEL",
"ETHERNET TXTBFR",
"DARKNESS",
"FEED_TYPE",
"TOF",
"PITCH",
"PRINT_MODE",
"PRESENTLABEL",
"RECALIBRATE",
"WIDTH",
"NO_MEDIA",
"OFF_AFTER",
"AUX_POWER",
"ERROR_LEVEL",
"REPORT_LEVEL",
"SHIFT LEFT",
"REPRINT",
"AUTO_TOF",
"MEDIA_ADJUST",
"LANGUAGE"
};
String[] vars=varsnormal;
if(hasPCLFirmware)
{
vars=varspcl;
}
textAreaProfile.setText("!!0 0 0 0\n!0 0 0 0\n");
String val;
for(String var : vars)
{
val=PrinterHelper.getVariable(var);
if(val==null)
{
continue;
}
if(var!=null)
{
if(var.equals("COMM"))
{
val=val.replace("OFF", "N");
val=val.replace("ON", "R");
}
else if(var.equals("TXTBFR"))
{
val=val.replace(",", " ");
}
else if(var.equals("ETHERNET IP"))
{
val=val.replace("ADDRESS", "");
}
else if(var.equals("ERROR_LEVEL"))
{
int i=Integer.parseInt(val);
switch(i)
{
case 0:
val="INFO";
break;
case 1:
val="VALIDATION_INFO";
break;
case 2:
val="FEEDBACK";
break;
case 3:
val="PARSE_ERROR";
break;
case 4:
val="RENDER_ERROR";
break;
case 5:
val="SEVERE_ERROR";
break;
default:
val="SEVERE_ERROR";
break;
}
}
else if(var.equals("PRINT_MODE"))
{
if(val.equals("0"))
{
val="DT";
}
else
{
val="TT";
}
}
else if(var.equals("AUX_POWER"))
{
if(val.equals("0"))
{
val="OFF";
}
else
{
val="ON";
}
}
textAreaProfile.append("VARIABLE "+var+" "+val+"\n");
textAreaProfile.update();
}
}
textAreaProfile.append("VARIABLE WRITE\n");
textAreaProfile.append("END\n");
}
private void applyProfile()
{
String profile=textAreaProfile.getText();
PrinterHelper.send(profile);
JAdminDialogMessage dialog=new JAdminDialogMessage(Messages.getString("CompositeProfileManagement.0"));
dialog.setMessage(Messages.getString("CompositeProfileManagement.1"));
dialog.closeAfter(2000);
}
}
```
## File: JAdmin/src/com/cognitive/admin/CompositeRepair.java
```java
public class CompositeRepair extends Composite
{
private boolean connected=false;
private boolean firstPaintSinceConnected=true;
private boolean dumbTerminal=true;
private Logger logger=null;
private Composite compositePrinterID=null;
static Label labelModelNumber=null;
private Label labelSerialNumber=null;
private Label labelMAC=null;
private Label labelModelNumberActual=null;
private Label labelSerialNumberActual=null;
private Label labelMACActual=null;
private Composite compositeButtons=null;
private Button buttonRenewSN_MAC=null;
private Button buttonKtoD=null;
private Button buttonRefresh=null;
public CompositeRepair(Composite parent, int style)
{
super(parent, style);
initialize();
}
private void initialize()
{
GridLayout gridLayout=new GridLayout();
gridLayout.numColumns=1;
gridLayout.verticalSpacing=15;
gridLayout.horizontalSpacing=15;
createCompositePrinterID();
this.setLayout(gridLayout);
createCompositeButtons();
setSize(new Point(606, 200));
this.addPaintListener(new org.eclipse.swt.events.PaintListener()
{
public void paintControl(org.eclipse.swt.events.PaintEvent e)
{
if(connected&&firstPaintSinceConnected&&!dumbTerminal)
{
firstPaintSinceConnected=false;
refresh();
}
}
});
}
public void setConnectionState(boolean connected, boolean dumbTerminal)
{
logger=GUIHelper.logger;
logger.trace("");
this.connected=connected;
this.dumbTerminal=dumbTerminal;
firstPaintSinceConnected=true;
GUIHelper.setEnabled(this, connected&&!dumbTerminal);
}
private void convertKtoD()
{
String serialNumber=GUIHelper.clean(PrinterHelper.commandWaitResponse("!show serialnumber"));
JAdminDialogMessage dialog=new JAdminDialogMessage(Messages.getString("CompositeRepair.3"));
if(serialNumber.charAt(0)=='K')
{
StringBuffer newSerialNumber=new StringBuffer(serialNumber);
newSerialNumber.setCharAt(0, 'D');
PrinterHelper.send("!load serialnumber "+newSerialNumber.toString());
serialNumber=GUIHelper.clean(PrinterHelper.commandWaitResponse("!show serialnumber"));
if(serialNumber.equals(newSerialNumber.toString()))
{
dialog.setMessage(Messages.getString("CompositeRepair.2"));
}
else
{
dialog.setMessage(Messages.getString("CompositeRepair.1"));
}
}
else
{
dialog.setMessage(Messages.getString("CompositeRepair.0"));
}
dialog.closeAfter(2000);
}
private void renewSN_MAC()
{
try
{
GUIHelper.setCursor(SWT.CURSOR_WAIT);
StringBuffer newSerialNumber=new StringBuffer();
StringBuffer newMAC=new StringBuffer();
char locationCode;
if(labelModelNumberActual.getText().equalsIgnoreCase("z060800000"))
{
locationCode=(GUIHelper.prefs.get("MAN_LOCATION_CODE", "-")).charAt(0);
if(locationCode=='-')
{
String msg=Messages.getString("CompositeRepair.4");
GUIHelper.logger.error(msg);
GUIHelper.error(msg);
return;
}
}
else
{
locationCode=labelModelNumberActual.getText().charAt(0);
}
PrinterId printerId=TestEngine.dbCreateNewPrinter(locationCode, labelModelNumberActual.getText(), true);
if(printerId==null)
{
GUIHelper.error(Messages.getString("CompositeRepair.5"));
return;
}
else
{
if(!TestEngine.setSN_MAC(printerId))
{
GUIHelper.error(Messages.getString("CompositeRepair.6"));
return;
}
}
refresh();
}
catch(Exception e)
{
return;
}
finally
{
GUIHelper.setCursor(0);
}
}
private void createCompositePrinterID()
{
GridData gridData3=new GridData();
gridData3.horizontalAlignment=GridData.FILL;
gridData3.grabExcessHorizontalSpace=true;
gridData3.verticalAlignment=GridData.CENTER;
GridData gridData2=new GridData();
gridData2.horizontalAlignment=GridData.FILL;
gridData2.grabExcessHorizontalSpace=true;
gridData2.verticalAlignment=GridData.CENTER;
GridData gridData1=new GridData();
gridData1.horizontalAlignment=GridData.FILL;
gridData1.grabExcessHorizontalSpace=true;
gridData1.verticalAlignment=GridData.CENTER;
GridLayout gridLayout1=new GridLayout();
gridLayout1.numColumns=2;
gridLayout1.verticalSpacing=15;
gridLayout1.horizontalSpacing=15;
GridData gridData=new GridData();
gridData.horizontalAlignment=GridData.FILL;
gridData.grabExcessHorizontalSpace=true;
gridData.grabExcessVerticalSpace=false;
gridData.verticalAlignment=GridData.FILL;
compositePrinterID=new Composite(this, SWT.NONE);
compositePrinterID.setLayoutData(gridData);
compositePrinterID.setLayout(gridLayout1);
labelModelNumber=new Label(compositePrinterID, SWT.NONE);
labelModelNumber.setText(Messages.getString("CompositeRepair.7"));
labelModelNumberActual=new Label(compositePrinterID, SWT.NONE);
labelModelNumberActual.setText("");
labelModelNumberActual.setLayoutData(gridData1);
labelSerialNumber=new Label(compositePrinterID, SWT.NONE);
labelSerialNumber.setText(Messages.getString("CompositeRepair.8"));
labelSerialNumberActual=new Label(compositePrinterID, SWT.NONE);
labelSerialNumberActual.setText("");
labelSerialNumberActual.setLayoutData(gridData2);
labelMAC=new Label(compositePrinterID, SWT.NONE);
labelMAC.setText(Messages.getString("CompositeRepair.9"));
labelMACActual=new Label(compositePrinterID, SWT.NONE);
labelMACActual.setText("");
labelMACActual.setLayoutData(gridData3);
buttonRefresh=new Button(compositePrinterID, SWT.NONE);
buttonRefresh.setText(Messages.getString("General.1"));
buttonRefresh
.addSelectionListener(new org.eclipse.swt.events.SelectionAdapter()
{
public void widgetSelected(org.eclipse.swt.events.SelectionEvent e)
{
refresh();
}
});
}
private void refresh()
{
String serialNumber=GUIHelper.clean(PrinterHelper.commandWaitResponse("!SHOW SERIALNUMBER"));
labelSerialNumberActual.setText(serialNumber);
String mac=GUIHelper.clean(PrinterHelper.commandWaitResponse("!SHOW MAC"));
labelMACActual.setText(mac);
String modelNumber=GUIHelper.clean(PrinterHelper.commandWaitResponse("!SHOW MODELNUMBER"));
labelModelNumberActual.setText(modelNumber);
boolean printerExistsInDb=false;
try
{
printerExistsInDb=TestEngine.checkDB(serialNumber, mac, modelNumber);
}
catch(DBException e)
{
return;
}
if(!printerExistsInDb)
{
GUIHelper.error(Messages.getString("CompositeRepair.11"));
}
}
private void createCompositeButtons()
{
GridLayout gridLayout2=new GridLayout();
gridLayout2.numColumns=2;
GridData gridData4=new GridData();
gridData4.horizontalAlignment=GridData.FILL;
gridData4.grabExcessHorizontalSpace=true;
gridData4.grabExcessVerticalSpace=true;
gridData4.verticalAlignment=GridData.FILL;
compositeButtons=new Composite(this, SWT.NONE);
compositeButtons.setLayoutData(gridData4);
compositeButtons.setLayout(gridLayout2);
buttonRenewSN_MAC=new Button(compositeButtons, SWT.NONE);
buttonRenewSN_MAC.setText(Messages.getString("CompositeRepair.12"));
buttonRenewSN_MAC
.addSelectionListener(new org.eclipse.swt.events.SelectionAdapter()
{
public void widgetSelected(org.eclipse.swt.events.SelectionEvent e)
{
renewSN_MAC();
}
});
buttonKtoD=new Button(compositeButtons, SWT.NONE);
buttonKtoD.setText(Messages.getString("CompositeRepair.13"));
buttonKtoD.addSelectionListener(new org.eclipse.swt.events.SelectionAdapter()
{
public void widgetSelected(org.eclipse.swt.events.SelectionEvent e)
{
convertKtoD();
}
});
}
}
```
## File: JAdmin/src/com/cognitive/admin/Configurator.java
```java
public class Configurator
{
private Properties properties;
private String jAdminHome;
static String brand="Cognitive";
private enum OS
{
WINDOWS,
LINUX,
MAC,
UNKNOWN
}
private OS os;
public Configurator()
{
properties=System.getProperties();
os=getOS();
GUIHelper.loadBrandingProperties();
brand=GUIHelper.brand.getProperty("company.name", "Cognitive").replaceAll("TPG", "").replaceAll(" ", "");
jAdminHome=getAppDir();
configureLogging();
configurePreferences();
}
private OS getOS()
{
String osName=properties.getProperty("os.name");
System.out.println("OS:"+osName);
if(osName.indexOf("Windows")!=-1)
{
return OS.WINDOWS;
}
else if(osName.indexOf("Linux")!=-1)
{
return OS.LINUX;
}
else if(osName.indexOf("Mac")!=-1)
{
return OS.MAC;
}
else
{
return OS.UNKNOWN;
}
}
public void savePrefs()
{
FileOutputStream prefsOutputStream=null;
try
{
prefsOutputStream=new FileOutputStream(jAdminHome+"preferences.xml");
GUIHelper.prefs.exportNode(prefsOutputStream);
}
catch(Exception e)
{
GUIHelper.logger.error(e, e);
}
}
private boolean getOrMakeDir(String path)
{
File dir=null;
try
{
dir=new File(path);
if(dir.exists())
{
File test=new File(path+"/test");
boolean created=false;
try
{
created=test.createNewFile();
if(created)
{
test.delete();
}
}
catch(Exception e)
{
return false;
}
return true;
}
else if(dir.mkdir())
{
return true;
}
else
{
return false;
}
}
catch(Exception e)
{
return false;
}
}
private String getAppDir()
{
String testPath=null;
String publicPath=null;
final String cognitiveDirName=brand+"/";
switch(os)
{
case WINDOWS:
publicPath="C:\\Program Files\\";
break;
case LINUX:
case MAC:
default:
publicPath="/usr/local/";
break;
}
if(publicPath!=null)
{
testPath=publicPath+cognitiveDirName;
if(getOrMakeDir(testPath))
{
return testPath;
}
}
String privatePath=properties.getProperty("user.home")+"/";
testPath=privatePath+cognitiveDirName;
if(getOrMakeDir(testPath))
{
return testPath;
}
return null;
}
public void installDocumentation()
{
GUIHelper.logger.trace("");
if(GUIHelper.prefs.getBoolean("ACTIVATE_MANUFACTURING", false))
{
GUIHelper.logger.debug(Messages.getString("Configurator.0"));
return;
}
GUIHelper.logger.debug(Messages.getString("Configurator.1"));
String packageName="com.cognitive.doc";
String localPath=jAdminHome+"Documentation/";
atLeastOneFileCopied=false;
installJAR(packageName, localPath);
if(atLeastOneFileCopied)
{
GUIHelper.message(Messages.getString("Configurator.2")+localPath, SWT.OK|SWT.ICON_INFORMATION);
atLeastOneFileCopied=false;
installMenuLinks(localPath);
}
}
private void installMenuLinks(String localPath)
{
GUIHelper.logger.trace(localPath);
File dir=new File(localPath);
FilenameFilter filter=new FilenameFilter(){
public boolean accept(File dir, String name)
{
return name.endsWith(".pdf");
}
};
File[] list=dir.listFiles(filter);
URL url=null;
String urlString=null;
try
{
for(File file : list)
{
createShortcut(file);
}
}
catch(Exception e)
{
GUIHelper.logger.error(e, e);
}
}
private void createShortcut(File file)
{
GUIHelper.logger.trace(file.getName());
if(os!=OS.WINDOWS)
{
return;
}
final String userName=(properties.getProperty("user.name")).toLowerCase();
GUIHelper.logger.debug("userName: "+userName);
File dir=new File("C:\\Documents and Settings\\");
FilenameFilter filter=new FilenameFilter(){
public boolean accept(File dir, String name)
{
if(name.toLowerCase().indexOf(userName)==-1)
{
return false;
}
else
{
return true;
}
}
};
String[] userDirs=dir.list(filter);
GUIHelper.logger.debug("Possible user dirs: "+userDirs.length);
GUIHelper.logger.debug("Installing shortcuts for users: "+userDirs);
for(String userDir : userDirs)
{
String shortcutDest="";
if(brand.equalsIgnoreCase("Cognitive"))
{
shortcutDest="C:\\Documents and Settings\\"+userDir+"\\Start Menu\\Programs\\CognitiveTPG Printer Administrator\\";
}
else if(brand.equalsIgnoreCase("TallyDascom"))
{
shortcutDest="C:\\Documents and Settings\\"+userDir+"\\Start Menu\\Programs\\Tally Dascom Printer Administrator\\";
}
else
{
shortcutDest="C:\\Documents and Settings\\"+userDir+"\\Start Menu\\Programs\\"+brand+" Printer Administrator\\";
}
GUIHelper.logger.debug("Shortcut dest: "+shortcutDest);
File destDir=new File(shortcutDest);
if(!destDir.exists())
{
destDir.mkdir();
}
GUIHelper.logger.debug(userName);
GUIHelper.logger.debug(shortcutDest);
String shortcutName=file.getName();
String urlString=null;
File shortcutFile=null;
FileWriter fileWriter=null;
try
{
urlString=((file.toURI()).toURL()).toString();
shortcutFile=new File(shortcutDest+shortcutName+".url");
fileWriter=new FileWriter(shortcutFile);
fileWriter.write("[InternetShortcut]\n");
fileWriter.write("URL="+urlString+"\n");
fileWriter.write("IconIndex=0\n");
fileWriter.write("IconFile=C:\\Program Files\\"+brand+"\\Documentation\\pdf.ico\n");
fileWriter.write("HotKey=0\n");
fileWriter.write("IDList=\n");
fileWriter.write("[{000214A0-0000-0000-C000-000000000046}]\n");
fileWriter.write("Prop3=19,9\n");
fileWriter.close();
}
catch(Exception e)
{
GUIHelper.logger.error(e, e);
return;
}
}
}
public void installFPKTool()
{
GUIHelper.logger.trace("");
if(os!=OS.WINDOWS)
{
return;
}
String packageName="com.cognitive.manufacturing.fpk";
String localPath=jAdminHome+"FPK/";
if(GUIHelper.prefs.getBoolean("ACTIVATE_REPAIR", false)||GUIHelper.prefs.getBoolean("ACTIVATE_MANUFACTURING", false))
{
installJAR(packageName, localPath);
}
}
public void installDrivers()
{
GUIHelper.logger.trace("");
String packageName=null;
String localPath=jAdminHome+"Drivers/";
switch(os)
{
case WINDOWS:
packageName="com.cognitive.windows_drivers";
break;
default:
GUIHelper.logger.trace("No drivers to install for this operating system.");
return;
}
atLeastOneFileCopied=false;
installJAR(packageName, localPath);
if(GUIHelper.prefs.getBoolean("ACTIVATE_MANUFACTURING", false))
{
packageName+="_mfg";
installJAR(packageName, localPath);
}
if(atLeastOneFileCopied)
{
atLeastOneFileCopied=false;
}
}
private boolean atLeastOneFileCopied=false;
private void installJAR(String packageName, String localPath)
{
GUIHelper.logger.trace("");
File localDir=new File(localPath);
if(!localDir.exists())
{
if(!localDir.mkdir())
{
GUIHelper.logger.error("Can't create dir ["+localPath+"]");
return;
}
}
Vector<String>fileNames=null;
fileNames=GUIHelper.getPackageEntries(packageName);
Enumeration<String>e=fileNames.elements();
String fileName=null;
JAdminDialogMessage dialog=new JAdminDialogMessage(Messages.getString("Configurator.4"));
dialog.show();
while(e.hasMoreElements())
{
fileName=(String)e.nextElement();
copyResource(fileName, packageName, localPath, dialog);
}
dialog.close();
return;
}
private URL getConfigFile(String fileName, String localPath, String jarPath)
{
File file=new File(localPath+fileName);
if(file.exists())
{
try
{
return file.toURI().toURL();
}
catch(MalformedURLException e)
{
return null;
}
}
else
{
return copyResource(fileName, jarPath, localPath, null);
}
}
private void configureLogging()
{
try
{
Logger logger=Logger.getRootLogger();
String packageName="com.cognitive.admin";
String fileName="logger.cfg";
URL url=getConfigFile(fileName, jAdminHome, packageName);
if(url!=null)
{
PropertyConfigurator.configure(url);
RollingFileAppender fileAppender=(RollingFileAppender)logger.getAppender("file");
if(fileAppender!=null)
{
fileAppender.setFile(jAdminHome+"/JAdmin.log");
fileAppender.activateOptions();
}
}
else
{
PatternLayout layout=new PatternLayout("%d||%-10t|%-5p|%-7c|%50.50C|%35.35M|%m%n");
if(brand.startsWith("Tally"))
{
layout=new PatternLayout("%d||%-10t|%-5p|%-7c|%35.35M|%m%n");
}
ConsoleAppender consoleAppender=new ConsoleAppender(layout);
logger.addAppender(consoleAppender);
consoleAppender.activateOptions();
RollingFileAppender fileAppender=new RollingFileAppender(layout, jAdminHome+"/JAdmin.log");
logger.addAppender(fileAppender);
fileAppender.activateOptions();
logger.setLevel((Level)Level.ERROR);
}
GUIHelper.logger=Logger.getLogger("ADMIN");
GUIHelper.logger.info("Logger is up.");
}
catch(Exception e)
{
e.printStackTrace();
}
}
private void configurePreferences()
{
GUIHelper.logger.trace("");
try
{
GUIHelper.prefs.removeNode();
}
catch(Exception e)
{
GUIHelper.logger.warn(e, e);
}
String fileName="preferences.xml";
String packageName="com.cognitive.admin";
URL url=getConfigFile(fileName, jAdminHome, packageName);
try
{
if(url!=null)
{
InputStream inputStream=url.openStream();
if(inputStream!=null)
{
Preferences.importPreferences(inputStream);
}
}
}
catch(Exception e)
{
GUIHelper.logger.error(e, e);
}
GUIHelper.prefs=Preferences.systemNodeForPackage(MainShell.class);
fileName="security.xml";
try
{
File xml=new File(jAdminHome+fileName);
if(xml!=null&&!xml.delete())
GUIHelper.logger.warn("Failed to delete and reload \"security.xml\" file in JAdmin home directory.");
}
catch(Exception e)
{
GUIHelper.logger.warn("Failed to delete and reload \"security.xml\" file in JAdmin home directory.");
GUIHelper.logger.error(e, e);
}
url=getConfigFile(fileName, jAdminHome, packageName);
try
{
if(url!=null) SecurityConfig.loadConfigs(jAdminHome+fileName);
}
catch(Exception e)
{
GUIHelper.logger.error(e, e);
}
}
private URL copyResource(String resourceName, String packageName, String localPath, JAdminDialogMessage dialog)
{
String msg="Copying resource: ["+resourceName+"] from ["+packageName+"] to ["+localPath+"].";
logOrPrint(msg, null);
FileOutputStream out=null;
BufferedOutputStream bufferedOut=null;
String resourcePath=packageName.replace('.', '/')+"/";
InputStream inputStream=getClass().getClassLoader().getResourceAsStream(resourcePath+resourceName);
if(inputStream==null)
{
msg="Can't find resource ["+resourcePath+resourceName+"].";
logOrPrint(msg, null);
return null;
}
int resourceSize=-1;
try
{
resourceSize=inputStream.available();
}
catch(IOException e)
{
msg="Unable to get size for resource "+resourceName;
logOrPrint(msg, e);
return null;
}
msg="size of ["+resourceName+"] is "+resourceSize;
logOrPrint(msg, null);
File dest=new File(localPath+resourceName);
if(!dest.exists()||(dest.length()!=resourceSize))
{
msg="Updating/creating "+resourceName;
logOrPrint(msg, null);
if(dialog!=null)
{
dialog.setMessage(resourceName);
GUIHelper.update();
atLeastOneFileCopied=true;
}
try
{
dest.createNewFile();
out=new FileOutputStream(dest);
bufferedOut=new BufferedOutputStream(out);
int c;
while((c=inputStream.read())!=-1)
{
bufferedOut.write(c);
}
inputStream.close();
out.flush();
bufferedOut.flush();
bufferedOut.close();
out.close();
}
catch(Exception e)
{
logOrPrint(e.toString(), e);
if(dest.exists())
{
dest.delete();
}
return null;
}
}
else
{
logOrPrint("Skpping up-to-date "+resourceName, null);
}
try
{
return dest.toURI().toURL();
}
catch(Exception e)
{
return null;
}
}
private void logOrPrint(String msg, Exception e)
{
if(brand.startsWith("Tally"))
{
msg=msg.replace("cognitive", "***");
}
StackTraceElement[] stack=Thread.currentThread().getStackTrace();
StackTraceElement callingFuntion=stack[2];
String callingFuntionName=callingFuntion.getMethodName();
String displayMsg="<FROM "+callingFuntionName+">"+msg;
if(GUIHelper.logger!=null)
{
if(e!=null)
{
GUIHelper.logger.error(displayMsg, e);
}
else
{
GUIHelper.logger.debug(displayMsg);
}
}
else
{
System.out.println(displayMsg);
if(e!=null)
{
e.printStackTrace();
}
}
}
}
```
## File: JAdmin/src/com/cognitive/admin/FirmwareMap.java
```java
public class FirmwareMap
{
public static String LX="195170.408||195170.409";
public static String DLX="195170.408||195170.409";
public static String CI="195170.409";
public static String CXI="195170.409";
public static String PCL="195176.406";
public static String TGPCL="195176.406";
public static String TG="195170.408||195170.409";
public static String WM="195170.408||195170.409";
public static String CG="195170.406||195170.408||195170.409||195170.410";
public static String ME="195170.411";
public static String GT="195170.408||195170.409";
public static String TS="195184.404";
public static String BT="195184.404";
public static String newBT="195186.409";
public static String GWN="195170.408||195170.409";
public static String Resco="195170.331";
public static String HD="195170.408";
public static String SI="195170.328";
public static String olderVersions[]={
"195170.401",
"195170.404"
};
}
```
## File: JAdmin/src/com/cognitive/admin/FirmwareUpdater.java
```java
public class FirmwareUpdater
{
byte[] buff=null;
ProgressBar progressBar=null;
boolean isThroughManufacturing=false;
public FirmwareUpdater(byte[] buff, ProgressBar progressBar)
{
this.buff=buff;
this.progressBar=progressBar;
}
public void updateFirmware(boolean isThroughManufacturing)
{
this.isThroughManufacturing=isThroughManufacturing;
try
{
String val="100";
int currentVersion=0;
String bufferTimedReset=null;
if((isThroughManufacturing&&(!TestEngine.isConnectionTypeParallelOnly))||((!isThroughManufacturing)&&(!CompositeConnectionSettings.isConnectionTypeParallel)))
{
bufferTimedReset=PrinterHelper.setAndGetVariable("BUFFER_TIMED_RESET", val);
if(bufferTimedReset==null)
{
return;
}
if(!bufferTimedReset.equals(val))
{
GUIHelper.logger.warn("Failed setting BUFFER_TIMED_RESET; Staying with "+bufferTimedReset);
}
else
{
GUIHelper.logger.info("BUFFER_TIMED_RESET set to "+bufferTimedReset);
}
String currentFirmware=GUIHelper.clean(PrinterHelper.commandWaitResponse("!QR"));
if(currentFirmware==null)
{
return;
}
String regexPartNumber="\\d{3}-\\d{3}-\\d{3}";
String currentPartNumber=GUIHelper.getMatch(currentFirmware, regexPartNumber);
String regexVersion="\\d{3}$";
currentVersion=Integer.parseInt(GUIHelper.getMatch(currentPartNumber, regexVersion));
}
else
{
PrinterHelper.setVariable("BUFFER_TIMED_RESET", val);
currentVersion=Integer.parseInt(TestEngine.currentVersion);
GUIHelper.logger.info("BUFFER_TIMED_RESET set to "+val);
}
Downloader downloader=new Downloader(buff, currentVersion);
downloader.start();
progressBar.setMinimum(0);
progressBar.setMaximum(100);
int i=0;
while(downloader.isAlive())
{
Thread.sleep(100);
progressBar.setSelection(i%100);
progressBar.update();
GUIHelper.myDisplay.update();
}
val="65534";
if((isThroughManufacturing&&(!TestEngine.isConnectionTypeParallelOnly))||((!isThroughManufacturing)&&(!CompositeConnectionSettings.isConnectionTypeParallel)))
{
if((isThroughManufacturing&&TestEngine.isConnectionTypeSerial)||((!isThroughManufacturing)&&CompositeConnectionSettings.isConnectionTypeSerial))
{
if(!TestEngine.establishSerialConnection(115200, false))
{
TestEngine.establishSerialConnection(9600);
PrinterHelper.setVariable("COMM", "115200,N,8,1,N");
PrinterHelper.printer.waitForResponse(".*115200.*", 10);
TestEngine.establishSerialConnection(115200);
}
}
bufferTimedReset=PrinterHelper.setAndGetVariable("BUFFER_TIMED_RESET", val);
if(bufferTimedReset==null)
{
return;
}
if(!bufferTimedReset.equals(val))
{
GUIHelper.logger.warn("Failed setting BUFFER_TIMED_RESET; Staying with "+bufferTimedReset);
}
else
{
GUIHelper.logger.info("BUFFER_TIMED_RESET set to "+bufferTimedReset);
}
}
else
{
PrinterHelper.setVariable("BUFFER_TIMED_RESET", val);
GUIHelper.logger.info("BUFFER_TIMED_RESET set to "+val);
}
}
catch(Exception e)
{
GUIHelper.error(Messages.getString("FirmwareUpdater.0")+e.toString()+Messages.getString("FirmwareUpdater.1"));
GUIHelper.logger.error("Caught an exception: ", e);
try
{
PrinterHelper.printer.closeConnection();
GUIHelper.mainShell.setConnectionState(false, false);
}
catch(Exception e2)
{
GUIHelper.logger.error(e, e);
}
return;
}
}
class Downloader extends Thread
{
IPrinterConnection conn=null;
byte[] buff;
int currentVersion;
boolean persistentConnection=false;
public Downloader(byte[] buff, int currentVersion)
{
GUIHelper.logger.trace("");
conn=PrinterHelper.printer.getConnection();
switch(conn.getType())
{
case OS_PRINTER:
case SERIAL:
persistentConnection=true;
break;
default:
persistentConnection=false;
break;
}
this.setName("Downloader");
this.buff=buff;
this.currentVersion=currentVersion;
GUIHelper.setCursor(SWT.CURSOR_WAIT);
}
private void disconnect()
{
try
{
PrinterHelper.printer.closeConnection();
GUIHelper.mainShell.setConnectionState(false, false);
}
catch(Exception e)
{
}
}
private void reconnect()
{
disconnect();
int i=0;
boolean connected=false;
while(!connected&&(i++<15))
{
try
{
Thread.sleep(5000);
}
catch(Exception e)
{
GUIHelper.logger.warn(e, e);
}
GUIHelper.logger.debug("Trying to establish connection...");
try
{
PrinterHelper.printer.openConnection(conn);
connected=PrinterHelper.printer.isConnected();
}
catch(Exception e)
{
GUIHelper.logger.debug(e, e);
connected=false;
}
}
}
public void run()
{
try
{
PrinterHelper.printer.send(buff);
if((isThroughManufacturing&&(!TestEngine.isConnectionTypeParallelOnly))||((!isThroughManufacturing)&&(!CompositeConnectionSettings.isConnectionTypeParallel)))
{
PrinterHelper.printer.waitFor(".*Success.*", 180);
PrinterHelper.printer.waitFor(PrinterHelper.GENERAL_PRINTER_READY, 3);
if(currentVersion<100)
{
GUIHelper.logger.info("Sending Ethernet Reset to reboot for original firmware version "+currentVersion);
PrinterHelper.printer.setVariable("ETHERNET", "RESET");
}
if(!persistentConnection)
{
reconnect();
}
PrinterHelper.printer.waitFor(PrinterHelper.GENERAL_PRINTER_READY, 30);
try
{
GUIHelper.logger.info("Waiting for another 30 seconds for the printer to be actually ready");
Thread.sleep(30000);
}
catch(Exception e)
{
GUIHelper.logger.warn(e, e);
}
}
}
catch(Exception e)
{
GUIHelper.logger.error(e, e);
GUIHelper.myDisplay.syncExec(new Runnable()
{
public void run()
{
GUIHelper.error(Messages.getString("FirmwareUpdater.2"));
}
});
return;
}
}
}
}
```
## File: JAdmin/src/com/cognitive/admin/FontMap.java
```java
public class FontMap
{
public static String[] general200dpi={
"8859-1.map",
"8859-2.map",
"8859-5.map",
"8859-7.map",
"8859-9.map",
"8859-15.map",
"CP437.map",
"CP737.map",
"CP850.map",
"CP852.map",
"CP855.map",
"CP857.map",
"CP860.map",
"CP861.map",
"CP863.map",
"CP865.map",
"CP866.map",
"CP869.map",
"CP1250.map",
"CP1251.map",
"CP1252.map",
"CP1253.map",
"CP1254.map",
"ItalianKBMap.map",
"RussianKBMap.map",
"SpanishKBMap.map",
"19021001uffonta.chr",
"19021001uffontd.chr",
"19021101uffontb.chr",
"F3x5.chr",
"F5x7ex.chr",
"F8x8ex.chr",
"F9x12ex.chr",
"F12x16ex.chr",
"F18x23ex.chr",
"F24x31ex.chr",
"tri06_U.chr",
"tri08_U.chr",
"tri10_U.chr",
"tri16_U.chr",
"tri24_U.chr",
"tri36_U.chr",
"tri48_U.chr",
"EPL1_200.chr",
"EPL2_200.chr",
"EPL3_200.chr",
"EPL4_200.chr",
"EPL5_200.chr",
"ZPLA.chr",
"ZPLB.chr",
"ZPLD.chr",
"ZPLE_200.chr",
"ZPLF.chr",
"ZPLG.chr",
"ZPLH_200.chr",
"ZPLP.chr",
"ZPLQ.chr",
"ZPLR.chr",
"ZPLS.chr",
"ZPLT.chr",
"ZPLU.chr",
"ZPLV.chr",
"ZPL0.chr",
"19010201.fnt",
"19010301.fnt",
"19010401.fnt",
"ocrb16.chr",
"ocrb18.chr",
"ocrb24.chr",
"shftj16.chr",
"shftj24.chr",
"shftjis.chr"
};
public static String[] general300dpi={
"8859-1.map",
"8859-2.map",
"8859-5.map",
"8859-7.map",
"8859-9.map",
"8859-15.map",
"CP437.map",
"CP737.map",
"CP850.map",
"CP852.map",
"CP855.map",
"CP857.map",
"CP860.map",
"CP861.map",
"CP863.map",
"CP865.map",
"CP866.map",
"CP869.map",
"CP1250.map",
"CP1251.map",
"CP1252.map",
"CP1253.map",
"CP1254.map",
"ItalianKBMap.map",
"RussianKBMap.map",
"SpanishKBMap.map",
"19021001uffonta.chr",
"19021001uffontd.chr",
"19021101uffontb.chr",
"F3x5.chr",
"F5x7ex.chr",
"F8x8ex.chr",
"F9x12ex.chr",
"F12x16ex.chr",
"F18x23ex.chr",
"F24x31ex.chr",
"tri06_U_300.chr",
"tri08_U_300.chr",
"tri10_U_300.chr",
"tri16_U_300.chr",
"tri24_U_300.chr",
"tri36_U_300.chr",
"tri48_U_300.chr",
"EPL1_300.chr",
"EPL2_300.chr",
"EPL3_300.chr",
"EPL4_300.chr",
"EPL5_300.chr",
"ZPLA.chr",
"ZPLB.chr",
"ZPLD.chr",
"ZPLE_300.chr",
"ZPLF.chr",
"ZPLG.chr",
"ZPLH_300.chr",
"ZPLP.chr",
"ZPLQ.chr",
"ZPLR.chr",
"ZPLS.chr",
"ZPLT.chr",
"ZPLU.chr",
"ZPLV.chr",
"ZPL0.chr",
"19010201.fnt",
"19010301.fnt",
"19010401.fnt",
"ocrb16.chr",
"ocrb18.chr",
"ocrb24.chr",
"shftj16.chr",
"shftj24.chr",
"shftjis.chr"
};
public static String[] wingman200dpi={
"8859-1.map",
"8859-2.map",
"8859-5.map",
"8859-7.map",
"8859-9.map",
"8859-15.map",
"CP437.map",
"CP737.map",
"CP850.map",
"CP852.map",
"CP855.map",
"CP857.map",
"CP860.map",
"CP861.map",
"CP863.map",
"CP865.map",
"CP866.map",
"CP869.map",
"CP1250.map",
"CP1251.map",
"CP1252.map",
"CP1253.map",
"CP1254.map",
"ItalianKBMap.map",
"RussianKBMap.map",
"SpanishKBMap.map",
"19021001uffonta.chr",
"19021001uffontd.chr",
"19021101uffontb.chr",
"EPL1_200.chr",
"EPL2_200.chr",
"EPL3_200.chr",
"EPL4_200.chr",
"EPL5_200.chr",
"ZPLA.chr",
"ZPLB.chr",
"ZPLD.chr",
"ZPLE_200.chr",
"ZPLF.chr",
"ZPLG.chr",
"ZPLH_200.chr",
"ZPLP.chr",
"ZPLQ.chr",
"ZPLR.chr",
"ZPLS.chr",
"ZPLT.chr",
"ZPLU.chr",
"ZPLV.chr",
"ZPL0.chr"
};
public static String[] wingman300dpi={
"8859-1.map",
"8859-2.map",
"8859-5.map",
"8859-7.map",
"8859-9.map",
"8859-15.map",
"CP437.map",
"CP737.map",
"CP850.map",
"CP852.map",
"CP855.map",
"CP857.map",
"CP860.map",
"CP861.map",
"CP863.map",
"CP865.map",
"CP866.map",
"CP869.map",
"CP1250.map",
"CP1251.map",
"CP1252.map",
"CP1253.map",
"CP1254.map",
"ItalianKBMap.map",
"RussianKBMap.map",
"SpanishKBMap.map",
"19021001uffonta.chr",
"19021001uffontd.chr",
"19021101uffontb.chr",
"EPL1_300.chr",
"EPL2_300.chr",
"EPL3_300.chr",
"EPL4_300.chr",
"EPL5_300.chr",
"ZPLA.chr",
"ZPLB.chr",
"ZPLD.chr",
"ZPLE_300.chr",
"ZPLF.chr",
"ZPLG.chr",
"ZPLH_300.chr",
"ZPLP.chr",
"ZPLQ.chr",
"ZPLR.chr",
"ZPLS.chr",
"ZPLT.chr",
"ZPLU.chr",
"ZPLV.chr",
"ZPL0.chr"
};
public static String[] pcl={
"8859-1.map",
"8859-2.map",
"8859-5.map",
"8859-7.map",
"8859-9.map",
"8859-15.map",
"CP437.map",
"CP737.map",
"CP850.map",
"CP852.map",
"CP855.map",
"CP857.map",
"CP860.map",
"CP861.map",
"CP863.map",
"CP865.map",
"CP866.map",
"CP869.map",
"CP1250.map",
"CP1251.map",
"CP1252.map",
"CP1253.map",
"CP1254.map",
"ItalianKBMap.map",
"RussianKBMap.map",
"SpanishKBMap.map",
"19021001uffonta.chr",
"19021001uffontd.chr",
"19021101uffontb.chr",
"F3x5.chr",
"F5x7ex.chr",
"F8x8ex.chr",
"F9x12ex.chr",
"F12x16ex.chr",
"F18x23ex.chr",
"F24x31ex.chr",
"tri06_U_300.chr",
"tri08_U_300.chr",
"tri10_U_300.chr",
"tri16_U_300.chr",
"tri24_U_300.chr",
"tri36_U_300.chr",
"tri48_U_300.chr",
"19010201.fnt",
"19010301.fnt",
"19010401.fnt",
"ocrb16.chr",
"ocrb18.chr",
"ocrb24.chr",
"shftj16.chr",
"shftj24.chr",
"shftjis.chr"
};
public static String[] asianfonts={
"19010201.fnt",
"19010301.fnt",
"19010401.fnt",
"ocrb16.chr",
"ocrb18.chr",
"ocrb24.chr",
"shftj16.chr",
"shftj24.chr",
"shftjis.chr"
};
public static String[] lx200dpi={
"19021001uffonta.chr",
"19021001uffontd.chr",
"19021101uffontb.chr",
"F3x5.chr",
"F5x7ex.chr",
"F8x8ex.chr",
"F9x12ex.chr",
"F12x16ex.chr",
"F18x23ex.chr",
"F24x31ex.chr",
"Tri06.chr",
"Tri08.chr",
"Tri10.chr",
"Tri16.chr",
"Tri24.chr",
"Tri36.chr",
"Tri48.chr",
"19010201.fnt",
"19010301.fnt",
"19010401.fnt",
"ocrb16.chr",
"ocrb18.chr",
"ocrb24.chr",
"shftj16.chr",
"shftj24.chr",
"shftjis.chr"
};
public static String[] lx300dpi={
"19021001uffonta.chr",
"19021001uffontd.chr",
"19021101uffontb.chr",
"F3x5.chr",
"F5x7ex.chr",
"F8x8ex.chr",
"F9x12ex.chr",
"F12x16ex.chr",
"F18x23ex.chr",
"F24x31ex.chr",
"Tri06CG_3.chr",
"Tri08CG_3.chr",
"Tri10CG_3.chr",
"Tri16CG_3.chr",
"Tri24CG_3.chr",
"Tri36CG_3.chr",
"Tri48CG_3.chr",
"19010201.fnt",
"19010301.fnt",
"19010401.fnt",
"ocrb16.chr",
"ocrb18.chr",
"ocrb24.chr",
"shftj16.chr",
"shftj24.chr",
"shftjis.chr"
};
public static String[] only200dpi={
"tri06_U.chr",
"tri08_U.chr",
"tri10_U.chr",
"tri16_U.chr",
"tri24_U.chr",
"tri36_U.chr",
"tri48_U.chr",
"EPL1_200.chr",
"EPL2_200.chr",
"EPL3_200.chr",
"EPL4_200.chr",
"EPL5_200.chr",
"ZPLE_200.chr",
"ZPLH_200.chr"
};
public static String[] only300dpi={
"tri06_U_300.chr",
"tri08_U_300.chr",
"tri10_U_300.chr",
"tri16_U_300.chr",
"tri24_U_300.chr",
"tri36_U_300.chr",
"tri48_U_300.chr",
"EPL1_300.chr",
"EPL2_300.chr",
"EPL3_300.chr",
"EPL4_300.chr",
"EPL5_300.chr",
"ZPLE_300.chr",
"ZPLH_300.chr"
};
public static String[] nonpcl={
"EPL1_300.chr",
"EPL2_300.chr",
"EPL3_300.chr",
"EPL4_300.chr",
"EPL5_300.chr",
"ZPLA.chr",
"ZPLB.chr",
"ZPLD.chr",
"ZPLE_300.chr",
"ZPLF.chr",
"ZPLG.chr",
"ZPLH_300.chr",
"ZPLP.chr",
"ZPLQ.chr",
"ZPLR.chr",
"ZPLS.chr",
"ZPLT.chr",
"ZPLU.chr",
"ZPLV.chr",
"ZPL0.chr"
};
public static String[] resco={
"8859-1.map",
"8859-2.map",
"8859-5.map",
"8859-7.map",
"8859-9.map",
"8859-15.map",
"CP437.map",
"CP737.map",
"CP850.map",
"CP852.map",
"CP855.map",
"CP857.map",
"CP860.map",
"CP861.map",
"CP863.map",
"CP865.map",
"CP866.map",
"CP869.map",
"CP1250.map",
"CP1251.map",
"CP1252.map",
"CP1253.map",
"CP1254.map",
"ItalianKBMap.map",
"RussianKBMap.map",
"SpanishKBMap.map",
"19021001uffonta.chr",
"19021001uffontd.chr",
"19021101uffontb.chr",
"F3x5.chr",
"F5x7ex.chr",
"F8x8ex.chr",
"F9x12ex.chr",
"F12x16ex.chr",
"F18x23ex.chr",
"F24x31ex.chr",
"Tri06.chr",
"Tri08.chr",
"Tri10.chr",
"Tri16.chr",
"Tri24.chr",
"Tri36.chr",
"Tri48.chr",
"EPL1_200.chr",
"EPL2_200.chr",
"EPL3_200.chr",
"EPL4_200.chr",
"EPL5_200.chr",
"ZPLA.chr",
"ZPLB.chr",
"ZPLD.chr",
"ZPLE_200.chr",
"ZPLF.chr",
"ZPLG.chr",
"ZPLH_200.chr",
"ZPLP.chr",
"ZPLQ.chr",
"ZPLR.chr",
"ZPLS.chr",
"ZPLT.chr",
"ZPLU.chr",
"ZPLV.chr",
"ZPL0.chr"
};
public static String[] security={
"19021001uffonta.chr",
"19021001uffontd.chr",
"19021101uffontb.chr",
"F3x5.chr",
"F5x7ex.chr",
"F8x8ex.chr",
"F9x12ex.chr",
"F12x16ex.chr",
"F18x23ex.chr",
"F24x31ex.chr",
"tri06_U_300.chr",
"tri08_U_300.chr",
"tri10_U_300.chr",
"tri16_U_300.chr",
"tri24_U_300.chr",
"tri36_U_300.chr",
"tri48_U_300.chr"
};
}
```
## File: JAdmin/src/com/cognitive/admin/GUIHelper.java
```java
public class GUIHelper
{
public static Shell myShell=null;
public static Display myDisplay=null;
public static Logger logger=null;
public static MainShell mainShell=null;
public static Preferences prefs=Preferences.systemNodeForPackage(MainShell.class);
public static Properties brand=null;
public enum LocationCode
{
A,
B,
C,
D,
E,
G,
J,
M,
N,
T,
V,
DocuShield
}
static private boolean isComposite(Object o)
{
Class<?>subclass=o.getClass();
Class<?>superclass=subclass.getSuperclass();
while(superclass!=null)
{
String className=superclass.getName();
if(className.equals("org.eclipse.swt.widgets.Composite"))
{
return true;
}
subclass=superclass;
superclass=subclass.getSuperclass();
}
return false;
}
public static void update()
{
myDisplay.syncExec(new Runnable()
{
public void run()
{
myDisplay.readAndDispatch();
myDisplay.update();
}
});
}
public static void setEnabled(Composite composite, boolean enabled)
{
composite.setEnabled(enabled);
Control[] children=composite.getChildren();
if(children==null)
{
return;
}
for(Control c : children)
{
if(isComposite(c))
{
setEnabled((Composite)c, enabled);
}
else
{
c.setEnabled(enabled);
}
}
}
public static void blankify(Composite composite)
{
Control[] children=composite.getChildren();
if(children==null)
{
return;
}
for(Control c : children)
{
if(isComposite(c))
{
blankify((Composite)c);
}
else
{
String className=c.getClass().getName();
if(className.equals("org.eclipse.swt.widgets.Text"))
{
Text w=(Text)c;
w.setText("");
}
else if(className.equals("org.eclipse.swt.widgets.Button"))
{
Button w=(Button)c;
w.setSelection(false);
}
else if(className.equals("org.eclipse.swt.widgets.Combo"))
{
Combo w=(Combo)c;
w.select(-1);
}
}
}
}
public static boolean booleanFromString(String onOff)
{
if(onOff==null)
{
return false;
}
if(onOff.startsWith("ON")||onOff.startsWith("1")||onOff.startsWith("YES"))
{
return true;
}
else
{
return false;
}
}
public static String stringFromBoolean(boolean bool)
{
if(bool)
{
return "ON";
}
else
{
return "OFF";
}
}
public static void setCursor(int cursorType)
{
Cursor cursor=myDisplay.getSystemCursor(cursorType);
myShell.setCursor(cursor);
}
public static void error(String msg)
{
message(msg, SWT.OK|SWT.ICON_ERROR);
}
public static void info(String msg)
{
message(msg, SWT.OK|SWT.ICON_INFORMATION);
}
public static int message(String message, int options)
{
MessageBox messageBox=new MessageBox(myShell, options);
messageBox.setMessage(message);
int retVal=messageBox.open();
myDisplay.update();
return retVal;
}
public static void applySimpleTextField(Text text, String variable)
{
logger.trace("");
try
{
setCursor(SWT.CURSOR_WAIT);
text.setText(PrinterHelper.printer.setAndGetVariable(variable, text.getText()));
}
catch(SocketException e)
{
PrinterHelper.handleSocketException(e);
}
catch(Exception e)
{
error(Messages.getString("GUIHelper.0")+variable+"].");
logger.error("Caught an exception on set-and-get ["+variable+"]: ", e);
return;
}
finally
{
setCursor(0);
}
}
public static void refreshSimpleTextField(Text text, String variable)
{
logger.trace("");
try
{
setCursor(SWT.CURSOR_WAIT);
text.setText(PrinterHelper.printer.getVariable(variable));
}
catch(SocketException e)
{
PrinterHelper.handleSocketException(e);
}
catch(Exception e)
{
error(Messages.getString("GUIHelper.1")+variable+"].");
logger.error("Caught an exception: ", e);
return;
}
finally
{
setCursor(0);
}
}
public static void applySimpleCheckBox(Button checkBox, String variable)
{
logger.trace("");
try
{
setCursor(SWT.CURSOR_WAIT);
String newVal;
if(checkBox.getSelection())
{
newVal="ON";
}
else
{
newVal="OFF";
}
PrinterHelper.setVariable(variable, newVal);
refreshSimpleCheckBox(checkBox, variable);
}
catch(Exception e)
{
error(Messages.getString("GUIHelper.2")+variable+"].");
logger.error(e, e);
return;
}
finally
{
setCursor(0);
}
}
public static void refreshSimpleCheckBox(Button checkBox, String variable)
{
logger.trace("");
try
{
setCursor(SWT.CURSOR_WAIT);
checkBox.setSelection(GUIHelper.booleanFromString((PrinterHelper.printer.getVariable(variable))));
}
catch(SocketException e)
{
PrinterHelper.handleSocketException(e);
}
catch(Exception e)
{
error(Messages.getString("GUIHelper.1")+variable+"].");
logger.error(e, e);
return;
}
finally
{
setCursor(0);
}
}
public static BufferedReader openTextFile(String path, StringBuffer pathUsed)
{
logger.trace("");
FileDialog fd=new FileDialog(myShell, SWT.OPEN);
fd.setFilterPath(path);
String fileName=fd.open();
if(fileName==null)
{
return null;
}
FileReader frd=null;
try
{
frd=new FileReader(fileName);
}
catch(FileNotFoundException e)
{
logger.warn("File not found: "+fileName);
error(Messages.getString("GUIHelper.4"));
return null;
}
BufferedReader brd=new BufferedReader(frd);
pathUsed.append(fd.getFilterPath());
return brd;
}
public static byte[] readBinaryFile(String fileName) throws Exception
{
logger.trace("");
File f=new File(fileName);
FileInputStream fis=new FileInputStream(f);
DataInputStream dis=new DataInputStream(fis);
byte[] b=new byte[(int)f.length()];
dis.readFully(b);
dis.close();
fis.close();
return b;
}
public static byte[] readBinaryFile(InputStream inputStream) throws Exception
{
logger.trace("");
int size=inputStream.available();
byte buff[]=new byte[size];
int c=-1;
int bytesRead=0;
while((c=inputStream.read())!=-1)
{
buff[bytesRead++]=(byte)c;
}
GUIHelper.logger.debug("inputStream size: "+size);
GUIHelper.logger.debug("bytes read: "+bytesRead);
return buff;
}
public static String saveTextFile(String text, String path)
{
logger.trace("");
FileDialog fd=new FileDialog(myShell, SWT.SAVE);
fd.setFilterPath(path);
String fileName=fd.open();
if(fileName==null)
{
return path;
}
FileWriter fwt=null;
try
{
fwt=new FileWriter(fileName);
}
catch(IOException e)
{
logger.error(e, e);
error(Messages.getString("GUIHelper.5"));
return path;
}
BufferedWriter bwt=new BufferedWriter(fwt);
try
{
bwt.write(text);
bwt.flush();
bwt.close();
fwt.close();
}
catch(Exception e)
{
error(Messages.getString("GUIHelper.6"));
logger.error(e, e);
return path;
}
return fd.getFilterPath();
}
static public String getMatch(String input, String regex)
{
String content=null;
try
{
Pattern pattern=Pattern.compile(regex);
Matcher matcher=pattern.matcher(input);
if(matcher.find())
{
content=matcher.group();
}
else
{
content="";
}
}
catch(Exception e)
{
GUIHelper.logger.error(e, e);
content="";
}
return content;
}
static byte[] getResourceAsByteArray(String resourceName)
{
InputStream inputStream=myShell.getClass().getClassLoader().getResourceAsStream(resourceName);
if(inputStream==null)
{
logger.error("Can't find resource: "+resourceName);
return null;
}
byte buff[]=null;
try
{
buff=GUIHelper.readBinaryFile(inputStream);
}
catch(Exception e)
{
logger.error(e, e);
return null;
}
return buff;
}
static char calculateCRC(byte c, char calc_crc)
{
char crc_tbl1[]={0x0000, 0xcc01, 0xd801, 0x1400,
0xf001, 0x3c00, 0x2800, 0xe401,
0xa001, 0x6c00, 0x7800, 0xb401,
0x5000, 0x9c01, 0x8801, 0x4400};
char crc_tbl2[]={0x0000, 0xc0c1, 0xc181, 0x0140,
0xc301, 0x03c0, 0x0280, 0xc241,
0xc601, 0x06c0, 0x0780, 0xc741,
0x0500, 0xc5c1, 0xc481, 0x0440};
char tbl1_idx;
char tbl2_idx;
tbl2_idx=(char)((c ^ calc_crc)&0x0f);
tbl1_idx=(char)(((c ^ calc_crc)&0xf0)>>4);
calc_crc=(char)(((calc_crc>>8)&0x00ff) ^ crc_tbl1[tbl1_idx] ^ crc_tbl2[tbl2_idx]);
return calc_crc;
}
static String getCRC(String resourceName)
{
InputStream inputStream=myShell.getClass().getClassLoader().getResourceAsStream(resourceName);
if(inputStream==null)
{
System.out.println("Can't find resource: "+resourceName);
return null;
}
String hex=null;
try
{
int size=inputStream.available();
int c=-1;
int bytesRead=0;
char crc=0;
int ctr=0;
while((c=inputStream.read())!=-1)
{
bytesRead=bytesRead+1;
if(!((bytesRead<23)||(bytesRead>60&&bytesRead<67)||(bytesRead>(size-2))))
{
ctr++;
crc=calculateCRC((byte)c, crc);
}
}
hex=Integer.toHexString(crc);
inputStream.close();
}
catch(Exception e)
{
logger.error(e, e);
return null;
}
return hex;
}
static void loadBrandingProperties()
{
brand=new Properties();
try
{
brand.load(MainShell.class.getClassLoader().getResourceAsStream("com/cognitive/brand/brand.properties"));
}
catch(IOException e)
{
brand.setProperty("company.name", "CognitiveTPG");
brand.setProperty("company.logo", "MainLogo.gif");
brand.setProperty("company.printerImage", "LabelPositioningImage.jpg");
}
}
static InputStream getManifestForClass(Class<?>theClass)
{
String classResName=theClass.getName().replace('.', '/')+".class";
GUIHelper.logger.trace(classResName);
URL urlToClass=theClass.getClassLoader().getResource(classResName);
String strUrl=urlToClass.toString();
int index=strUrl.lastIndexOf('!');
if(index==-1)
{
GUIHelper.logger.debug("Class wasn't loaded from a JAR file.");
return null;
}
String strUrlBase=strUrl.substring(0, index+1);
URL urlToManifest=null;
try
{
urlToManifest=new URL(strUrlBase+"/META-INF/MANIFEST.MF");
}
catch(MalformedURLException mue)
{
return null;
}
try
{
GUIHelper.logger.debug("Manifest: "+urlToManifest.toString());
return urlToManifest.openStream();
}
catch(IOException e)
{
GUIHelper.logger.debug("Manifest: "+urlToManifest.toString());
return null;
}
}
static Vector<String>getPackageEntries(String packageName)
{
String logPackageName=packageName;
if(brand.getProperty("company.name", "CognitiveTPG").startsWith("Tally"))
{
logPackageName=logPackageName.replace("cognitive", "***");
}
logger.trace(logPackageName);
Vector<String>fileNames=new Vector<String>();
Class<?>theClass=null;
try
{
theClass=Class.forName(packageName+".MarkerClass");
}
catch(ClassNotFoundException e)
{
GUIHelper.logger.error("Can't find marker class for "+logPackageName);
return fileNames;
}
InputStream is=getManifestForClass(theClass);
if(is==null)
{
GUIHelper.logger.error("Can't find manifest for ["+theClass.getName()+"].");
return fileNames;
}
InputStreamReader ir=new InputStreamReader(is);
if(ir==null)
{
GUIHelper.logger.error("Can't create InputStreamReader.");
return fileNames;
}
BufferedReader br=new BufferedReader(ir);
if(br==null)
{
GUIHelper.logger.error("Can't create BufferedReader.");
return fileNames;
}
try
{
String line=br.readLine();
String fileName=null;
int nameStartsHere=-1;
while(line!=null)
{
if(line.indexOf("Name: ")!=-1&&line.indexOf("MarkerClass")==-1)
{
fileName=line.substring(line.lastIndexOf('/')+1);
fileNames.add(fileName);
GUIHelper.logger.debug("Adding: "+fileName);
}
line=br.readLine();
}
}
catch(Exception e)
{
GUIHelper.logger.error(e, e);
}
return fileNames;
}
static public String clean(String str)
{
if(str==null)
{
return null;
}
str=str.replace('\n', ' ');
str=str.replace('\r', ' ');
str=str.trim();
return str;
}
static private String getStorage(String storage)
{
int iStorage=Integer.parseInt(storage);
switch(iStorage)
{
case 0:
return "RAM";
case 3:
return "Flash";
default:
return storage.trim();
}
}
static public String compressedBitmapFont=Messages.getString("GUIHelper.7");
static private String getType(String type)
{
int iType=Integer.parseInt(type);
switch(iType)
{
case 0:
return Messages.getString("GUIHelper.8");
case 1:
return Messages.getString("GUIHelper.9");
case 2:
return Messages.getString("GUIHelper.10");
case 3:
return Messages.getString("GUIHelper.11");
case 4:
return Messages.getString("GUIHelper.12");
case 5:
return Messages.getString("GUIHelper.13");
case 6:
return Messages.getString("GUIHelper.14");
case 7:
return Messages.getString("GUIHelper.15");
case 8:
return Messages.getString("GUIHelper.16");
case 9:
return compressedBitmapFont;
case 10:
return Messages.getString("GUIHelper.17");
case 11:
return Messages.getString("GUIHelper.18");
case 12:
return Messages.getString("GUIHelper.19");
case 13:
return Messages.getString("GUIHelper.20");
case 14:
return Messages.getString("GUIHelper.21");
case 15:
return Messages.getString("GUIHelper.22");
case 16:
return Messages.getString("GUIHelper.23");
case 17:
return Messages.getString("GUIHelper.24");
case 18:
return Messages.getString("GUIHelper.25");
case 19:
return Messages.getString("GUIHelper.26");
case 20:
return Messages.getString("GUIHelper.27");
case 21:
return Messages.getString("GUIHelper.28");
case 22:
return Messages.getString("GUIHelper.29");
case 23:
return Messages.getString("GUIHelper.30");
case 24:
return Messages.getString("GUIHelper.31");
case 25:
return Messages.getString("GUIHelper.32");
case 26:
return Messages.getString("GUIHelper.33");
case 35:
return Messages.getString("GUIHelper.34");
default:
return Messages.getString("GUIHelper.35")+iType;
}
}
static private String[] parseObject(String object)
{
logger.trace("");
String name=null;
String type=null;
String storage=null;
String size=null;
String description=null;
try
{
String[] fields=object.split(",");
int numFields=fields.length;
if(numFields<6)
{
return null;
}
storage=getStorage(fields[0].trim());
type=getType(fields[1].trim());
name=fields[2].trim();
size=fields[3].trim();
description=fields[5].trim();
}
catch(Exception e)
{
GUIHelper.error(Messages.getString("GUIHelper.36")+e.toString());
logger.error(e, e);
return null;
}
return new String[]{name, type, storage, size, description};
}
public static Vector<String[]>getParsedObjectList()
{
logger.trace("");
Vector<String[]>parsedObjectList=new Vector<String[]>();
String objectList=PrinterHelper.commandWaitResponse("!LS");
if(objectList!=null)
{
GUIHelper.logger.debug(objectList);
String[] objects=objectList.split("\n");
for(String object : objects)
{
if(object.matches(".*END-OF-LIST.*"))
{
break;
}
else
{
String[] parsedObject=parseObject(object);
if(parsedObject!=null)
{
parsedObjectList.add(parsedObject);
}
}
}
}
return parsedObjectList;
}
}
```
## File: JAdmin/src/com/cognitive/admin/JAdminDialogMessage.java
```java
public class JAdminDialogMessage
{
private Shell sShell=null;
private Label message=null;
public JAdminDialogMessage(String title)
{
sShell=new Shell(SWT.APPLICATION_MODAL|SWT.TITLE|SWT.BORDER);
sShell.setSize(new Point(334, 138));
sShell.setText(title);
GridData gridData=new GridData();
gridData.horizontalAlignment=GridData.CENTER;
gridData.grabExcessHorizontalSpace=true;
gridData.grabExcessVerticalSpace=true;
gridData.verticalAlignment=GridData.CENTER;
sShell.setLayout(new GridLayout());
message=new Label(sShell, SWT.CENTER|SWT.WRAP);
message.setText(title);
message.setLayoutData(gridData);
show();
}
public void show()
{
Rectangle bounds=GUIHelper.myShell.getBounds();
Rectangle rect=sShell.getBounds();
int x=bounds.x+(bounds.width-rect.width)/2;
int y=bounds.y+(bounds.height-rect.height)/2;
sShell.setLocation(x, y);
sShell.setActive();
sShell.setVisible(true);
GUIHelper.update();
}
public void setMessage(String msg)
{
message.setText(msg);
sShell.layout();
Point currentSize=sShell.getSize();
Point preferredSize=sShell.computeSize(SWT.DEFAULT, SWT.DEFAULT, true);
GUIHelper.update();
}
public void closeAfter(int milliseconds)
{
try
{
Thread.sleep(milliseconds);
}
catch(InterruptedException e)
{
GUIHelper.logger.error(e, e);
}
finally
{
sShell.dispose();
}
}
public void hide()
{
sShell.setVisible(false);
}
public void close()
{
sShell.dispose();
}
}
```
## File: JAdmin/src/com/cognitive/admin/JAdminDialogRadio.java
```java
public class JAdminDialogRadio
{
private Shell sShell=null;
private Button buttonOk=null;
private Button buttonCancel=null;
private boolean done=false;
private int selectedButton=-1;
private Vector<Button>radioButtons=null;
public JAdminDialogRadio(String title)
{
sShell=new Shell(SWT.APPLICATION_MODAL|SWT.TITLE|SWT.BORDER);
sShell.setSize(new Point(334, 138));
sShell.setText(title);
RowLayout rowLayout=new RowLayout();
rowLayout.type=org.eclipse.swt.SWT.VERTICAL;
rowLayout.justify=true;
rowLayout.fill=true;
rowLayout.marginBottom=10;
rowLayout.marginHeight=10;
rowLayout.marginLeft=10;
rowLayout.marginRight=10;
rowLayout.marginTop=10;
rowLayout.marginWidth=10;
sShell.setLayout(rowLayout);
radioButtons=new Vector<Button>();
}
public void addOption(String option)
{
Button button=new Button(sShell, SWT.RADIO);
button.setText(option);
button.addSelectionListener(new org.eclipse.swt.events.SelectionAdapter()
{
public void widgetSelected(org.eclipse.swt.events.SelectionEvent e)
{
buttonOk.setEnabled(true);
}
});
radioButtons.add(button);
sShell.pack(true);
}
private void addOkCancel()
{
RowLayout rowLayout=new RowLayout();
rowLayout.type=org.eclipse.swt.SWT.HORIZONTAL;
rowLayout.justify=true;
rowLayout.fill=true;
rowLayout.marginBottom=0;
rowLayout.marginHeight=0;
rowLayout.marginLeft=10;
rowLayout.marginRight=10;
rowLayout.marginTop=10;
rowLayout.marginWidth=10;
Composite actionButtons=new Composite(sShell, SWT.NONE);
actionButtons.setLayout(rowLayout);
buttonOk=new Button(actionButtons, SWT.PUSH);
buttonOk.setText("  OK  ");
buttonOk.setEnabled(false);
buttonOk.addSelectionListener(new org.eclipse.swt.events.SelectionAdapter()
{
public void widgetSelected(org.eclipse.swt.events.SelectionEvent e)
{
done=true;
selectedButton=findSelectedButton();
}
});
buttonCancel=new Button(actionButtons, SWT.PUSH);
buttonCancel.setText("Cancel");
buttonCancel.addSelectionListener(new org.eclipse.swt.events.SelectionAdapter()
{
public void widgetSelected(org.eclipse.swt.events.SelectionEvent e)
{
done=true;
selectedButton=-1;
}
});
actionButtons.pack(true);
sShell.pack(true);
}
private void show()
{
addOkCancel();
Rectangle bounds=GUIHelper.myShell.getBounds();
Rectangle rect=sShell.getBounds();
int x=bounds.x+(bounds.width-rect.width)/2;
int y=bounds.y+(bounds.height-rect.height)/2;
sShell.setLocation(x, y);
sShell.setActive();
sShell.setVisible(true);
}
public int waitForSelection()
{
show();
while(!done)
{
try
{
Thread.sleep(50);
GUIHelper.update();
}
catch(InterruptedException e)
{
GUIHelper.logger.error(e, e);
sShell.dispose();
return-1;
}
}
sShell.dispose();
return selectedButton;
}
private int findSelectedButton()
{
for(int i=0; i<radioButtons.size(); i++)
if(radioButtons.elementAt(i).getSelection())
return i;
return-1;
}
}
```
## File: JAdmin/src/com/cognitive/admin/MainShell.java
```java
public class MainShell implements Observer
{
static TimerTaskHeartbeat timerTaskHeartbeat=null;
static Timer timer=null;
static Configurator config=null;
static boolean initializing=true;
private Shell sShell=null;
private TabFolder tabFolder=null;
private CompositeCPLEditor compositeCPLEditor=null;
private Group groupPrinterStatus=null;
private Button buttonHeartbeat=null;
private Label labelPrinterStatus=null;
private CompositeConnectionSettings compositeConnectionSettings=null;
private Label labelLogoImage=null;
private CompositeLabelPositioning compositeLabelPositioning=null;
private CompositePrinterSettings compositePrinterSettings=null;
private CompositeFontsAndObjects compositeFontsAndObjects=null;
private CompositePCLWindowing compositePCLWindowing=null;
private CompositeFirmwareCPR compositeFirmwareCPR=null;
private CompositeProfileManagement compositeProfileManagement=null;
private CompositeRepair compositeRepair=null;
private CompositeManufacturing compositeManufacturingTest=null;
private CompositeAbout compositeAbout=null;
public void update(Observable observable, Object object)
{
GUIHelper.logger.trace("");
String className=observable.getClass().getName();
if(className.equals("com.cognitive.printer.Printer"))
{
updatePrinter(object);
}
else
{
GUIHelper.logger.warn("Received update from unknown observable ["+observable.toString()+"]");
}
}
private void updatePrinter(Object object)
{
GUIHelper.logger.trace("");
if(object!=null)
{
if(object.toString().equals("030470 DISCONNECTED 074030"))
{
GUIHelper.logger.info("Disconnected");
}
}
else
{
GUIHelper.logger.warn("Received null object.");
}
}
public void setConnectionState(boolean connected, boolean dumbTerminal)
{
GUIHelper.logger.trace("");
buttonHeartbeat.setEnabled(connected&&!dumbTerminal);
compositeConnectionSettings.setConnectionState(connected, dumbTerminal);
compositeCPLEditor.setConnectionState(connected, dumbTerminal);
compositePrinterSettings.setConnectionState(connected, dumbTerminal);
compositeLabelPositioning.setConnectionState(connected, dumbTerminal);
compositePCLWindowing.setConnectionState(connected, dumbTerminal);
if(connected&&!dumbTerminal)
{
boolean hasPCLFirmware=false;
String currentFirmware=GUIHelper.clean(PrinterHelper.commandWaitResponse("!QR"));
if(currentFirmware!=null)
{
hasPCLFirmware=currentFirmware.indexOf("176")>0;
}
if(hasPCLFirmware)
{
TabItem tabPCLWindowing=new TabItem(tabFolder, SWT.NONE, 6);
tabPCLWindowing.setText(Messages.getString("MainShell.10"));
tabPCLWindowing.setControl(compositePCLWindowing);
tabFolder.redraw();
}
}
if((!connected)&&(tabFolder.getItem(6).getText().equalsIgnoreCase(Messages.getString("MainShell.10"))))
{
tabFolder.getItem(6).dispose();
}
compositeFontsAndObjects.setConnectionState(connected, dumbTerminal);
compositeFirmwareCPR.setConnectionState(connected, dumbTerminal);
compositeProfileManagement.setConnectionState(connected, dumbTerminal);
if(compositeRepair!=null)
{
compositeRepair.setConnectionState(connected, dumbTerminal);
}
if(timer==null)
{
timer=new Timer("Timer");
}
if(initializing)
{
initializing=false;
buttonHeartbeat.setSelection(GUIHelper.prefs.getBoolean("USE_HEARTBEATS", false));
}
if(connected)
{
GUIHelper.logger.trace("connected");
labelPrinterStatus.setText(Messages.getString("MainShell.0"));
labelPrinterStatus.setBackground(Display.getCurrent().getSystemColor(SWT.COLOR_DARK_GREEN));
if(!dumbTerminal&&buttonHeartbeat.getSelection())
{
startHeartbeats();
}
}
else
{
GUIHelper.logger.trace("disconnected");
try
{
buttonHeartbeat.setEnabled(false);
if(timer!=null)
{
timer.cancel();
timer=null;
}
}
catch(IllegalStateException e)
{
}
displayConnectionStatus(ConnectionStatus.DISCONNECTED);
}
}
public void toggleHeartbeats()
{
if(buttonHeartbeat.getSelection())
{
startHeartbeats();
}
else
{
stopHeartbeats();
}
}
public boolean heartbeatsEnabled()
{
return buttonHeartbeat.getSelection();
}
public void startHeartbeats()
{
buttonHeartbeat.setSelection(true);
try
{
if(PrinterHelper.printer.isConnected())
{
displayConnectionStatus(ConnectionStatus.CONNECTED);
timerTaskHeartbeat=new TimerTaskHeartbeat();
timerTaskHeartbeat.setDisplay(Display.getCurrent());
timer.schedule(timerTaskHeartbeat, timerTaskHeartbeat.getInterval(), timerTaskHeartbeat.getInterval());
}
}
catch(IllegalStateException e)
{
}
}
public void stopHeartbeats()
{
buttonHeartbeat.setSelection(false);
if(timerTaskHeartbeat!=null)
{
timerTaskHeartbeat.cancel();
timerTaskHeartbeat=null;
}
displayConnectionStatus(ConnectionStatus.UNKNOWN);
}
public enum ConnectionStatus
{
CONNECTED,
DISCONNECTED,
UNKNOWN
}
public void displayConnectionStatus(ConnectionStatus cs)
{
switch(cs)
{
case CONNECTED:
labelPrinterStatus.setBackground(Display.getCurrent().getSystemColor(SWT.COLOR_DARK_GREEN));
labelPrinterStatus.setText(Messages.getString("MainShell.0"));
break;
case DISCONNECTED:
labelPrinterStatus.setText(Messages.getString("MainShell.2"));
labelPrinterStatus.setBackground(Display.getCurrent().getSystemColor(SWT.COLOR_RED));
break;
case UNKNOWN:
default:
labelPrinterStatus.setBackground(Display.getCurrent().getSystemColor(SWT.COLOR_BLUE));
labelPrinterStatus.setText(Messages.getString("MainShell.3"));
break;
}
}
private void createTabFolder()
{
GridData gridData=new GridData();
gridData.horizontalAlignment=GridData.FILL;
gridData.grabExcessHorizontalSpace=true;
gridData.grabExcessVerticalSpace=true;
gridData.horizontalSpan=2;
gridData.verticalAlignment=GridData.FILL;
tabFolder=new TabFolder(sShell, SWT.V_SCROLL|SWT.H_SCROLL);
tabFolder.setLayoutData(gridData);
createCompositeCPLEditor();
createCompositeConnectionSettings();
createCompositeLabelPositioning();
createCompositePrinterSettings();
createCompositeFontsAndObjects();
createCompositePCLWindowing();
createCompositeFirmwareCPR();
createCompositeProfileManagement();
createCompositeAbout();
TabItem tabConnectionSettings=new TabItem(tabFolder, SWT.NONE);
tabConnectionSettings.setText(Messages.getString("MainShell.4"));
tabConnectionSettings.setControl(compositeConnectionSettings);
TabItem tabPrinterSettings=new TabItem(tabFolder, SWT.NONE);
tabPrinterSettings.setText(Messages.getString("MainShell.5"));
tabPrinterSettings.setControl(compositePrinterSettings);
TabItem tabLabelPositioning=new TabItem(tabFolder, SWT.NONE);
tabLabelPositioning.setText(Messages.getString("MainShell.6"));
tabLabelPositioning.setControl(compositeLabelPositioning);
TabItem tabFontsAndObjects=new TabItem(tabFolder, SWT.NONE);
tabFontsAndObjects.setText(Messages.getString("MainShell.7"));
tabFontsAndObjects.setControl(compositeFontsAndObjects);
TabItem tabProfileManagement=new TabItem(tabFolder, SWT.NONE);
tabProfileManagement.setText(Messages.getString("MainShell.8"));
tabProfileManagement.setControl(compositeProfileManagement);
TabItem tabFirmwareCPR=new TabItem(tabFolder, SWT.NONE);
tabFirmwareCPR.setText(Messages.getString("MainShell.9"));
tabFirmwareCPR.setControl(compositeFirmwareCPR);
TabItem tabPCLWindowing=new TabItem(tabFolder, SWT.NONE);
tabPCLWindowing.setText(Messages.getString("MainShell.10"));
tabPCLWindowing.setControl(compositePCLWindowing);
TabItem tabCPLEditor=new TabItem(tabFolder, SWT.NONE);
tabCPLEditor.setText(Messages.getString("MainShell.11"));
tabCPLEditor.setControl(compositeCPLEditor);
String yesNo=GUIHelper.prefs.get("SUPER_USER", "NO");
if(yesNo.equals("YES"))
{
createCompositeRepair();
TabItem tabRepair=new TabItem(tabFolder, SWT.NONE);
tabRepair.setText(Messages.getString("MainShell.12"));
tabRepair.setControl(compositeRepair);
}
if(GUIHelper.prefs.getBoolean("ACTIVATE_MANUFACTURING", false))
{
try
{
LocationCode.valueOf(GUIHelper.prefs.get("MAN_LOCATION_CODE", ""));
createCompositeManufacturingTest();
tabFolder.addSelectionListener(new org.eclipse.swt.events.SelectionAdapter()
{
public void widgetSelected(org.eclipse.swt.events.SelectionEvent e)
{
tabSelected(((TabItem)(e.item)).getText());
}
});
TabItem tabManufacturingTest=new TabItem(tabFolder, SWT.NONE);
tabManufacturingTest.setText(Messages.getString("MainShell.13"));
tabManufacturingTest.setControl(compositeManufacturingTest);
}
catch(IllegalArgumentException e)
{
String msg=Messages.getString("MainShell.14");
GUIHelper.logger.warn(msg);
GUIHelper.message(msg, SWT.OK|SWT.ICON_WARNING);
}
}
TabItem tabAbout=new TabItem(tabFolder, SWT.NONE);
tabAbout.setText(Messages.getString("MainShell.15"));
tabAbout.setControl(compositeAbout);
}
private void createCompositeCPLEditor()
{
compositeCPLEditor=new CompositeCPLEditor(tabFolder, SWT.NONE);
}
private void createGroupPrinterStatus()
{
GridData gridData3=new GridData();
gridData3.grabExcessHorizontalSpace=true;
gridData3.verticalAlignment=GridData.FILL;
gridData3.horizontalAlignment=GridData.FILL;
GridData gridData1=new GridData();
gridData1.grabExcessHorizontalSpace=true;
gridData1.verticalAlignment=GridData.CENTER;
gridData1.horizontalAlignment=GridData.CENTER;
GridLayout gridLayout1=new GridLayout();
gridLayout1.numColumns=3;
GridData gridData2=new GridData();
gridData2.horizontalAlignment=GridData.FILL;
gridData2.grabExcessHorizontalSpace=true;
gridData2.verticalAlignment=GridData.CENTER;
groupPrinterStatus=new Group(sShell, SWT.NONE);
groupPrinterStatus.setText(Messages.getString("MainShell.16"));
groupPrinterStatus.setLayout(gridLayout1);
groupPrinterStatus.setLayoutData(gridData2);
labelLogoImage=new Label(groupPrinterStatus, SWT.NONE);
labelLogoImage.setText("");
labelLogoImage.setImage(new Image(Display.getCurrent(), GUIHelper.myShell.getClass().getClassLoader().getResourceAsStream("com/cognitive/brand/MainLogo.gif")));
buttonHeartbeat=new Button(groupPrinterStatus, SWT.CHECK);
buttonHeartbeat.setText(Messages.getString("MainShell.17"));
buttonHeartbeat.setLayoutData(gridData1);
buttonHeartbeat
.addSelectionListener(new org.eclipse.swt.events.SelectionAdapter()
{
public void widgetSelected(org.eclipse.swt.events.SelectionEvent e)
{
toggleHeartbeats();
}
});
labelPrinterStatus=new Label(groupPrinterStatus, SWT.NONE);
labelPrinterStatus.setText(Messages.getString("MainShell.2"));
labelPrinterStatus.setForeground(Display.getCurrent().getSystemColor(SWT.COLOR_WHITE));
labelPrinterStatus.setLayoutData(gridData3);
labelPrinterStatus.setBackground(Display.getCurrent().getSystemColor(SWT.COLOR_RED));
}
private void createCompositeConnectionSettings()
{
compositeConnectionSettings=new CompositeConnectionSettings(tabFolder,
SWT.NONE);
}
static private void configure()
{
config=new Configurator();
}
static private void finit()
{
try
{
config.savePrefs();
if(timer!=null)
{
timer.cancel();
timer=null;
Thread.sleep(500);
}
if(PrinterHelper.printer!=null)
{
PrinterHelper.printer.closeConnection();
}
}
catch(SWTException e)
{
GUIHelper.logger.debug("printer.closeConnection SWT shutdwon.");
}
catch(Exception e)
{
GUIHelper.logger.error("printer.closeConnection failed:", e);
}
}
private void createCompositeLabelPositioning()
{
compositeLabelPositioning=new CompositeLabelPositioning(tabFolder,
SWT.NONE);
}
private void createCompositePrinterSettings()
{
compositePrinterSettings=new CompositePrinterSettings(tabFolder, SWT.NONE);
}
private void createCompositeFontsAndObjects()
{
compositeFontsAndObjects=new CompositeFontsAndObjects(tabFolder, SWT.NONE);
}
private void createCompositePCLWindowing()
{
compositePCLWindowing=new CompositePCLWindowing(tabFolder, SWT.NONE);
}
private void createCompositeFirmwareCPR()
{
compositeFirmwareCPR=new CompositeFirmwareCPR(tabFolder, SWT.NONE);
}
private void createCompositeProfileManagement()
{
compositeProfileManagement=new CompositeProfileManagement(tabFolder,
SWT.NONE);
}
private void createCompositeRepair()
{
compositeRepair=new CompositeRepair(tabFolder, SWT.NONE);
if(GUIHelper.brand.getProperty("company.name", "CognitiveTPG").startsWith("Tally"))
{
CompositeRepair.labelModelNumber.setText("ID Number:");
}
}
private void createCompositeManufacturingTest()
{
compositeManufacturingTest=new CompositeManufacturing(tabFolder, SWT.NONE);
if(GUIHelper.brand.getProperty("company.name", "CognitiveTPG").startsWith("Tally"))
{
CompositeManufacturing.labelModelNumber.setText("ID Number:");
}
}
private void createCompositeAbout()
{
compositeAbout=new CompositeAbout(tabFolder, SWT.NONE);
}
public static void main(String[] args)
{
try
{
configure();
GUIHelper.logger.trace("");
GUIHelper.logger.info("Version jadmin="+Versions.jadmin);
GUIHelper.logger.info("Version manFirmware="+Versions.manFirmware);
GUIHelper.logger.info("Version manCpr="+Versions.manCpr);
GUIHelper.logger.info("Version manFonts="+Versions.manFonts);
GUIHelper.logger.info("Version manLabels="+Versions.manLabels);
GUIHelper.logger.info("Retrieving default display value...");
Display display=null;
try
{
display=Display.getDefault();
}
catch(Exception e)
{
}
if(display==null)
{
GUIHelper.logger.info("Failed to get default display value; retrieving current display value...");
display=Display.getCurrent();
GUIHelper.logger.info("Current display value retrieved.");
}
else
{
GUIHelper.logger.info("Default display value retrieved.");
}
GUIHelper.logger.info("Initializing main shell value...");
MainShell thisClass=new MainShell();
GUIHelper.logger.info("Main shell value initialized.");
GUIHelper.logger.info("Creating main shell...");
thisClass.createSShell();
GUIHelper.logger.info("Main shell created.");
GUIHelper.logger.info("Opening main shell...");
thisClass.sShell.open();
GUIHelper.logger.info("Main shell opened.");
initializing=true;
config.installFPKTool();
while(!thisClass.sShell.isDisposed())
{
try
{
if(!display.readAndDispatch())
display.sleep();
}
catch(NullPointerException e)
{
if(e.getMessage()!=null&&e.getMessage().equals("12345DISCONNECT54321"))
{
}
else
{
handleMainLoopException(e);
}
continue;
}
catch(Exception e)
{
handleMainLoopException(e);
}
}
finit();
GUIHelper.logger.info("Main shell deinitialized.");
display.dispose();
GUIHelper.logger.info("Main shell disposed.");
}
catch(Exception e)
{
GUIHelper.logger.info("Main shell exception: "+e.getMessage());
handleMainLoopException(e);
}
finally
{
if(com.cognitive.admin.WindowsPrinterManager.spoolerStopped)
{
GUIHelper.logger.trace("Spooler started");
com.cognitive.admin.WindowsPrinterManager.startSpooler();
}
GUIHelper.logger.trace("finally");
System.exit(0);
}
}
static private void handleMainLoopException(Exception e)
{
GUIHelper.error("Error: "+e.toString()+Messages.getString("MainShell.19"));
try
{
GUIHelper.logger.error(e, e);
PrinterHelper.printer.closeConnection();
GUIHelper.mainShell.setConnectionState(false, false);
}
catch(Exception e2)
{
GUIHelper.logger.error("Caught an exception closing printer connection after exception in main display loop.", e2);
}
GUIHelper.logger.error("Caught an Exception: ", e);
GUIHelper.setCursor(0);
}
private void tabSelected(String tabName)
{
if(tabName.equals(Messages.getString("MainShell.20")))
{
labelPrinterStatus.setVisible(false);
buttonHeartbeat.setVisible(false);
}
else
{
labelPrinterStatus.setVisible(true);
buttonHeartbeat.setVisible(true);
}
}
public ConnectionType getConnectionType()
{
return compositeConnectionSettings.getConnectionType();
}
private void createSShell()
{
GridLayout gridLayout=new GridLayout();
gridLayout.numColumns=3;
sShell=new Shell();
GUIHelper.myShell=sShell;
GUIHelper.myDisplay=sShell.getDisplay();
GUIHelper.mainShell=this;
sShell.setText(Messages.getString("MainShell.21").replace("Cognitive", GUIHelper.brand.getProperty("company.name", "CognitiveTPG"))+Versions.jadmin);
sShell.setImage(new Image(Display.getCurrent(), GUIHelper.myShell.getClass().getClassLoader().getResourceAsStream("com/cognitive/brand/Main.ico")));
sShell.setLayout(gridLayout);
Label filler=new Label(sShell, SWT.NONE);
createGroupPrinterStatus();
createTabFolder();
sShell.setSize(sShell.computeSize(SWT.DEFAULT, SWT.DEFAULT));
setConnectionState(false, false);
}
}
```
## File: JAdmin/src/com/cognitive/admin/messages_fr.properties
```
General.0=Appliquer
General.1=Rafrachir
CompositeAbout.0=Firmware :
CompositeAbout.1=Polices:
CompositeAbout.2=tiquettes:
CompositeAbout.3=Pilotes:
CompositeAbout.4=Documentation:
CompositeAbout.5=Tlphone
CompositeAbout.6=Copyright
CompositeAbout.7=Tous droits rservs.
CompositeAbout.8=administrateur de l'imprimante cognitive
CompositeCPLEditor.0=Entre de l'imprimante
CompositeCPLEditor.10=Paramtres du compteur
CompositeCPLEditor.11=Intervalle (secs) :
CompositeCPLEditor.12=Rpter :
CompositeCPLEditor.13=Actuel:
CompositeCPLEditor.14=Dmarrer
CompositeCPLEditor.15=Pause
CompositeCPLEditor.16=Reprendre
CompositeCPLEditor.17=Arrter
CompositeCPLEditor.18=Erreur la lecture du fichier
CompositeCPLEditor.19=Erreur  l'envoi de CPL vers l'imprimante:CompositeCPLEditor.1=Sortie de l'imprimante
CompositeCPLEditor.20=Envoyer un fichier  l'imprimante
CompositeCPLEditor.21=Erreur lors de l'envoi du fichier  l'imprimante:
CompositeCPLEditor.2=Ouvrir un fichier
CompositeCPLEditor.3=Enregistrer sous fichier
CompositeCPLEditor.4=Effacer
CompositeCPLEditor.5=Envoyer  l'imprimante
CompositeCPLEditor.6=Voir les variables
CompositeCPLEditor.7=Voir le temps
CompositeCPLEditor.8=Enregistrer la sortie
CompositeCPLEditor.9=Effacer la sortie
CompositeConnectionSettings.0=Dconnecter
CompositeConnectionSettings.10=Utiliser la connexion srielle
CompositeConnectionSettings.11=Port COM:
CompositeConnectionSettings.12=Vitesse en bauds:
CompositeConnectionSettings.13=Connexion de l'imprimante du systme
CompositeConnectionSettings.14=Nom de l'imprimante:
CompositeConnectionSettings.15=Utiliser la connexion rseau
CompositeConnectionSettings.16=Adresse IP:
CompositeConnectionSettings.17=Port:
CompositeConnectionSettings.18=Terminal idiot
CompositeConnectionSettings.1=Connexion impossible. Vrifiez vos paramtres s.v.p.
CompositeConnectionSettings.20=Imprimer une tiquette test
CompositeConnectionSettings.21=Paramtres de connexion
CompositeConnectionSettings.22=Connexion srielle
CompositeConnectionSettings.23=Vitesse en bauds:
CompositeConnectionSettings.24=Taille du tampon:
CompositeConnectionSettings.25=Dbordement du tampon:
CompositeConnectionSettings.28=Connexion rseau
CompositeConnectionSettings.29=Adresse IP:
CompositeConnectionSettings.30=Masque Net:
CompositeConnectionSettings.31=Passerelle:
CompositeConnectionSettings.32=Numro du port RTEL:
CompositeConnectionSettings.33=Taille du tampon:
CompositeConnectionSettings.34=Vous pourriez perdre votre connexion rseau.\nS'il vous plat redmarrer l'imprimante.
CompositeConnectionSettings.35=Utiliser une connexion parallle
CompositeConnectionSettings.36=LPT Port:
CompositeConnectionSettings.37=Note: L'utilisation de la connexion en parallle est limit\net fonctionne avec les nouvelles imprimantes uniquement.
CompositeConnectionSettings.38=Stop Bits:
CompositeConnectionSettings.39=Utiliser connexion USB directe
CompositeConnectionSettings.3=Connecter
CompositeConnectionSettings.40=Note: Si un rglage Ethernet est\nmodifi, Redmarrez l'imprimante avant\nde tenter de se reconnecter.
CompositeConnectionSettings.41=Utiliser connexion Bluetooth
CompositeConnectionSettings.42=Est Bluetooth
CompositeConnectionSettings.4=Impossible de fermer la connexion de l'imprimante. Fermez s.v.p. cette application.
CompositeConnectionSettings.5=Pas ralis.
CompositeConnectionSettings.6=Erreur:CompositeConnectionSettings.9=Type de connexion
CompositeFirmwareCPR.0=Erreur  l'ouverture du fichier.
CompositeFirmwareCPR.10=Nouvelle image:
CompositeFirmwareCPR.11=Progression de la mise  jour:
CompositeFirmwareCPR.12=Tlchargement termin
CompositeFirmwareCPR.13=Mise  jour du micrologiciel a chou. Aborting.
CompositeFirmwareCPR.14=Mise  jour du Firmware annul.
CompositeFirmwareCPR.15=chec du tlchargement de polices. Aborting.
CompositeFirmwareCPR.16=Font tlcharger annul.
CompositeFirmwareCPR.17=Tlcharger le firmware a t effectue avec succs.\nAppuyez sur OK pour continuer avec le tlchargement de polices.
CompositeFirmwareCPR.18=Vous avez dj le dernier firmware.\nVoulez-vous continuer  tlcharger les polices?
CompositeFirmwareCPR.19=Vous avez maintenant le dernier firmware et les polices.
CompositeFirmwareCPR.1=Impossible de lire le fichier image du firmware:CompositeFirmwareCPR.20=Pas de mises  jour disponibles.
CompositeFirmwareCPR.21=S'il vous plat slectionnez Fichier Firmware.
CompositeFirmwareCPR.22=Attention: Aprs avoir changer le logiciel rsident (firmware) ou des polices, un redmarrage de l'imprimante et cette application est recommand.
CompositeFirmwareCPR.23=Nous ne recommandons pas de tlcharger une version logiciel rsident prcdente (ou infrieure).\nCela peut rendre l'imprimante inutilisable.\nContactez notre S.A.V. avant d'essayer de tlcharger tout logiciel rsident g sur l'imprimante.
CompositeFirmwareCPR.2=Firmware actuel:
CompositeFirmwareCPR.3=Numro de pice:
CompositeFirmwareCPR.4=Numro de la version:
CompositeFirmwareCPR.5=Date de parution:
CompositeFirmwareCPR.6=Mise  jour du firmware:
CompositeFirmwareCPR.7=Slectionner le fichier du firmware
CompositeFirmwareCPR.8=Obtenir tout dernier firmware par cognition
CompositeFirmwareCPR.9=Mise  jour du firmware
CompositeFontsAndObjects.0=Envoyer des objets  l'imprimante
CompositeFontsAndObjects.10=Erreur de tlchargement de l'objet
CompositeFontsAndObjects.11=Erreur  la lecture du fichier
CompositeFontsAndObjects.12=Attention: Aprs avoir sauvegards/envoys des objets ou des polices sur l'imprimante, un redmarrage de l'imprimante et cette application est recommand.
CompositeFontsAndObjects.1=Annuler les objets slectionns
CompositeFontsAndObjects.3=Nom
CompositeFontsAndObjects.4=Type
CompositeFontsAndObjects.5=Stockage
CompositeFontsAndObjects.6=Taille
CompositeFontsAndObjects.7=Description
CompositeFontsAndObjects.8=Erreur  l'ouverture du fichier.
CompositeFontsAndObjects.9=Erreur de tlchargement de l'objet
CompositeLabelPositioning.0=Largeur d'impression (pouces):
CompositeLabelPositioning.10=Indexage
CompositeLabelPositioning.11=Indexage actif
CompositeLabelPositioning.12=Barre
CompositeLabelPositioning.14=Espace
CompositeLabelPositioning.15=Calibrer
CompositeLabelPositioning.16=Encoche
CompositeLabelPositioning.17=Calibrage russi
CompositeLabelPositioning.18=Prsentation d'tiquette
CompositeLabelPositioning.19=Activer la prsentation d'tiquette
CompositeLabelPositioning.20=Avancer:
CompositeLabelPositioning.22=Rtracter:
CompositeLabelPositioning.23=Temps:
CompositeLabelPositioning.24=Le dcalage  gauche dplace l'image vers la gauche  travers\nl'tiquette depuis le point de vue de l'imprimante, donc vers la\ndroite depuis ce point de vue.
CompositeLabelPositioning.25=Dcalage  gauche (en centimes de pouce):
CompositeLabelPositioning.26=Ajustement du haut de page (en pas du moteur):
CompositeLabelPositioning.28=L'ajustement du haut de page dplace\nla marge suprieure de l'tiquette en descendant le long de la\npage, ce qui peut apparatre comme en haut'\ndepuis ce point de vue.
CompositeLabelPositioning.29=Vous avez slectionn un type d'avancement invalide.
CompositeLabelPositioning.31=Reu un type d'avancement invalide depuis l'imprimante :
CompositeLabelPositioning.32=Calibrage russi
CompositeLabelPositioning.33=Le calibrage a chou
CompositeLabelPositioning.35=Imprimer une tiquette test
CompositeLabelPositioning.5=Activer le recalibrage automatique
CompositeLabelPositioning.7=Activer l'ajustement du haut de page automatique
CompositeLabelPositioning.9=tiquette
CompositeManufacturing.0=Dmarrer
CompositeManufacturing.10=Test de la mmoire de sauvegarde
CompositeManufacturing.11=Identification de l'imprimante
CompositeManufacturing.12=Froissement du ruban
CompositeManufacturing.13=Paramtres finaux
CompositeManufacturing.14=Tlchargement CPR
CompositeManufacturing.15=Chargement des polices
CompositeManufacturing.16=Calibrage et indexage
CompositeManufacturing.17=Tte d'impression en haut/en bas
CompositeManufacturing.18=Qualit de l'impression
CompositeManufacturing.19=Test de la tte d'impression
CompositeManufacturing.1=Activer PCL
CompositeManufacturing.20=Test automatique
CompositeManufacturing.21=Impression tiquette d'expdition
CompositeManufacturing.22=Unit en cours de test:
CompositeManufacturing.23=Test de carte
CompositeManufacturing.24=Numro de srie:
CompositeManufacturing.25=Adresse MAC:
CompositeManufacturing.26=Demande de tlchargement de firmware
CompositeManufacturing.27=Spcifier SN&&MAC
CompositeManufacturing.28=Port sriel:CompositeManufacturing.29=Port parallle:
CompositeManufacturing.2=Rglage initial
CompositeManufacturing.30=Adresse IP:CompositeManufacturing.31=Nom de l'imprimante Windows:
CompositeManufacturing.32=Tte d'impression:
CompositeManufacturing.33=Priphriques:
CompositeManufacturing.34=Scanner :CompositeManufacturing.35=Imprimante d'tiquettes S/N :
CompositeManufacturing.36=Imprimante d'tiquettesde bote :CompositeManufacturing.37=Dtection automatique (seulement DLX)
CompositeManufacturing.38=Unit accepte.
CompositeManufacturing.39=Le test a chou. Annulation.
CompositeManufacturing.3=Chargement du firmware
CompositeManufacturing.40=Annulation du test.
CompositeManufacturing.41=Impossible de fermer la connexion de l'imprimante.\n\n
CompositeManufacturing.42=Code d'emplacement inconnu.
CompositeManufacturing.43=Imprimer tiquette du numro de srie
CompositeManufacturing.44=Imprimer tiquette de bote
CompositeManufacturing.45=Numro du modle:
CompositeManufacturing.46=Scanner
CompositeManufacturing.47=Assurez-vous que l'imprimante est allume et que\ntoutes les interfaces  tester sont connectes.\n\nLes alimentation et voyant Prt doit tre vert et le papier doit tre charg.\n\nCochez toutes les cases des interfaces  tester.\n\nNE PAS charger de papier ni mettre du ruban dans l'imprimante pour le moment.
CompositeManufacturing.48=S'assurer que l'imprimante est allume et que \ntoutes les interfaces  tester sont connectes.\n\nLes voyants Alimentation lectrique et Prt doivent tre verts.\n\nActiver la limite actuelle sur le dispositif de test.
CompositeManufacturing.49=Passer de charge
CompositeManufacturing.4=Tableau de commandeCompositeManufacturing.50=TallyGenicom
CompositeManufacturing.51=Nourrissez Bouton de test
CompositeManufacturing.52=Dsactivez la limite de courant sur le banc d'essai.
CompositeManufacturing.53=USB Direct ConnectCompositeManufacturing.54=Dsactivez Licences
CompositeManufacturing.55=Bluetooth Port COM:
CompositeManufacturing.56=Est Bluetooth
CompositeManufacturing.5=Interfaces de connexion
CompositeManufacturing.6=Contrle de l'absence de papier
CompositeManufacturing.7=Test de la peleuse
CompositeManufacturing.8=Rglage RTC
CompositeManufacturing.9=Contrle du ton
CompositePCLWindowing.0=Imprimer fichier PCL
CompositePCLWindowing.15=Paramtres de la fentre des tiquettes
CompositePCLWindowing.16=Toujours procder  ces mesures quand le papier est vu\ndans l'orientation portrait, mme si le texte de l'tiquette est dans l'orientation \npaysage.
CompositePCLWindowing.17=Origine de l'tiquette (pouces):
CompositePCLWindowing.18=Slectionner fichier PCL
CompositePCLWindowing.19=Envoyer  l'imprimante
CompositePCLWindowing.1=Envoyer PJL  l'imprimante
CompositePCLWindowing.20=Impossible de gnrer PJL avec les paramtres donns
CompositePCLWindowing.22=Impossible d'ouvrir le fichier
CompositePCLWindowing.2=Charger fichier PJL
CompositePCLWindowing.3=Enregistrer fichier PJL
CompositePCLWindowing.4=Actuel:
CompositePCLWindowing.5=Largeur de l'tiquette (pouces):
CompositePCLWindowing.7=Longueur de l'tiquette (pouces):
CompositePrinterSettings.0=Vitesse d'impression:
CompositePrinterSettings.10=Ajustement du support:
CompositePrinterSettings.12=Pas:
CompositePrinterSettings.14=Heure (hh:mm:ss, horloge  24 heures):
CompositePrinterSettings.16=Date (mm/jj/aa) :
CompositePrinterSettings.19=Imprimer une tiquette test
CompositePrinterSettings.20=Langage primaire
CompositePrinterSettings.21=PCL thermique
CompositePrinterSettings.22=Langage de programmation compatible Eltron
CompositePrinterSettings.23=Langage de programmation compatible Zebra
CompositePrinterSettings.24=Langage de programmation cognitif
CompositePrinterSettings.26=Mode thermique
CompositePrinterSettings.27=Thermique direct
CompositePrinterSettings.28=Transfert thermique
CompositePrinterSettings.2=Pas de support sorti (pouces) :
CompositePrinterSettings.32=Aucun
CompositePrinterSettings.33=Sriel
CompositePrinterSettings.34=Sriel&tiquette
CompositePrinterSettings.35=Vous avez slectionn un niveau de rapport invalide:
CompositePrinterSettings.43=Impossible de traduire le niveau de rapport de la suppression d'erreur  l'imprimante envoie le niveau :
CompositePrinterSettings.45=Bas
CompositePrinterSettings.46=Normal
CompositePrinterSettings.47=HautCompositePrinterSettings.48=Vous avez slectionn une vitesse invalide
CompositePrinterSettings.49=Personnalis
CompositePrinterSettings.4=Niveau du rapport de la suppression d'erreur:
CompositePrinterSettings.59=Rception d'une vitesse invalide depuis l'imprimante:CompositePrinterSettings.61=Rception d'un pas invalide depuis l'imprimante:
CompositePrinterSettings.62=Format de l'heure invalide.
CompositePrinterSettings.63=Format de la date invalide.
CompositePrinterSettings.64=Vous avez slectionn un langage invalide
CompositePrinterSettings.65=Disponible uniquement sur les imprimantes permettant PCL
CompositePrinterSettings.66=Vous avez slectionn un mode invalide
CompositePrinterSettings.67=Fonc
CompositePrinterSettings.68=Entrer la date conformment au format usuel dans votre environnement, donc mm/jj/aa ou jj.mm.aa
CompositePrinterSettings.69=Mauvais format de la date.
CompositePrinterSettings.6=Alimentation auxiliaire active
CompositePrinterSettings.8=Activer la rimpression automatique
CompositeProfileManagement.0=Profil de l'imprimante
CompositeProfileManagement.1=Le profil a t envoy.
CompositeProfileManagement.2=Ouvrir profil mmoris
CompositeProfileManagement.3=Obtenir le profil actuel de l'imprimante
CompositeProfileManagement.4=Enregistrer le profil dans un fichier
CompositeProfileManagement.5=Appliquer le profil  l'imprimante
CompositeProfileManagement.6=Erreur  la lecture du fichier
CompositeRepair.0=Mise  jour non ncessaire.
CompositeRepair.11=Cette imprimante n'existe pas dans la base de donnes.
CompositeRepair.12=Renouveler numro de srie&&MAC
CompositeRepair.13=K vers D
CompositeRepair.1=La mise  jour a chou.
CompositeRepair.2=La mise  jour a russi.
CompositeRepair.3=Fixateur du numro de srie: K vers D
CompositeRepair.4=Code d'emplacement inconnu.
CompositeRepair.5=Impossible d'obtenir une nouvelle paire SN/MAC depuis la base de donnes.
CompositeRepair.6=Impossible d'obtenir une nouvelle paire SN/MAC sur l'imprimante.
CompositeRepair.7=Numro du modle:
CompositeRepair.8=Numro de srie:
CompositeRepair.9=MAC :
Configurator.0=Saut de l'installation de la documentation pour le systme de production
Configurator.1=Excution de l'installation de la documentation pour le systme par dfaut
Configurator.2=Nouvelle documentation installe dans\n\n
Configurator.3=Vous pouvez raliser la procdure de nettoyage  l'avenir en excutant\n
Configurator.4=Installation en cours...
Configurator.5=Nouveaux pilotes installs dans\n\n
Configurator.6=\n\nNous conseillons de raliser une procdure de nettoyage de pilotes maintenant.\n\nVoulez-vous l'excuter maintenant ?
FirmwareUpdater.0=Erreur pendant le tlchargement du firmware:FirmwareUpdater.1=\n\n\nIl se peut que vous deviez redmarrer l'imprimante.
FirmwareUpdater.2=Une erreur s'est produite pendant le tlchargement de l'image du firmware. Redmarrez s.v.p. l'imprimante et faites une nouvelle tentative.
GUIHelper.0=Impossible de dfinir et obtenir [
GUIHelper.10=Police vectorielle
GUIHelper.11=Police personnalise
GUIHelper.12=Code exec
GUIHelper.13=Police bitmap
GUIHelper.14=Fichier du systme
GUIHelper.15=Fichier graphique
GUIHelper.16=Format avanc
GUIHelper.17=Saut de ligne rserv
GUIHelper.18=Tableau double octet
GUIHelper.19=Format rserv
GUIHelper.1=Impossible d'obtenir [
GUIHelper.20=Retour chariot rserv
GUIHelper.21=Police  double octet
GUIHelper.22=Menu
GUIHelper.23=Variable
GUIHelper.24=Commande du menu
GUIHelper.25=True type Sato
GUIHelper.26=AGFA IF
GUIHelper.27=Format EPL2
GUIHelper.28=Police de logiciel EPL2
GUIHelper.29=ZPL2 Graphique
GUIHelper.2=Impossible de dfinir [
GUIHelper.30=Format ZPL2
GUIHelper.31=Police ZPL2
GUIHelper.32=EPL2 Graphique
GUIHelper.33=Police bitmap PCL
GUIHelper.34=Police TrueType PCL
GUIHelper.35=ObjetGUIHelper.36=Erreur  la lecture d'objets depuis l'imprimante:
GUIHelper.37=Impossible d'ouvrir le fichier
GUIHelper.4=Impossible de trouver le fichier.
GUIHelper.5=L'enregistrement du fichier a chou.
GUIHelper.6=Erreur  l'criture du fichier
GUIHelper.7=Police bitmap comprime
GUIHelper.8=Non utilis
GUIHelper.9=Donnes du format
MainShell.0=Connect
MainShell.10=Fentrage PCL
MainShell.11=Script Editor
MainShell.12=Rparer
MainShell.13=Test de production
MainShell.14=Le code d'emplacement dans le fichier des favoris est invalide.\nL'onglet Production ne sera pas activ.
MainShell.15= propos de
MainShell.16=Statut de l'imprimante
MainShell.17=Battement de curMainShell.19=\n\nIl se peut que vous deviez redmarrer l'imprimante et/ou cette application.
MainShell.20=Test de production
MainShell.21=v administrateur de l'imprimante cognitive
MainShell.2=Dconnect
MainShell.3=Inconnu
MainShell.4=Paramtres de la connexion
MainShell.5=Paramtres de l'imprimante
MainShell.6=Positionnement de l'tiquette
MainShell.7=Polices et objets
MainShell.8=Gestion des profils
MainShell.9=Mise  jour du firmware
PrinterHelper.0=Connexion de la prise coupe. L'imprimante est dconnecte.
PrinterHelper.1=Impossible d'imprimer l'tiquette test :\n
PrinterHelper.2=Impossible de dfinir et obtenir la variable [
PrinterHelper.3=Impossible de dfinir la variable [
PrinterHelper.4=Impossible d'envoyer.
PrinterHelper.6=Pas de rponse  la commande [
PrinterHelper.7=Impossible d'obtenir la variable [
PrinterHelper.8=Ajustement du haut de page:PrinterHelper.9=Ajustement du dcalage  gauche:
TestEngine.0=Le numro du modle est invalide.
TestEngine.100=Impossible de connecter  une unit en cours de test.
TestEngine.101=Impossible de dtecter automatiquement une tte d'impression de srie C.
TestEngine.103=PCL n'a pas pu tre activ.
TestEngine.104=RUSSI
TestEngine.105=CHEC
TestEngine.106=SAUT
TestEngine.107=ANNUL
TestEngine.108=Aucun cble d'alimentation
TestEngine.109=Vous devriez voir le Prt feu rouge tournez, puis vert,\npuis rouge  nouveau pour une fraction de seconde, et enfin Vert fixe  nouveau.\nCela prendra un certain temps. Une fois que la lumire s'allume et reste vert pendant plus de 5 secondes, appuyez sur OK.
TestEngine.10=Comptage en pouces invalide [
TestEngine.110=J'attends le signal de papier.\nS'il vous plat appuyez sur le bouton de saut, puis appuyez sur OK.
TestEngine.111=S'il vous plat mettez l'imprimante hors tension et dbranchez tous les cbles.\nAttendre 5 secondes, puis rebranchez l'imprimante en utilisant simplement la connexion principale
TestEngine.112=Remettez l'imprimante et appuyez sur OK lorsque l'imprimante est prte.
TestEngine.113=Ne vous entendez une tonalit?
TestEngine.114=S'il vous plat levez la tte d'impression et appuyez sur OK.
TestEngine.115=S'il vous plat moins la tte d'impression et appuyez sur OK.
TestEngine.116=S'il vous plat appuyez sur le bouton de saut, puis appuyez sur OK.
TestEngine.117=Les mdias ont l'impression de pointe correctement?
TestEngine.118=12. Appuyez sur Avance/Enter pour entrer dans le menu Action.\n
TestEngine.119=13. Appuyez sur Avance/Enter pour entrer dans le menu Paramtres (Settings).\n
TestEngine.11=]. Le test de la batterie a chou.
TestEngine.120=14. Appuyez sur Avance/Enter deux fois pour enregistrer les paramtres.\n
TestEngine.121=15. Vrifiez cran LCD indique 'Settings Saved'.\n
TestEngine.122=16. Appuyez sur le bouton gauche jusqu' ce que dit LCD 'Ready'.\n\n\n
TestEngine.123=S'il vous plat Note: un cycle d'alimentation de cette imprimante avec le bouton FEED\nenfonce pour imprimer l'tiquette Test personnalis une fois l'unit passe.
TestEngine.124=La qualit de l'impression est-elle acceptable ?\nS'il vous plat utilisez un lecteur de code  barres.
TestEngine.125=Bluetooth
TestEngine.126=Se il vous plat valid que vous avez couplTestEngine.127=sur
TestEngine.128=puis appuyez sur OK pour continuer.
TestEngine.12=Le contrle du ton a chou.
TestEngine.129=Please replace the media with security media.\nMake sure that the media is loaded properly.\nPress OK to continue.TestEngine.13=Impossible d'excuter un test si aucune mthode de communication n'a t slectionne.
TestEngine.14=Impossible d'tablir une connexion primaire du type
TestEngine.16=Le numro de modle actuel de l'imprimante est
TestEngine.17=Le numro du modle de test est
TestEngine.18=Voulez-vous modifier le numro du modle de l'imprimante?
TestEngine.19=Impossible de se connecter  la base de donnes. Voulez-vous continuer sans nouvel ID de l'imprimante?
TestEngine.1=Le numro du modle est invalide.
TestEngine.20=Entrez s.v.p. un numro de srie valide.
TestEngine.21=Entrez s.v.p. une adresse MAC valide.
TestEngine.22=Le rglage du comptage en pouces  0 a chou; la valeur actuelle est
TestEngine.23=chec du rglage du numro de srie sur
TestEngine.24=chec du rglage du numro du modle sur
TestEngine.25=chec du rglage de MAC sur
TestEngine.26=; la valeur actuelle estTestEngine.28=chec du chargement CPR pour \n
TestEngine.29=Impossible d'envoyer le fichier CPR
TestEngine.2=Le firmware a besoin d'une mise  jour :\n
TestEngine.30=L'imprimante a-t-elle procd  un indexage correct pour le mode
TestEngine.31=Veuillez s.v.p. installer un ruban puis appuyer sur OK
TestEngine.32=chec du calibrage pour
TestEngine.33=Chargement du papier
TestEngine.34=Veuillez soulever s.v.p. la tte d'impression.
TestEngine.35=Le signal Tte en haut n'a pas t dtect. Le test a chou.
TestEngine.36=Veuillez charger s.v.p. du papier puis abaisser la tte d'impression.
TestEngine.37=Impossible d'obtenir l'tiquette du modle pour obtenir un test depuis la mmoire des donnes.
TestEngine.38=Impossible de construire ressource d'tiquette pour le support
TestEngine.39=Impossible de construire ressource d'tiquette pour la densit de l'impression
TestEngine.3=Version actuelle:TestEngine.40=Impossible de trouver l'tiquette de test [
TestEngine.41=] dans la mmoire des donnes.
TestEngine.46=Voyez-vous un froissement du ruban?
TestEngine.47=Scannage de qualit
TestEngine.48=Veuillez scanner s.v.p. le dernier code  barres imprim pour la qualit.
TestEngine.49=Impossible de se connecter au scanner.
TestEngine.4=Version de la mmoire des donnes:TestEngine.50=Impossible de fermer la connexion au scanner.
TestEngine.51=Impossible d'obtenir le rsultat du scannage.
TestEngine.52=Le scanner indique un faible niveau de qualit [
TestEngine.53=].\n\nFaites un nouvel essai s.v.p.
TestEngine.54=La qualit de l'impression est-elle acceptable ?
TestEngine.55=La connexion parallle a chou.
TestEngine.56=chec du rglage de l'adresse IP sur
TestEngine.57=; la valeur actuelle estTestEngine.58=Test de connectivit
TestEngine.59=Parallle
TestEngine.5=Voulez-vous procder  une mise  jour du firmware?
TestEngine.60=Rseau
TestEngine.61=Sriel
TestEngine.62=Impossible de fermer la connexion actuelle de l'imprimante.
TestEngine.64=USB
TestEngine.67=Impossible de rtablir la connexion primaire.
TestEngine.6=Impossible de trouver le firmware [
TestEngine.70=USB-A
TestEngine.71=Introduire la cl USB de test dans le port USB-A de l'imprimante.
TestEngine.72=Veuillez retirer s.v.p. le stick mmoire puis appuyer sur OK.
TestEngine.73=Le test USB-A a chou.
TestEngine.74=Impossible de dtecter automatiquement une tte d'impression de srie C.
TestEngine.75=Test de l'absence de papier
TestEngine.76=En attente du signal d'absence de papier.\nAppuyez s.v.p. sur le bouton d'avancement de feuille.
TestEngine.77=chec du capteur d'absence de papier.
TestEngine.78=Impossible d'tablir une connexion vers l'imprimante au niveau de "
TestEngine.79=Slection du cble d'alimentation
TestEngine.7=La mise  jour du firmware est termine.
TestEngine.80=Cble d'alimentation U.S.
TestEngine.81=Cble d'alimentation U.E./UK
TestEngine.82=Veuillez faire passer le support d'impression  travers la peleuse\net appuyer sur OK quand il est prt.
TestEngine.83=Le signal Patienter n'a pas t reu depuis l'imprimante. Le test a chou.
TestEngine.84=Appuyez sur OK puis retirez l'tiquette.
TestEngine.85=Le signal Prt n'a pas t reu depuis l'imprimante. Le test a chou.
TestEngine.86=Veuillez retirer le support d'impression de la peleuse\net appuyer sur OK quand c'est prt.
TestEngine.87=S'il vous plat consulter cran de l'imprimante afin de vrifier ce qui suit:\n\n
TestEngine.88=1.  Appuyez sur le bouton droit (bouton d'alimentation non) pour accder au menu principal.\n
TestEngine.89=2.  Appuyez sur le bouton Bas.\n
TestEngine.8=La mise  jour du firmware a chou.
TestEngine.90=3.  Appuyez sur Avance/Enter pour entrer dans Configuration de l'imprimante (Printer Setup).\n
TestEngine.91=4.  Appuyez sur le bouton Bas.\n
TestEngine.92=5.  Appuyez sur Avance/Enter pour entrer dans le menu Matriel (Hardware).\n
TestEngine.93=6.  Appuyez sur Avance/Enter pour entrer dans le menu Contraste LCD.\n
TestEngine.94=7.  Faites des changements de contraste en utilisant boutons Monter et Descendre.\n
TestEngine.95=8.  Appuyez sur Avance/Enter pour enregistrer le rglage du contraste.\n
TestEngine.96=9.  Vrifiez cran LCD indique 'Value Has Been Set'.\n
TestEngine.97=10. Appuyez sur le bouton gauche deux fois pour obtenir au menu principal.\n
TestEngine.98=11. Appuyez sur le bouton Bas  deux reprises.\n
TestEngine.99=Le tableau de commande fonctionne-t-il correctement?
TestEngine.9=Erreur  la fermeture de la connexion de l'imprimante pendant le test de la batterie.
```
## File: JAdmin/src/com/cognitive/admin/Messages.java
```java
public class Messages
{
private static final String BUNDLE_NAME="com.cognitive.admin.messages";
private static final Locale locale=Locale.getDefault();
private static final ResourceBundle RESOURCE_BUNDLE=ResourceBundle
.getBundle(BUNDLE_NAME, locale);
private Messages()
{
}
public static String getString(String key)
{
try
{
return RESOURCE_BUNDLE.getString(key);
}
catch(MissingResourceException e)
{
return '!'+key+'!';
}
}
}
```
## File: JAdmin/src/com/cognitive/admin/messages.properties
```
General.0=Apply
General.1=Refresh
CompositeAbout.0=Firmware:
CompositeAbout.1=Fonts:
CompositeAbout.2=Labels:
CompositeAbout.3=Drivers:
CompositeAbout.4=Documentation:
CompositeAbout.5=Phone
CompositeAbout.6=Copyright
CompositeAbout.7=All Rights Reserved.
CompositeAbout.8=Cognitive Printer Administrator
CompositeCPLEditor.0=Printer Input
CompositeCPLEditor.10=Timer Settings
CompositeCPLEditor.11=Interval (secs):
CompositeCPLEditor.12=Repeat:
CompositeCPLEditor.13=Current:
CompositeCPLEditor.14=Start
CompositeCPLEditor.15=Pause
CompositeCPLEditor.16=Resume
CompositeCPLEditor.17=Stop
CompositeCPLEditor.18=Error reading file
CompositeCPLEditor.19=Error sending CPL to printer:CompositeCPLEditor.1=Printer Output
CompositeCPLEditor.20=Send File To Printer
CompositeCPLEditor.21=Error sending File to printer:
CompositeCPLEditor.2=Open File
CompositeCPLEditor.3=Save To File
CompositeCPLEditor.4=Clear
CompositeCPLEditor.5=Send To Printer
CompositeCPLEditor.6=View Variables
CompositeCPLEditor.7=View Time
CompositeCPLEditor.8=Save Output
CompositeCPLEditor.9=Clear Output
CompositeConnectionSettings.0=Disconnect
CompositeConnectionSettings.10=Use Serial Connection
CompositeConnectionSettings.11=Com Port:
CompositeConnectionSettings.12=Baud Rate:
CompositeConnectionSettings.13=System Printer Connection
CompositeConnectionSettings.14=Printer Name:
CompositeConnectionSettings.15=Use Network Connection
CompositeConnectionSettings.16=IP Address:
CompositeConnectionSettings.17=Port:
CompositeConnectionSettings.18=Dumb Terminal
CompositeConnectionSettings.1=Unable to connect. Please check your settings.
CompositeConnectionSettings.20=Print Test Label
CompositeConnectionSettings.21=Connection Parameters
CompositeConnectionSettings.22=Serial Connection
CompositeConnectionSettings.23=Baud Rate:
CompositeConnectionSettings.24=Buffer Size:
CompositeConnectionSettings.25=Buffer Overflow:
CompositeConnectionSettings.28=Network Connection
CompositeConnectionSettings.29=IP Address:
CompositeConnectionSettings.30=Net Mask:
CompositeConnectionSettings.31=Gateway:
CompositeConnectionSettings.32=RTEL Port Number:
CompositeConnectionSettings.33=Buffer Size:
CompositeConnectionSettings.34=You might loose your Network Connection.\nPlease restart the printer.
CompositeConnectionSettings.35=Use Parallel Connection
CompositeConnectionSettings.36=LPT Port:
CompositeConnectionSettings.37=Note: The usage of the parallel connection is limited\nand works with newer printers only.
CompositeConnectionSettings.38=Stop Bits:
CompositeConnectionSettings.39=Use USB Direct Connection
CompositeConnectionSettings.3=Connect
CompositeConnectionSettings.40=Note: If an Ethernet Setting\nis changed, Reboot the printer\nbefore attempting to reconnect.
CompositeConnectionSettings.41=Use Bluetooth Connection
CompositeConnectionSettings.42=Is Bluetooth
CompositeConnectionSettings.4=Unable to close printer connection. Please close this application.
CompositeConnectionSettings.5=Not Implemented.
CompositeConnectionSettings.6=Error:CompositeConnectionSettings.9=Connection Type
CompositeFirmwareCPR.0=File Open error.
CompositeFirmwareCPR.10=New Image:
CompositeFirmwareCPR.11=Update Progress:
CompositeFirmwareCPR.12=Download Complete
CompositeFirmwareCPR.13=Firmware Update failed. Aborting.
CompositeFirmwareCPR.14=Firmware Update Cancelled.
CompositeFirmwareCPR.15=Font Download failed. Aborting.
CompositeFirmwareCPR.16=Font Download Cancelled.
CompositeFirmwareCPR.17=Firmware Download has Completed successfully.\nPress OK to continue with downloading fonts.
CompositeFirmwareCPR.18=You already have the latest Firmware.\nDo you wish to continue with downloading fonts?
CompositeFirmwareCPR.19=You now have the latest Firmware and Fonts.
CompositeFirmwareCPR.1=Can't read firmware image file:CompositeFirmwareCPR.20=No updates available.
CompositeFirmwareCPR.21=Please select Firmware File.
CompositeFirmwareCPR.22=Please Note: After Changing Firmware or Fonts it is suggested that the printer and this application be shut down and restarted.
CompositeFirmwareCPR.23=We do not recommend downloading to an earlier (or lower) version of firmware.\nIn some cases, this could render the printer inoperable.\nPlease contact our customer service prior to attempting any download of older firmware into the printer.
CompositeFirmwareCPR.2=Current Firmware:
CompositeFirmwareCPR.3=Part Number:
CompositeFirmwareCPR.4=Version Number:
CompositeFirmwareCPR.5=Release Date:
CompositeFirmwareCPR.6=Upgrade Firmware:
CompositeFirmwareCPR.7=Select Firmware File
CompositeFirmwareCPR.8=Get Latest Firmware from Cognitive
CompositeFirmwareCPR.9=Update Firmware
CompositeFontsAndObjects.0=Send Objects to Printer
CompositeFontsAndObjects.10=Object download error
CompositeFontsAndObjects.11=Error reading fileCompositeFontsAndObjects.12=Please Note: After Saving/Sending Objects or Fonts to the printer it is suggested that the printer and this application be shut down and restarted.
CompositeFontsAndObjects.1=Delete Selected Objects
CompositeFontsAndObjects.3=Name
CompositeFontsAndObjects.4=Type
CompositeFontsAndObjects.5=Storage
CompositeFontsAndObjects.6=Size
CompositeFontsAndObjects.7=Description
CompositeFontsAndObjects.8=File Open error.
CompositeFontsAndObjects.9=Object download error
CompositeLabelPositioning.0=Print Width (Inches):
CompositeLabelPositioning.10=Indexing
CompositeLabelPositioning.11=Indexing On
CompositeLabelPositioning.12=Bar
CompositeLabelPositioning.14=Gap
CompositeLabelPositioning.15=Calibrate
CompositeLabelPositioning.16=Notch
CompositeLabelPositioning.17=Calibration Successful
CompositeLabelPositioning.18=Label Presentation
CompositeLabelPositioning.19=Enable Label Presentation
CompositeLabelPositioning.20=Advance:
CompositeLabelPositioning.22=Retract:
CompositeLabelPositioning.23=Time:
CompositeLabelPositioning.24=Shift Left moves the image leftward across the\nlabelfrom the printer's point-of-view, i.e. to the\nright from this point-of-view.
CompositeLabelPositioning.25=Shift-Left (Hundredths of an Inch):
CompositeLabelPositioning.26=TOF Adjustment (Motor Steps):
CompositeLabelPositioning.28=Top-of-Form Adjustment moves\nthe label's top margin down the\npage, which may appear as 'up'\nfrom this point-of-view.
CompositeLabelPositioning.29=Invalid feed-type selected.
CompositeLabelPositioning.31=Received invalid feed type from printer:
CompositeLabelPositioning.32=Calibration Successful
CompositeLabelPositioning.33=Calibration Failed
CompositeLabelPositioning.35=Print Test Label
CompositeLabelPositioning.5=Enable Auto-Recalibration
CompositeLabelPositioning.7=Enable Automatic TOF
CompositeLabelPositioning.9=Label
CompositeManufacturing.0=Start
CompositeManufacturing.10=Backup Memory Test
CompositeManufacturing.11=Printer Identification
CompositeManufacturing.12=Ribbon Wrinkle
CompositeManufacturing.13=Final Settings
CompositeManufacturing.14=CPR Download
CompositeManufacturing.15=Font Loading
CompositeManufacturing.16=Calibration and Indexing
CompositeManufacturing.17=Print-head Up/Down
CompositeManufacturing.18=Print Quality
CompositeManufacturing.19=Print-Head Test
CompositeManufacturing.1=Enable PCL
CompositeManufacturing.20=Self-Test
CompositeManufacturing.21=Shipping Label Printing
CompositeManufacturing.22=Unit Under Test:
CompositeManufacturing.23=Board Test
CompositeManufacturing.24=Serial Number:
CompositeManufacturing.25=MAC Address:
CompositeManufacturing.26=Prompt for firmware download
CompositeManufacturing.27=Specify SN&&MAC
CompositeManufacturing.28=Serial Port:CompositeManufacturing.29=Parallel Port:
CompositeManufacturing.2=Initial Setup
CompositeManufacturing.30=IP Address:CompositeManufacturing.31=Windows Printer Name:
CompositeManufacturing.32=Print-head:
CompositeManufacturing.33=Peripherals:
CompositeManufacturing.34=Scanner:CompositeManufacturing.35=S/N Label Printer:
CompositeManufacturing.36=Box Label Printer:CompositeManufacturing.37=Auto-detect (DLX only)
CompositeManufacturing.38=Unit Passed.
CompositeManufacturing.39=Test failed. Aborting.
CompositeManufacturing.3=Firmware Load
CompositeManufacturing.40=Test Cancelled.
CompositeManufacturing.41=Can't close printer connection.\n\n
CompositeManufacturing.42=Unknown location code.
CompositeManufacturing.43=Print Serial Number Label
CompositeManufacturing.44=Print Box Label
CompositeManufacturing.45=Model Number:
CompositeManufacturing.46=Scan
CompositeManufacturing.47=Ensure the printer is turned on and that\nall interfaces to be tested are connected.\n\nThe Power and Ready lights should be green and the paper should be loaded.\n\nCheck all the boxes for the interfaces to be tested.\n\nDo NOT load ribbon into the printer at this time.
CompositeManufacturing.48=Ensure the printer is turned on and that\nall interfaces to be tested are connected.\n\nThe Power and Ready lights should be green.\n\nEnable current limit on the test fixture.
CompositeManufacturing.49=Skip Load
CompositeManufacturing.4=Control Panel
CompositeManufacturing.50=TallyGenicom
CompositeManufacturing.51=Feed Button Test
CompositeManufacturing.52=Disable current limit on the test fixture.
CompositeManufacturing.53=USB Direct ConnectCompositeManufacturing.54=Disable Licenses
CompositeManufacturing.55=Bluetooth COM Port:
CompositeManufacturing.56=Is Bluetooth
CompositeManufacturing.5=Connection Interfaces
CompositeManufacturing.6=Paper-out Check
CompositeManufacturing.7=Peeler Test
CompositeManufacturing.8=RTC Setup
CompositeManufacturing.9=Tone Check
CompositePCLWindowing.0=Print PCL File
CompositePCLWindowing.15=Label Window Parameters
CompositePCLWindowing.16=Always make these measurements with the paper viewed\nin portrait orientation, even if the label text is in landscape\norientation.
CompositePCLWindowing.17=Label Origin (Inches):
CompositePCLWindowing.18=Select PCL File
CompositePCLWindowing.19=Send to Printer
CompositePCLWindowing.1=Send PJL to Printer
CompositePCLWindowing.20=Can't generate PJL with the given parameters.
CompositePCLWindowing.22=Can't open fileCompositePCLWindowing.2=Load PJL File
CompositePCLWindowing.3=Save PJL File
CompositePCLWindowing.4=Actual:
CompositePCLWindowing.5=Label Width (Inches):
CompositePCLWindowing.7=Label Length (Inches):
CompositePrinterSettings.0=Print Speed:
CompositePrinterSettings.10=Media Adjust:
CompositePrinterSettings.12=Pitch:
CompositePrinterSettings.14=Time (hh:mm:ss, 24-hour clock):
CompositePrinterSettings.16=Date (mm/dd/yy):
CompositePrinterSettings.19=Print Test Label
CompositePrinterSettings.20=Primary Language
CompositePrinterSettings.21=Thermal PCL
CompositePrinterSettings.22=Eltron-compatible Programming Language
CompositePrinterSettings.23=Zebra-compatible Programming Language
CompositePrinterSettings.24=Cognitive Programming Language
CompositePrinterSettings.26=Thermal Mode
CompositePrinterSettings.27=Direct Thermal
CompositePrinterSettings.28=Thermal Transfer
CompositePrinterSettings.2=No-Media-Out (Inches):
CompositePrinterSettings.32=None
CompositePrinterSettings.33=Serial
CompositePrinterSettings.34=Serial&Label
CompositePrinterSettings.35=Invalid report level selected:
CompositePrinterSettings.43=Can't translate debug report level--printer sends level:
CompositePrinterSettings.45=Low
CompositePrinterSettings.46=Normal
CompositePrinterSettings.47=High
CompositePrinterSettings.48=Invalid speed selected
CompositePrinterSettings.49=Custom
CompositePrinterSettings.4=Debug Report Level:
CompositePrinterSettings.59=Invalid speed received from printer:CompositePrinterSettings.61=Invalid pitch received from printer:
CompositePrinterSettings.62=Invalid time format.
CompositePrinterSettings.63=Invalid date format.
CompositePrinterSettings.64=Invalid language selected
CompositePrinterSettings.65=Available only on PCL-enabled printers
CompositePrinterSettings.66=Invalid mode selected
CompositePrinterSettings.67=Darkness
CompositePrinterSettings.68=Enter the date according to the format customary for your locale, i.e. mm/dd/yy or dd.mm.yy
CompositePrinterSettings.69=Bad date format.
CompositePrinterSettings.6=Auxiliary Power On
CompositePrinterSettings.8=Enable Automatic Reprint
CompositeProfileManagement.0=Printer Profile
CompositeProfileManagement.1=Profile Sent.
CompositeProfileManagement.2=Open Stored Profile
CompositeProfileManagement.3=Get Printer's Current Profile
CompositeProfileManagement.4=Save Profile to File
CompositeProfileManagement.5=Apply Profile to Printer
CompositeProfileManagement.6=Error reading file
CompositeRepair.0=Update not needed.
CompositeRepair.11=This printer does not exist in the database.
CompositeRepair.12=Renew Serial Number&&MAC
CompositeRepair.13=K to D
CompositeRepair.1=Update failed.
CompositeRepair.2=Update successeded.
CompositeRepair.3=Serial number fixer: K to D
CompositeRepair.4=Unknown location code.
CompositeRepair.5=Can't get new SN/MAC pair from database.
CompositeRepair.6=Can't set new SN/MAC pair on printer.
CompositeRepair.7=Model Number:
CompositeRepair.8=Serial Number:
CompositeRepair.9=MAC:
Configurator.0=Skipping doc install for manufacturing system.
Configurator.1=Performing doc install for default system.
Configurator.2=New documentation installed in\n\n
Configurator.3=You may run the cleaning routine in the future by executing\n
Configurator.4=Installing...
Configurator.5=New drivers installed in\n\n
Configurator.6=\n\nWe recommend running a driver-cleanup routine at this time.\n\nWould you like to do this now?
FirmwareUpdater.0=Error during firmware download:FirmwareUpdater.1=\n\n\nYou might need to restart the printer.
FirmwareUpdater.2=An error occured while downloading the firmware image. Please restart the printer and try again.
GUIHelper.0=Can't set-and-get [
GUIHelper.10=Vector font
GUIHelper.11=Custom font
GUIHelper.12=Exec code
GUIHelper.13=Bitmap font
GUIHelper.14=System file
GUIHelper.15=Graphic file
GUIHelper.16=Enhanced format
GUIHelper.17=Reserved linefeed
GUIHelper.18=Double byte table
GUIHelper.19=Reserved format
GUIHelper.1=Can't get [
GUIHelper.20=Reserved CR
GUIHelper.21=Double byte font
GUIHelper.22=Menu
GUIHelper.23=Variable
GUIHelper.24=Menu control
GUIHelper.25=Sato true type
GUIHelper.26=AGFA IF
GUIHelper.27=EPL2 Format
GUIHelper.28=EPL2 Soft Font
GUIHelper.29=ZPL2 Graphic
GUIHelper.2=Can't set [
GUIHelper.30=ZPL2 Format
GUIHelper.31=ZPL2 Font
GUIHelper.32=EPL2 Graphic
GUIHelper.33=PCL Bitmap Font
GUIHelper.34=PCL TrueType Font
GUIHelper.35=ObjectGUIHelper.36=Error reading objects from printer:
GUIHelper.37=Can't open file
GUIHelper.4=File not found.
GUIHelper.5=File save failed.
GUIHelper.6=Error writing file
GUIHelper.7=Compressed bitmap font
GUIHelper.8=Unused
GUIHelper.9=Format data
MainShell.0=Connected
MainShell.10=PCL Windowing
MainShell.11=Script Editor
MainShell.12=Repair
MainShell.13=Manufacturing Test
MainShell.14=Location Code in preferences file is invalid.\nManufacturing tab will not be activated.
MainShell.15=About
MainShell.16=Printer Status
MainShell.17=Heartbeat
MainShell.19=\n\nYou might need to restart the printer and/or this application.
MainShell.20=Manufacturing Test
MainShell.21=Cognitive Printer Administrator v
MainShell.2=Disconnected
MainShell.3=Unknown
MainShell.4=Connection Settings
MainShell.5=Printer Settings
MainShell.6=Label Positioning
MainShell.7=Fonts and Objects
MainShell.8=Profile Management
MainShell.9=Firmware Upgrade
PrinterHelper.0=Socket connection broken. Printer is disconnected.
PrinterHelper.1=Can't print test label:\n
PrinterHelper.2=Can't set-and-get variable [
PrinterHelper.3=Can't set variable [
PrinterHelper.4=Can't send.
PrinterHelper.6=No response for command [
PrinterHelper.7=Can't get variable [
PrinterHelper.8=Top of Form Adjustment:PrinterHelper.9=Shift Left Adjustment:
TestEngine.0=Invalid model number.
TestEngine.100=Can't connect to unit under test.
TestEngine.101=Can't auto-detect C Series print-head.
TestEngine.103=Could not enable PCL.
TestEngine.104=PASSED
TestEngine.105=FAILED
TestEngine.106=SKIPPED
TestEngine.107=CANCELLED
TestEngine.108=No Power Cord
TestEngine.109=You Should see the Ready Light turn Red and then Green,\nthen Red again for a split second, and finally steady Green again.\nThis will take a while. Once the light turns and stays green for more than 5 seconds press OK.
TestEngine.10=Invalid inch-count [
TestEngine.110=Waiting for paper-out signal.\nPlease press the form-feed button and then press OK.
TestEngine.111=Please turn the printer off and unplug all the cables.\nWait 5 seconds, then reconnect the printer using just the primary connection
TestEngine.112=Turn the printer back on and press OK when the printer is ready.
TestEngine.113=Do you hear a tone?
TestEngine.114=Please raise the print-head and press OK.
TestEngine.115=Please lower the print-head and press OK.
TestEngine.116=Please press the form-feed button and then press OK.
TestEngine.117=Did the print-media advanced correctly?
TestEngine.118=12. Press Feed/Enter button to enter Action Menu.\n
TestEngine.119=13. Press Feed/Enter button to enter Settings Menu.\n
TestEngine.11=]. Battery test failed.
TestEngine.120=14. Press Feed/Enter button twice to save settings.\n
TestEngine.121=15. Verify LCD says 'Settings Saved'.\n
TestEngine.122=16. Press Left button until LCD says 'Ready'.\n\n\n
TestEngine.123=Please Note: Power cycle this printer with FEED button\npressed to print Custom Test Label once the unit passes.
TestEngine.124=Is the print quality acceptable?\nPlease use barcode reader.
TestEngine.125=Bluetooth
TestEngine.126=Please validate that you have pairedTestEngine.127=on
TestEngine.128=and then press OK to continue.
TestEngine.129=Please replace the media with security media.\nMake sure that the media is loaded properly.\nPress OK to continue.TestEngine.12=Tone-check failed.
TestEngine.13=Can't run a test with no communication methods selected.
TestEngine.14=Can't establish primary connection of typeTestEngine.16=Printer's current model number is
TestEngine.17=Test model number isTestEngine.18=Do you want to change the printer's model number?
TestEngine.19=Can't connect to database. Continue without new printer ID?
TestEngine.1=Invalid model number.
TestEngine.20=Please enter a valid serial number.
TestEngine.21=Please enter a valid MAC address.
TestEngine.22=Failed setting inch-count to 0; current value isTestEngine.23=Failed setting serial number to
TestEngine.24=Failed setting model number toTestEngine.25=Failed setting MAC to
TestEngine.26=; current value isTestEngine.28=CPR Loading failed for \n
TestEngine.29=Can't Send CPR fileTestEngine.2=Firmware needs updating:\n
TestEngine.30=Did the printer index correctly for modeTestEngine.31=Please load ribbon, then press OK
TestEngine.32=Calibration failed forTestEngine.33=Paper Loading
TestEngine.34=Please raise the print-head.
TestEngine.35=Did not detect Head-Up signal. Test failed.
TestEngine.36=Please lower the print-head.
TestEngine.37=Couldn't get get test pattern label from data-store.
TestEngine.38=Can't construct label resource for mediaTestEngine.39=Can't construct label resource for print density
TestEngine.3=Current version:TestEngine.40=Can't find test label [
TestEngine.41=] in data-store.
TestEngine.46=Do you see ribbon wrinkle?
TestEngine.47=Quality Scan
TestEngine.48=Please scan the last barcode printed for quality.
TestEngine.49=Can't connect to scanner
TestEngine.4=Data-store version:TestEngine.50=Can't close scanner connection.
TestEngine.51=Can't get scan result.
TestEngine.52=Scanner reports poor quality grade [
TestEngine.53=].\n\nPlease try again.
TestEngine.54=Is the print quality acceptable?
TestEngine.55=Parallel connection failed.
TestEngine.56=Failed setting IP address toTestEngine.57=; current value is
TestEngine.58=Testing Connectivity
TestEngine.59=Parallel
TestEngine.5=Would you like to do a firmware upgrade?
TestEngine.60=Network
TestEngine.61=Serial
TestEngine.62=Unable to close current printer connection.
TestEngine.64=USB
TestEngine.67=Unable to re-establish primary connection.
TestEngine.6=Can't find firmware [
TestEngine.70=USB-A
TestEngine.71=Insert the test USB key into the printer's USB-A port.
TestEngine.72=Please remove the memory stick, then press OK.
TestEngine.73=USB-A Test failed.
TestEngine.74=Can't auto-detect C Series print-head.
TestEngine.75=Paper-out Test
TestEngine.76=Waiting for paper-out signal.\nPlease press the form-feed button.
TestEngine.77=Paper-out sensor failed.
TestEngine.78=Can't establish connection to printer at "
TestEngine.79=Power Cord Selection
TestEngine.7=Updating firmware complete.
TestEngine.80=U.S. Power Cord
TestEngine.81=EU/UK Power Cord
TestEngine.82=Please thread the print-media through the peeler\nand press OK when ready.
TestEngine.83=Did not receive Wait signal from the printer. Test failed.
TestEngine.84=Press OK, then remove the label.
TestEngine.85=Did not receive Ready signal from the printer. Test Failed
TestEngine.86=Please un-thread the print-media from the peeler\nand press OK when ready.
TestEngine.87=Please view Printer LCD to verify the following:\n\n
TestEngine.88=1.  Press Right button (not Feed button) to enter Main Menu.\n
TestEngine.8=Firmware update failed.
TestEngine.89=2.  Press Down button.\n
TestEngine.90=3.  Press Feed/Enter button to enter Printer Setup.\n
TestEngine.91=4.  Press Down button.\n
TestEngine.92=5.  Press Feed/Enter button to enter Hardware Menu.\n
TestEngine.93=6.  Press Feed/Enter button to enter LCD Contrast Menu.\n
TestEngine.94=7.  Make contrast changes using Up and Down buttons.\n
TestEngine.95=8.  Press Feed/Enter to save contrast setting.\n
TestEngine.96=9.  Verify LCD says 'Value Has Been Set'.\n
TestEngine.97=10. Press Left button twice to get to Main Menu.\n
TestEngine.98=11. Press Down button twice.\n
TestEngine.99=Does the control panel function correctly?
TestEngine.9=Error closing printer connection during battery test.
```
## File: JAdmin/src/com/cognitive/admin/PrinterHelper.java
```java
public class PrinterHelper
{
static void handleSocketException(SocketException e)
{
GUIHelper.error(Messages.getString("PrinterHelper.0"));
GUIHelper.logger.error(e, e);
try
{
printer.closeConnection();
}
catch(Exception anotherException)
{
}
GUIHelper.mainShell.setConnectionState(false, false);
throw new NullPointerException("12345DISCONNECT54321");
}
public static void printTestLabel(String tof, String shiftLeft, String message)
{
GUIHelper.logger.trace("");
boolean isWingman=false;
boolean isTallyGenicom=false;
boolean isTallyDascom=false;
boolean isLX=false;
int printDensity=200;
int mediaWidth=2;
if(TestEngine.runningManufacturing&&TestEngine.isConnectionTypeParallelOnly)
{
isWingman=TestEngine.isWingman;
isTallyDascom=TestEngine.isTDModelNumber;
isTallyGenicom=TestEngine.isTGModelNumber;
printDensity=TestEngine.printDensity;
mediaWidth=TestEngine.mediaWidth;
isLX=TestEngine.isLX;
}
else
{
String mn=com.cognitive.printer.Printer.modelNumber;
isLX=mn.startsWith("LB");
String cname=GUIHelper.clean(commandWaitResponse("!SHOW OEMIDENTIFIER"));
if(mn.startsWith("DB"))
{
if(mn.charAt(11)=='Z')
{
isWingman=true;
}
}
if(cname.equalsIgnoreCase("TALLYDASCOM"))
{
isTallyDascom=true;
}
else if(cname.equalsIgnoreCase("TALLYGENICOM"))
{
isTallyGenicom=true;
}
}
StringBuffer label=new StringBuffer();
if(!isWingman)
{
if(isLX)
{
label.append("!");
}
label.append("!0 100 200 1\n");
label.append("INDEX\n");
label.append("END\n");
}
else
{
label.append("N\nP1\n");
}
send(label.toString());
label=new StringBuffer();
String width="";
String pitch="";
if(TestEngine.runningManufacturing&&TestEngine.isConnectionTypeParallelOnly)
{
if(mediaWidth==2)
{
width="220";
}
else
{
width="409";
}
pitch=""+printDensity;
}
else
{
width=getVariable("WIDTH");
if(width==null)
{
return;
}
pitch=getVariable("PITCH");
if(pitch==null)
{
return;
}
}
width=GUIHelper.getMatch(width, "\\d+");
float fWidth=Float.parseFloat(width);
int iPitch=Integer.parseInt(pitch);
int iDots=(int)(fWidth/100*iPitch);
String widthDots=Integer.toString(iDots);
String companyName="COGNITIVE TPG";
if(isTallyDascom)
{
companyName="TALLY DASCOM";
}
else if(isTallyGenicom)
{
companyName="TALLYGENICOM";
}
if(!isWingman)
{
if(isLX)
{
label.append("!");
}
label.append("!0 100 250 1\n");
label.append("DRAW_BOX 0 0 "+widthDots+" 2 3\n");
label.append("DRAW_BOX 0 0 2 200 3\n");
label.append("U B24 (3,0,0) 20 20 "+companyName+"\n");
label.append("U B24 (3,0,0) 20 60 Test Page\n");
}
else
{
label.append("N\n");
label.append("A20,20,0,1,1,1,N,\"COGNITIVE TPG\"\n");
label.append("A20,60,0,1,1,1,N,\"Test Page\"\n");
}
if(tof!="")
{
if(!isWingman)
{
label.append("U B24 (3,0,0) 20 100 "+Messages.getString("PrinterHelper.8")+tof+"\n");
}
else
{
label.append("A20,100,0,1,1,1,N,\""+Messages.getString("PrinterHelper.8")+tof+"\"\n");
}
}
if(shiftLeft!="")
{
if(!isWingman)
{
label.append("U B24 (3,0,0) 20 140 "+Messages.getString("PrinterHelper.9")+shiftLeft+"\n");
}
else
{
label.append("A20,140,0,1,1,1,N,\""+Messages.getString("PrinterHelper.9")+shiftLeft+"\"\n");
}
}
if(message!="")
{
if(!isWingman)
{
label.append("U B24 (3,0,0) 20 180 "+message+"\n");
}
else
{
label.append("A20,180,0,1,1,1,N,\""+message+"\"\n");
}
}
if(!isWingman)
{
label.append("END\n");
}
else
{
label.append("X0,0,3,"+widthDots+",2\n");
label.append("X0,0,3,2,200\n");
label.append("P1\n");
}
send(label.toString());
}
public static void printSelfTestLabel()
{
try
{
send("!PRINT TESTLABEL");
send("!L");
}
catch(Exception e)
{
GUIHelper.error(Messages.getString("PrinterHelper.1")+e.toString());
}
}
public static String setAndGetVariable(String variable, String value)
{
GUIHelper.logger.trace(variable+" : "+value);
String retVal=null;
try
{
GUIHelper.setCursor(SWT.CURSOR_WAIT);
retVal=printer.setAndGetVariable(variable, value);
}
catch(SocketException e)
{
handleSocketException(e);
}
catch(Exception e)
{
GUIHelper.error(Messages.getString("PrinterHelper.2")+variable+"].");
GUIHelper.logger.error(e, e);
return null;
}
finally
{
GUIHelper.setCursor(0);
}
return retVal;
}
public static void setVariable(String variable, String value)
{
GUIHelper.logger.trace(variable+" : "+value);
try
{
GUIHelper.setCursor(SWT.CURSOR_WAIT);
printer.setVariable(variable, value);
}
catch(SocketException e)
{
handleSocketException(e);
}
catch(Exception e)
{
GUIHelper.error(Messages.getString("PrinterHelper.3")+variable+"].\n\n"+e);
GUIHelper.logger.error(e, e);
}
finally
{
GUIHelper.setCursor(0);
}
}
public static void send(byte[] data)
{
GUIHelper.logger.trace("");
try
{
GUIHelper.setCursor(SWT.CURSOR_WAIT);
printer.send(data);
}
catch(SocketException e)
{
handleSocketException(e);
}
catch(Exception e)
{
GUIHelper.error(Messages.getString("PrinterHelper.4"));
GUIHelper.logger.error(e, e);
}
finally
{
GUIHelper.setCursor(0);
}
}
public static void send(String data)
{
GUIHelper.logger.trace(data);
try
{
GUIHelper.setCursor(SWT.CURSOR_WAIT);
printer.send(data+"\n");
}
catch(SocketException e)
{
handleSocketException(e);
}
catch(Exception e)
{
GUIHelper.error(Messages.getString("PrinterHelper.4"));
GUIHelper.logger.error(e, e);
}
finally
{
GUIHelper.setCursor(0);
}
}
public static String commandWaitResponse(String command)
{
GUIHelper.logger.trace(command);
String retVal=null;
try
{
GUIHelper.setCursor(SWT.CURSOR_WAIT);
retVal=printer.commandWaitResponse(command+"\n");
}
catch(SocketException e)
{
handleSocketException(e);
}
catch(Exception e)
{
command=(command.replace('\n', ' ')).replace('\r', ' ').trim();
GUIHelper.error(Messages.getString("PrinterHelper.6")+command+"].");
GUIHelper.logger.error(e, e);
return null;
}
finally
{
GUIHelper.setCursor(0);
}
return retVal;
}
public static boolean waitFor(String pattern, int seconds)
{
boolean retVal=false;
try
{
GUIHelper.setCursor(SWT.CURSOR_WAIT);
retVal=printer.waitFor(pattern, seconds);
}
catch(Exception e)
{
GUIHelper.logger.error(e, e);
return false;
}
finally
{
GUIHelper.setCursor(0);
}
return retVal;
}
public static String getVariable(String variable)
{
GUIHelper.logger.trace(variable);
String retVal=null;
try
{
GUIHelper.setCursor(SWT.CURSOR_WAIT);
retVal=printer.getVariable(variable);
}
catch(SocketException e)
{
handleSocketException(e);
}
catch(Exception e)
{
GUIHelper.error(Messages.getString("PrinterHelper.7")+variable+"].");
GUIHelper.logger.error(e, e);
return null;
}
finally
{
GUIHelper.setCursor(0);
}
return retVal;
}
public static final String GENERAL_PRINTER_READY=".*[RoOU]00000.*";
public static final String PEELER_PRINTER_READY=".*[RoOUP]0000.*";
public static Printer printer=new Printer();
}
```
## File: JAdmin/src/com/cognitive/admin/PrinterId.java
```java
public class PrinterId
{
private String modelNumber;
private int mac;
private char locationCode;
private String snPrefix;
private int serialNumber;
public PrinterId(String xmlPrinterId) throws DBException
{
GUIHelper.logger.trace(xmlPrinterId);
try
{
String snElement=GUIHelper.getMatch(xmlPrinterId, "<sn>.*</sn>");
serialNumber=Integer.parseInt(elementValue(snElement));
String macElement=GUIHelper.getMatch(xmlPrinterId, "<mac>.*</mac>");
mac=Integer.parseInt(elementValue(macElement));
String mnElement=GUIHelper.getMatch(xmlPrinterId, "<mn>.*</mn>");
modelNumber=new String(elementValue(mnElement));
String lcElement=GUIHelper.getMatch(xmlPrinterId, "<lc>.*</lc>");
locationCode=elementValue(lcElement).charAt(0);
String snpElement=GUIHelper.getMatch(xmlPrinterId, "<snp>.*</snp>");
snPrefix=new String(elementValue(snpElement));
}
catch(Exception e)
{
throw new DBException("Database access error: "+e.toString());
}
}
public PrinterId(String qualifiedSerialNumber, String qualifiedMac, String modelNumber)
{
GUIHelper.logger.trace(qualifiedSerialNumber+";"+qualifiedMac+"; "+modelNumber);
locationCode=qualifiedSerialNumber.charAt(0);
snPrefix=qualifiedSerialNumber.substring(1, 5);
serialNumber=Integer.parseInt(qualifiedSerialNumber.substring(5));
this.modelNumber=modelNumber;
String macHex=String.format("%2s%2s%2s",
qualifiedMac.substring(9, 11),
qualifiedMac.substring(12, 14),
qualifiedMac.substring(15));
mac=Integer.parseInt(macHex, 16);
}
@Override
public String toString()
{
StringBuffer retString=new StringBuffer();
retString.append("PrinterId:");
retString.append(" SN="+serialNumber);
retString.append("; SNP="+snPrefix);
retString.append("; LC="+locationCode);
retString.append("; MN="+modelNumber);
retString.append("; MAC="+mac);
return retString.toString();
}
@Override
public boolean equals(Object other)
{
if(this==other)
{
return true;
}
if(!(other instanceof PrinterId))
{
return false;
}
PrinterId otherPrinterId=(PrinterId)(other);
GUIHelper.logger.debug("This: "+this);
GUIHelper.logger.debug("Other: "+otherPrinterId);
return
this.serialNumber==otherPrinterId.serialNumber&&this.snPrefix.equals(otherPrinterId.snPrefix)&&this.locationCode==otherPrinterId.locationCode&&this.modelNumber.equals(otherPrinterId.modelNumber)&&this.mac==otherPrinterId.mac;
}
private String elementValue(String xmlElement)
{
int startIndex=xmlElement.indexOf('>')+1;
int endIndex=xmlElement.indexOf('<', startIndex);
return xmlElement.substring(startIndex, endIndex);
}
public String getQualifiedSerialNumber()
{
return String.format("%1s%4s%05d", locationCode, snPrefix, serialNumber);
}
public String getQualifiedMac()
{
String macLSB=String.format("%06X", mac);
String macHex="00:E0:70:"+macLSB.substring(0, 2)+":"+macLSB.substring(2, 4)+":"+macLSB.substring(4);
return macHex;
}
public int getSerialNumber()
{
return serialNumber;
}
public void setSerialNumber(int serialNumber)
{
this.serialNumber=serialNumber;
}
public String getModelNumber()
{
return modelNumber;
}
public void setModelNumber(String modelNumber)
{
this.modelNumber=modelNumber;
}
public char getLocationCode()
{
return locationCode;
}
public void setLocationCode(char locationCode)
{
this.locationCode=locationCode;
}
public int getMac()
{
return mac;
}
public void setMac(int mac)
{
this.mac=mac;
}
public String getSnPrefix()
{
return snPrefix;
}
public void setSnPrefix(String snPrefix)
{
this.snPrefix=snPrefix;
}
}
```
## File: JAdmin/src/com/cognitive/admin/QualityScanner.java
```java
public class QualityScanner
{
final int WAIT_FOR_DATA_TIMEOUT=30000;
final int WAIT_FOR_DATA_INTERVAL=100;
private InputStream inputStream;
private SerialPort serialPort;
private int baudRate;
private CommPortIdentifier portId;
private BufferedReader reader=null;
public QualityScanner(String port, int baud) throws NoSuchPortException
{
GUIHelper.logger.trace("");
baudRate=baud;
portId=CommPortIdentifier.getPortIdentifier(port);
}
public void openConnection() throws IOException, PortInUseException, UnsupportedCommOperationException
{
GUIHelper.logger.trace("");
serialPort=(SerialPort)portId.open("Quality Scanner", 2000);
inputStream=serialPort.getInputStream();
reader=new BufferedReader(new InputStreamReader(inputStream));
serialPort.setSerialPortParams(baudRate, SerialPort.DATABITS_8,
SerialPort.STOPBITS_1,
SerialPort.PARITY_NONE);
serialPort.setDTR(true);
serialPort.setRTS(true);
}
public void closeConnection() throws IOException
{
GUIHelper.logger.trace("");
if(null!=reader)
{
reader.close();
reader=null;
}
if(null!=inputStream)
{
inputStream.close();
inputStream=null;
}
if(null!=serialPort)
{
serialPort.close();
serialPort=null;
}
}
public boolean ready() throws IOException
{
if(reader!=null)
{
return reader.ready();
}
else
{
GUIHelper.logger.error("ready() called on null reader; returning false.");
throw new IOException("ready() called on null reader");
}
}
public String readLine() throws IOException
{
return reader.readLine()+"\n";
}
public String waitForBarcode()
{
String line=null;
String barcode=null;
long currentTime=(new GregorianCalendar()).getTimeInMillis();
long maxTime=currentTime+WAIT_FOR_DATA_TIMEOUT;
while(currentTime<=maxTime)
{
try
{
if(ready())
{
line=readLine().trim();
if(line.length()>0)
{
GUIHelper.logger.info(line);
if(line.charAt(0)=='*'&&line.charAt(line.length()-1)=='*'&&line.indexOf("Quick-Check")==-1)
{
barcode=line.substring(1, line.length()-1);
return barcode;
}
}
}
else
{
Thread.sleep(WAIT_FOR_DATA_INTERVAL);
GUIHelper.update();
currentTime=(new GregorianCalendar()).getTimeInMillis();
}
}
catch(Exception e)
{
GUIHelper.logger.error(e, e);
}
}
return null;
}
public String waitForGrade()
{
String gradeLine=null;
String grade=null;
String line=null;
long currentTime=(new GregorianCalendar()).getTimeInMillis();
long maxTime=currentTime+WAIT_FOR_DATA_TIMEOUT;
while(gradeLine==null&&currentTime<=maxTime)
{
try
{
if(ready())
{
line=readLine();
System.out.println(line);
if(line.indexOf("Decodability")!=-1)
{
gradeLine=line;
}
}
else
{
Thread.sleep(WAIT_FOR_DATA_INTERVAL);
GUIHelper.update();
currentTime=(new GregorianCalendar()).getTimeInMillis();
}
}
catch(Exception e)
{
GUIHelper.logger.error(e, e);
}
}
if(gradeLine!=null)
{
GUIHelper.logger.info("Grade: "+gradeLine);
grade=String.valueOf((GUIHelper.getMatch(line, "<[a-zA-Z]>")).charAt(1));
}
return grade;
}
}
```
## File: JAdmin/src/com/cognitive/admin/SecurityConfig.java
```java
public class SecurityConfig
{
private static HashMap<String, ConfigType>aConfigs=new HashMap<String, ConfigType>();
public static boolean loadConfigs(final String sConfigPath)
{
try
{
File inputFile=new File(sConfigPath);
DocumentBuilderFactory dbFactory=DocumentBuilderFactory.newInstance();
DocumentBuilder dBuilder=dbFactory.newDocumentBuilder();
Document document=dBuilder.parse(inputFile);
NodeList nList, nSettings;
Node nNode;
Element eNodeElement;
String sModelType;
aConfigs.clear();
document.getDocumentElement().normalize();
nList=document.getElementsByTagName("class");
eNodeElement=(Element)nList.item(0);
if(nList.getLength()!=1||!eNodeElement.getAttribute("name").equals("Security Configurations"))
return false;
nList=nList.item(0).getChildNodes();
if(nList.getLength()==0)
return false;
for(int iList=0; iList<nList.getLength();++iList)
{
nNode=nList.item(iList);
if(nNode.getNodeType()==Node.ELEMENT_NODE&&nNode.getNodeName().equals("configuration"))
{
eNodeElement=(Element)nNode;
sModelType=eNodeElement.getAttribute("type");
if(sModelType.startsWith("S"))
{
nSettings=eNodeElement.getElementsByTagName("setting");
aConfigs.put(sModelType, new ConfigType());
for(int iSetting=0; iSetting<nSettings.getLength();++iSetting)
{
nNode=nSettings.item(iSetting);
eNodeElement=(Element)nNode;
aConfigs.get(sModelType).addElement(eNodeElement);
}
}
}
}
return true;
}
catch(Exception e)
{
}
return false;
}
public static boolean isValidSetting(final String sModelType)
{
return aConfigs.containsKey(sModelType);
}
public static String getSetting(final String sModelType, final String sSetting)
{
if(isValidSetting(sModelType))
return aConfigs.get(sModelType).getValue(sSetting);
return "";
}
private static class ConfigType
{
private HashMap<String, String>hKeyValuePairs;
public ConfigType()
{
hKeyValuePairs=new HashMap<String, String>();
}
public void addElement(final Element eNodeElement)
{
hKeyValuePairs.put(eNodeElement.getAttribute("key"), eNodeElement.getAttribute("value"));
}
public String getValue(final String sKey)
{
if(hKeyValuePairs.containsKey(sKey))
return hKeyValuePairs.get(sKey);
return "";
}
}
}
```
## File: JAdmin/src/com/cognitive/admin/TestEngine.java
```java
public class TestEngine
{
static String jadminURLBase=GUIHelper.prefs.get("MAN_JADMIN_URL", "http://jadmin.cognitive.com/updatePrinter.php")+"?db="+GUIHelper.prefs.get("MAN_DATABASE", "manufacturing");
static String jadminURLBaseTG=GUIHelper.prefs.get("MAN_JADMIN_URL", "http://jadmin.dascom.com/updatePrinter.php")+"?db="+GUIHelper.prefs.get("MAN_DATABASE", "manufacturing");
static public boolean isConnectionTypeParallelOnly=false;
static public boolean isConnectionTypeSerial=false;
static public boolean runningManufacturing=false;
static enum TestStatus
{
PASSED,
FAILED,
SKIPPED,
CANCELLED,
REDO,
ABORTED
}
static enum TestStep
{
INITIAL_SETUP,
FIRMWARE_DOWNLOAD,
PRINTER_IDENTIFICATION,
FONT_DOWNLOAD,
CPR_DOWNLOAD,
CONTROL_PANEL,
CONNECTION_TYPES,
PRINTHEAD_UP_DOWN,
TONE_CHECK,
RTC_SETUP,
CALIBRATION,
FEED_BUTTON_TEST,
PEELER_TEST,
PRINTHEAD_TEST,
BACKUP_MEMORY_TEST,
PRINT_QUALITY_TEST,
RIBBON_WRINKLE_TEST,
FINAL_SETTINGS,
SELF_TEST,
SERIAL_NUMBER_LABEL,
BOX_LABEL
}
public static String[] TestStatusString={
Messages.getString("TestEngine.104"),
Messages.getString("TestEngine.105"),
Messages.getString("TestEngine.106"),
Messages.getString("TestEngine.107")
};
static enum ProductLine
{
CI,
CXI,
DLX,
LX
}
static enum PrintMethod
{
DT,
TT
}
static enum PrintHead
{
Automatic,
ROHM_KDxxxxDF,
HEC,
Kyocera,
AOI,
ROHM_KFxxxxGD
}
static enum ExitOption
{
STANDARD,
TEAR_BAR,
PEELER
}
static enum MemRTC
{
MB4,
MB8,
MB8_RTC
}
static enum ConfigurationEmulation
{
STANDARD,
CUSTOM,
WINGMAN,
GATTACA,
GATTACA_CUSTOM_COMGRPH,
GATTACA_CUSTOM_DATACARD,
GATTACA_CUSTOM_SIEMAN_1,
GATTACA_CUSTOM_SIEMAN_2,
GATTACA_CUSTOM_HOMEDEPOT,
GATTACA_CUSTOM_TOUCHSTAR,
GATTACA_CUSTOM_SUNQUEST,
GATTACA_CUSTOM_METER
}
static enum PowerSupplyCord
{
US,
EU_UK,
US_EU_UK,
NO_CORD,
NO_POWER_SUPPLY
}
static enum CommunicationInterface
{
USB_AB,
USB_AB_NETWORK,
USB_AB_NETWORK_SERIAL,
USB_AB_NETWORK_SERIAL_PARALLEL,
USB_AB_SERIAL,
USB_AB_SERIAL_BLUETOOTH,
USB_AB_PARALLEL,
USB_AB_SERIAL_PARALLEL,
SERIAL,
PARALLEL,
SERIAL_PARALLEL,
SERIAL_NETWORK,
SERIAL_NETWORK_PARALLEL,
USB_AB_LEGACY_NO_CABLE,
USB_AB_LEGACY_SERIAL_CABLE,
USB_AB_LEGACY_ADAPTOR_SERIAL_CABLE,
USB_AB_LEGACY_PARALLEL_CABLE,
ALL
}
static enum LanguageOption
{
STANDARD,
PCL
}
static boolean brandNewPrinter=false;
static boolean changedModelNumber=false;
static boolean changedSerialNumber=false;
static boolean changedMAC=false;
static boolean supportsFontCheckCommand=false;
static boolean supportsFactoryRestoreCommand=false;
static LocationCode locationCode;
static String serialNumber;
static String macHex;
static ProductLine productLine;
static PrintMethod printMethod;
static int mediaWidth;
static int printDensity;
static ExitOption exitOption;
static MemRTC memRTC;
static int printSpeed;
static ConfigurationEmulation configurationEmulation;
static PowerSupplyCord powerSupplyCord;
static CommunicationInterface communicationInterface;
static PrintHead printHead;
static LanguageOption languageOption;
static String customization;
static String currentFirmware;
static String latestFirmware=null;
static String currentVersion=null;
static String latestFirmwarePath;
static String testSleepAfter="157";
static String originalSleepAfter=null;
static TGModelNumbers tgModelNumbers=null;
static boolean isTGModelNumber=false;
static boolean isTDModelNumber=false;
static String tgModelFeature;
static String tgModelEmbeddedNumber;
static String tgModelUPC;
static String tgCompanyName="DASCOM Europe GmbH";
static String tgGermanyAddress1="Heuweg 3, D-89079 Ulm,";
static String tgGermanyAddress2="Germany";
static String tgUSAddress1="4500 Daly Drive";
static String tgUSAddress2="Chantilly, VA 20151 USA";
static String currentModelNumber;
static public String testModelNumber;
static String ezCustomerPartNumber;
static boolean isWingman=false;
static boolean isPCL=false;
static boolean isGattaca=false;
static boolean isMadeInChina=false;
static public boolean isMadeByEnnoconnMalaysia=false;
static public boolean isLX=false;
static public boolean isTouchstar=false;
static public boolean isMeter=false;
static public boolean isSiemens=false;
static public boolean isResco=false;
static public boolean isHD=false;
static public boolean isApple=false;
static public boolean isBT=false;
static public boolean isNetwork=false;
static public boolean isSecurity=false;
static public boolean isGWN=false;
static public boolean isDT=false;
static public boolean isBS=false;
static public boolean isCustomLabel_K542=false, printCustom_K542=false;
static boolean isFontDensityDifferent=false;
static boolean skipLoadingFirmware=false;
static boolean skipLoadingFonts=false;
static boolean skipLoadingCPRs=false;
static boolean isTestAborted=false;
static String btDeviceName;
static String btMacAddress;
static boolean firmwareLoadingFlashVersionnProblem=false;
static ConnectionType connectionType=ConnectionType.UNKNOWN;
static boolean parseModelNumber(String modelNumber)
{
GUIHelper.logger.info(modelNumber);
try
{
isWingman=false;
isGattaca=false;
isLX=false;
isTouchstar=false;
isMeter=false;
isSiemens=false;
isHD=false;
isApple=false;
isBT=false;
isDT=false;
isMadeByEnnoconnMalaysia=(locationCode==LocationCode.E);
if(modelNumber.startsWith("DB")||modelNumber.startsWith("LB"))
{
isTGModelNumber=false;
isTDModelNumber=false;
return parseDLX_LXModelNumber(modelNumber);
}
else if(modelNumber.startsWith("C"))
{
isTGModelNumber=false;
isTDModelNumber=false;
return parseCModelNumber(modelNumber);
}
else if(modelNumber.startsWith("16"))
{
try
{
if(CompositeManufacturing.checkBoxTG.getSelection())
{
isTGModelNumber=true;
isTDModelNumber=false;
}
else
{
isTDModelNumber=true;
isTGModelNumber=false;
}
}
catch(Exception e)
{
String oemID=GUIHelper.clean(PrinterHelper.commandWaitResponse("!SHOW OEMIDENTIFIER"));
GUIHelper.logger.info("Called for Get Latest Firmware: "+oemID);
if(oemID.contains("DASCOM"))
{
isTDModelNumber=true;
isTGModelNumber=false;
}
else
{
isTGModelNumber=true;
isTDModelNumber=false;
}
}
return convertTGModelNumber(modelNumber);
}
else
{
GUIHelper.error(Messages.getString("TestEngine.0"));
GUIHelper.logger.error("Can't parse model number "+modelNumber);
return false;
}
}
catch(Exception e)
{
GUIHelper.error(Messages.getString("TestEngine.1"));
GUIHelper.logger.error("Can't parse model number "+modelNumber);
return false;
}
}
static boolean convertTGModelNumber(String modelNumber)
{
GUIHelper.logger.trace(modelNumber);
if(tgModelNumbers==null)
{
tgModelNumbers=new TGModelNumbers(isTGModelNumber);
}
try
{
String convertedModelNumber=null;
convertedModelNumber=tgModelNumbers.getModelNumber(modelNumber);
convertedModelNumber=tgModelNumbers.getModelNumber(modelNumber);
tgModelFeature=tgModelNumbers.getModelFeature(modelNumber);
tgModelEmbeddedNumber=tgModelNumbers.getModelEmbeddedNumber(modelNumber);
tgModelUPC=tgModelNumbers.getModelUPC(modelNumber);
GUIHelper.logger.debug("Converted to: "+convertedModelNumber);
if(convertedModelNumber.startsWith("DB"))
{
return parseDLX_LXModelNumber(convertedModelNumber);
}
else if(convertedModelNumber.startsWith("C"))
{
return parseCModelNumber(convertedModelNumber);
}
else
{
GUIHelper.error(Messages.getString("TestEngine.0"));
GUIHelper.logger.error("Can't parse model number "+modelNumber);
return false;
}
}
catch(Exception e)
{
GUIHelper.error(Messages.getString("TestEngine.1"));
GUIHelper.logger.error("Can't parse model number "+modelNumber);
return false;
}
}
static boolean parseDLX_LXModelNumber(String modelNumber)
{
GUIHelper.logger.info(modelNumber);
if(modelNumber.startsWith("DB"))
productLine=ProductLine.DLX;
else
{
productLine=ProductLine.LX;
isLX=true;
}
char c;
c=modelNumber.charAt(2);
switch(c)
{
case 'D':
printMethod=PrintMethod.DT;
break;
case 'T':
printMethod=PrintMethod.TT;
break;
default:
return false;
}
GUIHelper.logger.info(TestEngine.printMethod);
mediaWidth=Integer.parseInt(modelNumber.substring(3, 4));
GUIHelper.logger.info(mediaWidth);
c=modelNumber.charAt(6);
switch(c)
{
case '2':
printDensity=200;
break;
case '3':
printDensity=300;
break;
default:
return false;
}
GUIHelper.logger.info(printDensity);
c=modelNumber.charAt(7);
switch(c)
{
case '0':
exitOption=ExitOption.STANDARD;
break;
case '1':
exitOption=ExitOption.TEAR_BAR;
break;
case '4':
exitOption=ExitOption.PEELER;
break;
default:
return false;
}
GUIHelper.logger.info(exitOption);
c=modelNumber.charAt(8);
switch(c)
{
case '4':
memRTC=MemRTC.MB4;
break;
case '8':
if(isLX)
memRTC=MemRTC.MB8_RTC;
else
memRTC=MemRTC.MB8;
break;
case '9':
memRTC=MemRTC.MB8_RTC;
break;
default:
return false;
}
GUIHelper.logger.info(memRTC);
c=modelNumber.charAt(9);
printSpeed=c-48;
GUIHelper.logger.debug(printSpeed);
customization=null;
c=modelNumber.charAt(11);
if(productLine==ProductLine.LX)
{
configurationEmulation=ConfigurationEmulation.GATTACA;
isGattaca=true;
}
else
{
switch(c)
{
case 'G':
configurationEmulation=ConfigurationEmulation.GATTACA;
isGattaca=true;
break;
case '0':
configurationEmulation=ConfigurationEmulation.STANDARD;
break;
case 'C':
configurationEmulation=ConfigurationEmulation.CUSTOM;
customization=modelNumber.substring(12);
break;
case 'Z':
configurationEmulation=ConfigurationEmulation.WINGMAN;
isWingman=true;
break;
case 'M':
configurationEmulation=ConfigurationEmulation.WINGMAN;
isWingman=true;
break;
case 'P':
configurationEmulation=ConfigurationEmulation.STANDARD;
languageOption=LanguageOption.PCL;
break;
default:
return false;
}
}
if(isGattaca)
{
c=modelNumber.charAt(12);
switch(c)
{
case 'C':
configurationEmulation=ConfigurationEmulation.GATTACA_CUSTOM_COMGRPH;
break;
case 'B':
configurationEmulation=ConfigurationEmulation.GATTACA_CUSTOM_COMGRPH;
break;
case 'D':
configurationEmulation=ConfigurationEmulation.GATTACA_CUSTOM_DATACARD;
break;
case 'E':
configurationEmulation=ConfigurationEmulation.GATTACA_CUSTOM_SIEMAN_2;
break;
case 'H':
configurationEmulation=ConfigurationEmulation.GATTACA_CUSTOM_HOMEDEPOT;
break;
case 'S':
if(modelNumber.charAt(13)=='Q')
{
configurationEmulation=ConfigurationEmulation.GATTACA_CUSTOM_SUNQUEST;
}
else
{
configurationEmulation=ConfigurationEmulation.GATTACA_CUSTOM_SIEMAN_1;
}
break;
case 'T':
configurationEmulation=ConfigurationEmulation.GATTACA_CUSTOM_TOUCHSTAR;
break;
case 'L':
configurationEmulation=ConfigurationEmulation.GATTACA_CUSTOM_METER;
break;
default:
break;
}
}
GUIHelper.logger.info(configurationEmulation);
if(configurationEmulation.toString().indexOf("CUSTOM")==-1)
{
c=modelNumber.charAt(12);
switch(c)
{
case '1':
case 'F':
powerSupplyCord=PowerSupplyCord.US;
break;
case '2':
powerSupplyCord=PowerSupplyCord.EU_UK;
break;
case '3':
powerSupplyCord=PowerSupplyCord.US_EU_UK;
break;
case 'N':
powerSupplyCord=PowerSupplyCord.NO_POWER_SUPPLY;
break;
case '0':
powerSupplyCord=PowerSupplyCord.NO_POWER_SUPPLY;
break;
default:
return false;
}
GUIHelper.logger.info(powerSupplyCord);
c=modelNumber.charAt(13);
if(isGattaca)
{
switch(c)
{
case '1':
communicationInterface=CommunicationInterface.SERIAL;
break;
case '2':
communicationInterface=CommunicationInterface.PARALLEL;
break;
case '3':
communicationInterface=CommunicationInterface.SERIAL_PARALLEL;
break;
case '4':
communicationInterface=CommunicationInterface.SERIAL_NETWORK;
break;
case '6':
communicationInterface=CommunicationInterface.SERIAL_NETWORK_PARALLEL;
break;
case 'U':
communicationInterface=CommunicationInterface.USB_AB;
break;
case 'E':
if(mediaWidth==2)
{
communicationInterface=CommunicationInterface.USB_AB_NETWORK_SERIAL;
}
else
{
communicationInterface=CommunicationInterface.USB_AB_NETWORK_SERIAL_PARALLEL;
}
break;
case 'S':
if(mediaWidth==2)
{
communicationInterface=CommunicationInterface.USB_AB_SERIAL;
}
else
{
communicationInterface=CommunicationInterface.USB_AB_SERIAL_PARALLEL;
}
break;
case 'M':
communicationInterface=CommunicationInterface.USB_AB_SERIAL_PARALLEL;
break;
case 'B':
communicationInterface=CommunicationInterface.USB_AB_SERIAL_BLUETOOTH;
isBT=true;
break;
case 'A':
communicationInterface=CommunicationInterface.USB_AB_SERIAL_BLUETOOTH;
isBT=true;
isApple=true;
break;
case 'P':
if(mediaWidth==2)
{
communicationInterface=CommunicationInterface.USB_AB_PARALLEL;
}
else
{
communicationInterface=CommunicationInterface.USB_AB_SERIAL_PARALLEL;
}
break;
default:
return false;
}
}
else
{
switch(c)
{
case 'U':
communicationInterface=CommunicationInterface.USB_AB;
break;
case 'L':
communicationInterface=CommunicationInterface.USB_AB_LEGACY_NO_CABLE;
break;
case 'E':
communicationInterface=CommunicationInterface.USB_AB_NETWORK;
break;
case 'S':
communicationInterface=CommunicationInterface.USB_AB_LEGACY_SERIAL_CABLE;
break;
case 'M':
communicationInterface=CommunicationInterface.USB_AB_LEGACY_ADAPTOR_SERIAL_CABLE;
break;
case 'P':
communicationInterface=CommunicationInterface.USB_AB_LEGACY_PARALLEL_CABLE;
break;
default:
return false;
}
}
GUIHelper.logger.info(communicationInterface);
}
else
{
if(isGattaca)
{
switch(configurationEmulation)
{
case GATTACA_CUSTOM_COMGRPH:
powerSupplyCord=PowerSupplyCord.US;
if(modelNumber.charAt(13)=='E')
{
communicationInterface=CommunicationInterface.USB_AB_NETWORK_SERIAL;
}
else
{
communicationInterface=CommunicationInterface.USB_AB_SERIAL;
}
if(modelNumber.charAt(12)=='B')
{
customization="BS";
isBS=true;
}
else
{
customization="COMGRPH";
}
break;
case GATTACA_CUSTOM_DATACARD:
powerSupplyCord=PowerSupplyCord.US;
return false;
case GATTACA_CUSTOM_SUNQUEST:
powerSupplyCord=PowerSupplyCord.US;
communicationInterface=CommunicationInterface.USB_AB_NETWORK_SERIAL_PARALLEL;
customization="SQ";
break;
case GATTACA_CUSTOM_SIEMAN_1:
powerSupplyCord=PowerSupplyCord.US;
communicationInterface=CommunicationInterface.USB_AB_SERIAL_PARALLEL;
isSiemens=true;
customization="S1";
break;
case GATTACA_CUSTOM_SIEMAN_2:
powerSupplyCord=PowerSupplyCord.EU_UK;
isSiemens=true;
return false;
case GATTACA_CUSTOM_HOMEDEPOT:
powerSupplyCord=PowerSupplyCord.US;
communicationInterface=CommunicationInterface.USB_AB_NETWORK_SERIAL_PARALLEL;
isHD=true;
customization="HD";
break;
case GATTACA_CUSTOM_TOUCHSTAR:
powerSupplyCord=PowerSupplyCord.NO_POWER_SUPPLY;
if(modelNumber.charAt(13)=='B')
{
communicationInterface=CommunicationInterface.USB_AB_SERIAL_BLUETOOTH;
customization="TOUCHSTAR2";
}
else
{
communicationInterface=CommunicationInterface.USB_AB_SERIAL_PARALLEL;
customization="TOUCHSTAR1";
}
isTouchstar=true;
break;
case GATTACA_CUSTOM_METER:
powerSupplyCord=PowerSupplyCord.NO_POWER_SUPPLY;
communicationInterface=CommunicationInterface.USB_AB_SERIAL_PARALLEL;
customization="METER";
isMeter=true;
break;
default:
return false;
}
}
else
{
if(customization.equalsIgnoreCase("01"))
{
powerSupplyCord=PowerSupplyCord.US;
communicationInterface=CommunicationInterface.USB_AB_LEGACY_ADAPTOR_SERIAL_CABLE;
}
else
{
return false;
}
}
GUIHelper.logger.info(powerSupplyCord);
GUIHelper.logger.info(communicationInterface);
GUIHelper.logger.info(customization);
}
return true;
}
static boolean parseCModelNumber(String modelNumber)
{
GUIHelper.logger.info("");
char c;
c=modelNumber.charAt(1);
switch(c)
{
case 'I':
productLine=ProductLine.CI;
break;
case 'X':
productLine=ProductLine.CXI;
break;
default:
return false;
}
c=modelNumber.charAt(2);
switch(c)
{
case 'D':
printMethod=PrintMethod.DT;
break;
case 'T':
printMethod=PrintMethod.TT;
break;
default:
return false;
}
GUIHelper.logger.info(printMethod);
mediaWidth=Integer.parseInt(modelNumber.substring(3, 4));
GUIHelper.logger.info(mediaWidth);
c=modelNumber.charAt(6);
switch(c)
{
case '0':
printDensity=200;
break;
case '3':
printDensity=300;
break;
default:
return false;
}
GUIHelper.logger.info(printDensity);
c=modelNumber.charAt(7);
switch(c)
{
case '0':
languageOption=LanguageOption.STANDARD;
break;
case '3':
languageOption=LanguageOption.PCL;
break;
default:
return false;
}
GUIHelper.logger.info(languageOption);
c=modelNumber.charAt(8);
switch(c)
{
case '0':
exitOption=ExitOption.STANDARD;
break;
default:
return false;
}
GUIHelper.logger.info(exitOption);
isResco=false;
isSecurity=false;
isGWN=false;
if(modelNumber.length()>=12)
{
customization=modelNumber.substring(10);
GUIHelper.logger.info(customization);
if(customization.equalsIgnoreCase("RX"))
{
customization=null;
}
else if(customization.equalsIgnoreCase("CS0"))
{
isResco=true;
}
else if(customization.startsWith("S"))
{
isSecurity=true;
if(customization.startsWith("SGWN"))
{
isGWN=true;
}
}
}
else
{
customization=null;
}
if((modelNumber.length()==9)&&(modelNumber.charAt(7)=='0')&&(!isTDModelNumber)&&(!isTGModelNumber))
{
isMadeInChina=true;
}
else
{
isMadeInChina=false;
}
memRTC=MemRTC.MB8_RTC;
communicationInterface=CommunicationInterface.ALL;
return true;
}
static String getCurrentFirmwarePartNumber()
{
GUIHelper.logger.info("");
String currentFirmwarePartNumber=null;
if(!isConnectionTypeParallelOnly)
{
currentFirmware=GUIHelper.clean(PrinterHelper.commandWaitResponse("!QR"));
if(currentFirmware!=null)
{
String regexPartNumber="\\d{3}-\\d{3}-\\d{3}";
currentFirmwarePartNumber=GUIHelper.getMatch(currentFirmware, regexPartNumber);
}
}
else
{
determineLatestFirmware();
currentFirmware=latestFirmware;
currentFirmwarePartNumber=latestFirmware.substring(0, 3)+"-"+latestFirmware.substring(3, 6)+"-"+latestFirmware.substring(7);
}
GUIHelper.logger.info("currentFirmware="+currentFirmware);
GUIHelper.logger.info("currentFirmwarePartNumber="+currentFirmwarePartNumber);
return currentFirmwarePartNumber;
}
static String getCurrentFirmwareVersion(String currentPartNumber)
{
if(currentPartNumber!=null)
{
String regexVersion="\\d{3}$";
currentVersion=GUIHelper.getMatch(currentPartNumber, regexVersion);
}
return currentVersion;
}
static void determineLatestFirmware()
{
GUIHelper.logger.info("");
if(!isTGModelNumber&&!isTDModelNumber)
{
switch(productLine)
{
case LX:
latestFirmware=FirmwareMap.LX;
break;
case DLX:
latestFirmware=FirmwareMap.DLX;
if(isWingman)
{
latestFirmware=FirmwareMap.WM;
}
if(isGattaca)
{
if(isBS)
{
latestFirmware=FirmwareMap.CG;
}
else if(isBT)
{
latestFirmware=FirmwareMap.BT;
}
else
{
latestFirmware=FirmwareMap.GT;
}
}
if(isTouchstar)
{
latestFirmware=FirmwareMap.TS;
}
if(isMeter)
{
latestFirmware=FirmwareMap.ME;
}
if(isHD)
{
latestFirmware=FirmwareMap.HD;
}
if(isSiemens)
{
latestFirmware=FirmwareMap.SI;
}
break;
case CI:
latestFirmware=FirmwareMap.CI;
break;
case CXI:
latestFirmware=FirmwareMap.CXI;
if(isResco)
{
latestFirmware=FirmwareMap.Resco;
}
if(isGWN)
{
latestFirmware=FirmwareMap.GWN;
}
if(isSecurity)
{
latestFirmware=SecurityConfig.getSetting(customization, "FIRMWARE");
}
break;
}
}
else
{
latestFirmware=FirmwareMap.TG;
}
}
static final Map<String, String>customFirmwareMap=new HashMap<String, String>();
static
{
customFirmwareMap.put("DBT24-2095-GBS", "195170.406");
customFirmwareMap.put("DBT24-2095-GCS", "195170.410");
customFirmwareMap.put("DBD42-2085-GHE", "195170.408");
customFirmwareMap.put("DBD42-2085-GSS", "195170.328");
customFirmwareMap.put("DBD42-2085-GSO", "195170.409");
customFirmwareMap.put("DBD42-2085-GSQ", "195170.409");
customFirmwareMap.put("CXT2-1300-C01", "195170.335");
}
static boolean firmwareNeedsUpdate(boolean firmwareAsk, StringBuffer newFirmware) throws ManufacturingTestException
{
GUIHelper.logger.info("");
String currentFileName="";
boolean manufacturing=GUIHelper.prefs.getBoolean("ACTIVATE_MANUFACTURING", false);
boolean CustomFirmware=GUIHelper.prefs.getBoolean("ACTIVATE_CUSTOM_FIRMWARE", false);
if(manufacturing&&CustomFirmware)
{
latestFirmware=GUIHelper.prefs.get("CUSTOM_FIRMWARE", null);
latestFirmwarePath=GUIHelper.prefs.get("CUSTOM_FIRMWARE_PATH", null);
if(latestFirmware==null)
{
GUIHelper.logger.info("latestFirmware=null");
CustomFirmware=false;
}
else
{
GUIHelper.logger.info("latestFirmware="+latestFirmware);
}
}
if(!CustomFirmware)
{
GUIHelper.logger.info("Not custom firmware");
determineLatestFirmware();
}
if(customFirmwareMap.containsKey(testModelNumber))
{
latestFirmware=customFirmwareMap.get(testModelNumber);
CustomFirmware=true;
if((latestFirmware.matches("195\\d{3}[.]3\\d{2}")&&currentFirmware.matches("195[-]\\d{3}[-]4\\d{2}.*"))||(latestFirmware.matches("195\\d{3}[.]4\\d{2}")&&currentFirmware.matches("195[-]\\d{3}[-]3\\d{2}.*")))
{
firmwareLoadingFlashVersionnProblem=true;
GUIHelper.logger.info("Detected there will be firmware incompatibility between versions 195170.3XX and 195170.4XX due to internal flash memory storage changes.");
}
}
if(!CustomFirmware&&customization!=null)
{
if(customization.equals("PCL"))
{
if(!isTGModelNumber&&!isTDModelNumber)
{
latestFirmware=FirmwareMap.PCL;
}
else
{
latestFirmware=FirmwareMap.TGPCL;
}
}
}
GUIHelper.logger.info("Latest firmware: "+latestFirmware);
String currentPartNumber=getCurrentFirmwarePartNumber();
if(currentPartNumber==null)
{
throw new ManufacturingTestException("Unable to get current firmware version.");
}
currentVersion=getCurrentFirmwareVersion(currentPartNumber);
String suffix="";
if(currentFirmware.indexOf("P")!=-1)
{
suffix="P";
}
if(currentFirmware.indexOf("RC")!=-1)
{
suffix=currentFirmware.substring(currentFirmware.indexOf("RC"), currentFirmware.indexOf("RC")+3);
}
String[] tokens=currentPartNumber.split("-");
String massagedPartNumber=tokens[0]+tokens[1];
currentFileName=massagedPartNumber+suffix.toString()+"."+currentVersion;
GUIHelper.logger.info("Current part number: "+currentPartNumber);
GUIHelper.logger.info("Current version: "+currentVersion);
GUIHelper.logger.info("Current file name: "+currentFileName);
boolean firmwareNeedsUpdate=false;
if(!latestFirmware.trim().contains(currentFileName.trim())||isConnectionTypeParallelOnly)
{
firmwareNeedsUpdate=true;
if(!latestFirmware.contains("||"))
{
if(currentFileName.contains("195184."))
{
if(latestFirmware.contains("195184.")||latestFirmware.contains("195186."))
latestFirmware=FirmwareMap.BT;
if(latestFirmware.trim().contains(currentFileName.trim()))
firmwareNeedsUpdate=false;
}
else if(currentFileName.contains("195186."))
{
if(latestFirmware.contains("195184.")||latestFirmware.contains("195186."))
latestFirmware=FirmwareMap.newBT;
if(latestFirmware.trim().contains(currentFileName.trim()))
firmwareNeedsUpdate=false;
}
else if(currentFileName.contains("195170.")&&(latestFirmware.contains("195184.")||latestFirmware.contains("195186.")))
{
if(latestFirmware.contains("195184.")||latestFirmware.contains("195186."))
latestFirmware=FirmwareMap.newBT;
if(latestFirmware.trim().contains(currentFileName.trim()))
firmwareNeedsUpdate=false;
}
}
else
{
if(currentFileName.contains("195184."))
{
if(latestFirmware.contains("195184.")||latestFirmware.contains("195186."))
latestFirmware=FirmwareMap.BT;
}
else if(currentFileName.contains("195186."))
{
if(latestFirmware.contains("195184.")||latestFirmware.contains("195186."))
latestFirmware=FirmwareMap.newBT;
}
else if(currentFileName.contains("195170.")&&(latestFirmware.contains("195184.")||latestFirmware.contains("195186.")))
{
if(latestFirmware.contains("195184.")||latestFirmware.contains("195186."))
latestFirmware=FirmwareMap.newBT;
}
else
{
String[] acceptableFirmware=latestFirmware.split("[|][|]");
latestFirmware=acceptableFirmware[acceptableFirmware.length-1].trim();
}
}
newFirmware.append(latestFirmware);
}
GUIHelper.logger.info("newFirmware: "+newFirmware);
if(firmwareNeedsUpdate)
{
if(!CustomFirmware&&brandNewPrinter)
{
return true;
}
else
{
if(firmwareAsk)
{
StringBuffer message=new StringBuffer();
message.append(Messages.getString("TestEngine.2"));
message.append(Messages.getString("TestEngine.3")+currentFileName+"\n");
message.append(Messages.getString("TestEngine.4")+latestFirmware.toString()+"\n");
if(!isConnectionTypeParallelOnly)
{
message.append("\n\n");
message.append(Messages.getString("TestEngine.5"));
int button=GUIHelper.message(message.toString(), SWT.ICON_QUESTION|SWT.YES|SWT.NO);
if(button==SWT.YES)
{
return true;
}
else
{
return false;
}
}
else
{
int button=GUIHelper.message(message.toString(), SWT.ICON_WORKING|SWT.OK);
if(button==SWT.OK)
{
return true;
}
else
{
return false;
}
}
}
else
{
return true;
}
}
}
else
{
return false;
}
}
static TestStatus doFirmwareDownload(boolean firmwareAsk, ProgressBar progressBarFirmwareDownload, boolean reEstablishConnection)
{
GUIHelper.logger.info("");
skipLoadingFirmware=GUIHelper.prefs.getBoolean("ACTIVATE_MANUFACTURING", false);
if(skipLoadingFirmware)
{
try
{
skipLoadingFirmware=CompositeManufacturing.checkBoxSkipLoad1.getSelection();
}
catch(Exception e)
{
skipLoadingFirmware=false;
}
}
if(!skipLoadingFirmware)
{
StringBuffer newFirmware=new StringBuffer();
try
{
if(!firmwareNeedsUpdate(firmwareAsk, newFirmware))
{
return TestStatus.SKIPPED;
}
}
catch(Exception e)
{
GUIHelper.logger.error(e, e);
GUIHelper.error(e.getMessage());
return TestStatus.FAILED;
}
byte buff[];
boolean CustomFirmware=GUIHelper.prefs.getBoolean("ACTIVATE_CUSTOM_FIRMWARE", false);
if(!CustomFirmware)
{
buff=GUIHelper.getResourceAsByteArray("com/cognitive/manufacturing/firmware/"+newFirmware.toString());
}
else
{
try
{
buff=GUIHelper.readBinaryFile(latestFirmwarePath+newFirmware.toString());
}
catch(Exception e)
{
GUIHelper.logger.error(e, e);
buff=null;
}
}
if(buff==null)
{
GUIHelper.error(Messages.getString("TestEngine.6")+newFirmware.toString()+"].");
return TestStatus.FAILED;
}
progressBarFirmwareDownload.setEnabled(true);
progressBarFirmwareDownload.setVisible(true);
GUIHelper.logger.info("Updating firmware.");
try
{
GUIHelper.setCursor(SWT.CURSOR_WAIT);
FirmwareUpdater firmwareUpdater=new FirmwareUpdater(buff, progressBarFirmwareDownload);
firmwareUpdater.updateFirmware(true);
if(isConnectionTypeParallelOnly)
{
GUIHelper.message(Messages.getString("TestEngine.109"), SWT.ICON_WORKING|SWT.OK);
}
GUIHelper.setCursor(SWT.DEFAULT);
GUIHelper.logger.info(Messages.getString("TestEngine.7"));
if(reEstablishConnection)
{
boolean success=establishPrimaryConnection(115200);
if(!success)
{
return TestStatus.FAILED;
}
}
}
catch(Exception e1)
{
GUIHelper.logger.error(e1, e1);
GUIHelper.error(Messages.getString("TestEngine.8"));
return TestStatus.FAILED;
}
finally
{
progressBarFirmwareDownload.setEnabled(false);
progressBarFirmwareDownload.setVisible(false);
}
if(!isConnectionTypeParallelOnly)
{
currentFirmware=GUIHelper.clean(PrinterHelper.commandWaitResponse("!QR"));
}
if(firmwareLoadingFlashVersionnProblem)
{
int button=GUIHelper.message("Firmware has successfully downloaded, but this version change may cause internal memory problems. Please manually power cycle the printer, and then continue the testing process.", SWT.OK|SWT.ICON_QUESTION);
firmwareLoadingFlashVersionnProblem=false;
}
return TestStatus.PASSED;
}
else
{
return TestStatus.SKIPPED;
}
}
static TestStatus doRTCSetup()
{
GUIHelper.logger.info("");
if(memRTC!=MemRTC.MB8_RTC)
{
return TestStatus.SKIPPED;
}
Calendar calendar=new GregorianCalendar();
int year=calendar.get(Calendar.YEAR);
int month=calendar.get(Calendar.MONTH)+1;
int day=calendar.get(Calendar.DAY_OF_MONTH);
int hour24=calendar.get(Calendar.HOUR_OF_DAY);
int minute=calendar.get(Calendar.MINUTE);
int second=calendar.get(Calendar.SECOND);
StringBuffer command=new StringBuffer();
String dateTime="!SET TIME "+year+" "+month+" "+day+" "+hour24+" "+minute+" "+second;
command.append(dateTime+"\n");
PrinterHelper.send(command.toString());
GUIHelper.logger.info(dateTime);
return TestStatus.PASSED;
}
static TestStatus doBackupMemoryTest(boolean testPowerCycle)
{
GUIHelper.logger.info("");
if(!isConnectionTypeParallelOnly)
{
if(testPowerCycle&&(memRTC==MemRTC.MB8_RTC))
{
if(isBT)
{
PrinterHelper.send("!!0 0 0 0");
PrinterHelper.send("!0 0 0 0");
PrinterHelper.send("VARIABLE BLUETOOTH CONFIGURE ON");
PrinterHelper.send("VARIABLE BLUETOOTH DEFAULT");
PrinterHelper.send("VARIABLE BLUETOOTH DEVICENAME "+testModelNumber);
PrinterHelper.send("VARIABLE BLUETOOTH DISCOVERABLE ON");
PrinterHelper.send("VARIABLE BLUETOOTH RESET");
PrinterHelper.send("END");
}
try
{
PrinterHelper.printer.closeConnection();
}
catch(Exception e)
{
GUIHelper.logger.error(e, e);
GUIHelper.error(Messages.getString("TestEngine.9"));
return TestStatus.FAILED;
}
String msg="";
if(connectionType==ConnectionType.OS_PRINTER)
{
msg=Messages.getString("TestEngine.64");
}
else if(connectionType==ConnectionType.SERIAL)
{
msg=Messages.getString("TestEngine.61");
}
else if(connectionType==ConnectionType.NETWORK)
{
msg=Messages.getString("TestEngine.60");
}
else if(connectionType==ConnectionType.PARALLEL)
{
msg=Messages.getString("TestEngine.59");
}
StringBuffer message=new StringBuffer();
message.append(Messages.getString("TestEngine.111"));
message.append(" ("+msg+").\n");
message.append(Messages.getString("TestEngine.112"));
GUIHelper.message(message.toString(), SWT.ICON_WORKING|SWT.OK);
if(!establishPrimaryConnection(9600))
{
return TestStatus.FAILED;
}
}
else
{
}
if(isBT)
{
PrinterHelper.send("!!0 0 0 0");
PrinterHelper.send("!0 0 0 0");
PrinterHelper.send("VARIABLE BLUETOOTH CONFIGURE ON");
PrinterHelper.send("VARIABLE BLUETOOTH DEFAULT");
PrinterHelper.send("VARIABLE BLUETOOTH DEVICENAME "+testModelNumber);
PrinterHelper.send("VARIABLE BLUETOOTH DISCOVERABLE ON");
PrinterHelper.send("VARIABLE BLUETOOTH RESET");
PrinterHelper.send("END");
}
String inchCount=PrinterHelper.commandWaitResponse("!SHOW INCHCOUNT");
if(inchCount==null)
{
return TestStatus.FAILED;
}
GUIHelper.logger.info(inchCount);
if(inchCount.matches("\\d{1,}"))
{
if(isSecurity)
{
int button;
PrinterHelper.send("!CAL 254\n!CAL 0\n!CAL 255\n!CAL 0\n");
button=GUIHelper.message("Is Paper Fed Until Perforation/Edge?", SWT.ICON_QUESTION|SWT.YES|SWT.NO);
if(button!=SWT.YES)
return TestStatus.FAILED;
}
return TestStatus.PASSED;
}
else
{
String failedMessage=Messages.getString("TestEngine.10")+inchCount+Messages.getString("TestEngine.11");
GUIHelper.logger.error(failedMessage);
GUIHelper.error(failedMessage);
return TestStatus.FAILED;
}
}
else
{
return TestStatus.SKIPPED;
}
}
static TestStatus doToneCheck()
{
GUIHelper.logger.info("");
if(isLX)
{
return TestStatus.SKIPPED;
}
String command="";
command="!0 0 0 0\nBEEP 60\nEND\n";
PrinterHelper.send(command);
int button=GUIHelper.message(Messages.getString("TestEngine.113"), SWT.ICON_QUESTION|SWT.YES|SWT.NO);
command="!0 0 0 0\nBEEP 1\nEND\n";
PrinterHelper.send(command);
if(button==SWT.YES)
{
GUIHelper.logger.info("Good");
return TestStatus.PASSED;
}
else
{
GUIHelper.logger.info("Bad");
GUIHelper.error(Messages.getString("TestEngine.12"));
return TestStatus.FAILED;
}
}
static boolean establishPrimaryConnection(int baud)
{
GUIHelper.logger.info("");
isConnectionTypeParallelOnly=false;
IPrinterConnection conn=null;
try
{
if(PrinterHelper.printer!=null)
{
GUIHelper.logger.warn("Closing pre-existing connection.");
try
{
PrinterHelper.printer.closeConnection();
GUIHelper.mainShell.setConnectionState(false, false);
}
catch(Exception e)
{
GUIHelper.logger.warn(e, e);
}
}
PrinterHelper.printer=new Printer();
if(locationCode!=GUIHelper.LocationCode.E&&isMadeByEnnoconnMalaysia==false)
{
GUIHelper.logger.info("Possible TSC location code detected: disabling parallel interface.");
CompositeManufacturing.checkBoxParallel.setEnabled(true);
CompositeManufacturing.checkBoxParallel.setSelection(false);
CompositeManufacturing.checkBoxParallel.setEnabled(false);
CompositeManufacturing.textParallelPort.setEnabled(true);
CompositeManufacturing.textParallelPort.setText("");
CompositeManufacturing.textParallelPort.setEnabled(false);
}
if(CompositeManufacturing.checkBoxUSBB.getSelection())
{
isConnectionTypeSerial=false;
isConnectionTypeParallelOnly=false;
connectionType=ConnectionType.OS_PRINTER;
conn=new WindowsPrinterConnection();
PrinterHelper.printer.openConnection(conn);
}
else if(CompositeManufacturing.checkBoxSerial.getSelection())
{
connectionType=ConnectionType.SERIAL;
isConnectionTypeSerial=true;
isConnectionTypeParallelOnly=false;
conn=new SerialConnection(CompositeManufacturing.textSerialPort.getText(), baud, 1);
PrinterHelper.printer.openConnection(conn);
boolean received=false;
PrinterHelper.send("!SHOW MODELNUMBER");
received=PrinterHelper.waitFor(".*Model Number.*", 1);
if(!received)
{
try
{
int newBaud=115200;
if(baud==115200)
{
newBaud=9600;
}
GUIHelper.logger.info("Establishing serial connection failed at baud rate of "+baud);
GUIHelper.logger.info("Trying to connect again at a different baud rate of "+newBaud);
if(establishSerialConnection(newBaud))
{
if(newBaud==9600)
{
PrinterHelper.setVariable("COMM", "115200,N,8,1,N");
PrinterHelper.printer.waitForResponse(".*115200.*", 10);
GUIHelper.logger.info("Trying to re-establish serial connection at 115200 baud rate");
return establishSerialConnection(115200);
}
else
{
return true;
}
}
else
{
return false;
}
}
catch(Exception ex)
{
GUIHelper.error(Messages.getString("TestEngine.14")+connectionType+".\n\n"+ex);
GUIHelper.logger.error(ex, ex);
return false;
}
}
}
else if(CompositeManufacturing.checkBoxNetwork.getSelection())
{
connectionType=ConnectionType.NETWORK;
isConnectionTypeSerial=false;
isConnectionTypeParallelOnly=false;
conn=new NetworkConnection(CompositeManufacturing.textIPAddress.getText(), 9100);
PrinterHelper.printer.openConnection(conn);
}
else if(CompositeManufacturing.checkBoxParallel.getSelection())
{
connectionType=ConnectionType.PARALLEL;
isConnectionTypeSerial=false;
isConnectionTypeParallelOnly=true;
conn=new ParallelConnection(CompositeManufacturing.textParallelPort.getText());
PrinterHelper.printer.openConnection(conn);
}
else
{
GUIHelper.error(Messages.getString("TestEngine.13"));
return false;
}
}
catch(Exception e)
{
GUIHelper.error(Messages.getString("TestEngine.14")+connectionType+".\n\n"+e);
GUIHelper.logger.error(e, e);
return false;
}
if(!isConnectionTypeParallelOnly&&!isConnectionTypeSerial)
{
if(!PrinterHelper.printer.isConnected())
{
if(connectionType==ConnectionType.OS_PRINTER)
{
GUIHelper.logger.warn("Closing pre-existing connection again for USB Direct Connect.");
try
{
PrinterHelper.printer.closeConnection();
PrinterHelper.printer.openConnection(conn);
}
catch(Exception e)
{
GUIHelper.error(Messages.getString("TestEngine.14")+connectionType+".\n\n"+e);
GUIHelper.logger.error(e, e);
return false;
}
if(!PrinterHelper.printer.isConnected())
{
GUIHelper.error(Messages.getString("TestEngine.14")+connectionType);
return false;
}
}
GUIHelper.error(Messages.getString("TestEngine.14")+connectionType);
return false;
}
}
GUIHelper.logger.info("Connected.");
return true;
}
static boolean establishSerialConnection(int baud)
{
GUIHelper.logger.info("");
return establishSerialConnection(baud, true);
}
static boolean establishSerialConnection(int baud, boolean showErrorDialog)
{
GUIHelper.logger.info("");
IPrinterConnection conn=null;
try
{
if(PrinterHelper.printer!=null)
{
GUIHelper.logger.warn("Closing pre-existing connection.");
try
{
PrinterHelper.printer.closeConnection();
GUIHelper.mainShell.setConnectionState(false, false);
}
catch(Exception e)
{
GUIHelper.logger.warn(e, e);
}
}
PrinterHelper.printer=new Printer();
isConnectionTypeSerial=true;
isConnectionTypeParallelOnly=false;
if(runningManufacturing)
{
conn=new SerialConnection(CompositeManufacturing.textSerialPort.getText(), baud, 1);
}
else
{
conn=new SerialConnection(CompositeConnectionSettings.comPort, baud, CompositeConnectionSettings.stopBits);
}
PrinterHelper.printer.openConnection(conn);
PrinterHelper.waitFor(PrinterHelper.GENERAL_PRINTER_READY, 1);
boolean received=false;
PrinterHelper.send("!SHOW MODELNUMBER");
received=PrinterHelper.waitFor(".*Model Number.*", 1);
if(!received)
{
if(showErrorDialog)
{
GUIHelper.error(Messages.getString("TestEngine.14")+ConnectionType.SERIAL);
}
return false;
}
else
{
GUIHelper.logger.info("Connected.");
return true;
}
}
catch(Exception e)
{
if(showErrorDialog)
{
GUIHelper.error(Messages.getString("TestEngine.14")+ConnectionType.SERIAL);
}
return false;
}
}
static boolean setSN_MAC(PrinterId printerId)
{
GUIHelper.logger.info("");
macHex=printerId.getQualifiedMac();
serialNumber=printerId.getQualifiedSerialNumber();
if(isGattaca&&(!serialNumber.startsWith("V")))
{
isMadeInChina=false;
serialNumber=serialNumber.replace(serialNumber.charAt(0), 'L');
}
else if(!(productLine==ProductLine.CI||productLine==ProductLine.CXI))
{
isMadeInChina=true;
}
if(isMadeByEnnoconnMalaysia)
{
serialNumber=serialNumber.replace(serialNumber.charAt(0), 'E');
}
GUIHelper.logger.info("Assigning new serial number ["+serialNumber+"].");
PrinterHelper.send("!LOAD SERIALNUMBER "+serialNumber);
if(isNetwork)
{
PrinterHelper.send("!LOAD MAC "+macHex);
GUIHelper.logger.info("Assigning new MAC ["+macHex+"].");
}
return true;
}
static TestStatus setModelNumber()
{
GUIHelper.logger.info("");
if(!isConnectionTypeParallelOnly)
{
if(currentModelNumber==null)
{
return TestStatus.FAILED;
}
if(currentModelNumber.equalsIgnoreCase(testModelNumber))
{
return TestStatus.SKIPPED;
}
}
if(brandNewPrinter||isConnectionTypeParallelOnly)
{
PrinterHelper.send("!LOAD MODELNUMBER "+testModelNumber);
changedModelNumber=true;
currentModelNumber=testModelNumber;
return TestStatus.PASSED;
}
else
{
String message=Messages.getString("TestEngine.16")+currentModelNumber+".\n"+Messages.getString("TestEngine.17")+testModelNumber+".\n\n"+Messages.getString("TestEngine.18");
int button=GUIHelper.message(message, SWT.OK|SWT.CANCEL|SWT.ICON_QUESTION);
if(button==SWT.CANCEL)
{
changedModelNumber=false;
return TestStatus.CANCELLED;
}
PrinterHelper.send("!LOAD MODELNUMBER "+testModelNumber);
changedModelNumber=true;
return TestStatus.PASSED;
}
}
static void updateOEMIdentifier(TestStep testStep)
{
if(testStep.equals(TestStep.INITIAL_SETUP))
{
if(testModelNumber.startsWith("700"))
{
PrinterHelper.send("!SET OEMMODELID "+CompositeManufacturing.textModelNumber.getText());
if(isTDModelNumber)
{
PrinterHelper.send("!SET OEMIDENTIFIER TALLYDASCOM");
}
else
{
PrinterHelper.send("!SET OEMIDENTIFIER TALLYGENICOM");
}
}
else
{
PrinterHelper.send("!SET OEMMODELID 0");
PrinterHelper.send("!SET OEMIDENTIFIER COGNITIVE");
}
if(!isConnectionTypeParallelOnly)
{
if(supportsFactoryRestoreCommand)
{
PrinterHelper.send("!!0 0 0 0\n!0 0 0 0\nVARIABLE FACTORY_RESTORE\nEND");
}
else
{
PrinterHelper.send("!!0 0 0 0\n!0 0 0 0\nVARIABLE RESET\nEND");
}
}
else
{
PrinterHelper.send("!!0 0 0 0\n!0 0 0 0\nVARIABLE RESET\nEND");
PrinterHelper.send("!!0 0 0 0\n!0 0 0 0\nVARIABLE FACTORY_RESTORE\nEND");
}
}
if(testStep.equals(TestStep.PRINTER_IDENTIFICATION))
{
if(testModelNumber.startsWith("700"))
{
PrinterHelper.send("!SET OEMMODELID "+CompositeManufacturing.textModelNumber.getText());
if(isTDModelNumber)
{
PrinterHelper.send("!SET OEMIDENTIFIER TALLYDASCOM");
}
else
{
PrinterHelper.send("!SET OEMIDENTIFIER TALLYGENICOM");
}
}
else
{
PrinterHelper.send("!SET OEMMODELID "+"0");
PrinterHelper.send("!SET OEMIDENTIFIER COGNITIVE");
}
PrinterHelper.send("!!0 0 0 0\n!0 0 0 0\nVARIABLE RESET\nEND");
try
{
PrinterHelper.setVariable("ETHERNET", "RESET");
Thread.sleep(40000);
}
catch(Exception e)
{
GUIHelper.logger.warn(e, e);
}
PrinterHelper.printer.waitFor(PrinterHelper.GENERAL_PRINTER_READY, 40);
}
if(testStep.equals(TestStep.CPR_DOWNLOAD))
{
if(testModelNumber.startsWith("700"))
{
PrinterHelper.send("!SET OEMMODELID "+CompositeManufacturing.textModelNumber.getText());
if(isTDModelNumber)
{
PrinterHelper.send("!SET OEMIDENTIFIER TALLYDASCOM");
}
else
{
PrinterHelper.send("!SET OEMIDENTIFIER TALLYGENICOM");
}
}
else
{
PrinterHelper.send("!SET OEMMODELID 0");
PrinterHelper.send("!SET OEMIDENTIFIER COGNITIVE");
}
}
}
static TestStatus identifyBrandNewPrinter()
{
GUIHelper.logger.info("");
changedSerialNumber=false;
changedMAC=false;
PrinterId printerId=null;
try
{
printerId=dbCreateNewPrinter(locationCode.toString().charAt(0), testModelNumber, isNetwork);
}
catch(Exception e)
{
GUIHelper.error(e.toString());
GUIHelper.logger.error(e, e);
return TestStatus.FAILED;
}
if(printerId==null)
{
int button=GUIHelper.message(Messages.getString("TestEngine.19"), SWT.ICON_QUESTION|SWT.YES|SWT.NO);
if(button==SWT.NO)
{
return TestStatus.FAILED;
}
else
{
return TestStatus.SKIPPED;
}
}
boolean success=setSN_MAC(printerId);
if(!success)
{
return TestStatus.FAILED;
}
else
{
changedSerialNumber=true;
if(isNetwork)
{
changedMAC=true;
}
return TestStatus.PASSED;
}
}
static boolean verifySerialNumberFormat(String sn)
{
if(sn.length()==0||sn.equalsIgnoreCase("z060800000"))
{
return false;
}
String match=GUIHelper.getMatch(sn, "\\w\\d{9}");
if(match.equals(sn))
{
if(isGattaca&&(!serialNumber.startsWith("V")))
{
isMadeInChina=false;
}
else if(!(productLine==ProductLine.CI||productLine==ProductLine.CXI))
{
isMadeInChina=true;
}
return true;
}
else
{
return false;
}
}
static boolean verifyMACFormat(String mc)
{
if(mc.length()==0||(mc.equalsIgnoreCase("00:00:00:00:00:ff")&&isNetwork))
{
return false;
}
if(isNetwork)
{
String match=GUIHelper.getMatch(mc, "\\w{2}(:\\w{2}){5}");
if(match.equals(mc))
{
return true;
}
else
{
return false;
}
}
else
{
return true;
}
}
static boolean verifySpecifiedIdentity()
{
if(!verifySerialNumberFormat(CompositeManufacturing.textSerialNumberActual.getText()))
{
GUIHelper.error(Messages.getString("TestEngine.20"));
return false;
}
if(!verifyMACFormat(CompositeManufacturing.textMacAddressActual.getText()))
{
GUIHelper.error(Messages.getString("TestEngine.21"));
return false;
}
return true;
}
static TestStatus assignSpecifiedIdentity()
{
GUIHelper.logger.info("");
try
{
if(!verifySpecifiedIdentity())
{
return TestStatus.FAILED;
}
PrinterHelper.send("!LOAD SERIALNUMBER "+CompositeManufacturing.textSerialNumberActual.getText());
PrinterHelper.send("!LOAD MAC "+CompositeManufacturing.textMacAddressActual.getText());
serialNumber=CompositeManufacturing.textSerialNumberActual.getText();
changedSerialNumber=true;
macHex=CompositeManufacturing.textMacAddressActual.getText();
if(isNetwork)
{
changedMAC=true;
}
CompositeManufacturing.checkBoxSpecSNMAC.setSelection(false);
CompositeManufacturing.textSerialNumberActual.setEditable(false);
CompositeManufacturing.textMacAddressActual.setEditable(false);
}
catch(Exception e)
{
return TestStatus.FAILED;
}
return TestStatus.PASSED;
}
static TestStatus doPrinterIdentification(boolean getNewPrinterID)
{
GUIHelper.logger.info("");
TestStatus subTestRes;
if(CompositeManufacturing.checkBoxSpecSNMAC.getSelection())
{
subTestRes=assignSpecifiedIdentity();
if(subTestRes==TestStatus.FAILED||subTestRes==TestStatus.CANCELLED)
{
return subTestRes;
}
}
else if(brandNewPrinter)
{
if(!isConnectionTypeParallelOnly)
{
PrinterHelper.send("!erase eventlog");
PrinterHelper.send("!LOAD INCHCOUNT 0x0000");
}
if(getNewPrinterID)
{
subTestRes=identifyBrandNewPrinter();
if(subTestRes==TestStatus.FAILED||subTestRes==TestStatus.CANCELLED)
{
return subTestRes;
}
}
}
subTestRes=setModelNumber();
if(subTestRes==TestStatus.FAILED||subTestRes==TestStatus.CANCELLED)
{
return subTestRes;
}
if(!(brandNewPrinter||changedMAC||changedModelNumber||changedSerialNumber))
{
return TestStatus.SKIPPED;
}
GUIHelper.logger.info("brandNewPrinter="+brandNewPrinter);
if(brandNewPrinter&&(!isConnectionTypeParallelOnly))
{
String ic=GUIHelper.clean(PrinterHelper.commandWaitResponse("!SHOW INCHCOUNT"));
if(!ic.equalsIgnoreCase("0"))
{
String msg=Messages.getString("TestEngine.22")+ic;
GUIHelper.error(msg);
GUIHelper.logger.error(msg);
return TestStatus.FAILED;
}
}
GUIHelper.logger.info("changedSerialNumber="+changedSerialNumber);
if(changedSerialNumber&&(!isConnectionTypeParallelOnly))
{
String sn=GUIHelper.clean(PrinterHelper.commandWaitResponse("!SHOW SERIALNUMBER"));
if(!sn.equalsIgnoreCase(serialNumber))
{
GUIHelper.error(Messages.getString("TestEngine.23")+serialNumber+"; current value is "+sn);
return TestStatus.FAILED;
}
}
GUIHelper.logger.info("changedModelNumber="+changedModelNumber);
if(changedModelNumber&&(!isConnectionTypeParallelOnly))
{
String mn=GUIHelper.clean(PrinterHelper.commandWaitResponse("!SHOW MODELNUMBER"));
if(!mn.equalsIgnoreCase(testModelNumber))
{
GUIHelper.error(Messages.getString("TestEngine.24")+testModelNumber+Messages.getString("TestEngine.26")+mn);
return TestStatus.FAILED;
}
}
GUIHelper.logger.info("changedMAC="+changedMAC);
if(changedMAC&&(!isConnectionTypeParallelOnly))
{
String ma=GUIHelper.clean(PrinterHelper.commandWaitResponse("!SHOW MAC"));
if(!ma.equalsIgnoreCase(macHex))
{
GUIHelper.error(Messages.getString("TestEngine.25")+macHex+Messages.getString("TestEngine.26")+ma);
return TestStatus.FAILED;
}
}
return TestStatus.PASSED;
}
static String httpGet(String urlString)
{
GUIHelper.logger.trace(urlString);
StringBuffer httpResponse=new StringBuffer();
try
{
GUIHelper.setCursor(SWT.CURSOR_WAIT);
URL server=new URL(urlString);
HttpURLConnection connection=(HttpURLConnection)server.openConnection();
connection.connect();
InputStream in=connection.getInputStream();
int c;
while((c=in.read())!=-1)
{
httpResponse.append((char)c);
}
in.close();
connection.disconnect();
}
catch(Exception e)
{
GUIHelper.logger.error(e, e);
return null;
}
finally
{
GUIHelper.setCursor(SWT.DEFAULT);
}
GUIHelper.logger.info(httpResponse.toString());
return httpResponse.toString();
}
static PrinterId dbCreateNewPrinter(char locationCode, String modelNumber, boolean isNetwork) throws DBException
{
GUIHelper.logger.info("");
Calendar calendar=new GregorianCalendar();
int year=calendar.get(Calendar.YEAR)-2000;
int week=calendar.get(Calendar.WEEK_OF_YEAR);
String snPrefix=String.format("%02d%02d", year, week);
StringBuffer urlEncodedQuery=new StringBuffer();
urlEncodedQuery.append("&");
urlEncodedQuery.append("act=inp");
urlEncodedQuery.append("&");
urlEncodedQuery.append("mn=");
urlEncodedQuery.append(modelNumber.replaceAll(" ", "%20"));
urlEncodedQuery.append("&");
urlEncodedQuery.append("lc=");
urlEncodedQuery.append(locationCode);
urlEncodedQuery.append("&");
urlEncodedQuery.append("snp=");
urlEncodedQuery.append(snPrefix);
urlEncodedQuery.append("&");
urlEncodedQuery.append("eth=");
urlEncodedQuery.append(isNetwork);
String url=jadminURLBase+urlEncodedQuery.toString();
if(isTGModelNumber||isTDModelNumber)
{
url=jadminURLBaseTG+urlEncodedQuery.toString();
}
String xmlPrinterId=httpGet(url);
if(xmlPrinterId==null)
{
return null;
}
else
{
return new PrinterId(xmlPrinterId);
}
}
static void displayPrinterID()
{
CompositeManufacturing.textSerialNumberActual.setText(serialNumber);
CompositeManufacturing.textMacAddressActual.setText(macHex);
CompositeManufacturing.textSerialNumberActual.setEnabled(true);
CompositeManufacturing.textMacAddressActual.setEnabled(true);
}
static TestStatus doLoadCPRs()
{
GUIHelper.logger.info("");
String currentFirmwarePartNumber=getCurrentFirmwarePartNumber();
if(Integer.parseInt(currentFirmwarePartNumber.substring(currentFirmwarePartNumber.length()-3))>326)
{
supportsFactoryRestoreCommand=true;
}
else
{
supportsFactoryRestoreCommand=false;
}
skipLoadingCPRs=GUIHelper.prefs.getBoolean("ACTIVATE_MANUFACTURING", false);
if(skipLoadingCPRs)
{
try
{
skipLoadingCPRs=CompositeManufacturing.checkBoxSkipLoad3.getSelection();
}
catch(Exception e)
{
skipLoadingCPRs=false;
}
}
if(!skipLoadingCPRs)
{
Vector<String>cprFiles=new Vector<String>();
switch(productLine)
{
case CI:
cprFiles.add("base_c.cpr");
if((isTGModelNumber||isTDModelNumber)&&testModelNumber.startsWith("7006"))
{
cprFiles.add("7006PID.cpr");
}
break;
case CXI:
cprFiles.add("base_c.cpr");
if((isTGModelNumber||isTDModelNumber)&&testModelNumber.startsWith("7008"))
{
cprFiles.add("7008PID.cpr");
}
break;
case LX:
if(isGattaca)
{
cprFiles.add("base_gattaca_lx.cpr");
}
break;
case DLX:
if(!isWingman)
{
if(!isGattaca)
{
cprFiles.add("base_dlx.cpr");
if((isTGModelNumber||isTDModelNumber)&&testModelNumber.startsWith("7005"))
{
cprFiles.add("7005PID.cpr");
}
}
else
{
cprFiles.add("base_gattaca_dlx.cpr");
}
}
else
{
cprFiles.add("base_wingman.cpr");
}
break;
}
if (printHead==PrintHead.Automatic)
{
if (productLine==ProductLine.DLX)
{
GUIHelper.logger.info("Printhead auto type selection: switching to use ROHM_KDxxxxDF type.");
printHead=PrintHead.ROHM_KDxxxxDF;
}
if ((productLine==ProductLine.CI||productLine==ProductLine.CXI))
{
GUIHelper.logger.info("Printhead auto type selection: switching to use HEC type.");
printHead=PrintHead.HEC;
}
}
if(productLine==ProductLine.DLX&&printHead!=PrintHead.ROHM_KDxxxxDF)
{
int button=GUIHelper.message("Warning!The printhead selected for the DLX printer is not set as "+"\"ROHM_KDxxxxDF\", which is what the production line uses by default. If the operator intended "+"on selecting a printhead other than \"ROHM_KDxxxxDF\", click yes to continue with the custom option. "+"Otherwise, click no to use the production line default printhead.", SWT.ICON_WARNING|SWT.YES|SWT.NO|SWT.CANCEL);
if (button==SWT.YES)
{
GUIHelper.logger.warn("User has manually decided to use a non-standard print head configuration of "+printHead.toString()+".");
}
else if(button==SWT.NO)
{
GUIHelper.logger.warn("User has manually decided to use a standard print head configuration of "+printHead.toString()+".");
CompositeManufacturing.comboPrintHead.select(1);
printHead=PrintHead.ROHM_KDxxxxDF;
}
else if(button==SWT.CANCEL)
{
return TestStatus.CANCELLED;
}
}
if((productLine==ProductLine.CI||productLine==ProductLine.CXI)&&printHead!=PrintHead.HEC)
{
int button=GUIHelper.message("Warning!The printhead selected for the C-Series printer is not set as "+"\"HEC\", which is what the production line uses by default. If the operator intended "+"on selecting a printhead other than \"HEC\", click*Yes*to continue with the custom option. "+"Otherwise, click*No*to use the production line default printhead.", SWT.ICON_WARNING|SWT.YES|SWT.NO|SWT.CANCEL);
if (button==SWT.YES)
{
GUIHelper.logger.warn("User has manually decided to use a non-standard print head configuration of "+printHead.toString()+".");
}
else if(button==SWT.NO)
{
GUIHelper.logger.warn("User has manually decided to use a standard print head configuration of "+printHead.toString()+".");
CompositeManufacturing.comboPrintHead.select(2);
printHead=PrintHead.HEC;
}
else if(button==SWT.CANCEL)
{
return TestStatus.CANCELLED;
}
}
if((productLine==ProductLine.DLX)&&(printHead==PrintHead.Kyocera))
{
cprFiles.add("phw_"+printHead.toString().toLowerCase()+"_"+mediaWidth+"in_"+printDensity+"dpi.cpr");
}
else
{
cprFiles.add("ph_"+printHead.toString().toLowerCase()+"_"+mediaWidth+"in_"+printDensity+"dpi.cpr");
}
switch(printMethod)
{
case DT:
cprFiles.add("mode_dt.cpr");
break;
case TT:
switch(productLine)
{
case CI:
case CXI:
cprFiles.add("mode_tt.cpr");
break;
case LX:
case DLX:
cprFiles.add("mode_tt_auto.cpr");
break;
}
}
switch(productLine)
{
case CI:
if(printMethod.equals(PrintMethod.TT))
{
cprFiles.add("ps_ci_tt.cpr");
}
else
{
cprFiles.add("ps_ci.cpr");
}
break;
case LX:
break;
case DLX:
cprFiles.add("ps_"+productLine.toString().toLowerCase()+".cpr");
break;
case CXI:
cprFiles.add("ps_"+productLine.toString().toLowerCase()+"_"+printDensity+"dpi.cpr");
break;
}
switch(productLine)
{
case CI:
case CXI:
cprFiles.add("tof_c.cpr");
break;
case LX:
case DLX:
cprFiles.add("tof_dlx.cpr");
break;
}
switch(exitOption)
{
case STANDARD:
case TEAR_BAR:
cprFiles.add("exit_standard.cpr");
break;
case PEELER:
cprFiles.add("exit_peeler_cutter.cpr");
break;
}
if(isApple)
{
cprFiles.add("apple.cpr");
}
cprFiles.add("serial_96008N1.cpr");
String cprPackage="com.cognitive.manufacturing.cpr";
Vector<String>fileNames=GUIHelper.getPackageEntries(cprPackage);
HashMap<String, Integer>patternBasedCprs=new HashMap<String, Integer>();
String modelNumber=CompositeManufacturing.textModelNumber.getText().trim();
if(!fileNames.isEmpty())
{
for(String fileName : fileNames)
{
String pattern=fileName.replace('x', '.');
pattern=pattern.replace('X', '.');
if(modelNumber.matches(pattern))
{
Integer count=new Integer(pattern.split("\\.",-1).length-1);
patternBasedCprs.put(fileName, count);
}
}
if(!patternBasedCprs.isEmpty())
{
LinkedHashMap<String, Integer>patternBasedSortedCprs=sortHashMapByValuesD(patternBasedCprs);
for(Iterator<String>it=patternBasedSortedCprs.keySet().iterator(); it.hasNext();)
{
cprFiles.add(it.next());
}
patternBasedSortedCprs.clear();
}
patternBasedCprs.clear();
}
fileNames.clear();
if(isSecurity)
{
String sSecurityCPR=SecurityConfig.getSetting(customization, "CPR_SETTINGS");
cprFiles.clear();
if(!sSecurityCPR.equals(""))
cprFiles.add(sSecurityCPR);
}
String cprResourcePath="com/cognitive/manufacturing/cpr/";
boolean success;
for(String cprFile : cprFiles)
{
success=loadCPRFile(cprResourcePath+cprFile);
if(!success)
{
return TestStatus.FAILED;
}
}
if(isMeter)
{
if(!loadCPRFile("com/cognitive/manufacturing/cpr/MeterEnabled.cpr"))
return TestStatus.FAILED;
PrinterHelper.setVariable("BUFFER_TIMED_RESET", "65534");
PrinterHelper.setVariable("DARKNESS", "50");
PrinterHelper.setVariable("TXTBFR", "8192 4096");
PrinterHelper.setVariable("LANGUAGE", "NONE");
PrinterHelper.setVariable("COMPATIBLE", "OFF");
PrinterHelper.setVariable("COMPATIBLE LOCAL_PITCH", "ON");
PrinterHelper.setVariable("COMPATIBLE LX_VAR_ERROR", "ON");
PrinterHelper.setVariable("COMPATIBLE DBF_ROT_LOC_ADJUST", "OFF");
PrinterHelper.setVariable("COMPATIBLE DISABLE_RG_JUSTIFY", "ON");
PrinterHelper.setVariable("COMPATIBLE POWERUP_PITCH", "OFF");
PrinterHelper.setVariable("COMPATIBLE USE_LX_PARSER", "ON");
PrinterHelper.setVariable("COMPATIBLE LX_HEAD_DEFS", "ON");
PrinterHelper.setVariable("COMPATIBLE LX_SINGLE_LABEL", "ON");
}
PrinterHelper.setVariable("USER_FEEDBACK", "ON");
if(isSecurity)
{
try
{
Thread.sleep(5000);
}
catch(Exception e)
{
}
String[] sVariables=new String[]{"CPR_SCRIPT", "SECURITY_SCRIPT", "PROFILE_SCRIPT"};
for(int iVar=0; iVar<sVariables.length;++iVar)
{
String sSecurityResource=SecurityConfig.getSetting(customization, sVariables[iVar]);
byte[] buff;
if(!sSecurityResource.equals(""))
{
buff=GUIHelper.getResourceAsByteArray(cprResourcePath+sSecurityResource);
if(buff==null)
{
GUIHelper.error("Can't load custom file: "+sSecurityResource);
return TestStatus.FAILED;
}
PrinterHelper.send(buff);
}
}
}
return TestStatus.PASSED;
}
else
{
return TestStatus.SKIPPED;
}
}
@SuppressWarnings("unchecked")
static LinkedHashMap<String, Integer>sortHashMapByValuesD(HashMap passedMap)
{
List mapKeys=new ArrayList(passedMap.keySet());
List mapValues=new ArrayList(passedMap.values());
Comparator descending=Collections.reverseOrder();
Collections.sort(mapValues, descending);
Collections.sort(mapKeys);
LinkedHashMap sortedMap=new LinkedHashMap();
Iterator valueIt=mapValues.iterator();
while(valueIt.hasNext())
{
Object val=valueIt.next();
String comp2=val.toString();
Iterator keyIt=mapKeys.iterator();
while(keyIt.hasNext())
{
Object key=keyIt.next();
String comp1=passedMap.get(key).toString();
if(comp1.equals(comp2))
{
passedMap.remove(key);
mapKeys.remove(key);
sortedMap.put((String)key, (Double)val);
break;
}
}
}
return sortedMap;
}
static boolean loadCPRFile(String cprResourceName)
{
GUIHelper.logger.info("");
byte[] buff=GUIHelper.getResourceAsByteArray(cprResourceName);
if(buff!=null)
{
PrinterHelper.send(buff);
PrinterHelper.send("\n");
if(!isConnectionTypeParallelOnly)
{
PrinterHelper.waitFor(PrinterHelper.GENERAL_PRINTER_READY, 15);
}
if(cprResourceName.contains("base"))
{
updateOEMIdentifier(TestStep.CPR_DOWNLOAD);
}
if(supportsFactoryRestoreCommand)
{
PrinterHelper.send("!!0 0 0 0\n!0 0 0 0\nVARIABLE FACTORY_RESTORE\nEND");
}
else
{
PrinterHelper.send("!!0 0 0 0\n!0 0 0 0\nVARIABLE RESET\nEND");
}
GUIHelper.logger.info("Sent CPR file "+cprResourceName);
return true;
}
else
{
GUIHelper.error(Messages.getString("TestEngine.28")+cprResourceName);
GUIHelper.logger.error(Messages.getString("TestEngine.29")+cprResourceName);
return false;
}
}
static boolean loadBaseCPRFile(String cprResourceName)
{
GUIHelper.logger.info("");
byte[] buff=GUIHelper.getResourceAsByteArray(cprResourceName);
if(buff!=null)
{
PrinterHelper.send(buff);
PrinterHelper.send("\n");
GUIHelper.logger.info("Sent CPR file "+cprResourceName);
return true;
}
else
{
GUIHelper.error(Messages.getString("TestEngine.28")+cprResourceName);
GUIHelper.logger.error(Messages.getString("TestEngine.29")+cprResourceName);
return false;
}
}
static TestStatus doLoadFonts(int printDensity)
{
GUIHelper.logger.info("");
skipLoadingFonts=GUIHelper.prefs.getBoolean("ACTIVATE_MANUFACTURING", false);
if(skipLoadingFonts)
{
try
{
skipLoadingFonts=CompositeManufacturing.checkBoxSkipLoad2.getSelection();
}
catch(Exception e)
{
skipLoadingFonts=false;
}
}
if(!skipLoadingFonts)
{
if(!isSecurity)
{
PrinterHelper.setVariable("USER_FEEDBACK", "ON");
String currentFirmwarePartNumber=getCurrentFirmwarePartNumber();
if(Integer.parseInt(currentFirmwarePartNumber.substring(currentFirmwarePartNumber.length()-3))>156)
{
supportsFontCheckCommand=true;
}
else
{
supportsFontCheckCommand=false;
}
if((!supportsFontCheckCommand)||isConnectionTypeParallelOnly)
{
PrinterHelper.send("!i 3\n");
boolean success=false;
if(!isConnectionTypeParallelOnly)
{
success=PrinterHelper.waitFor(PrinterHelper.GENERAL_PRINTER_READY, 30);
}
else
{
try
{
Thread.sleep(4000);
success=true;
}
catch(Exception ex)
{
success=false;
}
}
if(!success)
{
String msg="Unable to delete all fonts and objects";
GUIHelper.logger.error(msg);
GUIHelper.error(msg);
return TestStatus.FAILED;
}
}
TestStatus subTest=TestStatus.FAILED;
String fontPackage="com.cognitive.manufacturing.fonts";
String[] fontList=null;
if(!isPCL)
{
if(printDensity==200)
{
if(isWingman)
{
fontList=FontMap.wingman200dpi;
}
else if(isLX)
{
fontList=FontMap.lx200dpi;
}
else if(isResco)
{
fontList=FontMap.resco;
}
else
{
fontList=FontMap.general200dpi;
}
}
else
{
if(isWingman)
{
fontList=FontMap.wingman300dpi;
}
else if(isLX)
{
fontList=FontMap.lx300dpi;
}
else
{
fontList=FontMap.general300dpi;
}
}
}
else
{
fontList=FontMap.pcl;
}
subTest=loadFonts(fontPackage, fontList);
if(subTest!=TestStatus.PASSED)
{
return subTest;
}
}
else
{
String sSecurityResource=SecurityConfig.getSetting(customization, "CTR_SCRIPT");
byte[] buff;
if(!sSecurityResource.equals(""))
{
buff=GUIHelper.getResourceAsByteArray("com/cognitive/manufacturing/cpr/"+sSecurityResource);
if(buff==null)
{
GUIHelper.error("Can't load custom file: "+sSecurityResource);
return TestStatus.FAILED;
}
PrinterHelper.send(buff);
try
{
Thread.sleep(5000);
}
catch(Exception e)
{
}
}
if(customization.equals("S00"))
{
PrinterHelper.send("!OBJECT MARK_TYPE 07\n!OBJECT PACK\n");
try
{
Thread.sleep(2000);
}
catch(Exception e)
{
}
}
sSecurityResource=SecurityConfig.getSetting(customization, "SECURITY_IMAGE");
if(!sSecurityResource.equals(""))
{
buff=GUIHelper.getResourceAsByteArray("com/cognitive/manufacturing/cpr/"+sSecurityResource);
if(buff==null)
{
GUIHelper.error("Can't load custom file: "+sSecurityResource);
return TestStatus.FAILED;
}
PrinterHelper.send(buff);
try
{
Thread.sleep(2000);
}
catch(Exception e)
{
}
}
}
return TestStatus.PASSED;
}
return TestStatus.SKIPPED;
}
static TestStatus loadFonts(String fontPackage, String[] fontList)
{
GUIHelper.logger.info("Loading fonts from: "+fontPackage);
Vector<String[]>currentObjects=new Vector<String[]>();
if(!isConnectionTypeParallelOnly)
{
currentObjects=GUIHelper.getParsedObjectList();
}
Vector<String[]>newObjects=new Vector<String[]>();
Vector<String>fileNames=GUIHelper.getPackageEntries(fontPackage);
if(!fileNames.isEmpty())
{
for(int i=0; i<fontList.length; i++)
{
for(String fileName : fileNames)
{
if(fontList[i].toUpperCase().equalsIgnoreCase(fileName.toUpperCase()))
{
String fontName=null;
String fontDesc=null;
int fontType=0;
String filePath=fontPackage.replace('.', '/')+"/"+fileName;
byte[] buff=GUIHelper.getResourceAsByteArray(filePath);
if(buff==null)
{
GUIHelper.logger.error("Can't read data-store font "+fileName);
return TestStatus.FAILED;
}
else
{
int numOfBytes=-1;
if(!currentObjects.isEmpty()&&supportsFontCheckCommand&&!isConnectionTypeParallelOnly)
{
numOfBytes=getObjectInfo(buff, filePath);
if(numOfBytes==-111)
{
GUIHelper.logger.error("Unable to Get Object Info");
GUIHelper.error("Unable to Get Object Info");
return TestStatus.FAILED;
}
}
fontName=getFontName(buff);
fontType=getFontType(buff);
fontDesc=getFontDesc(buff);
if(fontName==null)
{
String msg="Can't extract font name for file "+fileName;
GUIHelper.error(msg);
GUIHelper.logger.error(msg);
return TestStatus.FAILED;
}
else
{
newObjects.add(new String[]{fontName, String.valueOf(numOfBytes), fileName, String.valueOf(fontType), fontDesc});
}
}
break;
}
}
}
}
else
{
GUIHelper.logger.info("Font Package "+fontPackage+" is empty.");
}
if(!currentObjects.isEmpty()&&supportsFontCheckCommand&&!isConnectionTypeParallelOnly)
{
boolean isAnyMarkedForDeletion=false;
for(int i=currentObjects.size()-1; i>-1; i--)
{
String[] currentObject=currentObjects.get(i);
boolean found=false;
GUIHelper.logger.info("current font "+i+": "+currentObject[4]);
for(String[] newObject : newObjects)
{
if(currentObject[0].equalsIgnoreCase(newObject[0]))
{
GUIHelper.logger.info("current font "+i+": "+currentObject[4]+" found");
GUIHelper.logger.info("new font: "+newObject[4]);
found=true;
int numOfBytes=Integer.parseInt(newObject[1]);
if(numOfBytes>0)
{
PrinterHelper.send("!OBJECT MARK "+currentObject[0]);
isAnyMarkedForDeletion=true;
GUIHelper.logger.info("Marked for deletion Font (Older Version): "+currentObject[0]);
}
else if(((Integer.parseInt(newObject[3])==9)||(Integer.parseInt(newObject[3])==37))&&!currentObject[4].equalsIgnoreCase(newObject[4]))
{
PrinterHelper.send("!OBJECT MARK "+currentObject[0]);
isAnyMarkedForDeletion=true;
GUIHelper.logger.info("Marked for deletion Font (DPI change): "+currentObject[0]);
newObject[1]="-1";
}
break;
}
}
if(!found)
{
GUIHelper.logger.info("current font "+i+": "+currentObject[4]+" not found");
PrinterHelper.send("!OBJECT MARK "+currentObject[0]);
isAnyMarkedForDeletion=true;
GUIHelper.logger.info("Marked for deletion Font (Extra): "+currentObject[0]);
}
}
if(isAnyMarkedForDeletion)
{
GUIHelper.logger.info("Deleting all the fonts marked..");
PrinterHelper.send("!OBJECT PACK");
boolean success=false;
if(!isConnectionTypeParallelOnly)
{
success=PrinterHelper.waitFor(PrinterHelper.GENERAL_PRINTER_READY, 600);
if(!success)
{
String msg="Unable to delete fonts marked for deletion";
GUIHelper.logger.error(msg);
GUIHelper.error(msg);
return TestStatus.FAILED;
}
}
else
{
try
{
Thread.sleep(4000);
}
catch(Exception ex)
{
return TestStatus.FAILED;
}
}
}
}
for(String[] newObject : newObjects)
{
int numOfBytes=Integer.parseInt(newObject[1]);
if((numOfBytes==-1)||(numOfBytes>0))
{
boolean success=false;
byte[] buff=GUIHelper.getResourceAsByteArray(fontPackage.replace('.', '/')+"/"+newObject[2]);
if(buff==null)
{
GUIHelper.logger.error("Can't read data-store font "+newObject[2]);
return TestStatus.FAILED;
}
else
{
try
{
Thread.sleep(2000);
}
catch(Exception ex)
{
success=false;
}
PrinterHelper.send(buff);
if(!isConnectionTypeParallelOnly)
{
success=PrinterHelper.waitFor(PrinterHelper.GENERAL_PRINTER_READY, 120);
}
else
{
try
{
int waitFor=(int)((buff.length/1024)*50);
Thread.sleep(waitFor);
success=true;
}
catch(Exception ex)
{
success=false;
}
}
if(!success)
{
String msg="Can't confirm flashing of font "+newObject[2];
if(newObject[2].contains("map"))
{
msg="Can't confirm flashing of codepage/keyboard file "+newObject[2];
}
GUIHelper.logger.error(msg);
GUIHelper.error(msg);
return TestStatus.FAILED;
}
GUIHelper.logger.info("Successfully loaded font "+newObject[2]);
}
}
}
return TestStatus.PASSED;
}
static boolean isAsianFont(String fileName)
{
boolean isAsianFont=false;
String[] fontList=FontMap.asianfonts;
for(int i=0; i<fontList.length; i++)
{
if(fontList[i].toUpperCase().equalsIgnoreCase(fileName.toUpperCase()))
{
isAsianFont=true;
}
}
return isAsianFont;
}
static int getObjectInfo(byte[] buff, String filePath)
{
String command=parseFont(buff, filePath);
int i=0;
GUIHelper.logger.info("Command to check font:"+command);
try
{
i=Integer.parseInt(GUIHelper.clean(PrinterHelper.commandWaitResponse(command)));
}
catch(Exception e)
{
GUIHelper.logger.error(e, e);
GUIHelper.error(e.getMessage());
i=-111;
}
return i;
}
private static String parseFont(byte[] buff, String filePath)
{
String id=null;
int type=0;
String crc=null;
String version=null;
int length=buff.length;
if(length>500)
{
length=500;
}
String command=null;
String fontString=new String(buff, 0, length);
StringBuffer hexString=new StringBuffer();
String hex=null;
int i=0;
if(buff[0]=='C')
{
i=fontString.indexOf('!');
}
id=fontString.substring(i+10, i+18).trim();
type=buff[i+7]&0xFF;
hexString.append("0x");
if(type>35)
{
hex=Integer.toHexString(buff[i+56]&0xFF);
if(hex.length()==1)
{
hexString.append('0');
}
hexString.append(hex);
hex=Integer.toHexString(buff[i+57]&0xFF);
if(hex.length()==1)
{
hexString.append('0');
}
hexString.append(hex);
version=hexString.toString();
command="!OBJECT INFO "+id+" "+type+" "+version+"\n";
}
else
{
if(type!=14)
{
hex=Integer.toHexString(buff[buff.length-2]&0xFF);
if(hex.length()==1)
{
hexString.append('0');
}
hexString.append(hex);
hex=Integer.toHexString(buff[buff.length-1]&0xFF);
if(hex.length()==1)
{
hexString.append('0');
}
hexString.append(hex);
}
else
{
hexString.append(GUIHelper.getCRC(filePath));
}
crc=hexString.toString();
command="!OBJECT INFO "+id+" "+type+" "+crc+"\n";
}
return command;
}
private static int getFontType(byte[] buff)
{
int fontType=0;
int length=buff.length;
if(length>500)
{
length=500;
}
String fontString=new String(buff, 0, length);
int i=0;
if(buff[0]=='C')
{
i=80;
}
fontType=buff[i+7]&0xFF;
return fontType;
}
private static String getFontName(byte[] buff)
{
String fontName=null;
int length=buff.length;
if(length>500)
{
length=500;
}
String fontString=new String(buff, 0, length);
int i=0;
if(buff[0]=='C')
{
i=80;
}
fontName=fontString.substring(i+10, i+18).trim();
return fontName;
}
private static String getFontDesc(byte[] buff)
{
String fontDesc=null;
int length=buff.length;
if(length>500)
{
length=500;
}
String fontString=new String(buff, 0, length);
int i=0;
if(buff[0]=='C')
{
i=80;
}
fontDesc=fontString.substring(i+22, i+54).trim();
return fontDesc;
}
static boolean fontExists(String name, Vector<String[]>objectList)
{
GUIHelper.logger.trace("");
for(String[] object : objectList)
{
String fontName=object[0];
if(fontName.equalsIgnoreCase(name))
{
String type=object[1];
if(!type.equalsIgnoreCase(GUIHelper.compressedBitmapFont))
{
return true;
}
else
{
String description=object[4];
int fontDensity;
if(description.indexOf("300")!=-1)
{
fontDensity=300;
}
else if(description.indexOf("200")!=-1)
{
fontDensity=200;
}
else
{
fontDensity=0;
}
if(fontDensity==printDensity||fontDensity==0)
{
return true;
}
else
{
isFontDensityDifferent=true;
GUIHelper.logger.debug("Changing from "+fontDensity+" DPI to "+printDensity+" DPI resolution");
GUIHelper.logger.debug("Deleting all the fonts and objects for "+fontDensity+" DPI resolution");
return false;
}
}
}
}
return false;
}
static boolean isIndexingGood(String mode, String feed)
{
GUIHelper.logger.trace("");
int button=GUIHelper.message(Messages.getString("TestEngine.30")+mode+" and feed-type "+feed+"?",
SWT.ICON_QUESTION|SWT.YES|SWT.NO);
if(button==SWT.YES)
{
return true;
}
else
{
return false;
}
}
static TestStatus doCalibration(PrintMethod printMethod, boolean boardTest)
{
GUIHelper.logger.info("");
boolean result;
if(isSecurity)
{
String sSecurityScript=SecurityConfig.getSetting(customization, "CALIBRATION");
byte[] buff;
if(!sSecurityScript.equals(""))
{
buff=GUIHelper.getResourceAsByteArray("com/cognitive/manufacturing/cpr/"+sSecurityScript);
if(buff==null)
{
GUIHelper.error("Can't load custom file: "+sSecurityScript);
return TestStatus.FAILED;
}
PrinterHelper.send(buff);
}
}
else
{
if(!boardTest)
{
result=calibrate("DT", "BAR", 0);
if(!result)
return TestStatus.FAILED;
result=calibrate("DT", "GAP", 1);
if(!result)
return TestStatus.FAILED;
}
if(printMethod==PrintMethod.TT)
{
PrinterHelper.setVariable("PRINT_MODE", "TT");
if(!boardTest)
GUIHelper.message(Messages.getString("TestEngine.31"), SWT.ICON_WORKING|SWT.OK);
result=calibrate("TT", "BAR", 23);
if(!result)
return TestStatus.FAILED;
result=calibrate("TT", "GAP", 2);
if(!result)
return TestStatus.FAILED;
}
}
return TestStatus.PASSED;
}
static boolean calibrate(String mode, String feed, int n)
{
String desc="Mode: "+mode+"; Feed: "+feed;
GUIHelper.logger.info(desc);
PrinterHelper.setVariable("PRINT_MODE", mode);
PrinterHelper.setVariable("FEED_TYPE", feed);
PrinterHelper.setVariable("MEASURE_LABEL", "OFF");
PrinterHelper.setVariable("INDEX", "OFF");
if(!doFactoryCalibrate(n, desc))
{
return false;
}
PrinterHelper.send("!!0 0 0 0\n!0 0 0 0\nV INDEX SETTING CALIBRATE\nEND");
boolean received=false;
if(!isConnectionTypeParallelOnly)
{
received=PrinterHelper.waitFor(".*C3P.*", 60);
if(!received)
{
GUIHelper.error(Messages.getString("TestEngine.32")+desc);
return false;
}
}
else
{
try
{
Thread.sleep(8000);
}
catch(Exception ex)
{
return false;
}
}
PrinterHelper.setVariable("INDEX", "ON");
PrinterHelper.printTestLabel("", "", "Mode: "+mode+"; Feed: "+feed);
return isIndexingGood(mode, feed);
}
static boolean doFactoryCalibrate(int n, String desc)
{
PrinterHelper.send("!CAL 254");
PrinterHelper.send("!CAL "+n);
boolean received=false;
if(!isConnectionTypeParallelOnly)
{
received=PrinterHelper.waitFor(".*C"+n+"P.*", 60);
if(!received)
{
GUIHelper.error(Messages.getString("TestEngine.32")+desc);
return false;
}
}
else
{
try
{
Thread.sleep(8000);
}
catch(Exception ex)
{
return false;
}
}
PrinterHelper.send("!CAL 255");
return true;
}
static TestStatus doPrintHeadUpDown()
{
GUIHelper.logger.info("");
if(isConnectionTypeParallelOnly)
{
int button=GUIHelper.message(Messages.getString("TestEngine.114"), SWT.ICON_WORKING|SWT.OK);
if(button==SWT.OK)
{
try
{
Thread.sleep(5000);
}
catch(Exception ex)
{
return TestStatus.FAILED;
}
}
else
{
return TestStatus.FAILED;
}
button=GUIHelper.message(Messages.getString("TestEngine.115"), SWT.ICON_WORKING|SWT.OK);
if(button==SWT.OK)
{
try
{
PrinterHelper.setVariable("PRINT_MODE", "DT");
Thread.sleep(5000);
}
catch(Exception ex)
{
return TestStatus.FAILED;
}
}
else
{
return TestStatus.FAILED;
}
}
else
{
PrinterHelper.setVariable("PRINT_MODE", "DT");
JAdminDialogMessage dialog=new JAdminDialogMessage(Messages.getString("TestEngine.33"));
dialog.setMessage(Messages.getString("TestEngine.34"));
dialog.show();
boolean received=PrinterHelper.waitFor(".*U00000.*", 20);
dialog.hide();
if(!received)
{
dialog.close();
GUIHelper.error(Messages.getString("TestEngine.35"));
return TestStatus.FAILED;
}
dialog.setMessage(Messages.getString("TestEngine.36"));
dialog.show();
received=PrinterHelper.waitFor(".*[WR]00000.*", 60);
dialog.close();
if(!received)
{
return TestStatus.FAILED;
}
}
return TestStatus.PASSED;
}
static TestStatus doPrintHeadTest()
{
GUIHelper.logger.info("");
byte[] buff=null;
if(isLX)
{
buff=GUIHelper.getResourceAsByteArray("com/cognitive/manufacturing/labels/TestPattern_LX.txt");
}
else
{
buff=GUIHelper.getResourceAsByteArray("com/cognitive/manufacturing/labels/TestPattern.txt");
}
if(buff==null)
{
GUIHelper.error(Messages.getString("TestEngine.37"));
return TestStatus.FAILED;
}
PrinterHelper.send(buff);
int button=GUIHelper.message(Messages.getString("TestEngine.54"), SWT.ICON_QUESTION|SWT.YES|SWT.NO);
if(button==SWT.YES)
{
return TestStatus.PASSED;
}
else
{
return TestStatus.FAILED;
}
}
static StringBuffer getTestLabelPath(int mediaWidth, int printDensity)
{
StringBuffer path=new StringBuffer();
path.append("com/cognitive/manufacturing/labels/");
switch(mediaWidth)
{
case 2:
path.append("inch2/");
break;
case 4:
path.append("inch4/");
break;
default:
GUIHelper.error(Messages.getString("TestEngine.38")+mediaWidth);
return null;
}
switch(printDensity)
{
case 200:
path.append("dpi200/");
break;
case 300:
path.append("dpi300/");
break;
default:
GUIHelper.error(Messages.getString("TestEngine.39")+printDensity);
return null;
}
return path;
}
static TestStatus doPrintQuality(int mediaWidth, int printDensity)
{
GUIHelper.logger.info("");
boolean success;
StringBuffer path=getTestLabelPath(mediaWidth, printDensity);
if(path==null)
{
return TestStatus.FAILED;
}
PrinterHelper.setVariable("", "HIGHSPEED");
boolean testBT=((productLine!=ProductLine.LX)&&(CompositeManufacturing.checkBoxBT1.getSelection()));
if (testBT&&isBT)
{
StringBuffer btMacBarCode=new StringBuffer();
if(isLX)
{
btMacBarCode.append("!");
}
btMacBarCode.append("!0 100 300 1\n");
btMacBarCode.append("TEXT 1 20 15 Name:"+btDeviceName.replaceAll("BLUETOOTH DEVICENAME", "").replaceAll("=", "").trim().toUpperCase()+"\n");
btMacBarCode.append("TEXT 1 20 50 BT Address:"+btMacAddress+"\n");
btMacBarCode.append("END\n");
PrinterHelper.send(btMacBarCode.toString());
}
StringBuffer ladder=new StringBuffer(path.toString());
if(isWingman)
{
ladder.append("barcode_ladder_epl.txt");
}
else if(isLX)
{
ladder.append("barcode_ladder_LX.txt");
}
else
{
ladder.append("barcode_ladder.txt");
}
StringBuffer picket=new StringBuffer(path.toString());
if(isTDModelNumber)
{
picket.append("barcode_picket_td.txt");
}
else if(isTGModelNumber)
{
picket.append("barcode_picket_tg.txt");
}
else if(isWingman)
{
picket.append("barcode_picket_epl.txt");
}
else if(isLX)
{
picket.append("barcode_picket_LX.txt");
}
else
{
picket.append("barcode_picket.txt");
}
byte[] buff=GUIHelper.getResourceAsByteArray(ladder.toString());
if(buff==null)
{
GUIHelper.error(Messages.getString("TestEngine.40")+ladder.toString()+Messages.getString("TestEngine.41"));
return TestStatus.FAILED;
}
PrinterHelper.send(buff);
success=isQualityAcceptable(CompositeManufacturing.checkBoxScanner.getSelection());
if(!success)
{
return TestStatus.FAILED;
}
buff=GUIHelper.getResourceAsByteArray(picket.toString());
if(buff==null)
{
GUIHelper.error(Messages.getString("TestEngine.40")+picket.toString()+Messages.getString("TestEngine.41"));
return TestStatus.FAILED;
}
PrinterHelper.send(buff);
success=isQualityAcceptable(CompositeManufacturing.checkBoxScanner.getSelection());
if(!success)
{
return TestStatus.FAILED;
}
return TestStatus.PASSED;
}
static TestStatus doRibbonWrinkle(int mediaWidth, int printDensity)
{
GUIHelper.logger.trace("");
if(!((productLine==ProductLine.CI||productLine==ProductLine.CXI)&&printMethod==PrintMethod.TT))
{
return TestStatus.SKIPPED;
}
StringBuffer path=getTestLabelPath(mediaWidth, printDensity);
if(path==null)
{
return TestStatus.FAILED;
}
StringBuffer picket=new StringBuffer(path.toString());
if(isTDModelNumber)
{
picket.append("barcode_picket_td.txt");
}
else if(isTGModelNumber)
{
picket.append("barcode_picket_tg.txt");
}
else if(isLX)
{
picket.append("barcode_picket_LX.txt");
}
else
{
picket.append("barcode_picket.txt");
}
byte[] buff=GUIHelper.getResourceAsByteArray(picket.toString());
if(buff==null)
{
GUIHelper.error(Messages.getString("TestEngine.40")+picket.toString()+Messages.getString("TestEngine.41"));
return TestStatus.FAILED;
}
for(int i=0; i<15; i++)
{
PrinterHelper.send(buff);
try
{
Thread.sleep(700);
}
catch(Exception e)
{
}
}
int button=GUIHelper.message(Messages.getString("TestEngine.46"), SWT.ICON_QUESTION|SWT.YES|SWT.NO);
if(button==SWT.YES)
{
return TestStatus.FAILED;
}
else
{
return TestStatus.PASSED;
}
}
static boolean scanQuality()
{
JAdminDialogMessage dialog=new JAdminDialogMessage(Messages.getString("TestEngine.47"));
dialog.setMessage(Messages.getString("TestEngine.48"));
dialog.show();
long currentTime=(new GregorianCalendar()).getTimeInMillis();
long maxTime=currentTime+30000;
boolean retVal=false;
while(currentTime<=maxTime)
{
String grade=null;
QualityScanner scanner=null;
try
{
scanner=new QualityScanner(CompositeManufacturing.textScanner.getText().toUpperCase(), 9600);
scanner.openConnection();
grade=scanner.waitForGrade();
}
catch(Exception e)
{
GUIHelper.logger.error(e, e);
GUIHelper.error(Messages.getString("TestEngine.49"));
}
finally
{
dialog.hide();
try
{
scanner.closeConnection();
}
catch(Exception e)
{
GUIHelper.logger.error(e, e);
GUIHelper.error(Messages.getString("TestEngine.50"));
}
}
if(grade==null)
{
retVal=false;
GUIHelper.error(Messages.getString("TestEngine.51"));
break;
}
GUIHelper.logger.info("Grade: "+grade);
if(grade.matches("[ABC]"))
{
GUIHelper.myDisplay.beep();
retVal=true;
break;
}
else
{
dialog.setMessage(Messages.getString("TestEngine.52")+grade+Messages.getString("TestEngine.53"));
GUIHelper.myDisplay.beep();
GUIHelper.myDisplay.beep();
currentTime=(new GregorianCalendar()).getTimeInMillis();
continue;
}
}
return retVal;
}
static boolean isQualityAcceptable(boolean scan)
{
GUIHelper.logger.trace("");
if(scan)
{
return scanQuality();
}
else
{
int button=GUIHelper.message(Messages.getString("TestEngine.124"), SWT.ICON_QUESTION|SWT.YES|SWT.NO);
if(button==SWT.YES)
{
return true;
}
else
{
return false;
}
}
}
static TestStatus doFinalSettings()
{
GUIHelper.logger.info("");
boolean isSQ=false;
if(customization!=null)
{
if(customization.equals("01")||customization.equals("COMGRPH"))
{
byte[] buff=GUIHelper.getResourceAsByteArray("com/cognitive/manufacturing/cpr/W2M2.bmp");
if(buff==null)
{
GUIHelper.error("Can't load Custom File: W2M2.bmp");
return TestStatus.FAILED;
}
PrinterHelper.send("!!0 0 0 0\n!0 0 0 0\nGRAPHIC STORE BMP 3 W2M2");
PrinterHelper.send(buff);
boolean success=PrinterHelper.waitFor(PrinterHelper.GENERAL_PRINTER_READY, 120);
if(!success)
{
GUIHelper.error("Object download error: W2M2.bmp");
return TestStatus.FAILED;
}
buff=GUIHelper.getResourceAsByteArray("com/cognitive/manufacturing/cpr/COMG_4mat_VTerm5.txt");
if(buff==null)
{
GUIHelper.error("Can't load Custom File: COMG_4mat_VTerm5.txt");
return TestStatus.FAILED;
}
PrinterHelper.send(buff);
buff=GUIHelper.getResourceAsByteArray("com/cognitive/manufacturing/cpr/COMG_DLX_C01.cpr");
if(buff==null)
{
GUIHelper.error("Can't load Custom File: COMG_DLX_C01.cpr");
return TestStatus.FAILED;
}
PrinterHelper.send(buff);
if(customization.equals("COMGRPH"))
{
buff=GUIHelper.getResourceAsByteArray("com/cognitive/manufacturing/cpr/DLX_NoLXHeadDefs.cpr");
if(buff==null)
{
GUIHelper.error("Can't load Custom File: DLX_NoLXHeadDefs.cpr");
return TestStatus.FAILED;
}
PrinterHelper.send(buff);
}
}
else if(customization.equals("BS"))
{
byte[] buff=GUIHelper.getResourceAsByteArray("com/cognitive/manufacturing/cpr/bridgestone.txt");
if(buff==null)
{
GUIHelper.error("Can't load Custom File: bridgestone.txt");
return TestStatus.FAILED;
}
PrinterHelper.send(buff);
buff=GUIHelper.getResourceAsByteArray("com/cognitive/manufacturing/cpr/COMG_DLX_C02.cpr");
if(buff==null)
{
GUIHelper.error("Can't load Custom File: COMG_DLX_C02.cpr");
return TestStatus.FAILED;
}
PrinterHelper.send(buff);
buff=GUIHelper.getResourceAsByteArray("com/cognitive/manufacturing/cpr/DLX_NoLXHeadDefs.cpr");
if(buff==null)
{
GUIHelper.error("Can't load Custom File: DLX_NoLXHeadDefs.cpr");
return TestStatus.FAILED;
}
PrinterHelper.send(buff);
}
else if(customization.equals("PCL"))
{
enablePCL(false);
isPCL=true;
}
else if(customization.equals("D1"))
{
boolean success=loadCPRFile("com/cognitive/manufacturing/cpr/DSCXD41000D1.cpr");
if(!success)
{
return TestStatus.FAILED;
}
}
else if(customization.equals("SQ"))
{
String modelNumber=CompositeManufacturing.textModelNumber.getText();
if(!(modelNumber.charAt(11)=='G'&&modelNumber.charAt(12)=='S'&&modelNumber.charAt(13)=='S'))
{
byte[] buff=GUIHelper.getResourceAsByteArray("com/cognitive/manufacturing/cpr/SunQuest.cpr");
if(buff==null)
{
GUIHelper.error("Can't load Custom File: SunQuest.cpr");
return TestStatus.FAILED;
}
PrinterHelper.send(buff);
isSQ=true;
}
}
else if(customization.equals("HD"))
{
byte[] buff=GUIHelper.getResourceAsByteArray("com/cognitive/manufacturing/cpr/HomeDepot.cpr");
if(buff==null)
{
GUIHelper.error("Can't load Custom File: HomeDepot.cpr");
return TestStatus.FAILED;
}
PrinterHelper.send(buff);
}
else if(customization.equals("S1"))
{
String modelNumber=CompositeManufacturing.textModelNumber.getText();
if(!(modelNumber.charAt(11)=='G'&&modelNumber.charAt(12)=='S'&&modelNumber.charAt(13)=='S'))
{
byte[] buff=GUIHelper.getResourceAsByteArray("com/cognitive/manufacturing/cpr/Siemens.cpr");
if(buff==null)
{
GUIHelper.error("Can't load Custom File: Siemens.cpr");
return TestStatus.FAILED;
}
PrinterHelper.send(buff);
}
}
}
if(isGWN)
{
byte[] buff=GUIHelper.getResourceAsByteArray("com/cognitive/manufacturing/cpr/gwinb.pcx");
if(buff==null)
{
GUIHelper.error("Can't load Custom File: gwinb.pcx");
return TestStatus.FAILED;
}
PrinterHelper.send("!!0 0 0 0\n!0 0 0 0\nGRAPHIC STORE PCX 3 gwinb");
PrinterHelper.send(buff);
boolean success=PrinterHelper.waitFor(PrinterHelper.GENERAL_PRINTER_READY, 120);
if(!success)
{
GUIHelper.error("Object download error: gwinb.pcx");
return TestStatus.FAILED;
}
buff=GUIHelper.getResourceAsByteArray("com/cognitive/manufacturing/cpr/gwn_85.pcx");
if(buff==null)
{
GUIHelper.error("Can't load Custom File: gwn_85.pcx");
return TestStatus.FAILED;
}
PrinterHelper.send("!!0 0 0 0\n!0 0 0 0\nGRAPHIC STORE PCX 3 gwn_85");
PrinterHelper.send(buff);
success=PrinterHelper.waitFor(PrinterHelper.GENERAL_PRINTER_READY, 120);
if(!success)
{
GUIHelper.error("Object download error: gwn_85.pcx");
return TestStatus.FAILED;
}
buff=GUIHelper.getResourceAsByteArray("com/cognitive/manufacturing/cpr/gwn_wrnb.pcx");
if(buff==null)
{
GUIHelper.error("Can't load Custom File: gwn_wrnb.pcx");
return TestStatus.FAILED;
}
PrinterHelper.send("!!0 0 0 0\n!0 0 0 0\nGRAPHIC STORE PCX 3 gwn_wrnb");
PrinterHelper.send(buff);
success=PrinterHelper.waitFor(PrinterHelper.GENERAL_PRINTER_READY, 120);
if(!success)
{
GUIHelper.error("Object download error: gwn_wrnb.pcx");
return TestStatus.FAILED;
}
buff=GUIHelper.getResourceAsByteArray("com/cognitive/manufacturing/cpr/gwnvdbig.pcx");
if(buff==null)
{
GUIHelper.error("Can't load Custom File: gwnvdbig.pcx");
return TestStatus.FAILED;
}
PrinterHelper.send("!!0 0 0 0\n!0 0 0 0\nGRAPHIC STORE PCX 3 gwnvdbig");
PrinterHelper.send(buff);
success=PrinterHelper.waitFor(PrinterHelper.GENERAL_PRINTER_READY, 120);
if(!success)
{
GUIHelper.error("Object download error: gwnvdbig.pcx");
return TestStatus.FAILED;
}
buff=GUIHelper.getResourceAsByteArray("com/cognitive/manufacturing/cpr/vld3x4b.pcx");
if(buff==null)
{
GUIHelper.error("Can't load Custom File: vld3x4b.pcx");
return TestStatus.FAILED;
}
PrinterHelper.send("!!0 0 0 0\n!0 0 0 0\nGRAPHIC STORE PCX 3 vld3x4b");
PrinterHelper.send(buff);
success=PrinterHelper.waitFor(PrinterHelper.GENERAL_PRINTER_READY, 120);
if(!success)
{
GUIHelper.error("Object download error: vld3x4b.pcx");
return TestStatus.FAILED;
}
success=loadCPRFile("com/cognitive/manufacturing/cpr/security.cpr");
if(!success)
{
return TestStatus.FAILED;
}
}
if(isResco)
{
boolean success=loadCPRFile("com/cognitive/manufacturing/cpr/resco.cpr");
if(!success)
{
return TestStatus.FAILED;
}
}
if(!isPCL&&CompositeManufacturing.checkBoxDisableLicenses.getSelection())
{
if((productLine==ProductLine.CXI)&&(mediaWidth==4))
{
if(!disablePCL())
{
return TestStatus.FAILED;
}
}
}
isPCL=false;
if((productLine==ProductLine.DLX)&&(printMethod==PrintMethod.TT)&&(printDensity==200)&&(mediaWidth==4))
{
byte[] buff=GUIHelper.getResourceAsByteArray("com/cognitive/manufacturing/cpr/DLX_NoLXHeadDefs.cpr");
if(buff==null)
{
GUIHelper.error("Can't load Custom File: DLX_NoLXHeadDefs.cpr");
return TestStatus.FAILED;
}
PrinterHelper.send(buff);
}
if(isTouchstar)
{
byte[] buff=GUIHelper.getResourceAsByteArray("com/cognitive/manufacturing/cpr/_TSBMP_.bmp");
if(buff==null)
{
GUIHelper.error("Can't load Custom File: _TSBMP_.bmp");
return TestStatus.FAILED;
}
PrinterHelper.send("!!0 0 0 0\n!0 0 0 0\nGRAPHIC STORE BMP 3 _TSBMP_");
PrinterHelper.send(buff);
boolean success=PrinterHelper.waitFor(PrinterHelper.GENERAL_PRINTER_READY, 120);
if(!success)
{
GUIHelper.error("Object download error: _TSBMP_.bmp");
return TestStatus.FAILED;
}
if(customization.equalsIgnoreCase("TOUCHSTAR2"))
{
buff=GUIHelper.getResourceAsByteArray("com/cognitive/manufacturing/cpr/TS_TestLabel2.prn");
}
else
{
buff=GUIHelper.getResourceAsByteArray("com/cognitive/manufacturing/cpr/TS_TestLabel.prn");
}
if(buff==null)
{
GUIHelper.error("Can't load Custom File: TS_TestLabel.prn");
return TestStatus.FAILED;
}
PrinterHelper.send(buff);
success=loadCPRFile("com/cognitive/manufacturing/cpr/touchstar.1Stop.cpr");
if(!success)
{
return TestStatus.FAILED;
}
if(!enableTS())
{
return TestStatus.FAILED;
}
}
else if(isMeter)
{
GUIHelper.logger.trace("Meter-enabled printer-configuring final settings.");
String serialNumber=GUIHelper.clean(PrinterHelper.commandWaitResponse("!SHOW SERIALNUMBER")).toUpperCase().trim();
String addressMAC=GUIHelper.clean(PrinterHelper.commandWaitResponse("!SHOW MAC")).toUpperCase().trim();
String key="ERROR";
byte[] buffer=null;
GUIHelper.logger.trace("Generating license key with serial number \""+serialNumber+"\" and MAC address \""+addressMAC+"\".");
String exeName="FPKtool.exe";
String companyname=GUIHelper.brand.getProperty("company.name", "CognitiveTPG").replaceAll("TPG", "").replaceAll(" ", "");
String path="C:/Program Files/"+companyname+"/FPK/";
int exitVal;
try
{
Process proc=new ProcessBuilder(path+exeName, "-e0", "-k13", "-s=\""+serialNumber+"\"", "-m=\""+addressMAC+"\"", "\""+path+"eth_disable_meter_enable.txt\"", "\""+path+"fpk.out\"").start();
exitVal=proc.waitFor();
if(exitVal!=0)
{
String msg="FPK generation failed with error code ["+exitVal+"].";
GUIHelper.error(msg);
GUIHelper.logger.error(msg);
return TestStatus.FAILED;
}
}
catch(Exception e)
{
String msg="FPK generation failed due to exception ["+e.toString()+"].";
GUIHelper.error(msg);
return TestStatus.FAILED;
}
StringBuffer licenseLabel=new StringBuffer();
try
{
File file=new File(path+"fpk.out");
FileReader fileReader=new FileReader(file);
BufferedReader bufferedReader=new BufferedReader(fileReader);
String line;
while((line=bufferedReader.readLine())!=null)
{
licenseLabel.append(line+"\n");
}
bufferedReader.close();
file.delete();
}
catch(FileNotFoundException e)
{
String msg="Can't find fpk output file.";
GUIHelper.error(msg);
GUIHelper.logger.error(msg);
return TestStatus.FAILED;
}
catch(IOException e)
{
String msg="Can't read fpk output file.";
GUIHelper.error(msg);
GUIHelper.logger.error(msg);
return TestStatus.FAILED;
}
key=licenseLabel.toString();
if(key.contains("ERROR")||key.equals(""))
{
GUIHelper.logger.trace("Failed to generate a license key.");
return TestStatus.FAILED;
}
PrinterHelper.send("!LOAD LICENSE 44 \n"+key+"\n");
buffer=GUIHelper.getResourceAsByteArray("com/cognitive/manufacturing/cpr/Meter_TestLabel.prn");
if(buffer==null)
{
GUIHelper.error("Failed to load custom file \"Meter_TestLabel.prn\".");
return TestStatus.FAILED;
}
if(!loadCPRFile("com/cognitive/manufacturing/cpr/MeterEnabled.cpr"))
return TestStatus.FAILED;
PrinterHelper.send(buffer);
PrinterHelper.setVariable("BUFFER_TIMED_RESET", "65534");
PrinterHelper.setVariable("DARKNESS", "50");
PrinterHelper.setVariable("TXTBFR", "8192 4096");
PrinterHelper.setVariable("LANGUAGE", "NONE");
PrinterHelper.setVariable("COMPATIBLE", "OFF");
PrinterHelper.setVariable("COMPATIBLE LOCAL_PITCH", "ON");
PrinterHelper.setVariable("COMPATIBLE LX_VAR_ERROR", "ON");
PrinterHelper.setVariable("COMPATIBLE DBF_ROT_LOC_ADJUST", "OFF");
PrinterHelper.setVariable("COMPATIBLE DISABLE_RG_JUSTIFY", "ON");
PrinterHelper.setVariable("COMPATIBLE POWERUP_PITCH", "OFF");
PrinterHelper.setVariable("COMPATIBLE USE_LX_PARSER", "ON");
PrinterHelper.setVariable("COMPATIBLE LX_HEAD_DEFS", "ON");
PrinterHelper.setVariable("COMPATIBLE LX_SINGLE_LABEL", "ON");
}
else
{
if(CompositeManufacturing.checkBoxDisableLicenses.getSelection()&&(productLine==ProductLine.DLX)&&(mediaWidth==4))
{
if(!disableTS())
{
return TestStatus.FAILED;
}
}
boolean success=loadCPRFile("com/cognitive/manufacturing/cpr/user_feedback_off.cpr");
if(!success)
{
return TestStatus.FAILED;
}
}
if(isSQ)
{
byte[] buff=GUIHelper.getResourceAsByteArray("com/cognitive/manufacturing/cpr/Set_Pitch_100.txt");
if(buff==null)
{
GUIHelper.error("Can't load Custom File: Set_Pitch_100.txt");
return TestStatus.FAILED;
}
PrinterHelper.send(buff);
isSQ=false;
}
if(isResco)
{
byte[] buff=GUIHelper.getResourceAsByteArray("com/cognitive/manufacturing/cpr/resco.txt");
if(buff==null)
{
GUIHelper.error("Can't load Custom File: resco.txt");
return TestStatus.FAILED;
}
PrinterHelper.send(buff);
}
if(isGWN)
{
byte[] buff=GUIHelper.getResourceAsByteArray("com/cognitive/manufacturing/cpr/security.txt");
if(buff==null)
{
GUIHelper.error("Can't load Custom File: security.txt");
return TestStatus.FAILED;
}
PrinterHelper.send(buff);
}
if(isHD)
PrinterHelper.send("!!0 0 0 0\n!0 0 0 0\nVARIABLE ETHERNET LINK AUTO\nVARIABLE WRITE\nEND\n");
if(testModelNumber.equals("CXT2-1300-C01"))
PrinterHelper.send("!!0 0 0 0\n!0 0 0 0\nVARIABLE ETHERNET DHCP OFF\nVARIABLE ETHERNET IP 192.168.5.101\nVARIABLE ETHERNET NETMASK 255.255.255.0\nVARIABLE ETHERNET GATEWAY 192.168.5.1\nVARIABLE WRITE\nVARIABLE ETHERNET RESET\nEND\n");
if(isMadeByEnnoconnMalaysia&&serialNumber!=null&&serialNumber.length()>0)
{
if(serialNumber.substring(0, 1)!="E")
{
serialNumber='E'+serialNumber.substring(1);
GUIHelper.logger.info("Loading location-coded serial number ["+serialNumber+"] in final configuration.");
CompositeManufacturing.textSerialNumberActual.setText(serialNumber);
PrinterHelper.send("!LOAD SERIALNUMBER "+serialNumber+"\n\n");
}
}
GUIHelper.logger.info("Implemented factory default settings");
return TestStatus.PASSED;
}
static TestStatus doSelfTest()
{
GUIHelper.logger.info("");
if(isSecurity)
{
int button;
if(isSecurity)
{
String sSecurityTest=SecurityConfig.getSetting(customization, "TEST_SCRIPT");
byte[] buff;
if(!sSecurityTest.equals(""))
{
buff=GUIHelper.getResourceAsByteArray("com/cognitive/manufacturing/cpr/"+sSecurityTest);
if(buff==null)
{
GUIHelper.error("Can't load test script: "+sSecurityTest);
return TestStatus.FAILED;
}
PrinterHelper.send(buff);
button=GUIHelper.message("Is Voided Prescription Printed Correctly?", SWT.ICON_QUESTION|SWT.YES|SWT.NO);
if(button!=SWT.YES)
return TestStatus.FAILED;
}
}
PrinterHelper.printSelfTestLabel();
if(isSecurity)
{
if(!customization.equals("S00"))
{
button=GUIHelper.message("Are Appropriate Security Settings Printed On Diagnostic Form?", SWT.ICON_QUESTION|SWT.YES|SWT.NO);
if(button!=SWT.YES)
return TestStatus.FAILED;
}
PrinterHelper.send("!CAL 254\n!CAL 0\n!CAL 255\n!CAL 0\n");
}
if(isTouchstar)
GUIHelper.message(Messages.getString("TestEngine.123"), SWT.ICON_WORKING|SWT.OK);
}
else
{
if(isBT)
{
PrinterHelper.send("!!0 0 0 0");
PrinterHelper.send("!0 0 0 0");
PrinterHelper.send("VARIABLE BLUETOOTH CONFIGURE ON");
PrinterHelper.send("VARIABLE BLUETOOTH DEFAULT");
PrinterHelper.send("VARIABLE BLUETOOTH DEVICENAME "+testModelNumber);
PrinterHelper.send("VARIABLE BLUETOOTH DISCOVERABLE ON");
PrinterHelper.send("VARIABLE BLUETOOTH RESET");
PrinterHelper.send("END");
try
{
Thread.sleep(2000);
}
catch(Exception ex)
{
return TestStatus.FAILED;
}
}
PrinterHelper.printSelfTestLabel();
if(isTouchstar)
{
GUIHelper.message(Messages.getString("TestEngine.123"), SWT.ICON_WORKING|SWT.OK);
}
if(isGWN)
{
try
{
Thread.sleep(5000);
}
catch(Exception ex)
{
return TestStatus.FAILED;
}
GUIHelper.message(Messages.getString("TestEngine.129"), SWT.ICON_WORKING|SWT.OK);
boolean result;
result=calibrate("DT", "BAR", 0);
if(!result)
{
return TestStatus.FAILED;
}
if(customization.endsWith("A"))
{
byte[] buff=GUIHelper.getResourceAsByteArray("com/cognitive/manufacturing/cpr/GWNASample.txt");
if(buff==null)
{
GUIHelper.error("Can't load Gwinnett A sample script: GWNASample.txt");
return TestStatus.FAILED;
}
PrinterHelper.send(buff);
}
else
{
byte[] buff=GUIHelper.getResourceAsByteArray("com/cognitive/manufacturing/cpr/GWNBSample.txt");
if(buff==null)
{
GUIHelper.error("Can't load Gwinnett B sample script: GWNBSample.txt");
return TestStatus.FAILED;
}
PrinterHelper.send(buff);
}
}
}
return TestStatus.PASSED;
}
static boolean followUpParallelTest()
{
GUIHelper.logger.info("");
String retString=PrinterHelper.getVariable("SLEEP_AFTER");
if(retString==null)
{
return false;
}
retString=retString.trim();
{
if(!retString.equals(testSleepAfter))
{
GUIHelper.error(Messages.getString("TestEngine.55"));
GUIHelper.logger.info("Testing parallel connection-part two: bad: SLEEP_AFTER is "+retString);
GUIHelper.logger.info("Bad");
return false;
}
else
{
GUIHelper.logger.info("Testing parallel connection-part two: good: SLEEP_AFTER is "+retString);
PrinterHelper.setVariable("SLEEP_AFTER", originalSleepAfter);
GUIHelper.logger.info("Testing parallel connection-part two: good: SLEEP_AFTER reverted to "+originalSleepAfter);
return true;
}
}
}
static boolean postNetworkTest()
{
String ipAddress=PrinterHelper.getVariable("ETHERNET IP");
if(ipAddress==null||!ipAddress.equals(CompositeManufacturing.textIPAddress.getText()))
{
GUIHelper.error(Messages.getString("TestEngine.56")+CompositeManufacturing.textIPAddress.getText()+Messages.getString("TestEngine.57")+ipAddress);
return false;
}
return true;
}
static boolean getNetworkParameters(StringBuffer ipNetmask, StringBuffer ipGateway)
{
return false;
}
static boolean preNetworkTest()
{
GUIHelper.logger.info("");
StringBuffer ipNetmask=new StringBuffer(GUIHelper.prefs.get("MAN_IP_NETMASK", "AUTO"));
StringBuffer ipGateway=new StringBuffer(GUIHelper.prefs.get("MAN_IP_GATEWAY", "AUTO"));
if(ipNetmask.toString().equalsIgnoreCase("AUTO")||ipGateway.toString().equalsIgnoreCase("AUTO"))
{
boolean success=getNetworkParameters(ipNetmask, ipGateway);
if(!success)
{
GUIHelper.error("Unable to determine network setup.\nPlease edit Preferences.xml to determine it manually.");
return false;
}
}
StringBuffer label=new StringBuffer();
label.append("!!0 0 0 0\n");
label.append("!0 0 0 0\n");
label.append("VARIABLE USER_FEEDBACK ON\n");
label.append("VARIABLE ETHERNET DHCP OFF\n");
label.append("VARIABLE ETHERNET IP "+CompositeManufacturing.textIPAddress.getText()+"\n");
label.append("VARIABLE ETHERNET NETMASK "+ipNetmask.toString()+"\n");
label.append("VARIABLE ETHERNET GATEWAY "+ipGateway.toString()+"\n");
label.append("VARIABLE WRITE\n");
label.append("VARIABLE ETHERNET RESET\n");
label.append("END\n");
PrinterHelper.send(label.toString());
try
{
PrinterHelper.printer.closeConnection();
}
catch(Exception e)
{
GUIHelper.error(Messages.getString("TestEngine.62"));
return false;
}
try
{
Thread.sleep(10000);
}
catch(Exception ex)
{
return false;
}
boolean success=establishPrimaryConnection(115200);
if(!success)
{
GUIHelper.error(Messages.getString("TestEngine.67"));
return false;
}
try
{
Thread.sleep(20000);
}
catch(Exception ex)
{
return false;
}
return true;
}
static TestStatus doConnectionTypes()
{
btDeviceName="";
GUIHelper.logger.info("");
if(!isConnectionTypeParallelOnly)
{
boolean testForC=false;
boolean testForDLX=false;
boolean testParallel=false;
testForC=((productLine==ProductLine.CI||productLine==ProductLine.CXI)&&CompositeManufacturing.checkBoxParallel.getSelection());
testForDLX=((productLine==ProductLine.DLX||productLine==ProductLine.LX)&&CompositeManufacturing.checkBoxParallel.getSelection()&&((communicationInterface.toString().indexOf("LEGACY")!=-1)||(communicationInterface.toString().indexOf("PARALLEL")!=-1)));
testParallel=testForC||testForDLX;
boolean testSerial=false;
testForC=((productLine==ProductLine.CI||productLine==ProductLine.CXI)&&CompositeManufacturing.checkBoxSerial.getSelection());
testForDLX=((productLine==ProductLine.DLX||productLine==ProductLine.LX)&&CompositeManufacturing.checkBoxSerial.getSelection()&&((communicationInterface.toString().indexOf("LEGACY")!=-1)||(communicationInterface.toString().indexOf("SERIAL")!=-1)));
testSerial=testForC||testForDLX;
boolean testUSBB=((productLine!=ProductLine.LX)&&(CompositeManufacturing.checkBoxUSBB.getSelection()));
boolean testUSBA=((productLine!=ProductLine.LX)&&(CompositeManufacturing.checkBoxUSBA.getSelection()));
boolean testBT=((productLine!=ProductLine.LX)&&(CompositeManufacturing.checkBoxBT1.getSelection()));
boolean testNetwork=false;
testForC=((productLine==ProductLine.CI||productLine==ProductLine.CXI)&&CompositeManufacturing.checkBoxNetwork.getSelection());
testForDLX=((productLine==ProductLine.DLX||productLine==ProductLine.LX)&&(communicationInterface.toString().indexOf("NETWORK")!=-1)&&CompositeManufacturing.checkBoxNetwork.getSelection());
testNetwork=testForC||testForDLX;
JAdminDialogMessage ctDialog=new JAdminDialogMessage(Messages.getString("TestEngine.58"));
ctDialog.show();
try
{
if(testSerial||testBT)
{
PrinterHelper.setVariable("COMM", "115200,N,8,1,N");
PrinterHelper.printer.waitForResponse(".*115200.*", 10);
if(testBT)
{
ctDialog.setMessage(Messages.getString("TestEngine.125"));
PrinterHelper.send("!!0 0 0 0\n!0 0 0 0\nVARIABLE BLUETOOTH DEFAULT ON\nEND");
try
{
Thread.sleep(5000);
}
catch(Exception e)
{
GUIHelper.logger.warn(e, e);
return TestStatus.FAILED;
}
PrinterHelper.send("!!0 0 0 0\n!0 0 0 0\nVARIABLE BLUETOOTH DEVICENAME ?\nEND\n");
btDeviceName=PrinterHelper.printer.waitForResponse(".*BLUETOOTH DEVICENAME=.*", 20);
if(btDeviceName==null||!btDeviceName.trim().startsWith("BLUE"))
{
return TestStatus.FAILED;
}
String message=Messages.getString("TestEngine.126")+btDeviceName+"\n"+Messages.getString("TestEngine.127")+CompositeManufacturing.textBTPort1.getText()+" "+Messages.getString("TestEngine.128");
GUIHelper.message(message, SWT.OK);
}
else
{
ctDialog.setMessage(Messages.getString("TestEngine.61"));
}
}
if(testNetwork)
{
ctDialog.setMessage(Messages.getString("TestEngine.60"));
if(!preNetworkTest())
{
return TestStatus.FAILED;
}
}
if(testParallel)
{
ctDialog.setMessage(Messages.getString("TestEngine.59"));
originalSleepAfter=PrinterHelper.getVariable("SLEEP_AFTER");
if(originalSleepAfter==null)
{
return TestStatus.FAILED;
}
}
try
{
PrinterHelper.printer.closeConnection();
}
catch(Exception e)
{
GUIHelper.error(Messages.getString("TestEngine.62"));
return TestStatus.FAILED;
}
if(testParallel)
{
ctDialog.setMessage(Messages.getString("TestEngine.59"));
GUIHelper.logger.info("Testing parallel connection-part one.");
testParallel=true;
String port=CompositeManufacturing.textParallelPort.getText();
IPrinterConnection conn=null;
try
{
conn=new ParallelConnection(port);
PrinterHelper.printer.openConnection(conn);
PrinterHelper.setVariable("SLEEP_AFTER", testSleepAfter);
GUIHelper.logger.info("Testing parallel connection-part one: SLEEP_AFTER set to "+testSleepAfter);
GUIHelper.logger.info("Closing parallel connection.");
PrinterHelper.printer.closeConnection();
}
catch(Exception e)
{
GUIHelper.logger.error(e, e);
}
}
if(testUSBB)
{
ctDialog.setMessage(Messages.getString("TestEngine.64"));
if(!testConnection(ConnectionType.OS_PRINTER, false))
{
return TestStatus.FAILED;
}
}
if(testSerial)
{
ctDialog.setMessage(Messages.getString("TestEngine.61"));
if(!testConnection(ConnectionType.SERIAL, false))
{
return TestStatus.FAILED;
}
}
if(testBT)
{
ctDialog.setMessage(Messages.getString("TestEngine.125"));
}
if(testNetwork)
{
ctDialog.setMessage(Messages.getString("TestEngine.60"));
if(!testConnection(ConnectionType.NETWORK, false))
{
return TestStatus.FAILED;
}
}
boolean success=establishPrimaryConnection(115200);
if(!success)
{
GUIHelper.error(Messages.getString("TestEngine.67"));
return TestStatus.FAILED;
}
else
{
if(testBT)
{
ctDialog.setMessage(Messages.getString("TestEngine.125"));
if(isBT)
{
PrinterHelper.send("!!0 0 0 0");
PrinterHelper.send("!0 0 0 0");
PrinterHelper.send("VARIABLE BLUETOOTH CONFIGURE ON");
PrinterHelper.send("VARIABLE BLUETOOTH DEFAULT");
PrinterHelper.send("VARIABLE BLUETOOTH DEVICENAME "+testModelNumber);
PrinterHelper.send("VARIABLE BLUETOOTH DISCOVERABLE ON");
PrinterHelper.send("VARIABLE BLUETOOTH RESET");
PrinterHelper.send("END");
}
PrinterHelper.send("!!0 0 0 0\n!0 0 0 0\nVARIABLE BLUETOOTH CONFIGURE OFF\nEND\n");
PrinterHelper.printer.waitFor(PrinterHelper.GENERAL_PRINTER_READY, 3);
PrinterHelper.send("!!0 0 0 0\n!0 0 0 0\nVARIABLE BLUETOOTH BDADDR ?\nEND\n");
btMacAddress=PrinterHelper.printer.waitForResponse(".*BLUETOOTH BDADDR=.*", 20);
if(btMacAddress==null||!btMacAddress.trim().startsWith("BLUE"))
{
return TestStatus.FAILED;
}
btMacAddress=btMacAddress.replaceAll("BLUETOOTH BDADDR", "");
btMacAddress=btMacAddress.replaceAll("=", "").trim().toUpperCase();
btMacAddress=btMacAddress.substring(0, 2)+":"+btMacAddress.substring(2, 4)+":"+btMacAddress.substring(4, 6)+":"+btMacAddress.substring(6, 8)+":"+btMacAddress.substring(8, 10)+":"+btMacAddress.substring(10);
GUIHelper.logger.info(btDeviceName+" and BLUETOOTH Address: "+btMacAddress);
PrinterHelper.send("!!0 0 0 0\n!0 0 0 0\nVARIABLE BLUETOOTH FORGET\nEND\n");
PrinterHelper.printer.waitFor(PrinterHelper.GENERAL_PRINTER_READY, 2);
PrinterHelper.send("!!0 0 0 0\n!0 0 0 0\nVARIABLE BLUETOOTH RESET\nEND\n");
PrinterHelper.printer.waitFor(PrinterHelper.GENERAL_PRINTER_READY, 4);
}
}
if(testParallel)
{
ctDialog.setMessage(Messages.getString("TestEngine.59"));
if(!followUpParallelTest())
{
return TestStatus.FAILED;
}
}
if(testNetwork)
{
ctDialog.setMessage(Messages.getString("TestEngine.60"));
postNetworkTest();
}
if(testUSBA)
{
ctDialog.setMessage(Messages.getString("TestEngine.70"));
originalSleepAfter=PrinterHelper.getVariable("SLEEP_AFTER");
if(originalSleepAfter==null)
{
return TestStatus.FAILED;
}
GUIHelper.logger.info("Testing USB-A: SLEEP_AFTER before: "+originalSleepAfter);
JAdminDialogMessage dialog=new JAdminDialogMessage("USB-A Test");
dialog.setMessage(Messages.getString("TestEngine.71"));
dialog.show();
int maxTime=60000;
int currentTime=0;
int intervalTime=1000;
String currentSleepAfter=null;
success=false;
while(currentTime<=maxTime)
{
try
{
Thread.sleep(intervalTime);
}
catch(InterruptedException e)
{
GUIHelper.logger.error(e, e);
}
currentTime+=intervalTime;
currentSleepAfter=PrinterHelper.getVariable("SLEEP_AFTER");
if(currentSleepAfter==null)
{
return TestStatus.FAILED;
}
if(currentSleepAfter.equals(originalSleepAfter))
{
continue;
}
else
{
GUIHelper.logger.info("Testing USB-A: SLEEP_AFTER after: "+currentSleepAfter);
PrinterHelper.setVariable("SLEEP_AFTER", originalSleepAfter);
GUIHelper.logger.info("Testing USB-A: SLEEP_AFTER reverted to: "+originalSleepAfter);
success=true;
break;
}
}
dialog.close();
GUIHelper.message(Messages.getString("TestEngine.72"), SWT.OK|SWT.ICON_WORKING);
if(!success)
{
GUIHelper.message(Messages.getString("TestEngine.73"), SWT.OK|SWT.ICON_ERROR);
return TestStatus.FAILED;
}
}
}
finally
{
ctDialog.close();
}
return TestStatus.PASSED;
}
else
{
return TestStatus.SKIPPED;
}
}
static boolean testConnection(ConnectionType connectionType, boolean testBT)
{
GUIHelper.logger.info(connectionType);
IPrinterConnection conn=null;
try
{
switch(connectionType)
{
case OS_PRINTER:
connectionType=ConnectionType.OS_PRINTER;
conn=new WindowsPrinterConnection();
PrinterHelper.printer.openConnection(conn);
break;
case SERIAL:
connectionType=ConnectionType.SERIAL;
if(!testBT)
{
conn=new SerialConnection(CompositeManufacturing.textSerialPort.getText(), 115200, 1);
}
else
{
try
{
conn=new SerialConnection(CompositeManufacturing.textBTPort1.getText(), 115200, 1);
}
catch(Exception e)
{
GUIHelper.logger.info("Can't open BT connection.");
return false;
}
}
PrinterHelper.printer.openConnection(conn);
break;
case NETWORK:
connectionType=ConnectionType.NETWORK;
conn=new NetworkConnection(CompositeManufacturing.textIPAddress.getText(), 9100);
PrinterHelper.printer.openConnection(conn);
break;
}
if(!PrinterHelper.printer.isConnected())
{
GUIHelper.logger.info("Can't open "+connectionType+" connection.");
GUIHelper.error("Can't open "+connectionType+" connection.");
return false;
}
}
catch(Exception e)
{
GUIHelper.error("Can't open "+connectionType+" connection.");
return false;
}
GUIHelper.logger.info(connectionType+" connection good.");
try
{
GUIHelper.logger.info("Closing "+connectionType+" connection.");
PrinterHelper.printer.closeConnection();
}
catch(Exception e)
{
GUIHelper.error("Can't close "+connectionType+" connection.");
return false;
}
return true;
}
static TestStatus getHeadType()
{
GUIHelper.logger.info("");
String selection=CompositeManufacturing.comboPrintHead.getItem((CompositeManufacturing.comboPrintHead.getSelectionIndex()));
printHead=PrintHead.valueOf(selection);
GUIHelper.logger.info("Head type is "+printHead);
return TestStatus.PASSED;
}
static TestStatus doPaperOutCheck()
{
GUIHelper.logger.info("");
PrinterHelper.setVariable("PRINT_MODE", "DT");
PrinterHelper.setVariable("USER_FEEDBACK", "ON");
if(!isConnectionTypeParallelOnly)
{
JAdminDialogMessage dialog=new JAdminDialogMessage(Messages.getString("TestEngine.75"));
dialog.setMessage(Messages.getString("TestEngine.76"));
dialog.show();
boolean received=PrinterHelper.waitFor(".*O00000.*", 120);
dialog.close();
if(!received)
{
GUIHelper.error(Messages.getString("TestEngine.77"));
return TestStatus.FAILED;
}
}
else
{
int button=GUIHelper.message(Messages.getString("TestEngine.110"), SWT.ICON_WORKING|SWT.OK);
if(button==SWT.OK)
{
try
{
Thread.sleep(10000);
}
catch(Exception ex)
{
return TestStatus.FAILED;
}
}
else
{
return TestStatus.FAILED;
}
}
return TestStatus.PASSED;
}
static TestStatus doFeedButtonTest()
{
GUIHelper.logger.info("");
int button=GUIHelper.message(Messages.getString("TestEngine.116"), SWT.ICON_WORKING|SWT.OK);
if(button==SWT.OK)
{
int button1=GUIHelper.message(Messages.getString("TestEngine.117"), SWT.ICON_QUESTION|SWT.YES|SWT.NO);
if(button1==SWT.YES)
{
return TestStatus.PASSED;
}
else
{
return TestStatus.FAILED;
}
}
else
{
return TestStatus.FAILED;
}
}
static TestStatus doInitialSetup(String message)
{
GUIHelper.logger.info("");
testModelNumber=CompositeManufacturing.textModelNumber.getText();
if(testModelNumber.equalsIgnoreCase("DLX-K542"))
{
establishPrimaryConnection(115200);
testModelNumber=PrinterHelper.commandWaitResponse("!SHOW MODELNUMBER");
CompositeManufacturing.textModelNumber.setText(testModelNumber);
isCustomLabel_K542=true;
}
else { isCustomLabel_K542=false; }
int button=GUIHelper.message(message, SWT.OK|SWT.CANCEL|SWT.ICON_WORKING);
if(button==SWT.CANCEL)
{
return TestStatus.CANCELLED;
}
boolean success=false;
success=parseModelNumber(CompositeManufacturing.textModelNumber.getText());
if(!success)
{
return TestStatus.FAILED;
}
isNetwork=((productLine==ProductLine.CI||productLine==ProductLine.CXI)||((productLine==ProductLine.DLX||productLine==ProductLine.LX)&&(communicationInterface.toString().indexOf("NETWORK")!=-1)));
success=establishPrimaryConnection(115200);
if(!success)
{
return TestStatus.FAILED;
}
PrinterHelper.setVariable("USER_FEEDBACK", "ON");
if(!isConnectionTypeParallelOnly)
{
serialNumber=PrinterHelper.commandWaitResponse("!SHOW SERIALNUMBER");
if(serialNumber==null)
{
return TestStatus.FAILED;
}
if(serialNumber.equalsIgnoreCase("z060800000"))
{
brandNewPrinter=true;
}
else if(Integer.parseInt(serialNumber.substring(1, 3))<6)
{
message="The serial number "+serialNumber+" is invalid.\n\nWould you like to assign a new serial number to this printer?";
button=GUIHelper.message(message, SWT.ICON_QUESTION|SWT.YES|SWT.NO);
if(button==SWT.YES)
{
brandNewPrinter=true;
}
else
{
brandNewPrinter=false;
}
}
else
{
if(isGattaca&&(!serialNumber.startsWith("V")))
{
isMadeInChina=false;
}
else if(!(productLine==ProductLine.CI||productLine==ProductLine.CXI))
{
isMadeInChina=true;
}
brandNewPrinter=false;
if(isMadeByEnnoconnMalaysia)
{
CompositeManufacturing.textSerialNumberActual.setText(serialNumber);
}
}
}
else
{
if(CompositeManufacturing.checkBoxSpecSNMAC.getSelection())
{
if(!verifySpecifiedIdentity())
{
return TestStatus.FAILED;
}
serialNumber=CompositeManufacturing.textSerialNumberActual.getText();
macHex=CompositeManufacturing.textMacAddressActual.getText();
brandNewPrinter=false;
}
else
{
brandNewPrinter=true;
}
}
if(!isConnectionTypeParallelOnly)
{
macHex=PrinterHelper.commandWaitResponse("!SHOW MAC");
if(macHex==null)
{
return TestStatus.FAILED;
}
}
if(isTGModelNumber||isTDModelNumber)
{
testModelNumber=tgModelEmbeddedNumber;
}
GUIHelper.logger.info("testModelNumber "+testModelNumber);
GUIHelper.logger.info("brandNewPrinter "+brandNewPrinter);
if(!isConnectionTypeParallelOnly)
{
currentModelNumber=GUIHelper.clean(PrinterHelper.commandWaitResponse("!SHOW MODELNUMBER"));
GUIHelper.logger.info("currentModelNumber "+currentModelNumber);
}
String currentFirmwarePartNumber=getCurrentFirmwarePartNumber();
if(Integer.parseInt(currentFirmwarePartNumber.substring(currentFirmwarePartNumber.length()-3))>326)
{
supportsFactoryRestoreCommand=true;
}
else
{
supportsFactoryRestoreCommand=false;
}
if(!brandNewPrinter)
{
updateOEMIdentifier(TestStep.INITIAL_SETUP);
if(!isConnectionTypeParallelOnly)
{
if(currentModelNumber==null)
{
return TestStatus.FAILED;
}
if(((currentModelNumber.startsWith("DB")||currentModelNumber.startsWith("C"))&&testModelNumber.startsWith("700"))||(currentModelNumber.startsWith("700")&&(testModelNumber.startsWith("DB")||testModelNumber.startsWith("C"))))
{
PrinterHelper.send("!LOAD MODELNUMBER "+testModelNumber);
}
}
}
return TestStatus.PASSED;
}
static String getMonthYear()
{
GUIHelper.logger.trace("");
int year=2000+Integer.parseInt(serialNumber.substring(1, 3));
int weekOfYear=Integer.parseInt(serialNumber.substring(3, 5));
GregorianCalendar calendar=new GregorianCalendar(year, 0, 1);
calendar.set(Calendar.WEEK_OF_YEAR, Math.min(weekOfYear, 52));
calendar.set(Calendar.DAY_OF_WEEK, Calendar.SATURDAY);
int monthInt=calendar.get(Calendar.MONTH);
String monthString=null;
switch(monthInt)
{
case 0:
monthString="January";
break;
case 1:
monthString="February";
break;
case 2:
monthString="March";
break;
case 3:
monthString="April";
break;
case 4:
monthString="May";
break;
case 5:
monthString="June";
break;
case 6:
monthString="July";
break;
case 7:
monthString="August";
break;
case 8:
monthString="September";
break;
case 9:
monthString="October";
break;
case 10:
monthString="November";
break;
case 11:
monthString="December";
break;
default:
GUIHelper.error("Can't decode month.");
GUIHelper.logger.error("Can't decode month "+monthInt);
return null;
}
return monthString.substring(0, 3).toUpperCase()+" "+year;
}
static boolean constructDLXSerialNumberLabel(StringBuffer cplPart)
{
GUIHelper.logger.trace("");
String monthYear=getMonthYear();
if(monthYear==null)
{
return false;
}
if(!isTGModelNumber&&!isTDModelNumber)
{
String configNo=CompositeManufacturing.textModelNumber.getText();
if(isWingman)
{
configNo=configNo.replace("DB", "EZ");
}
cplPart.append("!+0 100 310 1\n");
cplPart.append("P 200\n");
cplPart.append("W 300\n");
cplPart.append("TEXT 1 22 40 "+configNo+"\n");
cplPart.append("TEXT 0 385 44 "+monthYear+"\n");
cplPart.append("TEXT 1 605 40 "+serialNumber+"\n");
cplPart.append("B CODE39(2:4)-552 140 60 "+serialNumber+"\n");
if(communicationInterface.toString().indexOf("NETWORK")!=-1)
{
cplPart.append("TEXT 0 620 168 "+macHex.toUpperCase()+"\n");
}
if(isLX)
{
cplPart.append("TEXT 1 385 245 "+CompositeManufacturing.textModelNumber.getText().replace("G", "")+"\n");
}
else
{
cplPart.append("TEXT 1 385 245 "+CompositeManufacturing.textModelNumber.getText()+"\n");
}
cplPart.append("END");
}
else if(isTDModelNumber)
{
cplPart.append("!+0 100 310 1\n");
cplPart.append("P 200\n");
cplPart.append("W 300\n");
cplPart.append("TEXT 1 22 40 "+tgModelEmbeddedNumber+"\n");
cplPart.append("TEXT 0 265 44 "+CompositeManufacturing.textModelNumber.getText()+"\n");
cplPart.append("TEXT 0 385 44 "+monthYear+"\n");
cplPart.append("TEXT 1 605 40 "+serialNumber+"\n");
cplPart.append("B CODE39(2:4)-552 140 60 "+serialNumber+"\n");
if(communicationInterface.toString().indexOf("NETWORK")!=-1)
{
cplPart.append("TEXT 0 660 152 "+macHex.toUpperCase()+"\n");
}
cplPart.append("TEXT 0 660 183 PRINTHEAD: "+printHead.toString().charAt(0)+"\n");
cplPart.append("STRING 12X16 803 220 24 VDC\n");
cplPart.append("STRING 12X16 803 248 6.25A\n");
cplPart.append("STRING 9X12 43 165 E231526\n");
cplPart.append("STRING 9X12 318 150 N270\n");
cplPart.append("TEXT 0 320 190 "+tgCompanyName+"\n");
cplPart.append("TEXT 0 320 220 "+tgGermanyAddress1+"\n");
cplPart.append("TEXT 0 320 250 "+tgGermanyAddress2+"\n");
cplPart.append("END");
}
else
{
cplPart.append("!+0 100 310 1\n");
cplPart.append("P 200\n");
cplPart.append("W 300\n");
cplPart.append("TEXT 1 22 40 "+tgModelEmbeddedNumber+"\n");
cplPart.append("TEXT 0 265 44 "+CompositeManufacturing.textModelNumber.getText()+"\n");
cplPart.append("TEXT 0 385 44 "+monthYear+"\n");
cplPart.append("TEXT 1 605 40 "+serialNumber+"\n");
cplPart.append("B CODE39(2:4)-552 140 60 "+serialNumber+"\n");
if(communicationInterface.toString().indexOf("NETWORK")!=-1)
{
cplPart.append("TEXT 0 560 152 "+macHex.toUpperCase()+"\n");
}
cplPart.append("TEXT 0 560 183 PRINTHEAD: "+printHead.toString().charAt(0)+"\n");
cplPart.append("TEXT 0 340 230 "+tgGermanyAddress1+"\n");
cplPart.append("TEXT 0 340 260 "+tgGermanyAddress2+"\n");
cplPart.append("END");
}
return true;
}
static boolean constructCSerialNumberLabel(StringBuffer cplPart)
{
GUIHelper.logger.trace("");
String monthYear=getMonthYear();
if(monthYear==null)
{
return false;
}
if(!isTGModelNumber&&!isTDModelNumber)
{
String configNo=CompositeManufacturing.textModelNumber.getText();
cplPart.append("!+0 100 820 1\n");
cplPart.append("TEXT 1 60 45 "+configNo+"\n");
cplPart.append("BARCODE CODE128(2:5)-40 155 75 "+configNo+"\n");
if(!isSecurity)
{
cplPart.append("TEXT 1 425 100 "+monthYear+"\n");
cplPart.append("TEXT 1 635 45 "+serialNumber+"\n");
cplPart.append("BARCODE CODE128(2:5)-620 155 75 "+serialNumber+"\n");
cplPart.append("TEXT 1 60 225 "+CompositeManufacturing.textModelNumber.getText()+"\n");
cplPart.append("TEXT 1 420 205 "+macHex.toUpperCase()+"\n");
cplPart.append("BARCODE CODE128(2:5)-380 315 75 "+macHex.toUpperCase()+"\n");
}
else
{
cplPart.append("TEXT 1 500 80 "+monthYear.substring(0, 3).toUpperCase()+"\n");
cplPart.append("TEXT 1 500 120 "+monthYear.substring(4).trim()+"\n");
cplPart.append("TEXT 1 635 45 "+serialNumber+"\n");
cplPart.append("BARCODE CODE128(2:5)-620 155 75 "+serialNumber+"\n");
cplPart.append("TEXT 1 30 225 "+CompositeManufacturing.textModelNumber.getText()+"\n");
cplPart.append("TEXT 1 420 205 "+macHex.toUpperCase()+"\n");
cplPart.append("BARCODE CODE128(2:5)-395 315 75 "+macHex.toUpperCase()+"\n");
}
cplPart.append("INDEX\n");
cplPart.append("END\n");
}
else if(isTDModelNumber)
{
cplPart.append("!+0 100 820 1\n");
cplPart.append("TEXT 1 90 45 "+CompositeManufacturing.textModelNumber.getText()+"\n");
cplPart.append("BARCODE CODE128(2:5)-80 155 75 "+CompositeManufacturing.textModelNumber.getText()+"\n");
cplPart.append("TEXT 1 340 100 "+monthYear+"\n");
cplPart.append("TEXT 1 585 45 "+serialNumber+"\n");
cplPart.append("BARCODE CODE128(2:5)-575 155 75 "+serialNumber+"\n");
cplPart.append("TEXT 1 65 520 "+tgModelEmbeddedNumber+"\n");
cplPart.append("TEXT 1 240 590 "+printHead.toString().charAt(0)+"\n");
cplPart.append("TEXT 1 410 495 "+macHex.toUpperCase()+"\n");
cplPart.append("BARCODE CODE128(2:5)-380 605 75 "+macHex.toUpperCase()+"\n");
cplPart.append("INDEX\n");
cplPart.append("END\n");
}
else
{
cplPart.append("!+0 100 820 1\n");
cplPart.append("U B42 (5,0,0) 50 50 Model Number:\n");
cplPart.append("U B42 (5,0,0) 50 120 ID Number:\n");
cplPart.append("U B42 (5,0,0) 50 260 Serial Number:\n");
cplPart.append("U B42 (5,0,0) 50 400 MAC:\n");
cplPart.append("U B42 (5,0,0) 400 50 "+tgModelEmbeddedNumber+"\n");
cplPart.append("U B42 (5,0,0) 400 110 "+CompositeManufacturing.textModelNumber.getText()+"\n");
cplPart.append("BARCODE CODE128(2:6)-400 230 75 "+CompositeManufacturing.textModelNumber.getText()+"\n");
cplPart.append("U B42 (5,0,0) 400 250 "+serialNumber+"\n");
cplPart.append("BARCODE CODE128(2:6)-400 370 75 "+serialNumber+"\n");
cplPart.append("U B42 (5,0,0) 400 390 "+macHex.toUpperCase()+"\n");
cplPart.append("BARCODE CODE128(2:5)-400 510 75 "+macHex.toUpperCase()+"\n");
cplPart.append("U B42 (5,0,0) 50 480 Printhead: "+printHead.toString().charAt(0)+"\n");
cplPart.append("FILL_BOX 25 530 840 10\n");
cplPart.append("U B42 (5,0,0) 25 550 Input Power:\n");
cplPart.append("U B42 (5,0,0) 25 600 24V, 6.25A\n");
if(isMadeByEnnoconnMalaysia)
cplPart.append("U B40 (5,0,0) 25 735 Made in Malaysia\n");
else
cplPart.append("U B40 (5,0,0) 25 735 Made in Taiwan\n");
cplPart.append("U B42 (5,0,0) 375 670 "+tgGermanyAddress1+"\n");
cplPart.append("U B42 (5,0,0) 375 725 "+tgGermanyAddress2+"\n");
cplPart.append("INDEX\n");
cplPart.append("END\n");
}
return true;
}
static boolean connectNamedPrinter(String name)
{
GUIHelper.logger.trace("");
IPrinterConnection conn=null;
try
{
PrinterHelper.printer.closeConnection();
if(name.matches("\\d{1,}\\.\\d{1,}\\.\\d{1,}\\.\\d{1,}"))
{
conn=new NetworkConnection(name, 9100);
}
else if(name.matches("COM.*"))
{
conn=new SerialConnection(name, 115200, 1);
}
else if(name.matches("LPT.*"))
{
conn=new ParallelConnection(name);
}
else if(name.matches("\\D.*"))
{
conn=new WindowsPrinterConnection();
}
GUIHelper.logger.info("Connected to "+name);
PrinterHelper.printer.openConnection(conn);
}
catch(Exception e)
{
GUIHelper.logger.error(e, e);
GUIHelper.error(Messages.getString("TestEngine.78")+name+"\"");
return false;
}
return true;
}
static TestStatus doSerialNumberLabel()
{
GUIHelper.logger.trace("");
if(!CompositeManufacturing.checkBoxSNLabelPrinter.getSelection())
{
return TestStatus.SKIPPED;
}
if(!connectNamedPrinter(CompositeManufacturing.textSNLabelPrinter.getText()))
{
return TestStatus.FAILED;
}
byte binaryPart[]=null;
StringBuffer cplPart=new StringBuffer();
String serialNumberLabel=null;
if(isCustomLabel_K542&&printCustom_K542)
{
try
{
String monthYear=getMonthYear();
if (printDensity==200)
{
binaryPart=GUIHelper.getResourceAsByteArray("com/cognitive/manufacturing/labels/K542-200DPI.lbl");
cplPart=new StringBuffer();
cplPart.append("!+0 100 310 2\n");
cplPart.append("VARIABLE DARKNESS 100\n");
cplPart.append("VARIABLE ENERGY 50\n");
cplPart.append("VARIABLE PRINT_SPEED 5000\n");
cplPart.append("VARIABLE SHIFT LEFT 30\n");
cplPart.append("VARIABLE WIDTH 900\n");
cplPart.append("TEXT 2 412 115 PN: DLX-K542\n");
cplPart.append("TEXT 2 412 155 SN: "+serialNumber+"\n");
cplPart.append("TEXT 2 412 195 Mfg.: "+monthYear+"\n");
cplPart.append("TEXT 2 412 235 Made in Malaysia\n");
cplPart.append("INDEX\n");
cplPart.append("END\n");
}
else if (printDensity==300)
{
binaryPart=GUIHelper.getResourceAsByteArray("com/cognitive/manufacturing/labels/K542-300DPI.lbl");
cplPart=new StringBuffer();
cplPart.append("!+0 100 465 2\n");
cplPart.append("VARIABLE DARKNESS 100\n");
cplPart.append("VARIABLE ENERGY 50\n");
cplPart.append("VARIABLE PRINT_SPEED 5000\n");
cplPart.append("VARIABLE SHIFT LEFT 0\n");
cplPart.append("VARIABLE WIDTH 639\n");
cplPart.append("TEXT 2 618 172 PN: DLX-K542\n");
cplPart.append("TEXT 2 618 232 SN: "+serialNumber+"\n");
cplPart.append("TEXT 2 618 292 Mfg.: "+monthYear+"\n");
cplPart.append("TEXT 2 618 352 Made in Malaysia\n");
cplPart.append("INDEX\n");
cplPart.append("END\n");
}
PrinterHelper.send(binaryPart);
PrinterHelper.send(cplPart.toString());
GUIHelper.logger.info("Sent custom DLX-K542 serial label to printer:\n"+cplPart.toString());
}
catch(Exception e)
{
GUIHelper.logger.error(e, e);
GUIHelper.logger.info("Failed to send custom label format DLX-K542 to printer.");
return TestStatus.FAILED;
}
return TestStatus.PASSED;
}
switch(productLine)
{
case CI:
case CXI:
if(!isTGModelNumber&&!isTDModelNumber)
{
if(isMadeInChina)
{
serialNumberLabel="com/cognitive/manufacturing/labels/C_SN_withCCC.lbl";
}
else
{
if(isSecurity||isGWN)
{
serialNumberLabel="com/cognitive/manufacturing/labels/C_SN_S.lbl";
}
else
{
serialNumberLabel="com/cognitive/manufacturing/labels/C_SN.lbl";
}
}
}
else if(isTDModelNumber)
{
serialNumberLabel="com/cognitive/manufacturing/labels/TD_C_SN.lbl";
}
else
{
serialNumberLabel="com/cognitive/manufacturing/labels/TG_C_SN.lbl";
}
if(isMadeByEnnoconnMalaysia)
{
GUIHelper.logger.warn("Appending Ennoconn identifier string to serial label file name.");
if(!isTGModelNumber&&!isTDModelNumber)
serialNumberLabel=serialNumberLabel.replaceFirst("[.]lbl", "_ENNO.lbl");
}
binaryPart=GUIHelper.getResourceAsByteArray(serialNumberLabel);
if(binaryPart==null)
{
String message="Can't get serial number label "+serialNumberLabel;
GUIHelper.logger.error(message);
GUIHelper.error(message);
return TestStatus.FAILED;
}
if(!constructCSerialNumberLabel(cplPart))
{
return TestStatus.FAILED;
}
break;
case LX:
case DLX:
if(!isTGModelNumber&&!isTDModelNumber)
{
if(isSiemens)
{
serialNumberLabel="com/cognitive/manufacturing/labels/DLX_SN_BC.lbl";
}
else if(isMadeInChina||serialNumber.startsWith("V"))
{
serialNumberLabel="com/cognitive/manufacturing/labels/DLX_SN_China.lbl";
}
else
{
serialNumberLabel="com/cognitive/manufacturing/labels/DLX_SN.lbl";
}
}
else if(isTDModelNumber)
{
serialNumberLabel="com/cognitive/manufacturing/labels/TD_DLX_SN.lbl";
}
else
{
serialNumberLabel="com/cognitive/manufacturing/labels/TG_DLX_SN.lbl";
}
if(isMadeByEnnoconnMalaysia)
{
GUIHelper.logger.warn("Appending Ennoconn identifier string to serial label file name.");
if(!isTGModelNumber&&!isTDModelNumber)
serialNumberLabel=serialNumberLabel.replaceFirst("[.]lbl", "_ENNO.lbl");
}
binaryPart=GUIHelper.getResourceAsByteArray(serialNumberLabel);
if(binaryPart==null)
{
String message="Can't get serial number label "+serialNumberLabel;
GUIHelper.logger.error(message);
GUIHelper.error(message);
return TestStatus.FAILED;
}
if(!constructDLXSerialNumberLabel(cplPart))
{
return TestStatus.FAILED;
}
break;
}
if(binaryPart!=null)
{
PrinterHelper.send(binaryPart);
}
if(cplPart!=null)
{
PrinterHelper.send(cplPart.toString());
}
try { PrinterHelper.printer.closeConnection(); }
catch(Exception e)
{
GUIHelper.logger.error(e, e);
GUIHelper.message("Unable to close connection to serial number label printer.", SWT.ICON_WARNING|SWT.OK);
}
return TestStatus.PASSED;
}
static boolean constructCBoxLabel(StringBuffer cplPart)
{
GUIHelper.logger.trace("");
if(!isTGModelNumber&&!isTDModelNumber)
{
String firmwarePartNumber=null;
if(isConnectionTypeParallelOnly)
{
firmwarePartNumber=latestFirmware.substring(0, 3)+"-"+latestFirmware.substring(3, 3)+"-"+latestFirmware.substring(7, 3);
}
else
{
firmwarePartNumber=GUIHelper.getMatch(currentFirmware, "\\d{3}-\\d{3}-\\d{3}");
}
JAdminDialogRadio dialog=new JAdminDialogRadio(Messages.getString("TestEngine.79"));
dialog.addOption(Messages.getString("TestEngine.80"));
dialog.addOption(Messages.getString("TestEngine.81"));
dialog.addOption(Messages.getString("TestEngine.108"));
int selection=dialog.waitForSelection();
String option=null;
switch(selection)
{
case-1:
return false;
case 0:
option="US Power Cord";
break;
case 1:
option="UK/EU Power Cord";
break;
case 2:
option="No Power Cord";
break;
}
cplPart.append("!+0 100 1460 1\n");
cplPart.append("VARIABLE DARKNESS 100\n");
cplPart.append("VARIABLE ENERGY 50\n");
cplPart.append("VARIABLE PRINT_SPEED 5000\n");
cplPart.append("VARIABLE SHIFT LEFT-35\n");
cplPart.append("VARIABLE WIDTH 426\n");
cplPart.append("FILL_BOX 15 20 965 10\n");
if(isSecurity||isGWN)
{
cplPart.append("U B32X80 (10,2,0) 40 80 MODEL:\n");
cplPart.append("U B35X80 (8,2,0) 300 80 "+CompositeManufacturing.textModelNumber.getText()+"\n");
cplPart.append("BARCODE CODE128(3:8)-300 260 100 "+CompositeManufacturing.textModelNumber.getText()+"\n");
}
else
{
cplPart.append("U B32X80 (10,2,0) 40 80 MODEL NO.:\n");
cplPart.append("U B35X80 (8,2,0) 425 80 "+CompositeManufacturing.textModelNumber.getText()+"\n");
cplPart.append("BARCODE CODE128(3:8)-425 260 100 "+CompositeManufacturing.textModelNumber.getText()+"\n");
}
cplPart.append("U B32X80 (10,2,0) 40 320 SERIAL NO.:\n");
cplPart.append("U B35X80 (8,2,0) 495 320 "+serialNumber+"\n");
cplPart.append("BARCODE CODE128(3:8)-525 500 100 "+serialNumber+"\n");
cplPart.append("U B32X80 (10,2,0) 40 560 FIRMWARE:\n");
cplPart.append("U B35X80 (8,2,0) 480 560 "+firmwarePartNumber+"\n");
cplPart.append("BARCODE CODE128(3:8)-465 740 100 "+firmwarePartNumber+"\n");
cplPart.append("U B32X80 (10,2,0) 40 800 OPTION:\n");
cplPart.append("U B35X80 (8,2,0) 345 800 "+option+"\n");
cplPart.append("FILL_BOX 5 20 10 1400\n");
cplPart.append("FILL_BOX 980 20 10 1400\n");
cplPart.append("FILL_BOX 15 1410 965 10\n");
if(isMadeByEnnoconnMalaysia)
cplPart.append("TEXT 0 40 1350 Made in Malaysia\n");
else
cplPart.append("TEXT 0 40 1350 Made in Taiwan\n");
cplPart.append("INDEX\n");
cplPart.append("END\n");
}
else if(isTDModelNumber)
{
cplPart.append("!+0 100 1460 1\n");
cplPart.append("FILL_BOX 25 30 900 10\n");
cplPart.append("U B32 (5,0,0) 30 50 MODEL NUMBER:\n");
cplPart.append("U B60 (6,0,0) 400 50 "+tgModelEmbeddedNumber+"\n");
cplPart.append("U B24 (3,0,0) 30 100 Thermal Printer\n");
cplPart.append("U B24 (3,0,0) 30 140 "+tgModelFeature+"\n");
cplPart.append("FILL_BOX 25 180 900 10\n");
cplPart.append("U B32 (5,0,0) 30 200 ID NUMBER:\n");
cplPart.append("U B42 (5,0,0) 400 200 "+CompositeManufacturing.textModelNumber.getText()+"\n");
cplPart.append("BARCODE CODE39(3:8)-200 320 75 "+CompositeManufacturing.textModelNumber.getText()+"\n");
cplPart.append("FILL_BOX 25 340 900 10\n");
cplPart.append("U B32 (5,0,0) 30 360 SERIAL NUMBER: (1S)\n");
cplPart.append("U B42 (5,0,0) 460 360 "+serialNumber+"\n");
cplPart.append("BARCODE CODE39(3:8)-150 480 75 "+serialNumber+"\n");
cplPart.append("FILL_BOX 25 500 900 10\n");
cplPart.append("BARCODE CODE39(2:6)-100 600 75 "+CompositeManufacturing.textModelNumber.getText()+serialNumber+"\n");
cplPart.append("FILL_BOX 25 620 900 10\n");
cplPart.append("U B32 (5,0,0) 30 670 PRINTHEAD:\n");
cplPart.append("U B32 (5,0,0) 250 670 "+printHead.toString().charAt(0)+"\n");
cplPart.append("FILL_BOX 25 760 900 10\n");
cplPart.append("U B32 (5,0,0) 30 780 MAC ADDRESS:\n");
cplPart.append("BARCODE_FONT U B20 (2,0,0) \n");
cplPart.append("BARCODE CODE39(3:8) 100 900 75 "+macHex.replace(":", "").toUpperCase()+"\n");
cplPart.append("FILL_BOX 25 940 900 10\n");
cplPart.append("U B42 (5,0,0) 55 1120 www.dascom.com\n");
cplPart.append("BARCODE_FONT 12X16(00,05,1,1,1,1)\n");
cplPart.append("BARCODE EAN13+(3:8) 470 1025 60 "+tgModelUPC+"\n");
cplPart.append("U B30 (3,0,0) 470 1100 "+tgCompanyName+"\n");
cplPart.append("U B30 (3,0,0) 470 1140 "+tgGermanyAddress1+" "+tgGermanyAddress2+"\n");
cplPart.append("FILL_BOX 15 30 10 1180\n");
cplPart.append("FILL_BOX 925 30 10 1180\n");
cplPart.append("FILL_BOX 25 1200 900 10\n");
if(isMadeByEnnoconnMalaysia)
cplPart.append("U A24 (4,0,0) 30 1220 Made in Malaysia\n");
else
cplPart.append("U A24 (4,0,0) 30 1220 Made in Taiwan\n");
cplPart.append("INDEX\n");
cplPart.append("END\n");
}
else
{
cplPart.append("!+0 100 1460 1\n");
cplPart.append("FILL_BOX 25 30 900 10\n");
cplPart.append("U B32 (5,0,0) 30 50 MODEL NUMBER:\n");
cplPart.append("U B60 (6,0,0) 400 50 "+tgModelEmbeddedNumber+"\n");
cplPart.append("U B24 (3,0,0) 30 100 Thermal Printer\n");
cplPart.append("U B24 (3,0,0) 30 140 "+tgModelFeature+"\n");
cplPart.append("FILL_BOX 25 180 900 10\n");
cplPart.append("U B32 (5,0,0) 30 200 ID NUMBER:\n");
cplPart.append("U B42 (5,0,0) 400 200 "+CompositeManufacturing.textModelNumber.getText()+"\n");
cplPart.append("BARCODE CODE39(3:8)-200 320 75 "+CompositeManufacturing.textModelNumber.getText()+"\n");
cplPart.append("FILL_BOX 25 340 900 10\n");
cplPart.append("U B32 (5,0,0) 30 360 SERIAL NUMBER: (1S)\n");
cplPart.append("U B42 (5,0,0) 460 360 "+serialNumber+"\n");
cplPart.append("BARCODE CODE39(3:8)-150 480 75 "+serialNumber+"\n");
cplPart.append("FILL_BOX 25 500 900 10\n");
cplPart.append("BARCODE CODE39(2:6)-100 600 75 "+CompositeManufacturing.textModelNumber.getText()+serialNumber+"\n");
cplPart.append("FILL_BOX 25 620 900 10\n");
cplPart.append("U B32 (5,0,0) 30 670 PRINTHEAD:\n");
cplPart.append("U B32 (5,0,0) 250 670 "+printHead.toString().charAt(0)+"\n");
cplPart.append("FILL_BOX 25 760 900 10\n");
cplPart.append("U B32 (5,0,0) 30 780 MAC ADDRESS:\n");
cplPart.append("BARCODE_FONT U B20 (2,0,0) \n");
cplPart.append("BARCODE CODE39(3:8) 100 900 75 "+macHex.replace(":", "").toUpperCase()+"\n");
cplPart.append("FILL_BOX 25 940 900 10\n");
cplPart.append("U B30 (3,0,0) 200 1080 www.tallygenicom.com\n");
cplPart.append("BARCODE_FONT 12X16(00,05,1,1,1,1)\n");
cplPart.append("BARCODE EAN13+(3:8) 535 1120 60 "+tgModelUPC+"\n");
cplPart.append("U B24 (3,0,0) 50 1150 TallyGenicom, "+tgGermanyAddress1+", "+tgGermanyAddress2+"\n");
cplPart.append("FILL_BOX 15 30 10 1180\n");
cplPart.append("FILL_BOX 925 30 10 1180\n");
cplPart.append("FILL_BOX 25 1200 900 10\n");
if(isMadeByEnnoconnMalaysia)
cplPart.append("U A24 (4,0,0) 30 1220 Made in Malaysia\n");
else
cplPart.append("U A24 (4,0,0) 30 1220 Made in Taiwan\n");
cplPart.append("INDEX\n");
cplPart.append("END\n");
}
return true;
}
static boolean constructDLXBoxLabel(StringBuffer cplPart)
{
GUIHelper.logger.trace("");
if(isTDModelNumber)
{
cplPart.append("!+0 100 1460 1\n");
cplPart.append("FILL_BOX 25 30 900 10\n");
cplPart.append("U B32 (5,0,0) 30 50 MODEL NUMBER:\n");
cplPart.append("U B60 (6,0,0) 400 50 "+tgModelEmbeddedNumber+"\n");
cplPart.append("U B24 (3,0,0) 30 100 Thermal Printer\n");
cplPart.append("U B24 (3,0,0) 30 140 "+tgModelFeature+"\n");
cplPart.append("FILL_BOX 25 180 900 10\n");
cplPart.append("U B32 (5,0,0) 30 200 ID NUMBER:\n");
cplPart.append("U B42 (5,0,0) 400 200 "+CompositeManufacturing.textModelNumber.getText()+"\n");
cplPart.append("BARCODE CODE39(3:8)-200 320 75 "+CompositeManufacturing.textModelNumber.getText()+"\n");
cplPart.append("FILL_BOX 25 340 900 10\n");
cplPart.append("U B32 (5,0,0) 30 360 SERIAL NUMBER: (1S)\n");
cplPart.append("U B42 (5,0,0) 460 360 "+serialNumber+"\n");
cplPart.append("BARCODE CODE39(3:8)-150 480 75 "+serialNumber+"\n");
cplPart.append("FILL_BOX 25 500 900 10\n");
cplPart.append("BARCODE CODE39(2:6)-100 600 75 "+CompositeManufacturing.textModelNumber.getText()+serialNumber+"\n");
cplPart.append("FILL_BOX 25 620 900 10\n");
cplPart.append("U B32 (5,0,0) 30 640 COMMUNICATIONS CONFIGURATION:\n");
if(communicationInterface.toString().indexOf("NETWORK")!=-1)
{
cplPart.append("U B880 (8,0,0) 50 42 .\n");
cplPart.append("TEXT 3(0,0,1,1) 240 662 O\n");
cplPart.append("TEXT 3(0,0,1,1) 440 662 O\n");
cplPart.append("U B880 (8,0,0) 700 42 .\n");
}
else if(communicationInterface.toString().indexOf("SERIAL")!=-1)
{
cplPart.append("U B880 (8,0,0) 50 42 .\n");
cplPart.append("U B880 (8,0,0) 240 42 .\n");
cplPart.append("TEXT 3(0,0,1,1) 440 662 O\n");
cplPart.append("TEXT 3(0,0,1,1) 700 662 O\n");
}
else if(communicationInterface.toString().indexOf("PARALLEL")!=-1)
{
cplPart.append("U B880 (8,0,0) 50 42 .\n");
cplPart.append("TEXT 3(0,0,1,1) 240 662 O\n");
cplPart.append("U B880 (8,0,0) 440 42 .\n");
cplPart.append("TEXT 3(0,0,1,1) 700 662 O\n");
}
else
{
cplPart.append("U B880 (8,0,0) 50 42 .\n");
cplPart.append("TEXT 3(0,0,1,1) 240 662 O\n");
cplPart.append("TEXT 3(0,0,1,1) 440 662 O\n");
cplPart.append("TEXT 3(0,0,1,1) 700 662 O\n");
}
cplPart.append("U B32 (5,0,0) 50 728 USB	SERIAL	PARALLEL	ETHERNET\n");
cplPart.append("FILL_BOX 25 760 900 10\n");
cplPart.append("U B32 (5,0,0) 30 780 MAC ADDRESS:\n");
if(communicationInterface.toString().indexOf("NETWORK")!=-1)
{
cplPart.append("BARCODE_FONT U B20 (2,0,0) \n");
cplPart.append("BARCODE CODE39(3:8) 100 900 75 "+macHex.replace(":", "").toUpperCase()+"\n");
}
cplPart.append("FILL_BOX 25 940 900 10\n");
cplPart.append("U B42 (5,0,0) 55 1120 www.dascom.com\n");
cplPart.append("BARCODE_FONT 12X16(00,05,1,1,1,1)\n");
cplPart.append("BARCODE EAN13+(3:8) 470 1025 60 "+tgModelUPC+"\n");
cplPart.append("U B30 (3,0,0) 470 1100 "+tgCompanyName+"\n");
cplPart.append("U B30 (3,0,0) 470 1140 "+tgGermanyAddress1+" "+tgGermanyAddress2+"\n");
cplPart.append("FILL_BOX 15 30 10 1180\n");
cplPart.append("FILL_BOX 925 30 10 1180\n");
cplPart.append("FILL_BOX 25 1200 900 10\n");
if(isMadeByEnnoconnMalaysia)
cplPart.append("U A24 (4,0,0) 30 1220 Made in Malaysia\n");
else
cplPart.append("U A24 (4,0,0) 30 1220 Made in Mexico\n");
cplPart.append("INDEX\n");
cplPart.append("END\n");
}
else if(isTGModelNumber)
{
cplPart.append("!+0 100 1460 1\n");
cplPart.append("FILL_BOX 25 30 900 10\n");
cplPart.append("U B32 (5,0,0) 30 50 MODEL NUMBER:\n");
cplPart.append("U B60 (6,0,0) 400 50 "+tgModelEmbeddedNumber+"\n");
cplPart.append("U B24 (3,0,0) 30 100 Thermal Printer\n");
cplPart.append("U B24 (3,0,0) 30 140 "+tgModelFeature+"\n");
cplPart.append("FILL_BOX 25 180 900 10\n");
cplPart.append("U B32 (5,0,0) 30 200 ID NUMBER:\n");
cplPart.append("U B42 (5,0,0) 400 200 "+CompositeManufacturing.textModelNumber.getText()+"\n");
cplPart.append("BARCODE CODE39(3:8)-200 320 75 "+CompositeManufacturing.textModelNumber.getText()+"\n");
cplPart.append("FILL_BOX 25 340 900 10\n");
cplPart.append("U B32 (5,0,0) 30 360 SERIAL NUMBER: (1S)\n");
cplPart.append("U B42 (5,0,0) 460 360 "+serialNumber+"\n");
cplPart.append("BARCODE CODE39(3:8)-150 480 75 "+serialNumber+"\n");
cplPart.append("FILL_BOX 25 500 900 10\n");
cplPart.append("BARCODE CODE39(2:6)-100 600 75 "+CompositeManufacturing.textModelNumber.getText()+serialNumber+"\n");
cplPart.append("FILL_BOX 25 620 900 10\n");
cplPart.append("U B32 (5,0,0) 30 640 COMMUNICATIONS CONFIGURATION:\n");
if(communicationInterface.toString().indexOf("NETWORK")!=-1)
{
cplPart.append("U B880 (8,0,0) 50 42 .\n");
cplPart.append("TEXT 3(0,0,1,1) 240 662 O\n");
cplPart.append("TEXT 3(0,0,1,1) 440 662 O\n");
cplPart.append("U B880 (8,0,0) 700 42 .\n");
}
else if(communicationInterface.toString().indexOf("SERIAL")!=-1)
{
cplPart.append("U B880 (8,0,0) 50 42 .\n");
cplPart.append("U B880 (8,0,0) 240 42 .\n");
cplPart.append("TEXT 3(0,0,1,1) 440 662 O\n");
cplPart.append("TEXT 3(0,0,1,1) 700 662 O\n");
}
else if(communicationInterface.toString().indexOf("PARALLEL")!=-1)
{
cplPart.append("U B880 (8,0,0) 50 42 .\n");
cplPart.append("TEXT 3(0,0,1,1) 240 662 O\n");
cplPart.append("U B880 (8,0,0) 440 42 .\n");
cplPart.append("TEXT 3(0,0,1,1) 700 662 O\n");
}
else
{
cplPart.append("U B880 (8,0,0) 50 42 .\n");
cplPart.append("TEXT 3(0,0,1,1) 240 662 O\n");
cplPart.append("TEXT 3(0,0,1,1) 440 662 O\n");
cplPart.append("TEXT 3(0,0,1,1) 700 662 O\n");
}
cplPart.append("U B32 (5,0,0) 50 728 USB	SERIAL	PARALLEL	ETHERNET\n");
cplPart.append("FILL_BOX 25 760 900 10\n");
cplPart.append("U B32 (5,0,0) 30 780 MAC ADDRESS:\n");
if(communicationInterface.toString().indexOf("NETWORK")!=-1)
{
cplPart.append("BARCODE_FONT U B20 (2,0,0) \n");
cplPart.append("BARCODE CODE39(3:8) 100 900 75 "+macHex.replace(":", "").toUpperCase()+"\n");
}
cplPart.append("FILL_BOX 25 940 900 10\n");
cplPart.append("U B30 (3,0,0) 200 1080 www.tallygenicom.com\n");
cplPart.append("BARCODE_FONT 12X16(00,05,1,1,1,1)\n");
cplPart.append("BARCODE EAN13+(3:8) 535 1120 60 "+tgModelUPC+"\n");
cplPart.append("U B24 (3,0,0) 50 1150 TallyGenicom, "+tgGermanyAddress1+", "+tgGermanyAddress2+"\n");
cplPart.append("FILL_BOX 15 30 10 1180\n");
cplPart.append("FILL_BOX 925 30 10 1180\n");
cplPart.append("FILL_BOX 25 1200 900 10\n");
if(isMadeByEnnoconnMalaysia)
cplPart.append("U A24 (4,0,0) 30 1220 Made in Malaysia\n");
else
cplPart.append("U A24 (4,0,0) 30 1220 Made in Mexico\n");
cplPart.append("INDEX\n");
cplPart.append("END\n");
}
else
{
String descriptionLine1="";
String descriptionLine2="200dpi, 8M, ";
String descriptionLine4="POWER CORD, ";
if(productLine==ProductLine.DLX)
descriptionLine1+="DLXi, ";
else if(productLine==ProductLine.LX)
descriptionLine1+="LX, ";
if(printMethod==PrintMethod.DT)
descriptionLine1+="DT, ";
else if(printMethod==PrintMethod.TT)
descriptionLine1+="TT, ";
if(mediaWidth==2)
descriptionLine1+="2\"";
else if(mediaWidth==4)
descriptionLine1+="4\"";
if(communicationInterface==CommunicationInterface.USB_AB)
descriptionLine2+="USB, ";
else if(communicationInterface==CommunicationInterface.USB_AB_NETWORK)
descriptionLine2+="USB/ETH, ";
else if(communicationInterface==CommunicationInterface.USB_AB_NETWORK_SERIAL)
descriptionLine2+="USB/ETH/SER, ";
else if(communicationInterface==CommunicationInterface.USB_AB_NETWORK_SERIAL_PARALLEL)
descriptionLine2+="USB/ETH/SER/PAR, ";
else if(communicationInterface==CommunicationInterface.USB_AB_SERIAL)
descriptionLine2+="SER, ";
else if(communicationInterface==CommunicationInterface.USB_AB_SERIAL_BLUETOOTH)
descriptionLine2+="SER/BTH, ";
else if(communicationInterface==CommunicationInterface.USB_AB_PARALLEL)
descriptionLine2+="USB/PAR, ";
else if(communicationInterface==CommunicationInterface.USB_AB_SERIAL_PARALLEL)
descriptionLine2+="USB/SER/PAR, ";
else if(communicationInterface==CommunicationInterface.SERIAL)
descriptionLine2+="SER, ";
else if(communicationInterface==CommunicationInterface.PARALLEL)
descriptionLine2+="PAR, ";
else if(communicationInterface==CommunicationInterface.SERIAL_PARALLEL)
descriptionLine2+="SER/PAR, ";
else if(communicationInterface==CommunicationInterface.SERIAL_NETWORK)
descriptionLine2+="SER/ETH, ";
else if(communicationInterface==CommunicationInterface.SERIAL_NETWORK_PARALLEL)
descriptionLine2+="SER/ETH/PAR, ";
else if(communicationInterface==CommunicationInterface.USB_AB_LEGACY_NO_CABLE)
descriptionLine2+="USB, ";
else if(communicationInterface==CommunicationInterface.USB_AB_LEGACY_SERIAL_CABLE)
descriptionLine2+="SER, ";
else if(communicationInterface==CommunicationInterface.USB_AB_LEGACY_ADAPTOR_SERIAL_CABLE)
descriptionLine2+="SER, ";
else if(communicationInterface==CommunicationInterface.USB_AB_LEGACY_PARALLEL_CABLE)
descriptionLine2+="PAR, ";
else if(communicationInterface==CommunicationInterface.ALL)
descriptionLine2+="USB/SER/PAR/ETH/BTH, ";
if(powerSupplyCord==PowerSupplyCord.US)
{
descriptionLine2+="US";
descriptionLine4+="US";
}
else if(powerSupplyCord==PowerSupplyCord.EU_UK)
{
descriptionLine2+="EURO+UK";
descriptionLine4+="EURO+UK";
}
else if(powerSupplyCord==PowerSupplyCord.US_EU_UK)
{
descriptionLine2+="US+EURO+UK";
descriptionLine4+="US+EURO+UK";
}
else if(powerSupplyCord==PowerSupplyCord.NO_CORD||powerSupplyCord==PowerSupplyCord.NO_POWER_SUPPLY)
{
descriptionLine2+="ANY";
descriptionLine4+="NO PS";
}
cplPart.append("!0 100 1460 1\n");
cplPart.append("VARIABLE DARKNESS 100\n");
cplPart.append("VARIABLE ENERGY 50\n");
cplPart.append("VARIABLE PRINT_SPEED 5000\n");
cplPart.append("VARIABLE SHIFT LEFT-35\n");
cplPart.append("VARIABLE WIDTH 426\n");
cplPart.append("DRAW_BOX 0 0 1025 1400 4\n");
cplPart.append("TEXT 2 54 25 MODEL NUMBER:\n");
cplPart.append("TEXT 3 140 105 "+CompositeManufacturing.textModelNumber.getText()+"\n");
cplPart.append("BARCODE CODE128(5:8)-108 295 112 "+CompositeManufacturing.textModelNumber.getText()+"\n");
cplPart.append("DRAW_BOX 0 400 1025 1000 4\n");
cplPart.append("TEXT 3 50 450 SERIAL NUMBER:\n");
cplPart.append("TEXT 4 50 520 "+serialNumber+"\n");
cplPart.append("BARCODE CODE128(5:8)-50 750 100 "+serialNumber+"\n");
cplPart.append("DRAW_BOX 0 800 1025 600 4\n");
cplPart.append("TEXT 3 50 850 DESCRIPTION:\n");
cplPart.append("TEXT 2 50 950 "+descriptionLine1+"\n");
cplPart.append("TEXT 2 50 1000 "+descriptionLine2+"\n");
cplPart.append("TEXT 2 50 1050 POWER SUPPLY 70WATT\n");
cplPart.append("TEXT 2 50 1100 "+descriptionLine4+"\n");
if(descriptionLine2.contains("USB"))
cplPart.append("TEXT 2 50 1150 ACCESSORY CABLE, USB\n");
else
cplPart.append("TEXT 2 50 1150 ACCESSORY CABLE, NONE\n");
cplPart.append("TEXT 2 875 1350 Rev N\n");
if(isMadeByEnnoconnMalaysia)
cplPart.append("TEXT 2 50 1410 Made in Malaysia\n");
else
cplPart.append("TEXT 2 50 1410 Made in Mexico\n");
cplPart.append("INDEX\n");
cplPart.append("END\n");
}
return true;
}
static TestStatus doBoxLabel()
{
GUIHelper.logger.trace("");
if(!CompositeManufacturing.checkBoxBoxLabelPrinter.getSelection())
{
return TestStatus.SKIPPED;
}
if(!connectNamedPrinter(CompositeManufacturing.textBoxLabelPrinter.getText()))
{
return TestStatus.FAILED;
}
byte binaryPart[]=null;
byte binaryPart2[]=null;
StringBuffer cplPart=new StringBuffer();
String boxLabel=null;
String boxLabel2=null;
switch(productLine)
{
case CI:
case CXI:
if(!isTGModelNumber&&!isTDModelNumber)
{
boxLabel="com/cognitive/manufacturing/labels/C_BOX_2.lbl";
}
else
{
if(isTDModelNumber)
{
boxLabel="com/cognitive/manufacturing/labels/TD_C_BOX.lbl";
boxLabel2="com/cognitive/manufacturing/labels/TG_C_BOX_2.lbl";
}
else
{
boxLabel="com/cognitive/manufacturing/labels/TG_C_BOX.lbl";
boxLabel2="com/cognitive/manufacturing/labels/TG_C_BOX_2.lbl";
}
binaryPart2=GUIHelper.getResourceAsByteArray(boxLabel2);
if(binaryPart2==null)
{
String message="Can't get box label "+boxLabel2;
GUIHelper.logger.error(message);
GUIHelper.error(message);
return TestStatus.FAILED;
}
}
binaryPart=GUIHelper.getResourceAsByteArray(boxLabel);
if(binaryPart==null)
{
String message="Can't get box label "+boxLabel;
GUIHelper.logger.error(message);
GUIHelper.error(message);
return TestStatus.FAILED;
}
if(!constructCBoxLabel(cplPart))
{
return TestStatus.FAILED;
}
break;
case LX:
case DLX:
if(isTGModelNumber||isTDModelNumber)
{
if(isTDModelNumber)
{
boxLabel="com/cognitive/manufacturing/labels/TD_C_BOX.lbl";
}
else
{
boxLabel="com/cognitive/manufacturing/labels/TG_C_BOX.lbl";
}
binaryPart=GUIHelper.getResourceAsByteArray(boxLabel);
if(binaryPart==null)
{
String message="Can't get box label "+boxLabel;
GUIHelper.logger.error(message);
GUIHelper.error(message);
return TestStatus.FAILED;
}
}
else
{
}
if(!constructDLXBoxLabel(cplPart))
{
return TestStatus.FAILED;
}
break;
}
if(binaryPart!=null)
{
PrinterHelper.send(binaryPart);
}
if(binaryPart2!=null)
{
PrinterHelper.send(binaryPart2);
}
if(cplPart!=null)
{
PrinterHelper.send(cplPart.toString());
}
if(binaryPart!=null)
{
PrinterHelper.send(binaryPart);
}
if(binaryPart2!=null)
{
PrinterHelper.send(binaryPart2);
}
if(cplPart!=null)
{
PrinterHelper.send(cplPart.toString());
}
try
{
PrinterHelper.printer.closeConnection();
}
catch(Exception e)
{
String message="Unable to close connection to box label printer.";
GUIHelper.logger.error(e, e);
GUIHelper.message(message, SWT.ICON_WARNING|SWT.OK);
}
return TestStatus.PASSED;
}
static TestStatus doPeelerTest()
{
GUIHelper.logger.info("");
if((communicationInterface.toString().indexOf("NETWORK")!=-1)||(communicationInterface==CommunicationInterface.ALL)||(CompositeManufacturing.checkBoxNetwork.getSelection()))
{
StringBuffer macBarCode=new StringBuffer();
if((!isWingman))
{
if(isLX)
{
macBarCode.append("!");
}
macBarCode.append("!0 100 300 1\n");
macBarCode.append("TEXT 1 20 15 MAC:\n");
macBarCode.append("TEXT 1 100 15 "+macHex.toUpperCase()+"\n");
macBarCode.append("BARCODE CODE128(2:5)-20 120 70 "+macHex.toUpperCase()+"\n");
macBarCode.append("END\n");
}
else
{
macBarCode.append("N\n");
macBarCode.append("A20,15,0,3,1,1,N,\"MAC:\"\n");
macBarCode.append("A100,15,0,3,1,1,N,\""+macHex.toUpperCase()+"\"\n");
macBarCode.append("B20,50,0,1A,2,4,70,N,\""+macHex.toUpperCase()+"\"\n");
macBarCode.append("P1\n");
}
PrinterHelper.send(macBarCode.toString());
}
if(exitOption!=ExitOption.PEELER)
{
return TestStatus.SKIPPED;
}
GUIHelper.message(Messages.getString("TestEngine.82"), SWT.OK|SWT.ICON_INFORMATION);
if(isLX)
{
PrinterHelper.send("!!0 100 200 1\nString 24X31 20 20 Peeler Test\nHALT\nEND");
}
else
{
PrinterHelper.send("!0 100 200 1\nString 24X31 20 20 Peeler Test\nHALT\nEND");
}
if(!isConnectionTypeParallelOnly)
{
if(!PrinterHelper.waitFor(".*W0....", 5))
{
GUIHelper.error(Messages.getString("TestEngine.83"));
return TestStatus.FAILED;
}
}
else
{
try
{
Thread.sleep(5000);
}
catch(Exception ex)
{
return TestStatus.FAILED;
}
}
GUIHelper.message(Messages.getString("TestEngine.84"), SWT.ICON_WORKING|SWT.OK);
if(!isConnectionTypeParallelOnly)
{
boolean success=PrinterHelper.waitFor(PrinterHelper.PEELER_PRINTER_READY, 10);
if(!success)
{
GUIHelper.error(Messages.getString("TestEngine.85"));
return TestStatus.FAILED;
}
}
else
{
try
{
Thread.sleep(5000);
}
catch(Exception ex)
{
return TestStatus.FAILED;
}
}
GUIHelper.message(Messages.getString("TestEngine.86"), SWT.OK|SWT.ICON_INFORMATION);
return TestStatus.PASSED;
}
static TestStatus doControlPanel()
{
if(productLine!=ProductLine.CXI)
{
return TestStatus.SKIPPED;
}
String message=Messages.getString("TestEngine.87")+Messages.getString("TestEngine.88")+Messages.getString("TestEngine.89")+Messages.getString("TestEngine.90")+Messages.getString("TestEngine.91")+Messages.getString("TestEngine.92")+Messages.getString("TestEngine.93")+Messages.getString("TestEngine.94")+Messages.getString("TestEngine.95")+Messages.getString("TestEngine.96")+Messages.getString("TestEngine.97")+Messages.getString("TestEngine.98")+Messages.getString("TestEngine.118")+Messages.getString("TestEngine.119")+Messages.getString("TestEngine.120")+Messages.getString("TestEngine.121")+Messages.getString("TestEngine.122")+Messages.getString("TestEngine.99");
int button=GUIHelper.message(message, SWT.ICON_QUESTION|SWT.YES|SWT.NO);
if(button==SWT.YES)
{
return TestStatus.PASSED;
}
else
{
return TestStatus.FAILED;
}
}
static boolean getShippingLabelInfo()
{
GUIHelper.logger.trace("");
boolean connected=establishPrimaryConnection(115200);
if(!connected)
{
GUIHelper.error(Messages.getString("TestEngine.100"));
return false;
}
String currentFirmwarePartNumber=TestEngine.getCurrentFirmwarePartNumber();
String modelNumber=GUIHelper.clean(PrinterHelper.commandWaitResponse("!SHOW MODELNUMBER"));
if(modelNumber.startsWith("700"))
{
if(Integer.parseInt(currentFirmwarePartNumber.substring(currentFirmwarePartNumber.length()-3))>150)
{
modelNumber=GUIHelper.clean(PrinterHelper.commandWaitResponse("!SHOW OEMMODELID"));
}
else
{
if(tgModelNumbers==null)
{
tgModelNumbers=new TGModelNumbers(isTGModelNumber);
}
modelNumber=tgModelNumbers.getModelID(modelNumber);
}
}
if(CompositeManufacturing.textModelNumber.getText().equalsIgnoreCase("DLX-K542"))
{
testModelNumber=PrinterHelper.commandWaitResponse("!SHOW MODELNUMBER");
isCustomLabel_K542=true;
}
parseModelNumber(modelNumber);
if (productLine==null&&modelNumber.startsWith("D")) { productLine=ProductLine.DLX; }
if (productLine==null&&modelNumber.startsWith("C")) { productLine=ProductLine.CXI; }
if ((printHead==null||printHead==PrintHead.Automatic)&&productLine==ProductLine.DLX)
{
GUIHelper.logger.info("Printhead auto type selection: switching to use ROHM_KDxxxxDF type.");
CompositeManufacturing.comboPrintHead.select(1);
printHead=PrintHead.ROHM_KDxxxxDF;
}
if ((printHead==null||printHead==PrintHead.Automatic)&&(productLine==ProductLine.CI||productLine==ProductLine.CXI))
{
GUIHelper.logger.info("Printhead auto type selection: switching to use HEC type.");
CompositeManufacturing.comboPrintHead.select(2);
printHead=PrintHead.HEC;
}
if(productLine==ProductLine.DLX&&printHead!=PrintHead.ROHM_KDxxxxDF)
{
int button=GUIHelper.message("Warning!The printhead selected for the DLX printer is not set as "+"\"ROHM_KDxxxxDF\", which is what the production line uses by default. If the operator intended "+"on selecting a printhead other than \"ROHM_KDxxxxDF\", click yes to continue with the custom option. "+"Otherwise, click no to use the production line default printhead.", SWT.ICON_WARNING|SWT.YES|SWT.NO|SWT.CANCEL);
if (button==SWT.YES)
{
GUIHelper.logger.warn("User has manually decided to use a non-standard print head configuration of "+printHead.toString()+".");
}
else if(button==SWT.NO)
{
GUIHelper.logger.warn("User has manually decided to use a standard print head configuration of "+printHead.toString()+".");
CompositeManufacturing.comboPrintHead.select(1);
printHead=PrintHead.ROHM_KDxxxxDF;
}
else if(button==SWT.CANCEL)
{
return false;
}
}
if((productLine==ProductLine.CI||productLine==ProductLine.CXI)&&printHead!=PrintHead.HEC)
{
int button=GUIHelper.message("Warning!The printhead selected for the C-Series printer is not set as "+"\"HEC\", which is what the production line uses by default. If the operator intended "+"on selecting a printhead other than \"HEC\", click*Yes*to continue with the custom option. "+"Otherwise, click*No*to use the production line default printhead.", SWT.ICON_WARNING|SWT.YES|SWT.NO|SWT.CANCEL);
if (button==SWT.YES)
{
GUIHelper.logger.warn("User has manually decided to use a non-standard print head configuration of "+printHead.toString()+".");
}
else if(button==SWT.NO)
{
GUIHelper.logger.warn("User has manually decided to use a standard print head configuration of "+printHead.toString()+".");
CompositeManufacturing.comboPrintHead.select(2);
printHead=PrintHead.HEC;
}
else if(button==SWT.CANCEL)
{
return false;
}
}
String selection=CompositeManufacturing.comboPrintHead.getItem((CompositeManufacturing.comboPrintHead.getSelectionIndex()));
printHead=PrintHead.valueOf(selection);
serialNumber=GUIHelper.clean(PrinterHelper.commandWaitResponse("!SHOW SERIALNUMBER"));
macHex=GUIHelper.clean(PrinterHelper.commandWaitResponse("!SHOW MAC"));
currentFirmware=GUIHelper.clean(PrinterHelper.commandWaitResponse("!QR"));
CompositeManufacturing.textModelNumber.setText(modelNumber);
CompositeManufacturing.textSerialNumberActual.setText(serialNumber);
CompositeManufacturing.textMacAddressActual.setText(macHex);
return true;
}
static void printSNLabel()
{
boolean retVal=getShippingLabelInfo();
if(retVal==false)
{
return;
}
doSerialNumberLabel();
}
static void printBoxLabel()
{
boolean retVal=getShippingLabelInfo();
if(retVal==false)
{
return;
}
doBoxLabel();
}
static boolean checkDB(String qualifiedSerialNumber, String qualifiedMac, String modelNumber) throws DBException
{
GUIHelper.logger.trace("");
PrinterId printerId=new PrinterId(qualifiedSerialNumber, qualifiedMac, modelNumber);
GUIHelper.logger.debug(printerId.toString());
StringBuffer urlEncodedQuery=new StringBuffer();
urlEncodedQuery.append("&");
urlEncodedQuery.append("act=gsn");
urlEncodedQuery.append("&");
urlEncodedQuery.append("sn=");
urlEncodedQuery.append(printerId.getSerialNumber());
urlEncodedQuery.append("&");
urlEncodedQuery.append("snp=");
urlEncodedQuery.append(printerId.getSnPrefix());
urlEncodedQuery.append("&");
urlEncodedQuery.append("lc=");
urlEncodedQuery.append(printerId.getLocationCode());
String url=jadminURLBase+urlEncodedQuery.toString();
if(isTGModelNumber)
{
url=jadminURLBaseTG+urlEncodedQuery.toString();
}
String xmlPrinterId=httpGet(url);
if(xmlPrinterId==null)
{
throw new DBException("Can't connect to database.");
}
PrinterId dbPrinterId=new PrinterId(xmlPrinterId);
GUIHelper.logger.debug(dbPrinterId.toString());
return printerId.equals(dbPrinterId);
}
static TestStatus enablePCL(boolean isParsingRequired)
{
GUIHelper.logger.trace("");
boolean connected=establishPrimaryConnection(115200);
if(!connected)
{
GUIHelper.error(Messages.getString("TestEngine.100"));
return TestStatus.FAILED;
}
if(isParsingRequired)
{
String currentFirmwarePartNumber=TestEngine.getCurrentFirmwarePartNumber();
String modelNumber=GUIHelper.clean(PrinterHelper.commandWaitResponse("!SHOW MODELNUMBER"));
if(modelNumber.startsWith("700"))
{
if(Integer.parseInt(currentFirmwarePartNumber.substring(currentFirmwarePartNumber.length()-3))>150)
{
modelNumber=GUIHelper.clean(PrinterHelper.commandWaitResponse("!SHOW OEMMODELID"));
}
else
{
if(tgModelNumbers==null)
{
tgModelNumbers=new TGModelNumbers(isTGModelNumber);
}
modelNumber=tgModelNumbers.getModelID(modelNumber);
}
}
boolean success=parseModelNumber(modelNumber);
if(!success)
{
GUIHelper.error(Messages.getString("TestEngine.103"));
return TestStatus.FAILED;
}
}
if(productLine==null)
{
productLine=ProductLine.CXI;
}
if(customization==null)
{
customization="PCL";
}
TestStatus testStatus=doFirmwareDownload(false, CompositeManufacturing.progressBarFirmwareDownload, true);
if(testStatus==TestStatus.FAILED||testStatus==TestStatus.CANCELLED)
{
GUIHelper.error(Messages.getString("TestEngine.103"));
return TestStatus.FAILED;
}
isPCL=true;
testStatus=doLoadFonts(printDensity);
if(testStatus==TestStatus.FAILED||testStatus==TestStatus.CANCELLED)
{
isPCL=false;
GUIHelper.error(Messages.getString("TestEngine.103"));
return TestStatus.FAILED;
}
isPCL=false;
String sn=GUIHelper.clean(PrinterHelper.commandWaitResponse("!SHOW SERIALNUMBER")).toUpperCase();
String mac=GUIHelper.clean(PrinterHelper.commandWaitResponse("!SHOW MAC")).toUpperCase();
String exeName="FPKtool.exe";
String companyname=GUIHelper.brand.getProperty("company.name", "CognitiveTPG").replaceAll("TPG", "").replaceAll(" ", "");
String path="C:/Program Files/"+companyname+"/FPK/";
int exitVal;
try
{
Process proc=new ProcessBuilder(path+exeName, "-e0", "-k13", "-s=\""+sn+"\"", "-m=\""+mac+"\"", "\""+path+"pcl_enable.txt\"", "\""+path+"fpk.out\"").start();
exitVal=proc.waitFor();
if(exitVal!=0)
{
String msg="FPK generation failed with error code ["+exitVal+"].";
GUIHelper.error(msg);
GUIHelper.logger.error(msg);
return TestStatus.FAILED;
}
}
catch(Exception e)
{
String msg="FPK generation failed due to exception ["+e.toString()+"].";
GUIHelper.error(msg);
return TestStatus.FAILED;
}
StringBuffer licenseLabel=new StringBuffer();
licenseLabel.append("!LOAD LICENSE 40 \n");
try
{
File file=new File(path+"fpk.out");
FileReader fileReader=new FileReader(file);
BufferedReader bufferedReader=new BufferedReader(fileReader);
String line;
while((line=bufferedReader.readLine())!=null)
{
licenseLabel.append(line+"\n");
}
PrinterHelper.send(licenseLabel.toString());
bufferedReader.close();
file.delete();
}
catch(FileNotFoundException e)
{
String msg="Can't find fpk output file.";
GUIHelper.error(msg);
GUIHelper.logger.error(msg);
return TestStatus.FAILED;
}
catch(IOException e)
{
String msg="Can't read fpk output file.";
GUIHelper.error(msg);
GUIHelper.logger.error(msg);
return TestStatus.FAILED;
}
PrinterHelper.setVariable("LANGUAGE", "PCL");
try
{
PrinterHelper.printer.closeConnection();
}
catch(Exception e)
{
String msg="Can't close printer connection.";
GUIHelper.error(msg);
GUIHelper.logger.error(msg);
return TestStatus.FAILED;
}
return TestStatus.PASSED;
}
static boolean enableTS()
{
GUIHelper.logger.trace("");
boolean connected=establishPrimaryConnection(115200);
if(!connected)
{
GUIHelper.error(Messages.getString("TestEngine.100"));
return false;
}
String sn=GUIHelper.clean(PrinterHelper.commandWaitResponse("!SHOW SERIALNUMBER")).toUpperCase();
String mac=GUIHelper.clean(PrinterHelper.commandWaitResponse("!SHOW MAC")).toUpperCase();
String exeName="FPKtool.exe";
String companyname=GUIHelper.brand.getProperty("company.name", "CognitiveTPG").replaceAll("TPG", "").replaceAll(" ", "");
String path="C:/Program Files/"+companyname+"/FPK/";
int exitVal;
try
{
Process proc=new ProcessBuilder(path+exeName, "-e0", "-k13", "-s=\""+sn+"\"", "-m=\""+mac+"\"", "\""+path+"eth_disable_TS_enable.txt\"", "\""+path+"fpk.out\"").start();
exitVal=proc.waitFor();
if(exitVal!=0)
{
String msg="FPK generation failed with error code ["+exitVal+"].";
GUIHelper.error(msg);
GUIHelper.logger.error(msg);
return false;
}
}
catch(Exception e)
{
String msg="FPK generation failed due to exception ["+e.toString()+"].";
GUIHelper.error(msg);
return false;
}
StringBuffer licenseLabel=new StringBuffer();
licenseLabel.append("!LOAD LICENSE 40 \n");
try
{
File file=new File(path+"fpk.out");
FileReader fileReader=new FileReader(file);
BufferedReader bufferedReader=new BufferedReader(fileReader);
String line;
while((line=bufferedReader.readLine())!=null)
{
licenseLabel.append(line+"\n");
}
PrinterHelper.send(licenseLabel.toString());
bufferedReader.close();
file.delete();
}
catch(FileNotFoundException e)
{
String msg="Can't find fpk output file.";
GUIHelper.error(msg);
GUIHelper.logger.error(msg);
return false;
}
catch(IOException e)
{
String msg="Can't read fpk output file.";
GUIHelper.error(msg);
GUIHelper.logger.error(msg);
return false;
}
try
{
PrinterHelper.printer.closeConnection();
}
catch(Exception e)
{
String msg="Can't close printer connection.";
GUIHelper.error(msg);
GUIHelper.logger.error(msg);
return false;
}
PrinterHelper.waitFor(PrinterHelper.GENERAL_PRINTER_READY, 5);
connected=establishPrimaryConnection(115200);
if(!connected)
{
GUIHelper.error(Messages.getString("TestEngine.100"));
return false;
}
return true;
}
static boolean disablePCL()
{
GUIHelper.logger.trace("");
boolean connected=establishPrimaryConnection(115200);
if(!connected)
{
GUIHelper.error(Messages.getString("TestEngine.100"));
return false;
}
String sn=GUIHelper.clean(PrinterHelper.commandWaitResponse("!SHOW SERIALNUMBER")).toUpperCase();
String mac=GUIHelper.clean(PrinterHelper.commandWaitResponse("!SHOW MAC")).toUpperCase();
String exeName="FPKtool.exe";
String companyname=GUIHelper.brand.getProperty("company.name", "CognitiveTPG").replaceAll("TPG", "").replaceAll(" ", "");
String path="C:/Program Files/"+companyname+"/FPK/";
int exitVal;
try
{
Process proc=new ProcessBuilder(path+exeName, "-e0", "-k13", "-s=\""+sn+"\"", "-m=\""+mac+"\"", "\""+path+"pcl_disable.txt\"", "\""+path+"fpk.out\"").start();
exitVal=proc.waitFor();
if(exitVal!=0)
{
String msg="FPK generation failed with error code ["+exitVal+"].";
GUIHelper.error(msg);
GUIHelper.logger.error(msg);
return false;
}
}
catch(Exception e)
{
String msg="FPK generation failed due to exception ["+e.toString()+"].";
GUIHelper.error(msg);
return false;
}
StringBuffer licenseLabel=new StringBuffer();
licenseLabel.append("!LOAD LICENSE 40 \n");
try
{
File file=new File(path+"fpk.out");
FileReader fileReader=new FileReader(file);
BufferedReader bufferedReader=new BufferedReader(fileReader);
String line;
while((line=bufferedReader.readLine())!=null)
{
licenseLabel.append(line+"\n");
}
PrinterHelper.send(licenseLabel.toString());
bufferedReader.close();
file.delete();
}
catch(FileNotFoundException e)
{
String msg="Can't find fpk output file.";
GUIHelper.error(msg);
GUIHelper.logger.error(msg);
return false;
}
catch(IOException e)
{
String msg="Can't read fpk output file.";
GUIHelper.error(msg);
GUIHelper.logger.error(msg);
return false;
}
PrinterHelper.setVariable("LANGUAGE", "NONE");
try
{
PrinterHelper.printer.closeConnection();
}
catch(Exception e)
{
String msg="Can't close printer connection.";
GUIHelper.error(msg);
GUIHelper.logger.error(msg);
return false;
}
PrinterHelper.waitFor(PrinterHelper.GENERAL_PRINTER_READY, 5);
connected=establishPrimaryConnection(115200);
if(!connected)
{
GUIHelper.error(Messages.getString("TestEngine.100"));
return false;
}
return true;
}
static boolean disableTS()
{
GUIHelper.logger.trace("");
boolean connected=establishPrimaryConnection(115200);
if(!connected)
{
GUIHelper.error(Messages.getString("TestEngine.100"));
return false;
}
String sn=GUIHelper.clean(PrinterHelper.commandWaitResponse("!SHOW SERIALNUMBER")).toUpperCase();
String mac=GUIHelper.clean(PrinterHelper.commandWaitResponse("!SHOW MAC")).toUpperCase();
String exeName="FPKtool.exe";
String companyname=GUIHelper.brand.getProperty("company.name", "CognitiveTPG").replaceAll("TPG", "").replaceAll(" ", "");
String path="C:/Program Files/"+companyname+"/FPK/";
int exitVal;
try
{
Process proc=new ProcessBuilder(path+exeName, "-e0", "-k13", "-s=\""+sn+"\"", "-m=\""+mac+"\"", "\""+path+"TS_disable.txt\"", "\""+path+"fpk.out\"").start();
exitVal=proc.waitFor();
if(exitVal!=0)
{
String msg="FPK generation failed with error code ["+exitVal+"].";
GUIHelper.error(msg);
GUIHelper.logger.error(msg);
return false;
}
}
catch(Exception e)
{
String msg="FPK generation failed due to exception ["+e.toString()+"].";
GUIHelper.error(msg);
return false;
}
StringBuffer licenseLabel=new StringBuffer();
licenseLabel.append("!LOAD LICENSE 40 \n");
try
{
File file=new File(path+"fpk.out");
FileReader fileReader=new FileReader(file);
BufferedReader bufferedReader=new BufferedReader(fileReader);
String line;
while((line=bufferedReader.readLine())!=null)
{
licenseLabel.append(line+"\n");
}
PrinterHelper.send(licenseLabel.toString());
bufferedReader.close();
file.delete();
}
catch(FileNotFoundException e)
{
String msg="Can't find fpk output file.";
GUIHelper.error(msg);
GUIHelper.logger.error(msg);
return false;
}
catch(IOException e)
{
String msg="Can't read fpk output file.";
GUIHelper.error(msg);
GUIHelper.logger.error(msg);
return false;
}
try
{
PrinterHelper.printer.closeConnection();
}
catch(Exception e)
{
String msg="Can't close printer connection.";
GUIHelper.error(msg);
GUIHelper.logger.error(msg);
return false;
}
PrinterHelper.waitFor(PrinterHelper.GENERAL_PRINTER_READY, 5);
connected=establishPrimaryConnection(115200);
if(!connected)
{
GUIHelper.error(Messages.getString("TestEngine.100"));
return false;
}
return true;
}
static void scanModelNumber()
{
QualityScanner scanner=null;
try
{
scanner=new QualityScanner(CompositeManufacturing.textScanner.getText().toUpperCase(), 9600);
scanner.openConnection();
CompositeManufacturing.textModelNumber.setText("");
CompositeManufacturing.buttonScanModelNumber.setEnabled(false);
String scannedModelNumber=scanner.waitForBarcode();
if(scannedModelNumber!=null)
{
CompositeManufacturing.textModelNumber.setText(scannedModelNumber);
}
}
catch(Exception e)
{
GUIHelper.error(Messages.getString("TestEngine.49"));
GUIHelper.logger.error(e, e);
}
finally
{
CompositeManufacturing.buttonScanModelNumber.setEnabled(true);
try
{
scanner.closeConnection();
}
catch(Exception e)
{
GUIHelper.logger.error(e, e);
GUIHelper.error(Messages.getString("TestEngine.50"));
}
}
}
}
```
## File: JAdmin/src/com/cognitive/admin/TGModelNumbers.java
```java
public class TGModelNumbers
{
private Hashtable<String, String>modelNumbers=null;
private Hashtable<String, String>modelFeatures=null;
private Hashtable<String, String>modelEmbeddedNumbers=null;
private Hashtable<String, String>modelUPCs=null;
public TGModelNumbers(boolean isTGModelNumber)
{
modelNumbers=new Hashtable<String, String>();
modelFeatures=new Hashtable<String, String>();
modelEmbeddedNumbers=new Hashtable<String, String>();
modelUPCs=new Hashtable<String, String>();
populateModelNumbers();
populateModelEmbeddedNumbers();
populateModelFeatures();
if(isTGModelNumber)
{
populateModelEAN13_tg();
}
else
{
populateModelEAN13_td();
}
}
private void populateModelNumbers()
{
modelNumbers.put("1600000", "CID2-1000");
modelNumbers.put("1600001", "CID2-1300");
modelNumbers.put("1600002", "CID2-1000");
modelNumbers.put("1600003", "CID2-1300");
modelNumbers.put("1600004", "CID2-1330");
modelNumbers.put("1600005", "CID2-1330");
modelNumbers.put("1600006", "CIT2-1000");
modelNumbers.put("1600007", "CIT2-1300");
modelNumbers.put("1600008", "CIT2-1000");
modelNumbers.put("1600010", "CIT2-1300");
modelNumbers.put("1600021", "CIT2-1330");
modelNumbers.put("1600023", "CIT2-1330");
modelNumbers.put("1600012", "CID4-1000");
modelNumbers.put("1600013", "CID4-1300");
modelNumbers.put("1600014", "CID4-1000");
modelNumbers.put("1600015", "CID4-1300");
modelNumbers.put("1600016", "CID4-1330");
modelNumbers.put("1600017", "CID4-1330");
modelNumbers.put("1600018", "CIT4-1000");
modelNumbers.put("1600019", "CIT4-1300");
modelNumbers.put("1600020", "CIT4-1000");
modelNumbers.put("1600022", "CIT4-1300");
modelNumbers.put("1600126", "CIT4-1330");
modelNumbers.put("1600128", "CIT4-1330");
modelNumbers.put("1600024", "CXD2-1000");
modelNumbers.put("1600025", "CXD2-1300");
modelNumbers.put("1600026", "CXD2-1000");
modelNumbers.put("1600027", "CXD2-1300");
modelNumbers.put("1600028", "CXD2-1330");
modelNumbers.put("1600029", "CXD2-1330");
modelNumbers.put("1600030", "CXT2-1000");
modelNumbers.put("1600031", "CXT2-1300");
modelNumbers.put("1600032", "CXT2-1000");
modelNumbers.put("1600034", "CXT2-1300");
modelNumbers.put("1600033", "CXT2-1330");
modelNumbers.put("1600035", "CXT2-1330");
modelNumbers.put("1600154", "CXT2-1000");
modelNumbers.put("1600155", "CXT2-1300");
modelNumbers.put("1600156", "CXT2-1330");
modelNumbers.put("1600036", "CXD4-1000");
modelNumbers.put("1600037", "CXD4-1300");
modelNumbers.put("1600038", "CXD4-1000");
modelNumbers.put("1600039", "CXD4-1300");
modelNumbers.put("1600040", "CXD4-1330");
modelNumbers.put("1600041", "CXD4-1330");
modelNumbers.put("1600042", "CXT4-1000");
modelNumbers.put("1600043", "CXT4-1300");
modelNumbers.put("1600044", "CXT4-1000");
modelNumbers.put("1600046", "CXT4-1300");
modelNumbers.put("1600127", "CXT4-1330");
modelNumbers.put("1600129", "CXT4-1330");
modelNumbers.put("1600157", "CXT4-1000");
modelNumbers.put("1600158", "CXT4-1300");
modelNumbers.put("1600159", "CXT4-1330");
modelNumbers.put("1600048", "DBD24-2085-01U");
modelNumbers.put("1600049", "DBD24-2085-02U");
modelNumbers.put("1600050", "DBD24-2085-01L");
modelNumbers.put("1600130", "DBD24-2085-01L");
modelNumbers.put("1600051", "DBD24-2085-01S");
modelNumbers.put("1600052", "DBD24-2085-01P");
modelNumbers.put("1600053", "DBD24-2085-02L");
modelNumbers.put("1600131", "DBD24-2085-02L");
modelNumbers.put("1600054", "DBD24-2085-02S");
modelNumbers.put("1600055", "DBD24-2085-02P");
modelNumbers.put("1600056", "DBD24-2485-01L");
modelNumbers.put("1600057", "DBD24-2485-01S");
modelNumbers.put("1600058", "DBD24-2485-01P");
modelNumbers.put("1600059", "DBD24-2485-02L");
modelNumbers.put("1600060", "DBD24-2485-02S");
modelNumbers.put("1600061", "DBD24-2485-02P");
modelNumbers.put("1600062", "DBD24-2085-01E");
modelNumbers.put("1600063", "DBD24-2085-02E");
modelNumbers.put("1600064", "DBD24-2485-01E");
modelNumbers.put("1600065", "DBD24-2485-02E");
modelNumbers.put("1600138", "DBD24-3085-01L");
modelNumbers.put("1600139", "DBD24-3085-02L");
modelNumbers.put("1600140", "DBD24-3085-P1L");
modelNumbers.put("1600141", "DBD24-3085-P2L");
modelNumbers.put("1600066", "DBT24-2085-01U");
modelNumbers.put("1600067", "DBT24-2085-02U");
modelNumbers.put("1600068", "DBT24-2085-01L");
modelNumbers.put("1600069", "DBT24-2085-01S");
modelNumbers.put("1600070", "DBT24-2085-01P");
modelNumbers.put("1600071", "DBT24-2085-02L");
modelNumbers.put("1600072", "DBT24-2085-02S");
modelNumbers.put("1600073", "DBT24-2085-02P");
modelNumbers.put("1600074", "DBT24-2485-01L");
modelNumbers.put("1600075", "DBT24-2485-01S");
modelNumbers.put("1600076", "DBT24-2485-01P");
modelNumbers.put("1600077", "DBT24-2485-02L");
modelNumbers.put("1600078", "DBT24-2485-02S");
modelNumbers.put("1600079", "DBT24-2485-02P");
modelNumbers.put("1600080", "DBT24-2095-01L");
modelNumbers.put("1600081", "DBT24-2095-01S");
modelNumbers.put("1600082", "DBT24-2095-01P");
modelNumbers.put("1600083", "DBT24-2095-02L");
modelNumbers.put("1600084", "DBT24-2095-02S");
modelNumbers.put("1600085", "DBT24-2095-02P");
modelNumbers.put("1600086", "DBT24-2085-01E");
modelNumbers.put("1600087", "DBT24-2085-02E");
modelNumbers.put("1600088", "DBT24-2485-01E");
modelNumbers.put("1600089", "DBT24-2485-02E");
modelNumbers.put("1600142", "DBT24-3085-01L");
modelNumbers.put("1600143", "DBT24-3085-02L");
modelNumbers.put("1600144", "DBT24-3085-P1L");
modelNumbers.put("1600145", "DBT24-3085-P2L");
modelNumbers.put("1600090", "DBD42-2085-01U");
modelNumbers.put("1600091", "DBD42-2085-02U");
modelNumbers.put("1600092", "DBD42-2085-01L");
modelNumbers.put("1600132", "DBD42-2085-01L");
modelNumbers.put("1600093", "DBD42-2085-01S");
modelNumbers.put("1600094", "DBD42-2085-01P");
modelNumbers.put("1600095", "DBD42-2085-02L");
modelNumbers.put("1600133", "DBD42-2085-02L");
modelNumbers.put("1600096", "DBD42-2085-02S");
modelNumbers.put("1600097", "DBD42-2085-02P");
modelNumbers.put("1600098", "DBD42-2485-01L");
modelNumbers.put("1600134", "DBD42-2485-01L");
modelNumbers.put("1600099", "DBD42-2485-01S");
modelNumbers.put("1600100", "DBD42-2485-01P");
modelNumbers.put("1600101", "DBD42-2485-02L");
modelNumbers.put("1600135", "DBD42-2485-02L");
modelNumbers.put("1600102", "DBD42-2485-02S");
modelNumbers.put("1600103", "DBD42-2485-02P");
modelNumbers.put("1600104", "DBD42-2085-01E");
modelNumbers.put("1600105", "DBD42-2085-02E");
modelNumbers.put("1600106", "DBD42-2485-01E");
modelNumbers.put("1600107", "DBD42-2485-02E");
modelNumbers.put("1600146", "DBD42-3085-01L");
modelNumbers.put("1600147", "DBD42-3085-02L");
modelNumbers.put("1600148", "DBD42-3085-P1L");
modelNumbers.put("1600149", "DBD42-3085-P2L");
modelNumbers.put("1600108", "DBT42-2085-01U");
modelNumbers.put("1600109", "DBT42-2085-02U");
modelNumbers.put("1600110", "DBT42-2085-01L");
modelNumbers.put("1600136", "DBT42-2085-01L");
modelNumbers.put("1600111", "DBT42-2085-01S");
modelNumbers.put("1600112", "DBT42-2085-01P");
modelNumbers.put("1600113", "DBT42-2085-02L");
modelNumbers.put("1600137", "DBT42-2085-02L");
modelNumbers.put("1600114", "DBT42-2085-02S");
modelNumbers.put("1600115", "DBT42-2085-02P");
modelNumbers.put("1600116", "DBT42-2485-01L");
modelNumbers.put("1600117", "DBT42-2485-01S");
modelNumbers.put("1600118", "DBT42-2485-01P");
modelNumbers.put("1600119", "DBT42-2485-02L");
modelNumbers.put("1600120", "DBT42-2485-02S");
modelNumbers.put("1600121", "DBT42-2485-02P");
modelNumbers.put("1600122", "DBT42-2085-01E");
modelNumbers.put("1600123", "DBT42-2085-02E");
modelNumbers.put("1600124", "DBT42-2485-01E");
modelNumbers.put("1600125", "DBT42-2485-02E");
modelNumbers.put("1600150", "DBT42-3085-01L");
modelNumbers.put("1600151", "DBT42-3085-02L");
modelNumbers.put("1600152", "DBT42-3085-P1L");
modelNumbers.put("1600153", "DBT42-3085-P2L");
}
private void populateModelEAN13_tg()
{
modelUPCs.put("1600000", "0746099411005");
modelUPCs.put("1600001", "0746099411012");
modelUPCs.put("1600002", "0746099411089");
modelUPCs.put("1600003", "0746099411036");
modelUPCs.put("1600004", "0746099411043");
modelUPCs.put("1600005", "0746099411050");
modelUPCs.put("1600006", "0746099410008");
modelUPCs.put("1600007", "0746099410015");
modelUPCs.put("1600008", "0746099410022");
modelUPCs.put("1600010", "0746099410039");
modelUPCs.put("1600021", "0746099411067");
modelUPCs.put("1600023", "0746099411074");
modelUPCs.put("1600012", "0746099411081");
modelUPCs.put("1600013", "0746099411098");
modelUPCs.put("1600014", "0746099411104");
modelUPCs.put("1600015", "0746099411111");
modelUPCs.put("1600016", "0746099411128");
modelUPCs.put("1600017", "0746099411135");
modelUPCs.put("1600018", "0746099410046");
modelUPCs.put("1600019", "0746099410053");
modelUPCs.put("1600020", "0746099410060");
modelUPCs.put("1600022", "0746099410077");
modelUPCs.put("1600126", "0746099410572");
modelUPCs.put("1600128", "0746099410961");
modelUPCs.put("1600024", "0746099411142");
modelUPCs.put("1600025", "0746099411159");
modelUPCs.put("1600026", "0746099411166");
modelUPCs.put("1600027", "0746099411173");
modelUPCs.put("1600028", "0746099411180");
modelUPCs.put("1600029", "0746099411197");
modelUPCs.put("1600030", "0746099410084");
modelUPCs.put("1600031", "0746099410091");
modelUPCs.put("1600032", "0746099410107");
modelUPCs.put("1600034", "0746099410114");
modelUPCs.put("1600033", "0746099411203");
modelUPCs.put("1600035", "0746099411210");
modelUPCs.put("1600036", "0746099411227");
modelUPCs.put("1600037", "0746099411234");
modelUPCs.put("1600038", "0746099411241");
modelUPCs.put("1600039", "0746099411258");
modelUPCs.put("1600040", "0746099411265");
modelUPCs.put("1600041", "0746099411272");
modelUPCs.put("1600042", "0746099410121");
modelUPCs.put("1600043", "0746099410138");
modelUPCs.put("1600044", "0746099410145");
modelUPCs.put("1600046", "0746099410152");
modelUPCs.put("1600127", "0746099410978");
modelUPCs.put("1600129", "0746099410589");
modelUPCs.put("1600048", "0746099411289");
modelUPCs.put("1600049", "0746099411296");
modelUPCs.put("1600050", "0746099410169");
modelUPCs.put("1600130", "0746099411302");
modelUPCs.put("1600051", "0746099082496");
modelUPCs.put("1600052", "0746099082502");
modelUPCs.put("1600053", "0746099410176");
modelUPCs.put("1600131", "0746099411319");
modelUPCs.put("1600054", "0746099411326");
modelUPCs.put("1600055", "0746099411333");
modelUPCs.put("1600056", "0746099411340");
modelUPCs.put("1600057", "0746099411357");
modelUPCs.put("1600058", "0746099411364");
modelUPCs.put("1600059", "0746099411371");
modelUPCs.put("1600060", "0746099411388");
modelUPCs.put("1600061", "0746099411395");
modelUPCs.put("1600062", "0746099411401");
modelUPCs.put("1600063", "0746099411418");
modelUPCs.put("1600064", "0746099411425");
modelUPCs.put("1600065", "0746099411432");
modelUPCs.put("1600138", "0746099411449");
modelUPCs.put("1600139", "0746099411456");
modelUPCs.put("1600140", "0746099411463");
modelUPCs.put("1600141", "0746099411470");
modelUPCs.put("1600066", "0746099411487");
modelUPCs.put("1600067", "0746099411494");
modelUPCs.put("1600068", "0746099411500");
modelUPCs.put("1600069", "0746099411517");
modelUPCs.put("1600070", "0746099411524");
modelUPCs.put("1600071", "0746099411531");
modelUPCs.put("1600072", "0746099411548");
modelUPCs.put("1600073", "0746099411555");
modelUPCs.put("1600074", "0746099411562");
modelUPCs.put("1600075", "0746099411579");
modelUPCs.put("1600076", "0746099411586");
modelUPCs.put("1600077", "0746099411593");
modelUPCs.put("1600078", "0746099411609");
modelUPCs.put("1600079", "0746099411616");
modelUPCs.put("1600080", "0746099411623");
modelUPCs.put("1600081", "0746099411630");
modelUPCs.put("1600082", "0746099411647");
modelUPCs.put("1600083", "0746099411654");
modelUPCs.put("1600084", "0746099411661");
modelUPCs.put("1600085", "0746099411678");
modelUPCs.put("1600086", "0746099411685");
modelUPCs.put("1600087", "0746099411692");
modelUPCs.put("1600088", "0746099411708");
modelUPCs.put("1600089", "0746099411715");
modelUPCs.put("1600142", "0746099411722");
modelUPCs.put("1600143", "0746099411739");
modelUPCs.put("1600144", "0746099411746");
modelUPCs.put("1600145", "0746099411753");
modelUPCs.put("1600090", "0746099411760");
modelUPCs.put("1600091", "0746099411777");
modelUPCs.put("1600092", "0746099410183");
modelUPCs.put("1600132", "0746099122222");
modelUPCs.put("1600093", "0746099082519");
modelUPCs.put("1600094", "0746099123038");
modelUPCs.put("1600095", "0746099410190");
modelUPCs.put("1600133", "0746099411784");
modelUPCs.put("1600096", "0746099411791");
modelUPCs.put("1600097", "0746099411807");
modelUPCs.put("1600098", "0746099410206");
modelUPCs.put("1600134", "0746099122239");
modelUPCs.put("1600099", "0746099123007");
modelUPCs.put("1600100", "0746099411814");
modelUPCs.put("1600101", "0746099410213");
modelUPCs.put("1600135", "0746099411821");
modelUPCs.put("1600102", "0746099411838");
modelUPCs.put("1600103", "0746099411845");
modelUPCs.put("1600104", "0746099411852");
modelUPCs.put("1600105", "0746099411869");
modelUPCs.put("1600106", "0746099411876");
modelUPCs.put("1600107", "0746099411883");
modelUPCs.put("1600146", "0746099411890");
modelUPCs.put("1600147", "0746099411906");
modelUPCs.put("1600148", "0746099411913");
modelUPCs.put("1600149", "0746099411920");
modelUPCs.put("1600108", "0746099411937");
modelUPCs.put("1600109", "0746099411944");
modelUPCs.put("1600110", "0746099410220");
modelUPCs.put("1600136", "0746099122246");
modelUPCs.put("1600111", "0746099122260");
modelUPCs.put("1600112", "0746099122277");
modelUPCs.put("1600113", "0746099410237");
modelUPCs.put("1600137", "0746099411951");
modelUPCs.put("1600114", "0746099411968");
modelUPCs.put("1600115", "0746099411975");
modelUPCs.put("1600116", "0746099411982");
modelUPCs.put("1600117", "0746099411999");
modelUPCs.put("1600118", "0746099412002");
modelUPCs.put("1600119", "0746099412019");
modelUPCs.put("1600120", "0746099410992");
modelUPCs.put("1600121", "0746099412026");
modelUPCs.put("1600122", "0746099412033");
modelUPCs.put("1600123", "0746099412040");
modelUPCs.put("1600124", "0746099412057");
modelUPCs.put("1600125", "0746099412064");
modelUPCs.put("1600150", "0746099412071");
modelUPCs.put("1600151", "0746099412088");
modelUPCs.put("1600152", "0746099412095");
modelUPCs.put("1600153", "0746099412101");
}
private void populateModelEAN13_td()
{
modelUPCs.put("1600000", "0746099411005");
modelUPCs.put("1600001", "0746099411012");
modelUPCs.put("1600002", "4010477160523");
modelUPCs.put("1600003", "4010477160530");
modelUPCs.put("1600004", "0746099411043");
modelUPCs.put("1600005", "4010477160547");
modelUPCs.put("1600006", "0746099410008");
modelUPCs.put("1600007", "0746099410015");
modelUPCs.put("1600008", "4010477160554");
modelUPCs.put("1600010", "4010477160561");
modelUPCs.put("1600021", "0746099411067");
modelUPCs.put("1600023", "4010477160578");
modelUPCs.put("1600012", "0746099411081");
modelUPCs.put("1600013", "0746099411098");
modelUPCs.put("1600014", "4010477160585");
modelUPCs.put("1600015", "4010477160592");
modelUPCs.put("1600016", "0746099411128");
modelUPCs.put("1600017", "4010477160608");
modelUPCs.put("1600018", "0746099410046");
modelUPCs.put("1600019", "0746099410053");
modelUPCs.put("1600020", "4010477160615");
modelUPCs.put("1600022", "4010477160622");
modelUPCs.put("1600126", "0746099410572");
modelUPCs.put("1600128", "4010477160639");
modelUPCs.put("1600024", "0746099411142");
modelUPCs.put("1600025", "0746099411159");
modelUPCs.put("1600026", "4010477160646");
modelUPCs.put("1600027", "4010477160653");
modelUPCs.put("1600028", "0746099411180");
modelUPCs.put("1600029", "4010477160660");
modelUPCs.put("1600030", "0746099410084");
modelUPCs.put("1600031", "0746099410091");
modelUPCs.put("1600032", "4010477160677");
modelUPCs.put("1600034", "4010477160684");
modelUPCs.put("1600033", "0746099411203");
modelUPCs.put("1600035", "4010477160691");
modelUPCs.put("1600154", "4010477160707");
modelUPCs.put("1600155", "4010477160714");
modelUPCs.put("1600156", "4010477160721");
modelUPCs.put("1600036", "0746099411227");
modelUPCs.put("1600037", "0746099411234");
modelUPCs.put("1600038", "4010477160738");
modelUPCs.put("1600039", "4010477160745");
modelUPCs.put("1600040", "0746099411265");
modelUPCs.put("1600041", "4010477160752");
modelUPCs.put("1600042", "0746099410121");
modelUPCs.put("1600043", "0746099410138");
modelUPCs.put("1600044", "4010477160769");
modelUPCs.put("1600046", "4010477160776");
modelUPCs.put("1600127", "0746099410978");
modelUPCs.put("1600129", "4010477160783");
modelUPCs.put("1600157", "4010477160790");
modelUPCs.put("1600158", "4010477160806");
modelUPCs.put("1600159", "4010477160813");
modelUPCs.put("1600048", "0746099411289");
modelUPCs.put("1600049", "4010477160820");
modelUPCs.put("1600050", "0746099410169");
modelUPCs.put("1600130", "0746099411302");
modelUPCs.put("1600051", "0746099082496");
modelUPCs.put("1600052", "0746099082502");
modelUPCs.put("1600053", "4010477160837");
modelUPCs.put("1600131", "4010477160844");
modelUPCs.put("1600054", "4010477160851");
modelUPCs.put("1600055", "4010477160868");
modelUPCs.put("1600056", "0746099411340");
modelUPCs.put("1600057", "0746099411357");
modelUPCs.put("1600058", "0746099411364");
modelUPCs.put("1600059", "4010477160875");
modelUPCs.put("1600060", "4010477160882");
modelUPCs.put("1600061", "4010477160899");
modelUPCs.put("1600062", "0746099411401");
modelUPCs.put("1600063", "4010477160905");
modelUPCs.put("1600064", "0746099411425");
modelUPCs.put("1600065", "4010477160912");
modelUPCs.put("1600138", "0746099411449");
modelUPCs.put("1600139", "4010477160929");
modelUPCs.put("1600140", "0746099411463");
modelUPCs.put("1600141", "4010477160936");
modelUPCs.put("1600066", "0746099411487");
modelUPCs.put("1600067", "4010477160943");
modelUPCs.put("1600068", "0746099411500");
modelUPCs.put("1600069", "0746099411517");
modelUPCs.put("1600070", "0746099411524");
modelUPCs.put("1600071", "4010477160950");
modelUPCs.put("1600072", "4010477160967");
modelUPCs.put("1600073", "4010477160974");
modelUPCs.put("1600074", "0746099411562");
modelUPCs.put("1600075", "0746099411579");
modelUPCs.put("1600076", "0746099411586");
modelUPCs.put("1600077", "4010477160981");
modelUPCs.put("1600078", "4010477160998");
modelUPCs.put("1600079", "4010477161001");
modelUPCs.put("1600080", "0746099411623");
modelUPCs.put("1600081", "0746099411630");
modelUPCs.put("1600082", "0746099411647");
modelUPCs.put("1600083", "4010477161018");
modelUPCs.put("1600084", "4010477161025");
modelUPCs.put("1600085", "4010477161032");
modelUPCs.put("1600086", "0746099411685");
modelUPCs.put("1600087", "4010477161049");
modelUPCs.put("1600088", "0746099411708");
modelUPCs.put("1600089", "4010477161056");
modelUPCs.put("1600142", "0746099411722");
modelUPCs.put("1600143", "4010477161063");
modelUPCs.put("1600144", "0746099411746");
modelUPCs.put("1600145", "4010477161070");
modelUPCs.put("1600090", "0746099411760");
modelUPCs.put("1600091", "4010477161087");
modelUPCs.put("1600092", "0746099410183");
modelUPCs.put("1600132", "0746099122222");
modelUPCs.put("1600093", "0746099082519");
modelUPCs.put("1600094", "0746099123038");
modelUPCs.put("1600095", "4010477161094");
modelUPCs.put("1600133", "4010477161100");
modelUPCs.put("1600096", "4010477161117");
modelUPCs.put("1600097", "4010477161124");
modelUPCs.put("1600098", "0746099410206");
modelUPCs.put("1600134", "0746099122239");
modelUPCs.put("1600099", "0746099123007");
modelUPCs.put("1600100", "0746099411814");
modelUPCs.put("1600101", "4010477161131");
modelUPCs.put("1600135", "4010477161148");
modelUPCs.put("1600102", "4010477161155");
modelUPCs.put("1600103", "4010477161162");
modelUPCs.put("1600104", "0746099411852");
modelUPCs.put("1600105", "4010477161179");
modelUPCs.put("1600106", "0746099411876");
modelUPCs.put("1600107", "4010477161186");
modelUPCs.put("1600146", "0746099411890");
modelUPCs.put("1600147", "4010477161193");
modelUPCs.put("1600148", "0746099411913");
modelUPCs.put("1600149", "4010477161209");
modelUPCs.put("1600108", "0746099411937");
modelUPCs.put("1600109", "4010477161216");
modelUPCs.put("1600110", "0746099410220");
modelUPCs.put("1600136", "0746099122246");
modelUPCs.put("1600111", "0746099122260");
modelUPCs.put("1600112", "0746099122277");
modelUPCs.put("1600113", "4010477161223");
modelUPCs.put("1600137", "4010477161230");
modelUPCs.put("1600114", "4010477161247");
modelUPCs.put("1600115", "4010477161254");
modelUPCs.put("1600116", "0746099411982");
modelUPCs.put("1600117", "0746099411999");
modelUPCs.put("1600118", "0746099412002");
modelUPCs.put("1600119", "4010477161261");
modelUPCs.put("1600120", "4010477161278");
modelUPCs.put("1600121", "4010477161285");
modelUPCs.put("1600122", "0746099412033");
modelUPCs.put("1600123", "4010477161292");
modelUPCs.put("1600124", "0746099412057");
modelUPCs.put("1600125", "4010477161308");
modelUPCs.put("1600150", "0746099412071");
modelUPCs.put("1600151", "4010477161315");
modelUPCs.put("1600152", "0746099412095");
modelUPCs.put("1600153", "4010477161322");
}
private void populateModelEmbeddedNumbers()
{
modelEmbeddedNumbers.put("1600000", "7006 DT2");
modelEmbeddedNumbers.put("1600001", "7006 DT2-300");
modelEmbeddedNumbers.put("1600002", "7006 DT2");
modelEmbeddedNumbers.put("1600003", "7006 DT2-300");
modelEmbeddedNumbers.put("1600004", "7006 DT2-PCL");
modelEmbeddedNumbers.put("1600005", "7006 DT2-PCL");
modelEmbeddedNumbers.put("1600006", "7006 TT2");
modelEmbeddedNumbers.put("1600007", "7006 TT2-300");
modelEmbeddedNumbers.put("1600008", "7006 TT2");
modelEmbeddedNumbers.put("1600010", "7006 TT2-300");
modelEmbeddedNumbers.put("1600021", "7006 TT2-PCL");
modelEmbeddedNumbers.put("1600023", "7006 TT2-PCL");
modelEmbeddedNumbers.put("1600012", "7006 DT4");
modelEmbeddedNumbers.put("1600013", "7006 DT4-300");
modelEmbeddedNumbers.put("1600014", "7006 DT4");
modelEmbeddedNumbers.put("1600015", "7006 DT4-300");
modelEmbeddedNumbers.put("1600016", "7006 DT4-PCL");
modelEmbeddedNumbers.put("1600017", "7006 DT4-PCL");
modelEmbeddedNumbers.put("1600018", "7006 TT4");
modelEmbeddedNumbers.put("1600019", "7006 TT4-300");
modelEmbeddedNumbers.put("1600020", "7006 TT4");
modelEmbeddedNumbers.put("1600022", "7006 TT4-300");
modelEmbeddedNumbers.put("1600126", "7006 TT4-PCL");
modelEmbeddedNumbers.put("1600128", "7006 TT4-PCL");
modelEmbeddedNumbers.put("1600024", "7008 DT2");
modelEmbeddedNumbers.put("1600025", "7008 DT2-300");
modelEmbeddedNumbers.put("1600026", "7008 DT2");
modelEmbeddedNumbers.put("1600027", "7008 DT2-300");
modelEmbeddedNumbers.put("1600028", "7008 DT2-PCL");
modelEmbeddedNumbers.put("1600029", "7008 DT2-PCL");
modelEmbeddedNumbers.put("1600030", "7008 TT2");
modelEmbeddedNumbers.put("1600031", "7008 TT2-300");
modelEmbeddedNumbers.put("1600032", "7008 TT2");
modelEmbeddedNumbers.put("1600034", "7008 TT2-300");
modelEmbeddedNumbers.put("1600033", "7008 TT2-PCL");
modelEmbeddedNumbers.put("1600035", "7008 TT2-PCL");
modelEmbeddedNumbers.put("1600154", "7008 TT2");
modelEmbeddedNumbers.put("1600155", "7008 TT2-300");
modelEmbeddedNumbers.put("1600156", "7008 TT2-PCL");
modelEmbeddedNumbers.put("1600036", "7008 DT4");
modelEmbeddedNumbers.put("1600037", "7008 DT4-300");
modelEmbeddedNumbers.put("1600038", "7008 DT4");
modelEmbeddedNumbers.put("1600039", "7008 DT4-300");
modelEmbeddedNumbers.put("1600040", "7008 DT4-PCL");
modelEmbeddedNumbers.put("1600041", "7008 DT4-PCL");
modelEmbeddedNumbers.put("1600042", "7008 TT4");
modelEmbeddedNumbers.put("1600043", "7008 TT4-300");
modelEmbeddedNumbers.put("1600044", "7008 TT4");
modelEmbeddedNumbers.put("1600046", "7008 TT4-300");
modelEmbeddedNumbers.put("1600127", "7008 TT4-PCL");
modelEmbeddedNumbers.put("1600129", "7008 TT4-PCL");
modelEmbeddedNumbers.put("1600157", "7008 TT4");
modelEmbeddedNumbers.put("1600158", "7008 TT4-300");
modelEmbeddedNumbers.put("1600159", "7008 TT4-PCL");
modelEmbeddedNumbers.put("1600048", "7005 DT2");
modelEmbeddedNumbers.put("1600049", "7005 DT2");
modelEmbeddedNumbers.put("1600050", "7005 DT2");
modelEmbeddedNumbers.put("1600130", "7005 DT2");
modelEmbeddedNumbers.put("1600051", "7005 DT2");
modelEmbeddedNumbers.put("1600052", "7005 DT2");
modelEmbeddedNumbers.put("1600053", "7005 DT2");
modelEmbeddedNumbers.put("1600131", "7005 DT2");
modelEmbeddedNumbers.put("1600054", "7005 DT2");
modelEmbeddedNumbers.put("1600055", "7005 DT2");
modelEmbeddedNumbers.put("1600056", "7005 DT2");
modelEmbeddedNumbers.put("1600057", "7005 DT2");
modelEmbeddedNumbers.put("1600058", "7005 DT2");
modelEmbeddedNumbers.put("1600059", "7005 DT2");
modelEmbeddedNumbers.put("1600060", "7005 DT2");
modelEmbeddedNumbers.put("1600061", "7005 DT2");
modelEmbeddedNumbers.put("1600062", "7005 DT2");
modelEmbeddedNumbers.put("1600063", "7005 DT2");
modelEmbeddedNumbers.put("1600064", "7005 DT2");
modelEmbeddedNumbers.put("1600065", "7005 DT2");
modelEmbeddedNumbers.put("1600138", "7005 DT2-300");
modelEmbeddedNumbers.put("1600139", "7005 DT2-300");
modelEmbeddedNumbers.put("1600140", "7005 DT2-PCL");
modelEmbeddedNumbers.put("1600141", "7005 DT2-PCL");
modelEmbeddedNumbers.put("1600066", "7005 TT2");
modelEmbeddedNumbers.put("1600067", "7005 TT2");
modelEmbeddedNumbers.put("1600068", "7005 TT2");
modelEmbeddedNumbers.put("1600069", "7005 TT2");
modelEmbeddedNumbers.put("1600070", "7005 TT2");
modelEmbeddedNumbers.put("1600071", "7005 TT2");
modelEmbeddedNumbers.put("1600072", "7005 TT2");
modelEmbeddedNumbers.put("1600073", "7005 TT2");
modelEmbeddedNumbers.put("1600074", "7005 TT2");
modelEmbeddedNumbers.put("1600075", "7005 TT2");
modelEmbeddedNumbers.put("1600076", "7005 TT2");
modelEmbeddedNumbers.put("1600077", "7005 TT2");
modelEmbeddedNumbers.put("1600078", "7005 TT2");
modelEmbeddedNumbers.put("1600079", "7005 TT2");
modelEmbeddedNumbers.put("1600080", "7005 TT2");
modelEmbeddedNumbers.put("1600081", "7005 TT2");
modelEmbeddedNumbers.put("1600082", "7005 TT2");
modelEmbeddedNumbers.put("1600083", "7005 TT2");
modelEmbeddedNumbers.put("1600084", "7005 TT2");
modelEmbeddedNumbers.put("1600085", "7005 TT2");
modelEmbeddedNumbers.put("1600086", "7005 TT2");
modelEmbeddedNumbers.put("1600087", "7005 TT2");
modelEmbeddedNumbers.put("1600088", "7005 TT2");
modelEmbeddedNumbers.put("1600089", "7005 TT2");
modelEmbeddedNumbers.put("1600142", "7005 TT2-300");
modelEmbeddedNumbers.put("1600143", "7005 TT2-300");
modelEmbeddedNumbers.put("1600144", "7005 TT2-PCL");
modelEmbeddedNumbers.put("1600145", "7005 TT2-PCL");
modelEmbeddedNumbers.put("1600090", "7005 DT4");
modelEmbeddedNumbers.put("1600091", "7005 DT4");
modelEmbeddedNumbers.put("1600092", "7005 DT4");
modelEmbeddedNumbers.put("1600132", "7005 DT4");
modelEmbeddedNumbers.put("1600093", "7005 DT4");
modelEmbeddedNumbers.put("1600094", "7005 DT4");
modelEmbeddedNumbers.put("1600095", "7005 DT4");
modelEmbeddedNumbers.put("1600133", "7005 DT4");
modelEmbeddedNumbers.put("1600096", "7005 DT4");
modelEmbeddedNumbers.put("1600097", "7005 DT4");
modelEmbeddedNumbers.put("1600098", "7005 DT4");
modelEmbeddedNumbers.put("1600134", "7005 DT4");
modelEmbeddedNumbers.put("1600099", "7005 DT4");
modelEmbeddedNumbers.put("1600100", "7005 DT4");
modelEmbeddedNumbers.put("1600101", "7005 DT4");
modelEmbeddedNumbers.put("1600135", "7005 DT4");
modelEmbeddedNumbers.put("1600102", "7005 DT4");
modelEmbeddedNumbers.put("1600103", "7005 DT4");
modelEmbeddedNumbers.put("1600104", "7005 DT4");
modelEmbeddedNumbers.put("1600105", "7005 DT4");
modelEmbeddedNumbers.put("1600106", "7005 DT4");
modelEmbeddedNumbers.put("1600107", "7005 DT4");
modelEmbeddedNumbers.put("1600146", "7005 DT4-300");
modelEmbeddedNumbers.put("1600147", "7005 DT4-300");
modelEmbeddedNumbers.put("1600148", "7005 DT4-PCL");
modelEmbeddedNumbers.put("1600149", "7005 DT4-PCL");
modelEmbeddedNumbers.put("1600108", "7005 TT4");
modelEmbeddedNumbers.put("1600109", "7005 TT4");
modelEmbeddedNumbers.put("1600110", "7005 TT4");
modelEmbeddedNumbers.put("1600136", "7005 TT4");
modelEmbeddedNumbers.put("1600111", "7005 TT4");
modelEmbeddedNumbers.put("1600112", "7005 TT4");
modelEmbeddedNumbers.put("1600113", "7005 TT4");
modelEmbeddedNumbers.put("1600137", "7005 TT4");
modelEmbeddedNumbers.put("1600114", "7005 TT4");
modelEmbeddedNumbers.put("1600115", "7005 TT4");
modelEmbeddedNumbers.put("1600116", "7005 TT4");
modelEmbeddedNumbers.put("1600117", "7005 TT4");
modelEmbeddedNumbers.put("1600118", "7005 TT4");
modelEmbeddedNumbers.put("1600119", "7005 TT4");
modelEmbeddedNumbers.put("1600120", "7005 TT4");
modelEmbeddedNumbers.put("1600121", "7005 TT4");
modelEmbeddedNumbers.put("1600122", "7005 TT4");
modelEmbeddedNumbers.put("1600123", "7005 TT4");
modelEmbeddedNumbers.put("1600124", "7005 TT4");
modelEmbeddedNumbers.put("1600125", "7005 TT4");
modelEmbeddedNumbers.put("1600150", "7005 TT4-300");
modelEmbeddedNumbers.put("1600151", "7005 TT4-300");
modelEmbeddedNumbers.put("1600152", "7005 TT4-PCL");
modelEmbeddedNumbers.put("1600153", "7005 TT4-PCL");
}
private void populateModelFeatures()
{
modelFeatures.put("1600000", "7006, DT, 2.4 inch, 200dpi, 6ips, Multi I/O, 120V-US");
modelFeatures.put("1600001", "7006, DT, 2.4 inch, 300dpi, 6ips, Multi I/O, 120V-US");
modelFeatures.put("1600002", "7006, DT, 2.4 inch, 200dpi, 6ips, Multi I/O, 230V-EU/UK");
modelFeatures.put("1600003", "7006, DT, 2.4 inch, 300dpi, 6ips, Multi I/O, 230V-EU/UK");
modelFeatures.put("1600004", "7006, DT, 2.4 inch, 300dpi, 6ips, Multi I/O, PCL, 120V-US");
modelFeatures.put("1600005", "7006, DT, 2.4 inch, 300dpi, 6ips, Multi I/O, PCL, 230V-EU/UK");
modelFeatures.put("1600006", "7006, TT, 2.4 inch, 200dpi, 6ips, Multi I/O, 120V-US");
modelFeatures.put("1600007", "7006, TT, 2.4 inch, 300dpi, 6ips, Multi I/O, 120V-US");
modelFeatures.put("1600008", "7006, TT, 2.4 inch, 200dpi, 6ips, Multi I/O, 230V-EU/UK");
modelFeatures.put("1600010", "7006, TT, 2.4 inch, 300dpi, 6ips, Multi I/O, 230V-EU/UK");
modelFeatures.put("1600021", "7006, TT, 2.4 inch, 300dpi, 6ips, Multi I/O, PCL, 120V-US");
modelFeatures.put("1600023", "7006, TT, 2.4 inch, 300dpi, 6ips, Multi I/O, PCL, 230V-EU/UK");
modelFeatures.put("1600012", "7006, DT, 4.3 inch, 200dpi, 6ips, Multi I/O, 120V-US");
modelFeatures.put("1600013", "7006, DT, 4.3 inch, 300dpi, 6ips, Multi I/O, 120V-US");
modelFeatures.put("1600014", "7006, DT, 4.3 inch, 200dpi, 6ips, Multi I/O, 230V-EU/UK");
modelFeatures.put("1600015", "7006, DT, 4.3 inch, 300dpi, 6ips, Multi I/O, 230V-EU/UK");
modelFeatures.put("1600016", "7006, DT, 4.3 inch, 300dpi, 6ips, Multi I/O, PCL, 120V-US");
modelFeatures.put("1600017", "7006, DT, 4.3 inch, 300dpi, 6ips, Multi I/O, PCL, 230V-EU/UK");
modelFeatures.put("1600018", "7006, TT, 4.3 inch, 200dpi, 6ips, Multi I/O, 120V-US");
modelFeatures.put("1600019", "7006, TT, 4.3 inch, 300dpi, 6ips, Multi I/O, 120V-US");
modelFeatures.put("1600020", "7006, TT, 4.3 inch, 200dpi, 6ips, Multi I/O, 230V-EU/UK");
modelFeatures.put("1600022", "7006, TT, 4.3 inch, 300dpi, 6ips, Multi I/O, 230V-EU/UK");
modelFeatures.put("1600126", "7006, TT, 4.3 inch, 300dpi, 6ips, Multi I/O, PCL, 120V-US");
modelFeatures.put("1600128", "7006, TT, 4.3 inch, 300dpi, 6ips, Multi I/O, PCL, 230V-EU/UK");
modelFeatures.put("1600024", "7008, DT, 2.4 inch, 200dpi, 8ips, Multi I/O, 120V-US");
modelFeatures.put("1600025", "7008, DT, 2.4 inch, 300dpi, 8ips, Multi I/O, 120V-US");
modelFeatures.put("1600026", "7008, DT, 2.4 inch, 200dpi, 8ips, Multi I/O, 230V-EU/UK");
modelFeatures.put("1600027", "7008, DT, 2.4 inch, 300dpi, 8ips, Multi I/O, 230V-EU/UK");
modelFeatures.put("1600028", "7008, DT, 2.4 inch, 300dpi, 8ips, Multi I/O, PCL, 120V-US");
modelFeatures.put("1600029", "7008, DT, 2.4 inch, 300dpi, 8ips, Multi I/O, PCL, 230V-EU/UK");
modelFeatures.put("1600030", "7008, TT, 2.4 inch, 200dpi, 8ips, Multi I/O, 120V-US");
modelFeatures.put("1600031", "7008, TT, 2.4 inch, 300dpi, 8ips, Multi I/O, 120V-US");
modelFeatures.put("1600032", "7008, TT, 2.4 inch, 200dpi, 8ips, Multi I/O, 230V-EU/UK");
modelFeatures.put("1600034", "7008, TT, 2.4 inch, 300dpi, 8ips, Multi I/O, 230V-EU/UK");
modelFeatures.put("1600033", "7008, TT, 2.4 inch, 300dpi, 8ips, Multi I/O, PCL, 120V-US");
modelFeatures.put("1600035", "7008, TT, 2.4 inch, 300dpi, 8ips, Multi I/O, PCL, 230V-EU/UK");
modelFeatures.put("1600154", "7008, TT, 2.4 inch, 200dpi, 8ips, Multi I/O, EU-LCD, 230V-EU/UK");
modelFeatures.put("1600155", "7008, TT, 2.4 inch, 300dpi, 8ips, Multi I/O, EU-LCD, 230V-EU/UK");
modelFeatures.put("1600156", "7008, TT, 2.4 inch, 300dpi, 8ips, Multi I/O, PCL, EU-LCD, 230V-EU/UK");
modelFeatures.put("1600036", "7008, DT, 4.3 inch, 200dpi, 8ips, Multi I/O, 120V-US");
modelFeatures.put("1600037", "7008, DT, 4.3 inch, 300dpi, 8ips, Multi I/O, 120V-US");
modelFeatures.put("1600038", "7008, DT, 4.3 inch, 200dpi, 8ips, Multi I/O, 230V-EU/UK");
modelFeatures.put("1600039", "7008, DT, 4.3 inch, 300dpi, 8ips, Multi I/O, 230V-EU/UK");
modelFeatures.put("1600040", "7008, DT, 4.3 inch, 300dpi, 8ips, Multi I/O, PCL, 120V-US");
modelFeatures.put("1600041", "7008, DT, 4.3 inch, 300dpi, 8ips, Multi I/O, PCL, 230V-EU/UK");
modelFeatures.put("1600042", "7008, TT, 4.3 inch, 200dpi, 8ips, Multi I/O, 120V-US");
modelFeatures.put("1600043", "7008, TT, 4.3 inch, 300dpi, 8ips, Multi I/O, 120V-US");
modelFeatures.put("1600044", "7008, TT, 4.3 inch, 200dpi, 8ips, Multi I/O, 230V-EU/UK");
modelFeatures.put("1600046", "7008, TT, 4.3 inch, 300dpi, 8ips, Multi I/O, 230V-EU/UK");
modelFeatures.put("1600127", "7008, TT, 4.3 inch, 300dpi, 8ips, Multi I/O, PCL, 120V-US");
modelFeatures.put("1600129", "7008, TT, 4.3 inch, 300dpi, 8ips, Multi I/O, PCL, 230V-EU/UK");
modelFeatures.put("1600157", "7008, TT, 4.3 inch, 200dpi, 8ips, Multi I/O, EU-LCD, 230V-EU/UK");
modelFeatures.put("1600158", "7008, TT, 4.3 inch, 300dpi, 8ips, Multi I/O, EU-LCD, 230V-EU/UK");
modelFeatures.put("1600159", "7008, TT, 4.3 inch, 300dpi, 8ips, Multi I/O, PCL, EU-LCD, 230V-EU/UK");
modelFeatures.put("1600048", "7005, DT, 2.4 inch, 200dpi, 5ips, USB, 120V-US");
modelFeatures.put("1600049", "7005, DT, 2.4 inch, 200dpi, 5ips, USB, 230V-EU/UK");
modelFeatures.put("1600050", "7005, DT, 2.4 inch, 200dpi, 5ips, Standard, 120V-US");
modelFeatures.put("1600130", "7005, DT, 2.4 inch, 200dpi, 5ips, USB, 120V-US");
modelFeatures.put("1600051", "7005, DT, 2.4 inch, 200dpi, 5ips, USB/Serial, 120V-US");
modelFeatures.put("1600052", "7005, DT, 2.4 inch, 200dpi, 5ips, USB/Parallel, 120V-US");
modelFeatures.put("1600053", "7005, DT, 2.4 inch, 200dpi, 5ips, Standard, 230V-EU/UK");
modelFeatures.put("1600131", "7005, DT, 2.4 inch, 200dpi, 5ips, USB, 230V-EU/UK");
modelFeatures.put("1600054", "7005, DT, 2.4 inch, 200dpi, 5ips, USB/Serial, 230V-EU/UK");
modelFeatures.put("1600055", "7005, DT, 2.4 inch, 200dpi, 5ips, USB/Parallel, 230V-EU/UK");
modelFeatures.put("1600056", "7005, DT, 2.4 inch, 200dpi, 5ips, Standard, Peeler, 120V-US");
modelFeatures.put("1600057", "7005, DT, 2.4 inch, 200dpi, 5ips, USB/Serial, Peeler, 120V-US");
modelFeatures.put("1600058", "7005, DT, 2.4 inch, 200dpi, 5ips, USB/Parallel, Peeler, 120V-US");
modelFeatures.put("1600059", "7005, DT, 2.4 inch, 200dpi, 5ips, Standard, Peeler, 230V-EU/UK");
modelFeatures.put("1600060", "7005, DT, 2.4 inch, 200dpi, 5ips, USB/Serial, Peeler, 230V-EU/UK");
modelFeatures.put("1600061", "7005, DT, 2.4 inch, 200dpi, 5ips, USB/Parallel, Peeler, 230V-EU/UK");
modelFeatures.put("1600062", "7005, DT, 2.4 inch, 200dpi, 5ips, USB/Ethernet, 120V-US");
modelFeatures.put("1600063", "7005, DT, 2.4 inch, 200dpi, 5ips, USB/Ethernet, 230V-EU/UK");
modelFeatures.put("1600064", "7005, DT, 2.4 inch, 200dpi, 5ips, USB/Ethernet, Peeler, 120V-US");
modelFeatures.put("1600065", "7005, DT, 2.4 inch, 200dpi, 5ips, USB/Ethernet, Peeler, 230V-EU/UK");
modelFeatures.put("1600138", "7005, DT, 2.4 inch, 300dpi, 5ips, Standard, 120V-US");
modelFeatures.put("1600139", "7005, DT, 2.4 inch, 300dpi, 5ips, Standard, 230V-EU/UK");
modelFeatures.put("1600140", "7005, DT, 2.4 inch, 300dpi, 5ips, Standard, PCL, 120V-US");
modelFeatures.put("1600141", "7005, DT, 2.4 inch, 300dpi, 5ips, Standard, PCL, 230V-EU/UK");
modelFeatures.put("1600066", "7005, TT, 2.4 inch, 200dpi, 5ips, USB, 120V-US");
modelFeatures.put("1600067", "7005, TT, 2.4 inch, 200dpi, 5ips, USB, 230V-EU/UK");
modelFeatures.put("1600068", "7005, TT, 2.4 inch, 200dpi, 5ips, Standard, 120V-US");
modelFeatures.put("1600069", "7005, TT, 2.4 inch, 200dpi, 5ips, USB/Serial, 120V-US");
modelFeatures.put("1600070", "7005, TT, 2.4 inch, 200dpi, 5ips, USB/Parallel, 120V-US");
modelFeatures.put("1600071", "7005, TT, 2.4 inch, 200dpi, 5ips, Standard, 230V-EU/UK");
modelFeatures.put("1600072", "7005, TT, 2.4 inch, 200dpi, 5ips, USB/Serial, 230V-EU/UK");
modelFeatures.put("1600073", "7005, TT, 2.4 inch, 200dpi, 5ips, USB/Parallel, 230V-EU/UK");
modelFeatures.put("1600074", "7005, TT, 2.4 inch, 200dpi, 5ips, Standard, Peeler, 120V-US");
modelFeatures.put("1600075", "7005, TT, 2.4 inch, 200dpi, 5ips, USB/Serial, Peeler, 120V-US");
modelFeatures.put("1600076", "7005, TT, 2.4 inch, 200dpi, 5ips, USB/Parallel, Peeler, 120V-US");
modelFeatures.put("1600077", "7005, TT, 2.4 inch, 200dpi, 5ips, Standard, Peeler, 230V-EU/UK");
modelFeatures.put("1600078", "7005, TT, 2.4 inch, 200dpi, 5ips, USB/Serial, Peeler, 230V-EU/UK");
modelFeatures.put("1600079", "7005, TT, 2.4 inch, 200dpi, 5ips, USB/Parallel, Peeler, 230V-EU/UK");
modelFeatures.put("1600080", "7005, TT, 2.4 inch, 200dpi, 5ips, Standard, RTC, 120V-US");
modelFeatures.put("1600081", "7005, TT, 2.4 inch, 200dpi, 5ips, USB/Serial, RTC, 120V-US");
modelFeatures.put("1600082", "7005, TT, 2.4 inch, 200dpi, 5ips, USB/Parallel, RTC, 120V-US");
modelFeatures.put("1600083", "7005, TT, 2.4 inch, 200dpi, 5ips, Standard, RTC, 230V-EU/UK");
modelFeatures.put("1600084", "7005, TT, 2.4 inch, 200dpi, 5ips, USB/Serial, RTC, 230V-EU/UK");
modelFeatures.put("1600085", "7005, TT, 2.4 inch, 200dpi, 5ips, USB/Parallel, RTC, 230V-EU/UK");
modelFeatures.put("1600086", "7005, TT, 2.4 inch, 200dpi, 5ips, USB/Ethernet, 120V-US");
modelFeatures.put("1600087", "7005, TT, 2.4 inch, 200dpi, 5ips, USB/Ethernet, 230V-EU/UK");
modelFeatures.put("1600088", "7005, TT, 2.4 inch, 200dpi, 5ips, USB/Ethernet, Peeler, 120V-US");
modelFeatures.put("1600089", "7005, TT, 2.4 inch, 200dpi, 5ips, USB/Ethernet, Peeler, 230V-EU/UK");
modelFeatures.put("1600142", "7005, TT, 2.4 inch, 300dpi, 5ips, Standard, 120V-US");
modelFeatures.put("1600143", "7005, TT, 2.4 inch, 300dpi, 5ips, Standard, 230V-EU/UK");
modelFeatures.put("1600144", "7005, TT, 2.4 inch, 300dpi, 5ips, Standard, PCL, 120V-US");
modelFeatures.put("1600145", "7005, TT, 2.4 inch, 300dpi, 5ips, Standard, PCL, 230V-EU/UK");
modelFeatures.put("1600090", "7005, DT, 4.2 inch, 200dpi, 5ips, USB, 120V-US");
modelFeatures.put("1600091", "7005, DT, 4.2 inch, 200dpi, 5ips, USB, 230V-EU/UK");
modelFeatures.put("1600092", "7005, DT, 4.2 inch, 200dpi, 5ips, Standard, 120V-US");
modelFeatures.put("1600132", "7005, DT, 4.2 inch, 200dpi, 5ips, USB, 120V-US");
modelFeatures.put("1600093", "7005, DT, 4.2 inch, 200dpi, 5ips, USB/Serial, 120V-US");
modelFeatures.put("1600094", "7005, DT, 4.2 inch, 200dpi, 5ips, USB/Parallel, 120V-US");
modelFeatures.put("1600095", "7005, DT, 4.2 inch, 200dpi, 5ips, Standard, 230V-EU/UK");
modelFeatures.put("1600133", "7005, DT, 4.2 inch, 200dpi, 5ips, USB, 230V-EU/UK");
modelFeatures.put("1600096", "7005, DT, 4.2 inch, 200dpi, 5ips, USB/Serial, 230V-EU/UK");
modelFeatures.put("1600097", "7005, DT, 4.2 inch, 200dpi, 5ips, USB/Parallel, 230V-EU/UK");
modelFeatures.put("1600098", "7005, DT, 4.2 inch, 200dpi, 5ips, Standard, Peeler, 120V-US");
modelFeatures.put("1600134", "7005, DT, 4.2 inch, 200dpi, 5ips, USB, Peeler, 120V-US");
modelFeatures.put("1600099", "7005, DT, 4.2 inch, 200dpi, 5ips, USB/Serial, Peeler, 120V-US");
modelFeatures.put("1600100", "7005, DT, 4.2 inch, 200dpi, 5ips, USB/Parallel, Peeler, 120V-US");
modelFeatures.put("1600101", "7005, DT, 4.2 inch, 200dpi, 5ips, Standard, Peeler, 230V-EU/UK");
modelFeatures.put("1600135", "7005, DT, 4.2 inch, 200dpi, 5ips, USB, Peeler, 230V-EU/UK");
modelFeatures.put("1600102", "7005, DT, 4.2 inch, 200dpi, 5ips, USB/Serial, Peeler, 230V-EU/UK");
modelFeatures.put("1600103", "7005, DT, 4.2 inch, 200dpi, 5ips, USB/Parallel, Peeler, 230V-EU/UK");
modelFeatures.put("1600104", "7005, DT, 4.2 inch, 200dpi, 5ips, USB/Ethernet, 120V-US");
modelFeatures.put("1600105", "7005, DT, 4.2 inch, 200dpi, 5ips, USB/Ethernet, 230V-EU/UK");
modelFeatures.put("1600106", "7005, DT, 4.2 inch, 200dpi, 5ips, USB/Ethernet, Peeler, 120V-US");
modelFeatures.put("1600107", "7005, DT, 4.2 inch, 200dpi, 5ips, USB/Ethernet, Peeler, 230V-EU/UK");
modelFeatures.put("1600142", "7005, DT, 4.2 inch, 300dpi, 5ips, Standard, 120V-US");
modelFeatures.put("1600143", "7005, DT, 4.2 inch, 300dpi, 5ips, Standard, 230V-EU/UK");
modelFeatures.put("1600144", "7005, DT, 4.2 inch, 300dpi, 5ips, Standard, PCL, 120V-US");
modelFeatures.put("1600145", "7005, DT, 4.2 inch, 300dpi, 5ips, Standard, PCL, 230V-EU/UK");
modelFeatures.put("1600108", "7005, TT, 4.2 inch, 200dpi, 5ips, USB, 120V-US");
modelFeatures.put("1600109", "7005, TT, 4.2 inch, 200dpi, 5ips, USB, 230V-EU/UK");
modelFeatures.put("1600110", "7005, TT, 4.2 inch, 200dpi, 5ips, Standard, 120V-US");
modelFeatures.put("1600136", "7005, TT, 4.2 inch, 200dpi, 5ips, USB, 120V-US");
modelFeatures.put("1600111", "7005, TT, 4.2 inch, 200dpi, 5ips, USB/Serial, 120V-US");
modelFeatures.put("1600112", "7005, TT, 4.2 inch, 200dpi, 5ips, USB/Parallel, 120V-US");
modelFeatures.put("1600113", "7005, TT, 4.2 inch, 200dpi, 5ips, Standard, 230V-EU/UK");
modelFeatures.put("1600137", "7005, TT, 4.2 inch, 200dpi, 5ips, USB, 230V-EU/UK");
modelFeatures.put("1600114", "7005, TT, 4.2 inch, 200dpi, 5ips, USB/Serial, 230V-EU/UK");
modelFeatures.put("1600115", "7005, TT, 4.2 inch, 200dpi, 5ips, USB/Parallel, 230V-EU/UK");
modelFeatures.put("1600116", "7005, TT, 4.2 inch, 200dpi, 5ips, Standard, Peeler, 120V-US");
modelFeatures.put("1600117", "7005, TT, 4.2 inch, 200dpi, 5ips, USB/Serial, Peeler, 120V-US");
modelFeatures.put("1600118", "7005, TT, 4.2 inch, 200dpi, 5ips, USB/Parallel, Peeler, 120V-US");
modelFeatures.put("1600119", "7005, TT, 4.2 inch, 200dpi, 5ips, Standard, Peeler, 230V-EU/UK");
modelFeatures.put("1600120", "7005, TT, 4.2 inch, 200dpi, 5ips, USB/Serial, Peeler, 230V-EU/UK");
modelFeatures.put("1600121", "7005, TT, 4.2 inch, 200dpi, 5ips, USB/Parallel, Peeler, 230V-EU/UK");
modelFeatures.put("1600122", "7005, TT, 4.2 inch, 200dpi, 5ips, USB/Ethernet, 120V-US");
modelFeatures.put("1600123", "7005, TT, 4.2 inch, 200dpi, 5ips, USB/Ethernet, 230V-EU/UK");
modelFeatures.put("1600124", "7005, TT, 4.2 inch, 200dpi, 5ips, USB/Ethernet, Peeler, 120V-US");
modelFeatures.put("1600125", "7005, TT, 4.2 inch, 200dpi, 5ips, USB/Ethernet, Peeler, 230V-EU/UK");
modelFeatures.put("1600150", "7005, TT, 4.2 inch, 300dpi, 5ips, Standard, 120V-US");
modelFeatures.put("1600151", "7005, TT, 4.2 inch, 300dpi, 5ips, Standard, 230V-EU/UK");
modelFeatures.put("1600152", "7005, TT, 4.2 inch, 300dpi, 5ips, Standard, PCL, 120V-US");
modelFeatures.put("1600153", "7005, TT, 4.2 inch, 300dpi, 5ips, Standard, PCL, 230V-EU/UK");
}
public String getModelNumber(String TGModelNumber)
{
return modelNumbers.get(TGModelNumber);
}
public String getModelFeature(String TGModelNumber)
{
return modelFeatures.get(TGModelNumber);
}
public String getModelEmbeddedNumber(String TGModelNumber)
{
return modelEmbeddedNumbers.get(TGModelNumber);
}
public String getModelUPC(String TGModelNumber)
{
return modelUPCs.get(TGModelNumber);
}
public String getModelID(String TGModelEmbeddedNumber)
{
Enumeration<String>embeddedNumbers=modelEmbeddedNumbers.keys();
boolean foundMatch=false;
String key="1600000";
while(embeddedNumbers.hasMoreElements()&&!foundMatch)
{
key=embeddedNumbers.nextElement();
String value=modelEmbeddedNumbers.get(key);
if(value.equalsIgnoreCase(TGModelEmbeddedNumber))
{
GUIHelper.logger.info("Found Match-Key: "+key+", Value: "+value+", Embedded Model Number: "+TGModelEmbeddedNumber);
foundMatch=true;
}
}
return key;
}
}
```
## File: JAdmin/src/com/cognitive/admin/TimerTaskCPL.java
```java
public class TimerTaskCPL extends TimerTask
{
private int repetitions;
private int current;
private String CPLString;
private Label labelCounter;
private HasCallback hasCallback;
public TimerTaskCPL(int repetitions, int current, String CPLString, Label labelCounter, HasCallback hasCallback)
{
super();
GUIHelper.logger.trace("");
this.CPLString=CPLString;
this.repetitions=repetitions;
this.current=current;
this.labelCounter=labelCounter;
this.hasCallback=hasCallback;
}
@Override
public void run()
{
GUIHelper.logger.trace("Repetition "+current);
try
{
PrinterHelper.printer.send(CPLString+"\n");
GUIHelper.myDisplay.syncExec(new Runnable()
{
public void run()
{
labelCounter.setText(current+"/"+repetitions);
}
});
}
catch(Exception e)
{
GUIHelper.logger.warn("Failed sending: "+e.toString(), e);
}
if(current==repetitions)
{
GUIHelper.myDisplay.syncExec(new Runnable()
{
public void run()
{
hasCallback.callback();
}
});
}
current++;
GUIHelper.logger.trace("Exiting");
}
}
```
## File: JAdmin/src/com/cognitive/admin/TimerTaskHeartbeat.java
```java
public class TimerTaskHeartbeat extends TimerTask
{
final int DEFAULT_HEARTBEAT_INTERVAL=25000;
final int DEFAUTL_MAX_MISSED_HEARTBEATS=3;
private long interval;
private int maxMissedHeartbeats;
private int missedHeartbeats;
private Display display;
public TimerTaskHeartbeat()
{
super();
GUIHelper.logger.trace("");
interval=GUIHelper.prefs.getLong("HEARTBEAT_INTERVAL", DEFAULT_HEARTBEAT_INTERVAL);
maxMissedHeartbeats=GUIHelper.prefs.getInt("MAX_MISSED_HEARTBEATS", DEFAUTL_MAX_MISSED_HEARTBEATS);
GUIHelper.logger.debug("Heartbeat task created with interval ["+interval+"] and maxMissed ["+maxMissedHeartbeats+"].");
}
public void setDisplay(Display display)
{
this.display=display;
}
public long getInterval()
{
return interval;
}
@Override
public void run()
{
GUIHelper.logger.trace("");
try
{
PrinterHelper.printer.getVariable("WIDTH");
display.syncExec(new Runnable()
{
public void run()
{
try
{
GUIHelper.mainShell.displayConnectionStatus(ConnectionStatus.CONNECTED);
}
catch(SWTException e)
{
GUIHelper.logger.warn(e, e);
return;
}
}
});
}
catch(Exception e)
{
missedHeartbeats++;
GUIHelper.logger.warn("Missed a heartbeat:", e);
display.syncExec(new Runnable()
{
public void run()
{
try
{
GUIHelper.mainShell.displayConnectionStatus(ConnectionStatus.UNKNOWN);
}
catch(SWTException e)
{
GUIHelper.logger.warn(e, e);
return;
}
}
});
}
if(missedHeartbeats>maxMissedHeartbeats)
{
try
{
this.cancel();
PrinterHelper.printer.closeConnection();
display.syncExec(new Runnable()
{
public void run()
{
try
{
GUIHelper.mainShell.setConnectionState(false, false);
}
catch(SWTException e)
{
GUIHelper.logger.warn(e, e);
return;
}
}
});
}
catch(Exception e)
{
GUIHelper.logger.warn("closeConnection failed:", e);
}
}
GUIHelper.logger.trace("Exiting");
}
}
```
## File: JAdmin/src/com/cognitive/admin/Versions.java
```java
public class Versions
{
public static String jadmin="1.5.5386";
public static String drivers="REVISIONDRIVERS";
public static String documentation="REVISIONDOC";
public static String manFirmware="";
public static String manCpr="";
public static String manFonts="";
public static String manLabels="";
public static String manFpk="";
}
```
## File: JAdmin/src/com/cognitive/admin/WindowsPrinterManager.java
```java
public class WindowsPrinterManager
{
static public boolean spoolerStopped=false;
static public boolean spoolerStarted=false;
public void deletePrinter(String printerName)
{
try
{
String companyname=GUIHelper.brand.getProperty("company.name", "CognitiveTPG").replaceAll("TPG", "").replaceAll(" ", "");
Runtime.getRuntime().exec("C:\\Program Files\\"+companyname+"\\Documentation\\delete.bat");
}
catch(IOException e)
{
e.printStackTrace();
}
}
public static void stopSpooler()
{
try
{
Runtime.getRuntime().exec("net.exe stop spooler");
Thread.sleep(3000);
spoolerStopped=true;
spoolerStarted=false;
}
catch(IOException e)
{
e.printStackTrace();
}
catch(Exception e)
{
e.printStackTrace();
}
}
public static void startSpooler()
{
try
{
Runtime.getRuntime().exec("net.exe start spooler");
spoolerStarted=true;
spoolerStopped=false;
}
catch(IOException e)
{
e.printStackTrace();
}
}
}
```
## File: JAdmin/src/com/cognitive/printer/CPLParser.java
```java
public class CPLParser
{
static public String clean(String str)
{
Printer.logger.trace("");
str=str.replace('\n', ' ');
str=str.replace('\r', ' ');
str=str.trim();
return str;
}
static public String getResponseValue(String response, String command) throws CPLParsingException
{
Printer.logger.trace("");
String retStr=null;
String tmp=command.replace('\n', ' ');
tmp=tmp.replace('\r', ' ');
tmp=tmp.trim();
tmp=tmp.toUpperCase();
if(clean(response).matches(".*=.*"))
{
if(tmp.matches(".*VARIABLE .*?.*")||tmp.matches("V .*?.*"))
{
int k=response.indexOf(getVariableName(tmp));
if(k>-1)
{
response=response.substring(k);
}
}
int i=response.indexOf('=');
int j=response.indexOf('\n');
if(j==-1)
{
retStr=response.substring(i+1).trim();
}
else
{
retStr=response.substring(i+1, j).trim();
}
}
else
{
if(tmp.matches(".*INDEX.*SETTING.*CALIBRATE.*")||tmp.matches(".*!CAL [012]3*"))
{
retStr=response.substring(response.indexOf("C"));
}
else
{
retStr=response;
}
}
Printer.logger.debug(retStr);
return retStr;
}
static public String getVariableName(String command) throws CPLParsingException
{
Printer.logger.trace("");
if(command.matches(".*VARIABLE .*?.*")||command.matches(".*V .*?.*"))
{
command=command.toUpperCase();
int i=command.indexOf("VARIABLE");
if(i!=-1)
{
i=command.indexOf('E')+1;
}
else
{
i=command.indexOf('V')+1;
}
int j=command.indexOf('?')-1;
Printer.logger.debug("getVariableName: ["+command.substring(i, j).trim()+"]");
return command.substring(i, j).trim();
}
else
{
throw new CPLParsingException("getVariableName called on non-variable command");
}
}
static public void getResponsePattern(String command, StringBuffer sbPatternStart, StringBuffer sbPatternEnd) throws CPLParsingException
{
Printer.logger.trace("");
String tmp=command.replace('\n', ' ');
tmp=tmp.replace('\r', ' ');
tmp=tmp.trim();
tmp=tmp.toUpperCase();
String patternStart=null;
String patternEnd=null;
if(tmp.matches(".*VARIABLE .*?.*")||tmp.matches("V .*?.*"))
{
if(tmp.matches(".*TIME .*"))
{
patternStart="(Sunday|Monday|Tuesday|Wednesday|Thursday|Friday|Saturday).*";
}
else if(tmp.matches(".*AUX_POWER.*"))
{
patternStart=".*AUXPOWER.*";
}
else if(tmp.matches(".*LANGUAGE.*"))
{
patternStart=".*AUX LANGUAGE.*";
}
else if(tmp.matches(".*BLUETOOTH DEVICENAME.*"))
{
patternStart=".*BLUETOOTH DEVICENAME=.*";
}
else if(tmp.matches(".*BLUETOOTH BDADDR.*"))
{
patternStart=".*BLUETOOTH BDADDR=.*";
}
else if(tmp.matches(".*INDEX.*"))
{
patternStart=".*INDEX.*";
}
else
{
patternStart=".*"+getVariableName(tmp)+".*";
}
}
else if(tmp.matches(".*INDEX.*SETTING.*CALIBRATE.*"))
{
patternStart=".*C3[FP]";
}
else if(tmp.matches(".*!CAL [012]3*"))
{
patternStart=".*C[012]3*[FP]";
}
else if(tmp.matches(".*SHOW MODELNUMBER.*"))
{
patternStart="Model Number.*";
}
else if(tmp.matches(".*SHOW SERIALNUMBER.*"))
{
patternStart=".*Serial Number.*";
}
else if(tmp.matches(".*SHOW INCHCOUNT.*"))
{
patternStart=".*Inches Printed.*";
}
else if(tmp.matches(".*SHOW MAC.*"))
{
patternStart=".*MAC.*";
}
else if(tmp.matches(".*!.*QR.*"))
{
patternStart=".*195-...-....*";
}
else if(tmp.matches(".*!.*QS.*"))
{
patternStart=".*[a-zA-Z]\\d{5}.*";
}
else if(tmp.matches(".*!.*LS.*"))
{
patternStart=".*,.*,.*,.*,.*,.*";
patternEnd=".*END-OF-LIST.*";
}
else if(tmp.matches(".*!D.*"))
{
patternStart="Success";
}
else if(tmp.matches(".*SHOW.*AD.*"))
{
patternStart="(\\d=\\d{3}\\s*){8}.*";
}
else
{
patternStart=".*";
}
Printer.logger.debug("getResponsePattern command: ["+tmp+"]");
Printer.logger.debug("getResponsePattern pattern: ["+patternStart+"] .. ["+patternEnd+"]");
sbPatternStart.append(patternStart);
sbPatternEnd.append(patternEnd);
}
}
```
## File: JAdmin/src/com/cognitive/printer/IOEnvironment.java
```java
public class IOEnvironment
{
final static String INPUT_PIPE="PIPE00";
final static String OUTPUT_PIPE="PIPE01";
final static String sGUID="00873FDF-61A8-11d1-AA5E-00C04FB1728B";
private	int hReadPort;
private	int hWritePort;
private	byte[]	aIOBuffer;
private	String sUsbGUID;
public IOEnvironment()
{
hReadPort=0;
hWritePort=0;
sUsbGUID=sGUID;
}
public String getUsbGUID()
{
return sUsbGUID;
}
public void setIOBuffer(byte[] aIOBuffer)
{
this.aIOBuffer=aIOBuffer;
}
public int getReadPort()
{
return this.hReadPort;
}
public int getWritePort()
{
return this.hWritePort;
}
public void setReadPort(int hReadPort)
{
this.hReadPort=hReadPort;
}
public void setWritePort(int hWritePort)
{
this.hWritePort=hWritePort;
}
}
```
## File: JAdmin/src/com/cognitive/printer/IPrinterConnection.java
```java
public interface IPrinterConnection
{
void openConnection() throws IOException,
PortInUseException,
UnsupportedCommOperationException,
NativeLibraryException;
void closeConnection() throws IOException, NativeLibraryException;
void send(String str) throws IOException, NativeLibraryException;
void send(byte data[]) throws IOException, NativeLibraryException;
boolean ready() throws IOException, NativeLibraryException;
String readLine() throws IOException, NativeLibraryException;
ConnectionType getType();
public enum ConnectionType
{
SERIAL,
PARALLEL,
OS_PRINTER,
NETWORK,
UNKNOWN
}
}
```
## File: JAdmin/src/com/cognitive/printer/NetworkConnection.java
```java
public class NetworkConnection implements IPrinterConnection
{
private String address=null;
private int port=-1;
private Socket socket=null;
private DataOutputStream outputStream=null;
private BufferedReader reader=null;
public NetworkConnection(String address, int port)
{
Printer.logger.trace("");
this.address=address;
this.port=port;
}
public void openConnection() throws IOException
{
Printer.logger.trace("");
socket=new Socket();
socket.connect(new InetSocketAddress(address, port), 10000);
outputStream=new DataOutputStream(socket.getOutputStream());
reader=new BufferedReader(new InputStreamReader(socket.getInputStream()));
}
public void closeConnection() throws IOException
{
Printer.logger.trace("");
if(null!=outputStream)
{
outputStream.flush();
outputStream.close();
outputStream=null;
}
if(null!=reader)
{
reader.close();
reader=null;
}
if(null!=socket)
{
socket.close();
socket=null;
}
}
public void send(String str) throws IOException
{
Printer.logger.trace(str);
send(str.getBytes());
}
public void send(byte data[]) throws IOException
{
Printer.logger.trace("");
outputStream.write(data);
}
public boolean ready() throws IOException
{
if(reader!=null)
{
return reader.ready();
}
else
{
Printer.logger.error("ready() called on null reader; returning false.");
throw new IOException("ready() called on null reader");
}
}
public String readLine() throws IOException
{
Printer.logger.trace("");
return reader.readLine()+"\n";
}
public ConnectionType getType()
{
return ConnectionType.NETWORK;
}
}
```
## File: JAdmin/src/com/cognitive/printer/ParallelConnection.java
```java
public class ParallelConnection implements IPrinterConnection
{
private OutputStream outputStream;
private ParallelPort parallelPort;
private CommPortIdentifier portId;
public ParallelConnection(String port) throws NoSuchPortException
{
Printer.logger.trace("");
portId=CommPortIdentifier.getPortIdentifier(port);
}
public void openConnection() throws IOException, PortInUseException, UnsupportedCommOperationException
{
Printer.logger.trace("");
parallelPort=(ParallelPort)portId.open("com.cogntive.printer", 30000);
GUIHelper.logger.info("Port name: "+parallelPort.getName());
parallelPort.setMode(ParallelPort.LPT_MODE_ANY);
int mode=parallelPort.getMode();
switch(mode)
{
case ParallelPort.LPT_MODE_ECP:
GUIHelper.logger.info("Mode is: ECP");
break;
case ParallelPort.LPT_MODE_EPP:
GUIHelper.logger.info("Mode is: EPP");
break;
case ParallelPort.LPT_MODE_NIBBLE:
GUIHelper.logger.info("Mode is: Nibble Mode.");
break;
case ParallelPort.LPT_MODE_PS2:
GUIHelper.logger.info("Mode is: Byte mode.");
break;
case ParallelPort.LPT_MODE_SPP:
GUIHelper.logger.info("Mode is: Compatibility mode.");
break;
case ParallelPort.LPT_MODE_ANY:
GUIHelper.logger.info("Mode is: Any mode.");
break;
default:
GUIHelper.logger.info("Mode is:"+mode);
break;
}
outputStream=parallelPort.getOutputStream();
}
public void closeConnection() throws IOException
{
Printer.logger.trace("");
if(null!=outputStream)
{
outputStream.flush();
outputStream.close();
outputStream=null;
}
if(null!=parallelPort)
{
parallelPort.close();
parallelPort=null;
}
}
public void send(String str) throws IOException
{
Printer.logger.trace(str);
send(str.getBytes());
}
public void send(byte data[]) throws IOException
{
Printer.logger.trace("");
outputStream.write(data);
outputStream.flush();
}
public boolean ready() throws IOException
{
return false;
}
public String readLine() throws IOException
{
return "";
}
public ConnectionType getType()
{
return ConnectionType.PARALLEL;
}
}
```
## File: JAdmin/src/com/cognitive/printer/Printer.java
```java
public class Printer extends Observable
{
final int WAIT_FOR_DATA_TIMEOUT=10000;
final int WAIT_FOR_DATA_INTERVAL=100;
final int WAIT_FOR_MUTEX_TIMEOUT=WAIT_FOR_DATA_TIMEOUT+1000;
private boolean continueReceiving=true;
private ReentrantLock mutex=null;
static private IPrinterConnection conn;
static private ReceiveThread receiver;
static public String modelNumber="";
static boolean showWaitFor=GUIHelper.prefs.getBoolean("SHOW_WAIT_FOR", false);
static Logger logger;
int responses=0;
long totalResponseTime=0;
public Printer()
{
logger=Logger.getLogger("PRINTER");
logger.trace("");
mutex=new ReentrantLock();
}
public void stopReceiver()
{
logger.trace("");
continueReceiving=false;
try
{
receiver.join();
}
catch(Exception e)
{
logger.error("Interrupted while joining receiver.");
}
}
public boolean acquireMutex()
{
try
{
return mutex.tryLock(WAIT_FOR_MUTEX_TIMEOUT, TimeUnit.MILLISECONDS);
}
catch(Exception e)
{
logger.error("Caught an exception: ", e);
return false;
}
}
public void releaseMutex()
{
if(mutex.isHeldByCurrentThread())
{
mutex.unlock();
}
}
public void openConnection(IPrinterConnection newConn) throws UnsupportedCommOperationException,
PortInUseException,
NativeLibraryException,
IOException
{
logger.trace("");
if((com.cognitive.admin.TestEngine.isConnectionTypeParallelOnly)&&(com.cognitive.admin.TestEngine.runningManufacturing))
{
modelNumber=com.cognitive.admin.TestEngine.testModelNumber;
}
conn=newConn;
conn.openConnection();
createReceiver();
}
public void closeConnection() throws UnsupportedCommOperationException,
PortInUseException,
NativeLibraryException,
IOException
{
logger.trace("");
continueReceiving=false;
try
{
if(receiver!=null)
{
receiver.join();
logger.debug("Receiver joined.");
}
if(conn!=null)
{
conn.closeConnection();
}
setChanged();
notifyObservers(new String("030470 DISCONNECTED 074030"));
}
catch(InterruptedException e)
{
logger.warn("Interrupted while waiting for receiver thread to exit: ", e);
}
}
private void createReceiver()
{
logger.trace("");
continueReceiving=true;
receiver=new ReceiveThread();
receiver.start();
}
public void send(byte data[]) throws InterruptedException,
NativeLibraryException, IOException, PrinterOperationException
{
logger.trace("");
try
{
if(mutex.tryLock(WAIT_FOR_MUTEX_TIMEOUT, TimeUnit.MILLISECONDS))
{
conn.send(data);
}
else
{
throw new PrinterOperationException(
"Timeout acquiring comm mutex.");
}
}
finally
{
if(mutex.isHeldByCurrentThread())
{
mutex.unlock();
}
}
}
public void send(String str) throws InterruptedException,
NativeLibraryException,
IOException,
PrinterOperationException
{
logger.trace(str);
try
{
if(mutex.tryLock(WAIT_FOR_MUTEX_TIMEOUT, TimeUnit.MILLISECONDS))
{
conn.send(str);
}
else
{
throw new PrinterOperationException("Timeout acquiring comm mutex.");
}
}
finally
{
if(mutex.isHeldByCurrentThread())
{
mutex.unlock();
}
}
}
private void waitForData() throws NativeLibraryException,
IOException,
InterruptedException,
PrinterOperationException
{
logger.trace("");
int waitTime=0;
while(!conn.ready())
{
Thread.sleep(WAIT_FOR_DATA_INTERVAL);
waitTime+=WAIT_FOR_DATA_INTERVAL;
if(waitTime>WAIT_FOR_DATA_TIMEOUT)
{
throw new PrinterOperationException("waitForData: timed out.");
}
}
}
public String clean(String str)
{
logger.trace("");
str=str.replace('\n', ' ');
str=str.replace('\r', ' ');
str=str.trim();
return str;
}
public String setAndGetVariable(String variable, String value) throws InterruptedException,
NativeLibraryException,
IOException,
PrinterOperationException,
CPLParsingException
{
try
{
if(mutex.tryLock(WAIT_FOR_MUTEX_TIMEOUT, TimeUnit.MILLISECONDS))
{
setVariable(variable, value);
return getVariable(variable);
}
else
{
throw new PrinterOperationException("Timeout acquiring comm mutex.");
}
}
finally
{
if(mutex.isHeldByCurrentThread())
{
mutex.unlock();
}
}
}
public String getVariable(String variable) throws PrinterOperationException,
CPLParsingException,
InterruptedException,
IOException,
NativeLibraryException
{
logger.trace("");
String preVar="!!0 0 0 0\n!0 0 0 0\nVARIABLE ";
String postVar=" ?\nEND\n";
String command=preVar+variable+postVar;
long t0=System.currentTimeMillis();
String response=commandWaitResponse(command);
long t1=System.currentTimeMillis();
logger.debug("Response time: "+(t1-t0)+" milliseconds.");
responses++;
totalResponseTime+=(t1-t0);
logger.debug("Average response time: "+(totalResponseTime/responses)+" for "+responses+" responses.");
return response;
}
public void setVariable(String variable, String value) throws InterruptedException,
NativeLibraryException,
IOException,
PrinterOperationException
{
logger.trace("");
String preVar="!!0 0 0 0\n!0 0 0 0\nVARIABLE ";
String postVar=" \nVARIABLE WRITE\nEND\n";
String command=preVar+variable+" "+value+postVar;
send(command);
}
public boolean waitFor(String pattern, int seconds)
{
logger.trace(pattern+" "+seconds);
String msg;
int numLoops=seconds*1000/WAIT_FOR_DATA_INTERVAL;
try
{
if(mutex.tryLock(WAIT_FOR_DATA_INTERVAL, TimeUnit.MILLISECONDS))
{
for(int i=0; i<numLoops; i++)
{
if(conn.ready())
{
msg=clean(conn.readLine());
if(msg.matches(pattern))
{
mutex.unlock();
logger.debug("Received ["+msg+"] matches pattern ["+pattern+"]");
return true;
}
else
{
Printer.logger.debug("Asynchronous message 3: ["+clean(msg)+"] while waiting for ["+pattern+"]");
setChanged();
notifyObservers(msg);
}
}
Thread.sleep(WAIT_FOR_DATA_INTERVAL);
}
}
}
catch(InterruptedException e)
{
Printer.logger.debug(e.toString());
}
catch(Exception e)
{
continueReceiving=false;
Printer.logger.fatal("Exiting RcvThrd due to exception:", e);
}
finally
{
if(mutex.isHeldByCurrentThread())
{
mutex.unlock();
}
}
if(mutex.isHeldByCurrentThread())
{
mutex.unlock();
}
logger.debug("Did not receive "+pattern);
return false;
}
public String commandWaitResponse(String command) throws PrinterOperationException,
CPLParsingException,
InterruptedException,
IOException,
NativeLibraryException
{
logger.trace("");
String msg="";
StringBuffer responsePatternStart=new StringBuffer("");
StringBuffer responsePatternEnd=new StringBuffer("");
StringBuffer response=new StringBuffer("");
try
{
if(mutex.tryLock(WAIT_FOR_MUTEX_TIMEOUT, TimeUnit.MILLISECONDS))
{
CPLParser.getResponsePattern(command, responsePatternStart, responsePatternEnd);
conn.send(command);
int ctr=0;
while(ctr<10)
{
waitForData();
msg=conn.readLine();
if(msg.trim().isEmpty())
{
ctr++;
if(ctr==10)
{
logger.debug("Receiving only empty strings..");
throw new PrinterOperationException("waitForData: timed out.");
}
}
else
{
ctr=10;
}
}
while(!clean(msg).matches(responsePatternStart.toString())&&!clean(msg).matches(responsePatternEnd.toString()))
{
Printer.logger.debug("Asynchronous message 2: ["+clean(msg)+"] while response pattern is ["+responsePatternStart+"]");
setChanged();
notifyObservers(msg);
waitForData();
msg=conn.readLine();
}
logger.trace("Response so far: "+clean(msg));
response.append(msg);
if(responsePatternEnd.toString().equals("null"))
{
logger.trace("returning one-line response: "+response.toString());
return CPLParser.getResponseValue(response.toString(), command);
}
else
{
logger.trace("waiting for multi-line response");
if(clean(msg).matches(responsePatternEnd.toString()))
{
return CPLParser.getResponseValue(response.toString(), command);
}
do
{
waitForData();
msg=conn.readLine();
logger.debug("Concatenating to multi-line response: "+clean(msg));
response.append(msg);
}
while(!clean(response.toString()).matches(responsePatternEnd.toString()));
logger.trace("returning multi-line response: "+clean(response.toString()));
return CPLParser.getResponseValue(response.toString(), command);
}
}
else
{
throw new PrinterOperationException("Timeout acquiring comm mutex.");
}
}
finally
{
if(mutex.isHeldByCurrentThread())
{
logger.trace("releasing mutex");
mutex.unlock();
}
}
}
public boolean isConnected()
{
logger.trace("");
String str=null;
try
{
str=commandWaitResponse("!SHOW MODELNUMBER\n");
modelNumber=str;
}
catch(PrinterOperationException e)
{
try
{
logger.warn("second attempt.");
str=commandWaitResponse("!SHOW MODELNUMBER\n");
modelNumber=str;
}
catch(Exception e2)
{
logger.error("", e2);
return false;
}
}
catch(Exception e)
{
logger.error("", e);
return false;
}
if(str=="")
{
return false;
}
else
{
return true;
}
}
class ReceiveThread extends Thread
{
String msg=null;
public ReceiveThread()
{
super();
logger.trace("");
}
public void run()
{
this.setName("RcvThrd");
logger.trace("");
while(continueReceiving)
{
try
{
if(mutex.tryLock(WAIT_FOR_DATA_INTERVAL, TimeUnit.MILLISECONDS))
{
if(conn.ready())
{
msg=conn.readLine();
mutex.unlock();
Printer.logger.debug("Asynchronous message 1: ["+clean(msg)+"]");
setChanged();
notifyObservers(msg);
}
else
{
mutex.unlock();
Thread.sleep(WAIT_FOR_DATA_INTERVAL);
}
}
}
catch(InterruptedException e)
{
Printer.logger.debug(e.toString());
}
catch(Exception e)
{
continueReceiving=false;
Printer.logger.fatal("Exiting RcvThrd due to exception:", e);
}
finally
{
if(mutex.isHeldByCurrentThread())
{
mutex.unlock();
}
}
}
logger.trace("Exiting");
}
}
public IPrinterConnection getConnection()
{
return conn;
}
public String waitForResponse(String pattern, int seconds)
{
logger.trace(pattern+" "+seconds);
String msg;
int numLoops=seconds*1000/WAIT_FOR_DATA_INTERVAL;
try
{
if(mutex.tryLock(WAIT_FOR_DATA_INTERVAL, TimeUnit.MILLISECONDS))
{
for(int i=0; i<numLoops; i++)
{
if(conn.ready())
{
msg=clean(conn.readLine());
if(msg.matches(pattern))
{
mutex.unlock();
logger.debug("Received ["+msg+"] matches pattern ["+pattern+"]");
return msg;
}
else
{
Printer.logger.debug("Asynchronous message 3: ["+clean(msg)+"] while waiting for ["+pattern+"]");
setChanged();
notifyObservers(msg);
}
}
Thread.sleep(WAIT_FOR_DATA_INTERVAL);
}
}
}
catch(InterruptedException e)
{
Printer.logger.debug(e.toString());
}
catch(Exception e)
{
continueReceiving=false;
Printer.logger.fatal("Exiting RcvThrd due to exception:", e);
}
finally
{
if(mutex.isHeldByCurrentThread())
{
mutex.unlock();
}
}
if(mutex.isHeldByCurrentThread())
{
mutex.unlock();
}
logger.debug("Did not receive "+pattern);
return "NONE";
}
}
```
## File: JAdmin/src/com/cognitive/printer/SerialConnection.java
```java
public class SerialConnection implements IPrinterConnection
{
private InputStream inputStream;
private DataOutputStream outputStream;
private SerialPort serialPort;
private int baudRate;
private int dataBits;
private int stopBits;
private int parity;
private CommPortIdentifier portId;
private BufferedReader reader=null;
@SuppressWarnings("unchecked")
public SerialConnection(String port, int baud, int stopbits) throws NoSuchPortException
{
Printer.logger.trace("");
baudRate=baud;
Enumeration pList=CommPortIdentifier.getPortIdentifiers();
while(pList.hasMoreElements())
{
CommPortIdentifier cpi=(CommPortIdentifier)pList.nextElement();
Printer.logger.info("Port "+cpi.getName()+" ");
if(cpi.getPortType()==CommPortIdentifier.PORT_SERIAL)
{
Printer.logger.info("is a Serial Port: "+cpi);
}
else if(cpi.getPortType()==CommPortIdentifier.PORT_PARALLEL)
{
Printer.logger.info("is a Parallel Port: "+cpi);
}
else
{
Printer.logger.info("is an Unknown Port: "+cpi);
}
if(cpi.getName().equalsIgnoreCase(port))
{
Printer.logger.info("Initializing... "+port);
portId=cpi;
break;
}
}
dataBits=SerialPort.DATABITS_8;
stopBits=SerialPort.STOPBITS_1;
if(stopbits==2)
{
stopBits=SerialPort.STOPBITS_2;
}
parity=SerialPort.PARITY_NONE;
}
public void openConnection() throws IOException, PortInUseException, UnsupportedCommOperationException
{
Printer.logger.trace("");
serialPort=(SerialPort)portId.open("com.cogntive.printer", 2000);
inputStream=serialPort.getInputStream();
reader=new BufferedReader(new InputStreamReader(inputStream));
serialPort.setSerialPortParams(baudRate, dataBits, stopBits, parity);
serialPort.setDTR(true);
serialPort.setRTS(true);
serialPort.setFlowControlMode(SerialPort.FLOWCONTROL_RTSCTS_IN|SerialPort.FLOWCONTROL_RTSCTS_OUT);
outputStream=new DataOutputStream(serialPort.getOutputStream());
}
public void closeConnection() throws IOException
{
Printer.logger.trace("");
if(null!=reader)
{
reader.close();
reader=null;
}
if(null!=outputStream)
{
outputStream.flush();
outputStream.close();
outputStream=null;
}
if(null!=inputStream)
{
inputStream.close();
inputStream=null;
}
if(null!=serialPort)
{
serialPort.close();
serialPort=null;
}
}
public void send(String str) throws IOException
{
Printer.logger.trace(str);
outputStream.writeBytes(str);
outputStream.flush();
}
public void send(byte data[]) throws IOException
{
Printer.logger.trace("");
outputStream.write(data);
outputStream.flush();
}
public boolean ready() throws IOException
{
if(reader!=null)
{
return reader.ready();
}
else
{
Printer.logger.error("ready() called on null reader; returning false.");
throw new IOException("ready() called on null reader");
}
}
public String readLine() throws IOException
{
Printer.logger.trace("");
int numLoops=0;
String retS="";
char c=(char)reader.read();
retS+=c;
while((c!='\r')&&(c!='\n'))
{
numLoops=0;
while(reader.ready()==false)
{
if(numLoops>=10)
{
retS+='\n';
return retS;
}
try
{
Thread.sleep(1);
}
catch(InterruptedException e)
{
Printer.logger.error("In readLine() Thread.sleep(1) threw an InterruptedException.");
throw new IOException("readLine(): unable to do Thread.sleep(1) while waiting for reader.ready()");
}
numLoops++;
}
c=(char)reader.read();
retS+=c;
}
return retS;
}
public ConnectionType getType()
{
return ConnectionType.SERIAL;
}
}
```
## File: JAdmin/src/com/cognitive/printer/UsbPort.java
```java
public class UsbPort
{
private static boolean m_bLibraryLoad=true;
private IOEnvironment ioe=null;
int ihWriteHandle=0;
int ihReadHandle=0;
int iGenericWrite=(int)0x40000000;
int iGenericRead=(int)0x80000000;
private boolean bConnected=false;
native int usbInitPipe(IOEnvironment ioe, int nDesiredAccess);
native int usbInitReadPipe(IOEnvironment ioe);
native int usbReadInputPipe(int nHandle, byte[] aReadData);
native int usbWriteOutputPipe(int nHandle, byte[] writeData);
native int usbClosePipe(int nHandle);
native int usbGetGenericReadValue();
native int usbGetBytesAvailable();
native int usbGetGenericWriteValue();
native String	usbGetErrorString(int nErrorCode);
native int usbSetCommTimeout(int nHandle, int nRITimeout, int nRTTMultiplier,
int nRTTConstant, int nWTTMultiplier, int nWTTConstant);
static
{
try
{
System.loadLibrary("JAdminUSB");
}
catch(UnsatisfiedLinkError ule)
{
m_bLibraryLoad=false;
}
}
public UsbPort()
{
ioe=new IOEnvironment();
}
public int open(String printerName) throws NativeLibraryException
{
int ret=-1;
int rc1=0;
int rc2=0;
if(ioe!=null)
{
if(m_bLibraryLoad)
{
try
{
int iDesc=usbGetGenericWriteValue();
rc1=usbInitPipe(ioe, iDesc);
if(rc1==1)
{
ihWriteHandle=ioe.getWritePort();
}
else
{
Integer iRc=new Integer(rc1);
}
iDesc=usbGetGenericReadValue();
rc2=usbInitPipe(ioe, iDesc);
if(rc2==1)
{
ihReadHandle=ioe.getReadPort();
}
else
{
Integer iRc=new Integer(rc2);
}
if(usbGetBytesAvailable()>0)
{
String sIgnore=read();
}
}
catch(UnsatisfiedLinkError e1)
{
e1.printStackTrace();
}
if(rc1==1&&rc2==1)
{
bConnected=true;
ret=0;
}
}
}
Integer iRc=new Integer(ret);
return ret;
};
public int print(String printString)
{
byte data[]=printString.getBytes();
int ret=usbWriteOutputPipe(ihWriteHandle, data);
return ret;
};
public int printBuffer(byte data[])
{
int ret=usbWriteOutputPipe(ihWriteHandle, data);
Integer iRet=new Integer(ret);
return ret;
};
public int close()
{
int ret=usbClosePipe(ihWriteHandle);
bConnected=false;
return ret;
};
public String read()
{
String sRet=null;
int iBytesAvailable=usbGetBytesAvailable();
byte[] aReadData=new byte[iBytesAvailable];
for(int i=0; i<iBytesAvailable; i++)
aReadData[i]=(byte)0x00;
usbReadInputPipe(ihReadHandle, aReadData);
sRet=new String(aReadData);
return sRet;
};
public int ready()
{
int ret=0;
if(usbGetBytesAvailable()>0)
ret=1;
return ret;
};
}
```
## File: JAdmin/src/com/cognitive/printer/WindowsPrinterConnection.java
```java
public class WindowsPrinterConnection implements IPrinterConnection
{
String address=null;
int port=-1;
private String printerName=null;
private UsbPort dll=null;
public WindowsPrinterConnection()
{
Printer.logger.trace("");
this.printerName="Printer";
dll=new UsbPort();
}
public void openConnection() throws NativeLibraryException
{
Printer.logger.trace("");
if(!com.cognitive.admin.WindowsPrinterManager.spoolerStopped)
{
com.cognitive.admin.WindowsPrinterManager.stopSpooler();
}
Printer.logger.trace("Spooler stopped");
int i=dll.open(printerName);
if(0!=i)
{
if(com.cognitive.admin.WindowsPrinterManager.spoolerStopped)
{
com.cognitive.admin.WindowsPrinterManager.startSpooler();
}
Printer.logger.trace("Spooler started");
Printer.logger.error("Native error code "+i);
throw new NativeLibraryException("WindowsPrinterConnection.openConnection returned error code "+i);
}
}
public void closeConnection() throws NativeLibraryException
{
Printer.logger.trace("");
int i=dll.close();
if(com.cognitive.admin.WindowsPrinterManager.spoolerStopped)
{
Printer.logger.trace("Spooler started");
com.cognitive.admin.WindowsPrinterManager.startSpooler();
}
if(0!=i)
{
if(com.cognitive.admin.WindowsPrinterManager.spoolerStopped)
{
Printer.logger.trace("Spooler started");
com.cognitive.admin.WindowsPrinterManager.startSpooler();
}
Printer.logger.error("Native error code "+i);
throw new NativeLibraryException("WindowsPrinterConnection.closeConnection returned error code "+i);
}
}
public void send(String str) throws NativeLibraryException
{
Printer.logger.trace(str);
int i=dll.printBuffer(str.getBytes());
if(0!=i)
{
Printer.logger.error("Native error code "+i);
throw new NativeLibraryException("WindowsPrinterConnection.send returned error code "+i);
}
}
public void send(byte data[]) throws NativeLibraryException
{
Printer.logger.trace("");
int i=dll.printBuffer(data);
if(0!=i)
{
Printer.logger.error("Native error code "+i);
throw new NativeLibraryException("WindowsPrinterConnection.send returned error code "+i);
}
}
public boolean ready() throws NativeLibraryException
{
int i=dll.ready();
switch(i)
{
case 0:
{
return false;
}
case 1:
{
return true;
}
default:
{
Printer.logger.error("Native error code "+i);
throw new NativeLibraryException("WindowsPrinterConnection.ready returned error code "+i);
}
}
}
public String readLine() throws NativeLibraryException
{
Printer.logger.trace("");
String line=dll.read();
if(line.startsWith("GetLastError"))
{
Printer.logger.error(line);
throw new NativeLibraryException("WindowsPrinterConnection.readLine "+line);
}
return line;
}
public static String select()
{
Printer.logger.trace("");
PrinterJob printJob=PrinterJob.getPrinterJob();
String printerName=null;
if(printJob.printDialog())
{
try
{
printerName=printJob.getPrintService().getName();
}
catch
(Exception PrintException)
{
}
}
return printerName;
}
public ConnectionType getType()
{
return ConnectionType.OS_PRINTER;
}
}
```
## File: JAdmin/src/com/cognitive/printer/WindowsPrinterConnectionDLL.java
```java
public class WindowsPrinterConnectionDLL
{
public native int open(String printerName);
public native int print(String printString);
public native int printBuffer(byte data[]);
public native int close();
public native String read();
public native int ready();
private static final long serialVersionUID=1;
static
{
Printer.logger.trace("");
System.loadLibrary("WindowsPrinterConnectionDLL");
}
}
```
## File: JAdmin/src/com/cognitive/util/exception/CPLParsingException.java
```java
public class CPLParsingException extends Exception
{
private static final long serialVersionUID=4;
public CPLParsingException(String msg)
{
super(msg);
}
}
```
## File: JAdmin/src/com/cognitive/util/exception/DBException.java
```java
public class DBException extends Exception
{
private static final long serialVersionUID=5;
public DBException(String msg)
{
super(msg);
}
}
```
## File: JAdmin/src/com/cognitive/util/exception/HasCallback.java
```java
public interface HasCallback
{
public void callback();
}
```
## File: JAdmin/src/com/cognitive/util/exception/ManufacturingTestException.java
```java
public class ManufacturingTestException extends Exception
{
private static final long serialVersionUID=3;
public ManufacturingTestException(String msg)
{
super(msg);
}
}
```
## File: JAdmin/src/com/cognitive/util/exception/NativeLibraryException.java
```java
public class NativeLibraryException extends Exception
{
private static final long serialVersionUID=2;
public NativeLibraryException(String msg)
{
super(msg);
}
}
```
## File: JAdmin/src/com/cognitive/util/exception/PrinterOperationException.java
```java
public class PrinterOperationException extends Exception
{
private static final long serialVersionUID=1;
public PrinterOperationException(String msg)
{
super(msg);
}
}
```
````
````DeviceInterfaceDrivers
This file is a merged representation of the entire codebase, combined into a single document by Repomix.
The content has been processed where comments have been removed, empty lines have been removed, content has been formatted for parsing in markdown style, security check has been disabled.
# File Summary
## Purpose
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
## File Format
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  a. A header with the file path (## File: path/to/file)
  b. The full contents of the file in a code block
## Usage Guidelines
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
## Notes
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Code comments have been removed from supported file types
- Empty lines have been removed from all files
- Content has been formatted for parsing in markdown style
- Security check has been disabled - content may contain sensitive information
- Files are sorted by Git change count (files with more changes are at the bottom)
# Directory Structure
```
DeviceInterfaceDriver/
  BTDevice.cpp
  BTDevice.hpp
  COMDevice.cpp
  COMDevice.hpp
  Device.cpp
  Device.hpp
  LANDevice.cpp
  LANDevice.hpp
  LPTDevice.cpp
  LPTDevice.hpp
  USBDevice.cpp
  USBDevice.hpp
  Utility.cpp
  Utility.hpp
```
# Files
## File: DeviceInterfaceDriver/BTDevice.cpp
```cpp
#include "BTDevice.hpp"
#include <boost/optional.hpp>
#include <memory>
#include <regex>
#include <thread>
#include <windows.h>
namespace Cognitive
{
static bool connectBLEDevice(SimpleBLE::Peripheral& peripheral, const std::string& address);
static bool readBLECharacteristic(SimpleBLE::Peripheral& peripheral, std::string& data);
static bool writeBLECharacteristic(SimpleBLE::Peripheral& peripheral, const std::string& data);
static size_t getBLEAvailableBytes(SimpleBLE::Peripheral& peripheral);
BTDevice::BTDevice() :
Service{},
BLEInterface{},
COMInterface{Service},
ErrorCode{},
Timeout{getDefaultTimeout()},
DevicePath{getDefaultDevicePath()}
{
}
BTDevice::~BTDevice()
{
Close();
Reset();
}
BTDevice::BTDevice(BTDevice&&moveValue) :
Service{},
BLEInterface{std::move(moveValue.BLEInterface)},
COMInterface{Service},
ErrorCode{moveValue.ErrorCode},
Timeout{std::exchange(moveValue.Timeout, getDefaultTimeout())},
DevicePath{std::move(moveValue.DevicePath)}
{
moveValue.ErrorCode.clear();
if(moveValue.COMInterface.is_open())
{
if(COMInterface.is_open())
{
COMInterface.close(ErrorCode);
}
DevicePath=std::move(moveValue.DevicePath);
if(!Open())
{
ErrorCode=boost::system::errc::make_error_code(boost::system::errc::io_error);
}
moveValue.COMInterface.close();
}
}
BTDevice& BTDevice::operator=(BTDevice&&moveValue)
{
if(this!=&moveValue)
{
Close();
ErrorCode=moveValue.ErrorCode;
Timeout=std::exchange(moveValue.Timeout, getDefaultTimeout());
DevicePath=std::move(moveValue.DevicePath);
BLEInterface=std::move(moveValue.BLEInterface);
moveValue.ErrorCode.clear();
if(moveValue.COMInterface.is_open())
{
COMInterface=boost::asio::serial_port(Service);
if(!Open())
{
ErrorCode=boost::system::errc::make_error_code(boost::system::errc::io_error);
}
moveValue.COMInterface.close();
}
}
return *this;
}
bool BTDevice::Close()
{
if(!isOpened())
{
return true;
}
ErrorCode.clear();
if(COMInterface.is_open())
{
COMInterface.cancel(ErrorCode);
auto closeLambda=[&]()
{
COMInterface.close(ErrorCode);
};
return ExecuteWithTimeout(Timeout, closeLambda)&&!ErrorCode;
}
else
{
auto disconnectLambda=[&]()
{
try
{
if(BLEInterface.is_connected())
{
BLEInterface.disconnect();
}
}
catch(...)
{
ErrorCode=boost::system::errc::make_error_code(boost::system::errc::io_error);
}
};
return ExecuteWithTimeout(Timeout, disconnectLambda)&&!ErrorCode;
}
}
bool BTDevice::Flush()
{
ErrorCode.clear();
if(!isOpened()&&!Open())
{
if(!ErrorCode)
{
ErrorCode=boost::system::errc::make_error_code(boost::system::errc::no_such_device);
}
return false;
}
if(COMInterface.is_open())
{
const BOOL result=PurgeComm(reinterpret_cast<HANDLE>(COMInterface.native_handle()),
PURGE_RXABORT | PURGE_TXABORT | PURGE_RXCLEAR | PURGE_TXCLEAR);
return result==TRUE;
}
return true;
}
bool BTDevice::Open()
{
ErrorCode.clear();
if(!isValid())
{
ErrorCode=boost::system::errc::make_error_code(boost::system::errc::invalid_argument);
return false;
}
if(isOpened())
{
return true;
}
if(DevicePath.find("COM")!=std::string::npos)
{
if(COMInterface.is_open())
{
COMInterface.close(ErrorCode);
if(ErrorCode)
{
return false;
}
}
COMInterface=boost::asio::serial_port(Service);
bool attemptOpen=false;
auto openLambda=[&]()
{
COMInterface.open(DevicePath, ErrorCode);
};
attemptOpen=ExecuteWithTimeout(Timeout, openLambda);
if(!attemptOpen||ErrorCode||!COMInterface.is_open())
{
Close();
return false;
}
boost::asio::serial_port_base::baud_rate baudRate(9600);
boost::asio::serial_port_base::character_size charSize(8);
boost::asio::serial_port_base::flow_control flowControl(boost::asio::serial_port_base::flow_control::none);
boost::asio::serial_port_base::parity parity(boost::asio::serial_port_base::parity::none);
boost::asio::serial_port_base::stop_bits stopBits(boost::asio::serial_port_base::stop_bits::one);
COMInterface.set_option(baudRate, ErrorCode);
if(ErrorCode)
{
Close(); return false;
}
COMInterface.set_option(charSize, ErrorCode);
if(ErrorCode)
{
Close(); return false;
}
COMInterface.set_option(flowControl, ErrorCode);
if(ErrorCode)
{
Close(); return false;
}
COMInterface.set_option(parity, ErrorCode);
if(ErrorCode)
{
Close(); return false;
}
COMInterface.set_option(stopBits, ErrorCode);
if(ErrorCode)
{
Close(); return false;
}
return true;
}
else
{
try
{
return connectBLEDevice(BLEInterface, DevicePath);
}
catch(...)
{
ErrorCode=boost::system::errc::make_error_code(boost::system::errc::io_error);
return false;
}
}
}
bool BTDevice::Reopen()
{
ErrorCode.clear();
if(isOpened()&&!Close())
{
return false;
}
return Open();
}
bool BTDevice::Reset()
{
ErrorCode.clear();
if(isOpened())
{
Close();
}
BLEInterface=SimpleBLE::Peripheral();
COMInterface=boost::asio::serial_port(Service);
ErrorCode.clear();
Timeout=getDefaultTimeout();
DevicePath=getDefaultDevicePath();
return true;
}
bool BTDevice::Read(std::string& readData)
{
ErrorCode.clear();
if(!(isOpened()||(!isOpened()&&Open())))
{
if(!ErrorCode)
{
ErrorCode=boost::system::errc::make_error_code(boost::system::errc::no_such_device);
}
return false;
}
if(COMInterface.is_open())
{
const std::size_t requestedSize=readData.size();
if(requestedSize==0)
{
std::size_t available=getAvailableBytes();
if(available > 0)
{
readData.resize(available);
}
else
{
return true;
}
}
readData.clear();
const std::size_t availableBytes=getAvailableBytes();
if(availableBytes > 0)
{
const std::size_t bytesToRead=std::min(availableBytes, requestedSize);
std::string buffer(bytesToRead, '\0');
boost::system::error_code errorCode;
try
{
std::size_t bytesRead=COMInterface.read_some(boost::asio::buffer(buffer), errorCode);
if(errorCode)
{
ErrorCode=errorCode;
return false;
}
buffer.resize(bytesRead);
readData.append(buffer);
if(readData.size() >=requestedSize)
{
return true;
}
}
catch(...)
{
ErrorCode=boost::system::errc::make_error_code(boost::system::errc::io_error);
return false;
}
}
const std::size_t remainingBytes=requestedSize - readData.size();
if(remainingBytes > 0)
{
if(Timeout==std::chrono::milliseconds::zero())
{
std::string buffer(remainingBytes, '\0');
boost::system::error_code errorCode;
try
{
std::size_t bytesRead=boost::asio::read(COMInterface, boost::asio::buffer(buffer),
boost::asio::transfer_at_least(remainingBytes), errorCode);
if(errorCode&&errorCode!=boost::asio::error::eof)
{
ErrorCode=errorCode;
return !readData.empty();
}
buffer.resize(bytesRead);
readData.append(buffer);
return !readData.empty();
}
catch(...)
{
ErrorCode=boost::system::errc::make_error_code(boost::system::errc::io_error);
return !readData.empty();
}
}
else
{
boost::asio::steady_timer timer(Service);
std::string buffer(remainingBytes, '\0');
boost::optional<boost::system::error_code> timerResult, readResult;
std::size_t bytesRead=0;
auto waitLambda=[&](const boost::system::error_code& state)
{
timerResult.reset(state);
};
auto readLambda=[&](const boost::system::error_code& state, std::size_t bytes)
{
readResult.reset(state);
bytesRead=bytes;
};
timer.expires_after(Timeout);
timer.async_wait(waitLambda);
boost::asio::async_read(COMInterface, boost::asio::buffer(buffer, remainingBytes),
boost::asio::transfer_at_least(1), readLambda);
Service.restart();
while(Service.run_one())
{
if(readResult)
{
timer.cancel();
}
else if(timerResult)
{
COMInterface.cancel(ErrorCode);
if(ErrorCode)
{
return !readData.empty();
}
}
}
if(readResult&&*readResult&&*readResult!=boost::asio::error::eof)
{
ErrorCode=*readResult;
return !readData.empty();
}
if(bytesRead > 0)
{
buffer.resize(bytesRead);
readData.append(buffer);
}
}
}
return !readData.empty()||requestedSize==0;
}
else
{
try
{
return readBLECharacteristic(BLEInterface, readData);
}
catch(...)
{
ErrorCode=boost::system::errc::make_error_code(boost::system::errc::io_error);
return false;
}
}
}
bool BTDevice::Read(std::string& readData, char readUntil)
{
ErrorCode.clear();
if(!(isOpened()||(!isOpened()&&Open())))
{
if(!ErrorCode)
{
ErrorCode=boost::system::errc::make_error_code(boost::system::errc::no_such_device);
}
return false;
}
readData.clear();
if(COMInterface.is_open())
{
const std::size_t availableBytes=getAvailableBytes();
if(availableBytes > 0)
{
std::string buffer(availableBytes, '\0');
boost::system::error_code errorCode;
try
{
std::size_t bytesRead=COMInterface.read_some(boost::asio::buffer(buffer), errorCode);
if(errorCode)
{
ErrorCode=errorCode;
return false;
}
buffer.resize(bytesRead);
size_t terminatorPos=buffer.find(readUntil);
if(terminatorPos!=std::string::npos)
{
readData.append(buffer, 0, terminatorPos + 1);
return true;
}
readData.append(buffer);
}
catch(...)
{
ErrorCode=boost::system::errc::make_error_code(boost::system::errc::io_error);
return false;
}
}
if(Timeout==std::chrono::milliseconds::zero())
{
while(true)
{
boost::system::error_code errorCode;
char singleChar;
try
{
size_t bytesRead=boost::asio::read(COMInterface, boost::asio::buffer(&singleChar, 1), errorCode);
if(errorCode)
{
ErrorCode=errorCode;
return !readData.empty();
}
if(bytesRead > 0)
{
readData.push_back(singleChar);
if(singleChar==readUntil)
{
return true;
}
}
}
catch(...)
{
ErrorCode=boost::system::errc::make_error_code(boost::system::errc::io_error);
return !readData.empty();
}
}
}
else
{
boost::asio::steady_timer timer(Service);
bool timeoutOccurred=false;
auto waitLambda=[&](const boost::system::error_code& state)
{
if(!state)
{
timeoutOccurred=true;
COMInterface.cancel(ErrorCode);
}
};
timer.expires_after(Timeout);
timer.async_wait(waitLambda);
while(!timeoutOccurred)
{
boost::optional<boost::system::error_code> readResult;
char singleChar;
bool charRead=false;
auto readLambda=[&](const boost::system::error_code& state, std::size_t bytes)
{
readResult.reset(state);
charRead=(bytes > 0);
};
COMInterface.async_read_some(boost::asio::buffer(&singleChar, 1), readLambda);
Service.restart();
Service.run_one();
if(!readResult||*readResult)
{
if(readResult)
{
ErrorCode=*readResult;
}
break;
}
if(charRead)
{
readData.push_back(singleChar);
if(singleChar==readUntil)
{
timer.cancel();
return true;
}
}
}
}
return !readData.empty();
}
else
{
if(readBLECharacteristic(BLEInterface, readData))
{
size_t terminatorPos=readData.find(readUntil);
if(terminatorPos!=std::string::npos)
{
readData.resize(terminatorPos + 1);
}
return !readData.empty();
}
return false;
}
}
bool BTDevice::Write(const std::string& writeData)
{
ErrorCode.clear();
if(writeData.empty())
{
return true;
}
if(!(isOpened()||(!isOpened()&&Open())))
{
if(!ErrorCode)
{
ErrorCode=boost::system::errc::make_error_code(boost::system::errc::no_such_device);
}
return false;
}
if(COMInterface.is_open())
{
if(Timeout==std::chrono::milliseconds::zero())
{
try
{
size_t bytesWritten=boost::asio::write(COMInterface, boost::asio::buffer(writeData), ErrorCode);
if(ErrorCode)
{
return false;
}
return bytesWritten==writeData.size();
}
catch(...)
{
ErrorCode=boost::system::errc::make_error_code(boost::system::errc::io_error);
return false;
}
}
else
{
boost::asio::steady_timer timer(Service);
boost::optional<boost::system::error_code> timerResult, writeResult;
size_t bytesWritten=0;
timer.expires_after(Timeout);
auto waitLambda=[&](const boost::system::error_code& state)
{
timerResult.reset(state);
};
auto writeLambda=[&](const boost::system::error_code& state, size_t bytes)
{
writeResult.reset(state);
bytesWritten=bytes;
};
timer.async_wait(waitLambda);
boost::asio::async_write(COMInterface, boost::asio::buffer(writeData), writeLambda);
Service.restart();
Service.run();
if(writeResult&&*writeResult)
{
ErrorCode=*writeResult;
return false;
}
if(timerResult&&!writeResult)
{
COMInterface.cancel(ErrorCode);
ErrorCode=boost::system::errc::make_error_code(boost::system::errc::timed_out);
return false;
}
return bytesWritten==writeData.size();
}
}
else
{
try
{
bool success=true;
auto writeLambda=[&]()
{
success=writeBLECharacteristic(BLEInterface, writeData);
if(!success)
{
ErrorCode=boost::system::errc::make_error_code(boost::system::errc::io_error);
}
};
return ExecuteWithTimeout(Timeout, writeLambda)&&success;
}
catch(...)
{
ErrorCode=boost::system::errc::make_error_code(boost::system::errc::io_error);
return false;
}
}
}
bool BTDevice::WriteRead(const std::string& writeData, std::string& readData,
const std::chrono::milliseconds pauseDuration)
{
ErrorCode.clear();
if(!Write(writeData))
{
return false;
}
std::this_thread::sleep_for(pauseDuration);
if(!Write("\n"))
{
return false;
}
std::this_thread::sleep_for(pauseDuration);
return Read(readData);
}
bool BTDevice::WriteRead(const std::string& writeData, std::string& readData, char readUntil,
const std::chrono::milliseconds pauseDuration)
{
ErrorCode.clear();
if(!Write(writeData))
{
return false;
}
std::this_thread::sleep_for(pauseDuration);
if(!Write("\n"))
{
return false;
}
std::this_thread::sleep_for(pauseDuration);
return Read(readData, readUntil);
}
std::size_t BTDevice::getAvailableBytes() const
{
if(!isOpened())
{
return 0;
}
if(COMInterface.is_open())
{
COMSTAT status{};
DWORD errors=0;
auto handle=const_cast<boost::asio::serial_port&>(COMInterface).native_handle();
if(ClearCommError(reinterpret_cast<HANDLE>(handle), &errors, &status))
{
return status.cbInQue;
}
}
else
{
try
{
SimpleBLE::Peripheral& nonConstInterface=const_cast<SimpleBLE::Peripheral&>(BLEInterface);
if(nonConstInterface.is_connected())
{
return getBLEAvailableBytes(nonConstInterface);
}
}
catch(...)
{
}
}
return 0;
}
std::string BTDevice::getDevicePath() const
{
return DevicePath;
}
boost::system::error_code BTDevice::getErrorCode() const
{
return ErrorCode;
}
std::chrono::milliseconds BTDevice::getTimeout() const
{
return Timeout;
}
bool BTDevice::setDevicePath(const std::string& devicePath)
{
ErrorCode.clear();
if(!isValidDevicePath(devicePath))
{
ErrorCode=boost::system::errc::make_error_code(boost::system::errc::invalid_argument);
return false;
}
if(isOpened())
{
if(!Close())
{
return false;
}
}
DevicePath=devicePath;
return true;
}
bool BTDevice::setTimeout(std::chrono::milliseconds waitTimeMs)
{
ErrorCode.clear();
if(!isValidTimeout(waitTimeMs))
{
ErrorCode=boost::system::errc::make_error_code(boost::system::errc::invalid_argument);
return false;
}
Timeout=waitTimeMs;
return true;
}
bool BTDevice::setTimeout(std::chrono::milliseconds::rep waitTimeMs)
{
return setTimeout(std::chrono::milliseconds(waitTimeMs));
}
bool BTDevice::isClosed() const
{
return !isOpened();
}
bool BTDevice::isLowEnergy() const
{
return DevicePath.find("COM")==std::string::npos;
}
bool BTDevice::isOpened() const
{
bool comOpen=COMInterface.is_open();
bool bleOpen=false;
try
{
SimpleBLE::Peripheral& nonConstInterface=const_cast<SimpleBLE::Peripheral&>(BLEInterface);
bleOpen=nonConstInterface.is_connected();
}
catch(...)
{
}
return comOpen||bleOpen;
}
bool BTDevice::isValid() const
{
return isValidDevicePath(DevicePath)&&isValidTimeout(Timeout)&&!ErrorCode;
}
std::string BTDevice::toString() const
{
if(ErrorCode)
{
return Format("Bluetooth device: \"{}\" with timeout of {} ms. with error code \"{}\"",
DevicePath, Timeout.count(), ErrorCode.message());
}
return Format("Bluetooth device: \"{}\" with timeout of {} ms. without an error code",
DevicePath, Timeout.count());
}
std::vector<std::string> BTDevice::getActiveSystemDevices()
{
std::vector<std::string> devices;
std::string nameBuffer(0x3FFF, '\0');
for(std::size_t index=1; index <=255; ++index)
{
std::string portName="COM" + std::to_string(index);
if(QueryDosDevice(portName.c_str(), &nameBuffer[0], static_cast<DWORD>(nameBuffer.size())))
{
const std::string keyPath("HARDWARE\\DEVICEMAP\\SERIALCOMM");
HKEY registryKey;
if(RegOpenKeyEx(HKEY_LOCAL_MACHINE, keyPath.c_str(), 0, KEY_READ, &registryKey)==ERROR_SUCCESS)
{
DWORD totalValues=0;
if(RegQueryInfoKey(registryKey, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr,
&totalValues, nullptr, nullptr, nullptr, nullptr)==ERROR_SUCCESS)
{
for(DWORD i=0; i < totalValues; ++i)
{
std::string value(0x3FFF, '\0'), data(0x3FFF, '\0');
DWORD valueLength=static_cast<DWORD>(value.size());
DWORD dataLength=static_cast<DWORD>(data.size());
if(RegEnumValue(registryKey, i, &value[0], &valueLength, nullptr, nullptr,
reinterpret_cast<LPBYTE>(&data[0]), &dataLength)==ERROR_SUCCESS)
{
value.resize(valueLength);
data.resize(dataLength - 1);
if(value.find("BTHMODE")!=std::string::npos&&data==portName)
{
devices.push_back(portName);
break;
}
}
}
}
RegCloseKey(registryKey);
}
}
}
try
{
auto adapters=SimpleBLE::Adapter::get_adapters();
if(!adapters.empty())
{
auto& adapter=adapters[0];
std::function<void(SimpleBLE::Peripheral)> scanCallback=[&devices](SimpleBLE::Peripheral peripheral)
{
devices.push_back(peripheral.address());
};
adapter.set_callback_on_scan_found(scanCallback);
adapter.scan_for(1000);
}
}
catch(...)
{
}
return devices;
}
std::string BTDevice::getDefaultDevicePath()
{
return std::string{};
}
std::chrono::milliseconds BTDevice::getDefaultTimeout()
{
return std::chrono::milliseconds::zero();
}
bool BTDevice::isValidDevicePath(const std::string& devicePath)
{
if(devicePath.empty())
{
return false;
}
if(devicePath.find("COM")!=std::string::npos)
{
try
{
static const std::regex comRegex("^COM([1-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])$",
std::regex::icase);
return std::regex_match(devicePath, comRegex);
}
catch(...)
{
return devicePath.substr(0, 3)=="COM"&&devicePath.size() > 3;
}
}
try
{
static const std::regex bleRegex("^([0-9A-Fa-f]{2}[:-]){5}([0-9A-Fa-f]{2})$");
return std::regex_match(devicePath, bleRegex);
}
catch(...)
{
return devicePath.size()==17;
}
}
bool BTDevice::isValidTimeout(std::chrono::milliseconds durationMs)
{
return durationMs >=std::chrono::milliseconds::zero();
}
bool BTDevice::isValidTimeout(std::chrono::milliseconds::rep durationMs)
{
return durationMs >=0;
}
bool connectBLEDevice(SimpleBLE::Peripheral& peripheral, const std::string& address)
{
try
{
auto adapters=SimpleBLE::Adapter::get_adapters();
if(adapters.empty())
{
return false;
}
auto& adapter=adapters[0];
bool deviceFound=false;
SimpleBLE::Peripheral targetPeripheral;
std::function<void(SimpleBLE::Peripheral)> scanCallback=[&deviceFound, &targetPeripheral, &address](SimpleBLE::Peripheral p)
{
if(p.address()==address)
{
deviceFound=true;
targetPeripheral=p;
}
};
adapter.set_callback_on_scan_found(scanCallback);
adapter.scan_for(5000);
adapter.scan_stop();
if(!deviceFound)
{
return false;
}
targetPeripheral.connect();
if(!targetPeripheral.is_connected())
{
return false;
}
peripheral=std::move(targetPeripheral);
return true;
}
catch(...)
{
return false;
}
}
bool writeBLECharacteristic(SimpleBLE::Peripheral& peripheral, const std::string& data)
{
if(!peripheral.is_connected())
{
return false;
}
try
{
auto services=peripheral.services();
if(services.empty())
{
return false;
}
auto& service=services[0];
auto characteristics=service.characteristics();
if(characteristics.empty())
{
return false;
}
for(auto& characteristic : characteristics)
{
try
{
std::string bytes(data.begin(), data.end());
peripheral.write_request(service.uuid(), characteristic.uuid(), bytes);
return true;
}
catch(...)
{
continue;
}
}
return false;
}
catch(...)
{
return false;
}
}
bool readBLECharacteristic(SimpleBLE::Peripheral& peripheral, std::string& data)
{
if(!peripheral.is_connected())
{
return false;
}
try
{
auto services=peripheral.services();
if(services.empty())
{
return false;
}
auto& service=services[0];
auto characteristics=service.characteristics();
if(characteristics.empty())
{
return false;
}
for(auto& characteristic : characteristics)
{
try
{
std::string bytes=peripheral.read(service.uuid(), characteristic.uuid());
data=bytes;
return true;
}
catch(...)
{
continue;
}
}
return false;
}
catch(...)
{
return false;
}
}
size_t getBLEAvailableBytes(SimpleBLE::Peripheral& peripheral)
{
if(!peripheral.is_connected())
{
return 0;
}
try
{
auto services=peripheral.services();
if(services.empty())
{
return 0;
}
auto& service=services[0];
auto characteristics=service.characteristics();
if(characteristics.empty())
{
return 0;
}
for(auto& characteristic : characteristics)
{
try
{
auto bytes=peripheral.read(service.uuid(), characteristic.uuid());
return bytes.size();
}
catch(...)
{
continue;
}
}
}
catch(...)
{
}
return 0;
}
}
```
## File: DeviceInterfaceDriver/BTDevice.hpp
```
#ifndef BTDevice_H
#define BTDevice_H
#include <boost/asio.hpp>
#include <simpleble/SimpleBLE.h>
#include "Device.hpp"
#include "Utility.hpp"
namespace Cognitive
{
class BTDevice : public Device
{
public:
BTDevice();
~BTDevice();
BTDevice(const BTDevice&)=delete;
BTDevice(BTDevice&&moveValue);
BTDevice& operator=(const BTDevice&)=delete;
BTDevice& operator=(BTDevice&&moveValue);
bool Close();
bool Flush();
bool Open();
bool Reopen();
bool Reset();
bool Read(std::string& readData);
bool Read(std::string& readData, char readUntil);
bool Write(const std::string& writeData);
bool WriteRead(const std::string& writeData, std::string& readData,
const std::chrono::milliseconds pauseDuration=std::chrono::milliseconds{50});
bool WriteRead(const std::string& writeData, std::string& readData, char readUntil,
const std::chrono::milliseconds pauseDuration=std::chrono::milliseconds{50});
std::size_t getAvailableBytes() const;
std::string getDevicePath() const;
boost::system::error_code getErrorCode() const;
std::chrono::milliseconds getTimeout() const;
bool setDevicePath(const std::string& devicePath);
bool setTimeout(std::chrono::milliseconds waitTimeMs);
bool setTimeout(std::chrono::milliseconds::rep waitTimeMs);
bool isClosed() const;
bool isLowEnergy() const;
bool isOpened() const;
bool isValid() const;
std::string toString() const;
static std::vector<std::string> getActiveSystemDevices();
static std::string getDefaultDevicePath();
static std::chrono::milliseconds getDefaultTimeout();
static bool isValidDevicePath(const std::string& devicePath);
static bool isValidTimeout(std::chrono::milliseconds durationMs);
static bool isValidTimeout(std::chrono::milliseconds::rep durationMs);
private:
boost::asio::io_context Service;
SimpleBLE::Peripheral BLEInterface;
boost::asio::serial_port COMInterface;
boost::system::error_code ErrorCode;
std::chrono::milliseconds Timeout;
std::string DevicePath;
};
}
#endif
```
## File: DeviceInterfaceDriver/COMDevice.cpp
```cpp
#include "COMDevice.hpp"
#include <boost/optional.hpp>
#include <regex>
#include <shlwapi.h>
namespace Cognitive
{
COMDevice::COMDevice() : Service{}, Interface{Service}, ErrorCode{}, Timeout{getDefaultTimeout()},
PortName{getDefaultPortName()}, BaudRate{getDefaultBaudRate()}, CharSize{getDefaultCharSize()},
FlowControl{getDefaultFlowControl()}, Parity{getDefaultParity()}, StopBits{getDefaultStopBits()}
{
}
COMDevice::~COMDevice()
{
Close();
Reset();
}
COMDevice::COMDevice(COMDevice&&moveValue) : Service{}, Interface{Service}, ErrorCode{moveValue.ErrorCode},
Timeout{std::exchange(moveValue.Timeout, getDefaultTimeout())}, PortName{std::move(moveValue.PortName)},
BaudRate{std::exchange(moveValue.BaudRate, getDefaultBaudRate())},
CharSize{std::exchange(moveValue.CharSize, getDefaultCharSize())},
FlowControl{std::exchange(moveValue.FlowControl, getDefaultFlowControl())},
Parity{std::exchange(moveValue.Parity, getDefaultParity())},
StopBits{std::exchange(moveValue.StopBits, getDefaultStopBits())}
{
moveValue.ErrorCode.clear();
if(moveValue.Interface.is_open())
{
if(Interface.is_open())
{
Interface.close(ErrorCode);
}
PortName=std::move(moveValue.PortName);
if(!Open())
{
ErrorCode=boost::system::errc::make_error_code(boost::system::errc::io_error);
}
moveValue.Interface.close();
}
}
COMDevice& COMDevice::operator=(COMDevice&&moveValue)
{
if(this!=&moveValue)
{
Close();
Interface=std::move(moveValue.Interface);
ErrorCode=moveValue.ErrorCode;
Timeout=std::exchange(moveValue.Timeout, getDefaultTimeout());
PortName=std::move(moveValue.PortName);
BaudRate=std::exchange(moveValue.BaudRate, getDefaultBaudRate());
CharSize=std::exchange(moveValue.CharSize, getDefaultCharSize());
FlowControl=std::exchange(moveValue.FlowControl, getDefaultFlowControl());
Parity=std::exchange(moveValue.Parity, getDefaultParity());
StopBits=std::exchange(moveValue.StopBits, getDefaultStopBits());
moveValue.ErrorCode.clear();
if(moveValue.Interface.is_open())
{
if(!Open())
{
ErrorCode=boost::system::errc::make_error_code(boost::system::errc::io_error);
}
moveValue.Interface.close();
}
}
return *this;
}
bool COMDevice::Close()
{
ErrorCode.clear();
if(!Interface.is_open())
{
return true;
}
Interface.cancel(ErrorCode);
auto closeLambda=[&]()
{
Interface.close(ErrorCode);
};
const bool success=ExecuteWithTimeout(Timeout, closeLambda);
return success&&!ErrorCode;
}
bool COMDevice::Flush()
{
ErrorCode.clear();
if(!Interface.is_open()&&!Open())
{
if(!ErrorCode)
{
ErrorCode=boost::system::errc::make_error_code(boost::system::errc::no_such_device);
}
return false;
}
const BOOL result=PurgeComm(reinterpret_cast<HANDLE>(Interface.native_handle()),
PURGE_RXABORT | PURGE_TXABORT | PURGE_RXCLEAR | PURGE_TXCLEAR);
return result==TRUE;
}
bool COMDevice::Open()
{
ErrorCode.clear();
if(!isValid())
{
ErrorCode=boost::system::errc::make_error_code(boost::system::errc::invalid_argument);
return false;
}
if(Interface.is_open())
{
return true;
}
if(Interface.is_open())
{
Interface.close(ErrorCode);
if(ErrorCode)
{
return false;
}
}
Interface=boost::asio::serial_port(Service);
const bool attemptOpen=ExecuteWithTimeout(Timeout, [&]()
{
Interface.open(PortName, ErrorCode);
});
if(!attemptOpen||ErrorCode||!Interface.is_open())
{
Close();
return false;
}
if(Interface.set_option(BaudRate, ErrorCode)||Interface.set_option(CharSize, ErrorCode)||Interface.set_option(FlowControl, ErrorCode)||Interface.set_option(Parity, ErrorCode)||Interface.set_option(StopBits, ErrorCode))
{
Close();
return false;
}
return true;
}
bool COMDevice::Reopen()
{
ErrorCode.clear();
if(isOpened()&&!Close())
{
return false;
}
return Open();
}
bool COMDevice::Reset()
{
ErrorCode.clear();
if(Interface.is_open())
{
Interface.close(ErrorCode);
}
Interface=boost::asio::serial_port(Service);
Timeout=getDefaultTimeout();
PortName.assign(getDefaultPortName());
BaudRate=getDefaultBaudRate();
CharSize=getDefaultCharSize();
FlowControl=getDefaultFlowControl();
Parity=getDefaultParity();
StopBits=getDefaultStopBits();
return !ErrorCode;
}
bool COMDevice::Read(std::string& readData)
{
ErrorCode.clear();
if(!(Interface.is_open()||(!Interface.is_open()&&Open())))
{
if(!ErrorCode)
{
ErrorCode=boost::system::errc::make_error_code(boost::system::errc::no_such_device);
}
return false;
}
const std::size_t requestedSize=readData.size();
if(requestedSize==0)
{
std::size_t available=getAvailableBytes();
if(available > 0)
{
readData.resize(available);
}
else
{
return true;
}
}
readData.clear();
const std::size_t availableBytes=getAvailableBytes();
if(availableBytes > 0)
{
const std::size_t bytesToRead=std::min(availableBytes, requestedSize);
std::string buffer(bytesToRead, '\0');
boost::system::error_code errorCode;
try
{
std::size_t bytesRead=Interface.read_some(boost::asio::buffer(buffer), errorCode);
if(errorCode)
{
ErrorCode=errorCode;
return false;
}
buffer.resize(bytesRead);
readData.append(buffer);
if(readData.size() >=requestedSize)
{
return true;
}
}
catch(...)
{
ErrorCode=boost::system::errc::make_error_code(boost::system::errc::io_error);
return false;
}
}
const std::size_t remainingBytes=requestedSize - readData.size();
if(remainingBytes > 0)
{
if(Timeout==std::chrono::milliseconds::zero())
{
const std::size_t remainingBytes=requestedSize - readData.size();
std::string buffer(remainingBytes, '\0');
boost::system::error_code errorCode;
try
{
std::size_t bytesRead=boost::asio::read(Interface, boost::asio::buffer(buffer),
boost::asio::transfer_at_least(remainingBytes), errorCode);
if(errorCode&&errorCode!=boost::asio::error::eof)
{
ErrorCode=errorCode;
return !readData.empty();
}
buffer.resize(bytesRead);
readData.append(buffer);
return !readData.empty();
}
catch(...)
{
ErrorCode=boost::system::errc::make_error_code(boost::system::errc::io_error);
return !readData.empty();
}
}
else
{
boost::asio::steady_timer timer(Service);
std::string buffer(remainingBytes, '\0');
boost::optional<boost::system::error_code> timerResult, readResult;
std::size_t bytesRead=0;
auto waitLambda=[&](const boost::system::error_code& state)
{
timerResult.reset(state);
};
auto readLambda=[&](const boost::system::error_code& state, std::size_t bytes)
{
readResult.reset(state);
bytesRead=bytes;
};
timer.expires_after(Timeout);
timer.async_wait(waitLambda);
boost::asio::async_read(Interface, boost::asio::buffer(buffer, remainingBytes),
boost::asio::transfer_at_least(1), readLambda);
Service.restart();
while(Service.run_one())
{
if(readResult)
{
timer.cancel();
}
else if(timerResult)
{
Interface.cancel(ErrorCode);
if(ErrorCode)
{
return !readData.empty();
}
}
}
if(readResult&&*readResult&&*readResult!=boost::asio::error::eof)
{
ErrorCode=*readResult;
return !readData.empty();
}
if(bytesRead > 0)
{
buffer.resize(bytesRead);
readData.append(buffer);
}
}
}
return !readData.empty()||requestedSize==0;
}
bool COMDevice::Read(std::string& readData, char readUntil)
{
ErrorCode.clear();
if(!(Interface.is_open()||(!Interface.is_open()&&Open())))
{
if(!ErrorCode)
{
ErrorCode=boost::system::errc::make_error_code(boost::system::errc::no_such_device);
}
return false;
}
Clear(readData);
const std::size_t availableBytes=getAvailableBytes();
if(availableBytes > 0)
{
std::string buffer(availableBytes, '\0');
boost::system::error_code errorCode;
try
{
std::size_t bytesRead=Interface.read_some(boost::asio::buffer(buffer), errorCode);
if(errorCode)
{
ErrorCode=errorCode;
return false;
}
size_t terminatorPos=Resize(buffer, bytesRead).find(readUntil);
if(terminatorPos!=std::string::npos)
{
readData.append(buffer, 0, terminatorPos + 1);
return true;
}
readData.append(buffer);
}
catch(...)
{
ErrorCode=boost::system::errc::make_error_code(boost::system::errc::io_error);
return false;
}
}
if(Timeout==std::chrono::milliseconds::zero())
{
while(true)
{
boost::system::error_code errorCode;
char singleChar;
try
{
size_t bytesRead=boost::asio::read(Interface, boost::asio::buffer(&singleChar, 1), errorCode);
if(errorCode)
{
ErrorCode=errorCode;
return !readData.empty();
}
if(bytesRead > 0)
{
readData.push_back(singleChar);
if(singleChar==readUntil)
{
return true;
}
}
}
catch(...)
{
ErrorCode=boost::system::errc::make_error_code(boost::system::errc::io_error);
return !readData.empty();
}
}
}
else
{
boost::asio::steady_timer timer(Service);
bool timeoutOccurred=false;
auto waitLambda=[&](const boost::system::error_code& state)
{
if(!state)
{
timeoutOccurred=true;
Interface.cancel(ErrorCode);
}
};
timer.expires_after(Timeout);
timer.async_wait(waitLambda);
while(!timeoutOccurred)
{
boost::optional<boost::system::error_code> readResult;
char singleChar;
bool charRead=false;
auto readLambda=[&](const boost::system::error_code& state, std::size_t bytes)
{
readResult.reset(state);
charRead=(bytes > 0);
};
Interface.async_read_some(boost::asio::buffer(&singleChar, 1), readLambda);
Service.restart();
Service.run_one();
if(!readResult||*readResult)
{
ErrorCode=*readResult;
break;
}
if(charRead)
{
readData.push_back(singleChar);
if(singleChar==readUntil)
{
timer.cancel();
return true;
}
}
}
}
return !readData.empty();
}
bool COMDevice::WriteRead(const std::string& writeData, std::string& readData,
const std::chrono::milliseconds pauseDuration)
{
ErrorCode.clear();
if(!Write(writeData))
{
return false;
}
BlockThread(pauseDuration);
if(!Write("\n"))
{
return false;
}
BlockThread(pauseDuration);
return Read(readData);
}
bool COMDevice::WriteRead(const std::string& writeData, std::string& readData, char readUntil,
const std::chrono::milliseconds pauseDuration)
{
ErrorCode.clear();
if(!Write(writeData))
{
return false;
}
BlockThread(pauseDuration);
if(!Write("\n"))
{
return false;
}
BlockThread(pauseDuration);
return Read(readData, readUntil);
}
bool COMDevice::Write(const std::string& writeData)
{
ErrorCode.clear();
if(writeData.empty())
{
return true;
}
if(!(Interface.is_open()||(!Interface.is_open()&&Open())))
{
if(!ErrorCode)
{
ErrorCode=boost::system::errc::make_error_code(boost::system::errc::no_such_device);
}
return false;
}
if(Timeout==std::chrono::milliseconds::zero())
{
try
{
size_t bytesWritten=boost::asio::write(Interface, boost::asio::buffer(writeData), ErrorCode);
if(ErrorCode)
{
return false;
}
return bytesWritten==writeData.size();
}
catch(...)
{
ErrorCode=boost::system::errc::make_error_code(boost::system::errc::io_error);
return false;
}
}
else
{
boost::asio::steady_timer timer(Service);
boost::optional<boost::system::error_code> timerResult, writeResult;
size_t bytesWritten=0;
timer.expires_after(Timeout);
auto waitLambda=[&](const boost::system::error_code& state)
{
timerResult.reset(state);
};
auto writeLambda=[&](const boost::system::error_code& state, size_t bytes)
{
writeResult.reset(state);
bytesWritten=bytes;
};
timer.async_wait(waitLambda);
boost::asio::async_write(Interface, boost::asio::buffer(writeData), writeLambda);
Service.restart();
Service.run();
if(writeResult&&*writeResult)
{
ErrorCode=*writeResult;
return false;
}
if(timerResult&&!writeResult)
{
Interface.cancel(ErrorCode);
ErrorCode=boost::system::errc::make_error_code(boost::system::errc::timed_out);
return false;
}
return bytesWritten==writeData.size();
}
}
std::size_t COMDevice::getAvailableBytes() const
{
if(Interface.is_open())
{
COMSTAT status{};
DWORD errors=0;
auto handle=const_cast<boost::asio::serial_port&>(Interface).native_handle();
if(ClearCommError(reinterpret_cast<HANDLE>(handle), &errors, &status))
{
return status.cbInQue;
}
}
return 0;
}
std::string COMDevice::getPortName() const
{
return PortName;
}
COMDevice::Option::baud_rate COMDevice::getBaudRate() const
{
return BaudRate;
}
COMDevice::Option::character_size COMDevice::getCharSize() const
{
return CharSize;
}
COMDevice::Option::flow_control COMDevice::getFlowControl() const
{
return FlowControl;
}
COMDevice::Option::parity COMDevice::getParity() const
{
return Parity;
}
COMDevice::Option::stop_bits COMDevice::getStopBits() const
{
return StopBits;
}
boost::system::error_code COMDevice::getErrorCode() const
{
return ErrorCode;
}
std::chrono::milliseconds COMDevice::getTimeout() const
{
return Timeout;
}
bool COMDevice::setPortName(const std::string& portName)
{
ErrorCode.clear();
if(!isValidPortName(portName))
{
ErrorCode=boost::system::errc::make_error_code(boost::system::errc::invalid_argument);
return false;
}
if(isOpened())
{
if(!Close())
{
return false;
}
}
PortName.assign(portName);
return true;
}
bool COMDevice::setBaudRate(Option::baud_rate baudRate)
{
ErrorCode.clear();
if(!isValidBaudRate(baudRate))
{
ErrorCode=boost::system::errc::make_error_code(boost::system::errc::invalid_argument);
return false;
}
BaudRate=baudRate;
if(Interface.is_open())
{
Interface.set_option(BaudRate, ErrorCode);
return !ErrorCode;
}
return true;
}
bool COMDevice::setBaudRate(std::uint32_t baudRate)
{
return setBaudRate(Option::baud_rate(baudRate));
}
bool COMDevice::setCharSize(Option::character_size charSize)
{
ErrorCode.clear();
if(!isValidCharSize(charSize))
{
ErrorCode=boost::system::errc::make_error_code(boost::system::errc::invalid_argument);
return false;
}
CharSize=charSize;
if(Interface.is_open())
{
Interface.set_option(CharSize, ErrorCode);
return !ErrorCode;
}
return true;
}
bool COMDevice::setCharSize(std::uint8_t charSize)
{
return setCharSize(Option::character_size(charSize));
}
bool COMDevice::setFlowControl(Option::flow_control flowControl)
{
ErrorCode.clear();
if(!isValidFlowControl(flowControl))
{
ErrorCode=boost::system::errc::make_error_code(boost::system::errc::invalid_argument);
return false;
}
FlowControl=flowControl;
if(Interface.is_open())
{
Interface.set_option(FlowControl, ErrorCode);
return !ErrorCode;
}
return true;
}
bool COMDevice::setParity(Option::parity parity)
{
ErrorCode.clear();
if(!isValidParity(parity))
{
ErrorCode=boost::system::errc::make_error_code(boost::system::errc::invalid_argument);
return false;
}
Parity=parity;
if(Interface.is_open())
{
Interface.set_option(Parity, ErrorCode);
return !ErrorCode;
}
return true;
}
bool COMDevice::setStopBits(Option::stop_bits stopBits)
{
ErrorCode.clear();
if(!isValidStopBits(stopBits))
{
ErrorCode=boost::system::errc::make_error_code(boost::system::errc::invalid_argument);
return false;
}
StopBits=stopBits;
if(Interface.is_open())
{
Interface.set_option(StopBits, ErrorCode);
return !ErrorCode;
}
return true;
}
bool COMDevice::setTimeout(std::chrono::milliseconds durationMs)
{
ErrorCode.clear();
if(!isValidTimeout(durationMs))
{
ErrorCode=boost::system::errc::make_error_code(boost::system::errc::invalid_argument);
return false;
}
Timeout=durationMs;
return true;
}
bool COMDevice::setTimeout(std::chrono::milliseconds::rep durationMs)
{
return setTimeout(std::chrono::milliseconds(durationMs));
}
std::string COMDevice::toString() const
{
constexpr std::array<std::string_view, 4> flowControlStrings={"no", "hardware", "software", "unknown"},
parityStrings={"no", "even", "odd", "unknown"}, stopBitsStrings={"one", "1.5", "two", "unknown"};
const std::string flowControl{flowControlStrings.at(static_cast<std::size_t>(FlowControl.value()))},
parity{parityStrings.at(static_cast<std::size_t>(Parity.value()))},
stopBits{stopBitsStrings.at(static_cast<std::size_t>(StopBits.value()))};
if(ErrorCode)
{
return Format("COM device: \"{}\" with {} baud rate, {} character bits, {} flow control, {} parity, "
"{} stop bits, and a timeout of {} ms. with error code \"{}\"", PortName, BaudRate.value(),
CharSize.value(), flowControl, parity, stopBits, Timeout.count(), ErrorCode.message());
}
return Format("COM device: \"{}\" with {} baud rate, {} character bits, {} flow control, {} parity, "
"{} stop bits, and a timeout of {} ms. without an error code", PortName, BaudRate.value(),
CharSize.value(), flowControl, parity, stopBits, Timeout.count());
}
bool COMDevice::isClosed() const
{
return !Interface.is_open();
}
bool COMDevice::isOpened() const
{
return Interface.is_open();
}
bool COMDevice::isValid() const
{
return isValidTimeout(Timeout)&&isValidBaudRate(BaudRate)&&isValidCharSize(CharSize)&&isValidParity(Parity)&&isValidFlowControl(FlowControl)&&isValidPortName(PortName)&&isValidStopBits(StopBits)&&!ErrorCode;
}
std::vector<std::string> COMDevice::getActiveSystemPorts()
{
std::vector<std::string> validPorts, resultPorts;
std::string nameBuffer(0x3FFF, '\0'), validName;
for(std::size_t index=1; index <=256; ++index)
{
validName.assign("COM" + std::to_string(index));
if(QueryDosDevice(validName.c_str(), nameBuffer.data(), static_cast<DWORD>(nameBuffer.size())))
validPorts.emplace_back(std::move(validName));
}
Clear(nameBuffer);
Clear(validName);
if(!validPorts.empty())
{
const std::string keyPath("HARDWARE\\DEVICEMAP\\SERIALCOMM");
std::size_t resultPortsCount=validPorts.size();
DWORD totalValues=0, errorCode=0;
HKEY registryKey;
if(RegOpenKeyEx(HKEY_LOCAL_MACHINE, keyPath.data(), 0, KEY_READ, &registryKey)==ERROR_SUCCESS)
{
errorCode=RegQueryInfoKey(registryKey, nullptr, nullptr, nullptr, nullptr,
nullptr, nullptr, &totalValues, nullptr, nullptr, nullptr, nullptr);
if(errorCode==ERROR_SUCCESS)
{
for(DWORD index=0; index < totalValues&&resultPortsCount > 0; ++index)
{
std::string value(0x3FFF, '\0'), data(value);
DWORD valueLength=static_cast<DWORD>(value.size()), dataLength=static_cast<DWORD>(data.size());
if(RegEnumValue(registryKey, index, value.data(), &valueLength, nullptr, nullptr,
reinterpret_cast<LPBYTE>(data.data()), &dataLength)==ERROR_SUCCESS&&dataLength > 0)
{
Resize(data, dataLength - 1);
Resize(value, valueLength);
if(StrStrI(value.data(), "BTHMODE")!=nullptr)
{
for(std::size_t port=0; port < validPorts.size()&&resultPortsCount > 0; ++port)
{
if(data==validPorts.at(port))
{
Clear(validPorts.at(port));
--resultPortsCount;
}
}
}
}
}
}
RegCloseKey(registryKey);
}
if(resultPortsCount==validPorts.size())
{
return validPorts;
}
if(resultPortsCount > 0)
{
resultPorts.reserve(resultPortsCount);
for(std::string& port : validPorts)
{
if(!port.empty())
{
resultPorts.emplace_back(std::move(port));
}
}
}
}
return resultPorts;
}
COMDevice::Option::baud_rate COMDevice::getDefaultBaudRate()
{
return COMDevice::Option::baud_rate(115200);
}
COMDevice::Option::character_size COMDevice::getDefaultCharSize()
{
return COMDevice::Option::character_size(8);
}
COMDevice::Option::flow_control COMDevice::getDefaultFlowControl()
{
return COMDevice::Option::flow_control(COMDevice::Option::flow_control::none);
}
COMDevice::Option::parity COMDevice::getDefaultParity()
{
return COMDevice::Option::parity(COMDevice::Option::parity::none);
}
std::string COMDevice::getDefaultPortName()
{
return std::string{};
}
COMDevice::Option::stop_bits COMDevice::getDefaultStopBits()
{
return COMDevice::Option::stop_bits(COMDevice::Option::stop_bits::one);
}
std::chrono::milliseconds COMDevice::getDefaultTimeout()
{
return std::chrono::milliseconds::zero();
}
bool COMDevice::isValidBaudRate(Option::baud_rate baudRate)
{
return isValidBaudRate(baudRate.value());
}
bool COMDevice::isValidBaudRate(std::uint32_t baudRate)
{
return baudRate > 0&&baudRate <=921600;
}
bool COMDevice::isValidCharSize(Option::character_size charSize)
{
return isValidCharSize(charSize.value());
}
bool COMDevice::isValidCharSize(std::uint8_t charSize)
{
return charSize >=5&&charSize <=8;
}
bool COMDevice::isValidFlowControl(Option::flow_control flowControl)
{
return (flowControl.value()==Option::flow_control::none)||(flowControl.value()==Option::flow_control::software)||(flowControl.value()==Option::flow_control::hardware);
}
bool COMDevice::isValidParity(Option::parity parity)
{
return (parity.value()==Option::parity::none)||(parity.value()==Option::parity::odd)||(parity.value()==Option::parity::even);
}
bool COMDevice::isValidPortName(const std::string& portName)
{
if(portName.size() < 4)
{
return false;
}
return std::regex_match(portName, std::regex("^(\\\\\\\\[.]\\\\)?COM([1-9]|[1-8][0-9]"
"|9[0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])$", std::regex_constants::icase));
}
bool COMDevice::isValidStopBits(Option::stop_bits stopBits)
{
return (stopBits.value()==Option::stop_bits::one)||(stopBits.value()==Option::stop_bits::onepointfive)||(stopBits.value()==Option::stop_bits::two);
}
bool COMDevice::isValidTimeout(std::chrono::milliseconds durationMs)
{
return durationMs >=std::chrono::milliseconds::zero();
}
bool COMDevice::isValidTimeout(std::chrono::milliseconds::rep durationMs)
{
return durationMs >=0;
}
}
```
## File: DeviceInterfaceDriver/COMDevice.hpp
```
#ifndef COMDevice_H
#define COMDevice_H
#include <boost/asio.hpp>
#include "Device.hpp"
#include "Utility.hpp"
namespace Cognitive
{
class COMDevice : public Device
{
public:
using Option=boost::asio::serial_port_base;
COMDevice();
~COMDevice();
COMDevice(COMDevice&&moveValue);
COMDevice& operator=(COMDevice&&moveValue);
COMDevice(const COMDevice&)=delete;
COMDevice& operator=(const COMDevice&)=delete;
bool Close();
bool Flush();
bool Open();
bool Reopen();
bool Reset();
bool Read(std::string& readData);
bool Read(std::string& readData, char readUntil);
bool Write(const std::string& writeData);
bool WriteRead(const std::string& writeData, std::string& readData,
const std::chrono::milliseconds pauseDuration=std::chrono::milliseconds{50});
bool WriteRead(const std::string& writeData, std::string& readData, char readUntil,
const std::chrono::milliseconds pauseDuration=std::chrono::milliseconds{50});
std::size_t getAvailableBytes() const;
std::string getPortName() const;
Option::baud_rate getBaudRate() const;
Option::character_size getCharSize() const;
Option::flow_control getFlowControl() const;
Option::parity getParity() const;
Option::stop_bits getStopBits() const;
boost::system::error_code getErrorCode() const;
std::chrono::milliseconds getTimeout() const;
bool setPortName(const std::string& portName);
bool setBaudRate(Option::baud_rate baudRate);
bool setBaudRate(std::uint32_t baudRate);
bool setCharSize(Option::character_size charSize);
bool setCharSize(std::uint8_t charSize);
bool setFlowControl(Option::flow_control flowControl);
bool setParity(Option::parity parity);
bool setStopBits(Option::stop_bits stopBits);
bool setTimeout(std::chrono::milliseconds durationMs);
bool setTimeout(std::chrono::milliseconds::rep durationMs);
bool isClosed() const;
bool isOpened() const;
bool isValid() const;
std::string toString() const;
static std::vector<std::string> getActiveSystemPorts();
static Option::baud_rate getDefaultBaudRate();
static Option::character_size getDefaultCharSize();
static Option::flow_control getDefaultFlowControl();
static Option::parity getDefaultParity();
static std::string getDefaultPortName();
static Option::stop_bits getDefaultStopBits();
static std::chrono::milliseconds getDefaultTimeout();
static bool isValidBaudRate(Option::baud_rate baudRate);
static bool isValidBaudRate(std::uint32_t baudRate);
static bool isValidCharSize(Option::character_size charSize);
static bool isValidCharSize(std::uint8_t charSize);
static bool isValidFlowControl(Option::flow_control flowControl);
static bool isValidParity(Option::parity parity);
static bool isValidPortName(const std::string& portName);
static bool isValidStopBits(Option::stop_bits stopBits);
static bool isValidTimeout(std::chrono::milliseconds durationMs);
static bool isValidTimeout(std::chrono::milliseconds::rep durationMs);
private:
boost::asio::io_context Service;
boost::asio::serial_port Interface;
boost::system::error_code ErrorCode;
std::chrono::milliseconds Timeout;
std::string PortName;
Option::baud_rate BaudRate;
Option::character_size CharSize;
Option::flow_control FlowControl;
Option::parity Parity;
Option::stop_bits StopBits;
};
}
#endif
```
## File: DeviceInterfaceDriver/Device.cpp
```cpp
#include "Device.hpp"
```
## File: DeviceInterfaceDriver/Device.hpp
```
#ifndef Device_H
#define Device_H
#include <boost/system/error_code.hpp>
#include <chrono>
#include <string>
#include <vector>
namespace Cognitive
{
class Device
{
public:
Device()=default;
virtual ~Device()=default;
Device(const Device&)=delete;
Device(Device&&)=delete;
Device& operator=(const Device&)=delete;
Device& operator=(Device&&)=delete;
virtual bool Close()=0;
virtual bool Flush()=0;
virtual bool Open()=0;
virtual bool Reopen()=0;
virtual bool Reset()=0;
virtual bool Read(std::string& readData)=0;
virtual bool Read(std::string& readData, char readUntil)=0;
virtual bool Write(const std::string& writeData)=0;
virtual bool WriteRead(const std::string& writeData, std::string& readData,
const std::chrono::milliseconds pauseDuration=std::chrono::milliseconds{50})=0;
virtual bool WriteRead(const std::string& writeData, std::string& readData, char readUntil,
const std::chrono::milliseconds pauseDuration=std::chrono::milliseconds{50})=0;
virtual std::size_t getAvailableBytes() const=0;
virtual boost::system::error_code getErrorCode() const=0;
virtual std::chrono::milliseconds getTimeout() const=0;
virtual bool setTimeout(std::chrono::milliseconds waitTimeMs)=0;
virtual bool setTimeout(std::chrono::milliseconds::rep waitTimeMs)=0;
virtual bool isClosed() const=0;
virtual bool isOpened() const=0;
virtual bool isValid() const=0;
virtual std::string toString() const=0;
};
}
#endif
```
## File: DeviceInterfaceDriver/LANDevice.cpp
```cpp
#include "LANDevice.hpp"
#include <boost/optional.hpp>
#include <regex>
namespace Cognitive
{
LANDevice::LANDevice() : Service{}, Interface{Service}, ErrorCode{},
Timeout{getDefaultTimeout()}, Address{getDefaultAddress()}, Port{getDefaultPort()}
{
}
LANDevice::~LANDevice()
{
Close();
Reset();
}
LANDevice::LANDevice(LANDevice&&moveValue) : Service{}, Interface{Service}, ErrorCode{moveValue.ErrorCode},
Timeout{std::exchange(moveValue.Timeout, getDefaultTimeout())}, Address{std::move(moveValue.Address)},
Port{std::exchange(moveValue.Port, getDefaultPort())}
{
moveValue.ErrorCode.clear();
if(moveValue.Interface.is_open())
{
if(Interface.is_open())
{
Interface.close(ErrorCode);
}
Address=std::move(moveValue.Address);
Port=moveValue.Port;
if(!Open())
{
ErrorCode=boost::system::errc::make_error_code(boost::system::errc::io_error);
}
moveValue.Interface.close();
}
}
LANDevice& LANDevice::operator=(LANDevice&&moveValue)
{
if(this!=&moveValue)
{
Close();
ErrorCode=moveValue.ErrorCode;
Timeout=std::exchange(moveValue.Timeout, getDefaultTimeout());
Address=std::move(moveValue.Address);
Port=std::exchange(moveValue.Port, getDefaultPort());
moveValue.ErrorCode.clear();
if(moveValue.Interface.is_open())
{
if(!Open())
{
ErrorCode=boost::system::errc::make_error_code(boost::system::errc::io_error);
}
moveValue.Interface.close();
}
}
return *this;
}
bool LANDevice::Close()
{
ErrorCode.clear();
if(!Interface.is_open())
{
return true;
}
Interface.cancel(ErrorCode);
const bool success=ExecuteWithTimeout(Timeout, [&]()
{
Interface.close(ErrorCode);
});
return success&&!ErrorCode;
}
bool LANDevice::Flush()
{
ErrorCode.clear();
if(!Interface.is_open()&&!Open())
{
if(!ErrorCode)
{
ErrorCode=boost::system::errc::make_error_code(boost::system::errc::no_such_device);
}
return false;
}
std::size_t available=getAvailableBytes();
if(available > 0)
{
std::string buffer(available, '\0');
boost::system::error_code tempError;
Interface.read_some(boost::asio::buffer(buffer), tempError);
}
return true;
}
bool LANDevice::Open()
{
ErrorCode.clear();
if(!isValid())
{
ErrorCode=boost::system::errc::make_error_code(boost::system::errc::invalid_argument);
return false;
}
if(Interface.is_open())
{
return true;
}
if(Interface.is_open())
{
Interface.close(ErrorCode);
if(ErrorCode)
{
return false;
}
}
Interface=boost::asio::ip::tcp::socket(Service);
boost::asio::ip::address address;
try
{
address=boost::asio::ip::make_address(Address=="localhost" ? "127.0.0.1" : Address);
}
catch(const boost::system::system_error& errorStatus)
{
ErrorCode=errorStatus.code();
return false;
}
boost::asio::ip::tcp::endpoint endpoint(address, Port);
if(Timeout==std::chrono::milliseconds::zero())
{
Interface.connect(endpoint, ErrorCode);
if(ErrorCode)
{
Interface.close();
return false;
}
}
else
{
boost::optional<boost::system::error_code> timerResult, connectResult;
boost::asio::steady_timer timer(Service, Timeout);
timer.async_wait([&](const boost::system::error_code& state)
{
timerResult.reset(state);
if(!state&&!connectResult)
{
Interface.cancel();
}
});
Interface.async_connect(endpoint, [&](const boost::system::error_code& state)
{
connectResult.reset(state);
timer.cancel();
});
Service.restart();
Service.run();
if(!connectResult||*connectResult)
{
ErrorCode=connectResult ? *connectResult
: boost::system::errc::make_error_code(boost::system::errc::timed_out);
Interface.close();
return false;
}
}
return true;
}
bool LANDevice::Reopen()
{
ErrorCode.clear();
if(isOpened()&&!Close())
{
return false;
}
return Open();
}
bool LANDevice::Reset()
{
ErrorCode.clear();
if(Interface.is_open())
{
Interface.close(ErrorCode);
}
Interface=boost::asio::ip::tcp::socket(Service);
Timeout=getDefaultTimeout();
Address.assign(getDefaultAddress());
Port=getDefaultPort();
return !ErrorCode;
}
bool LANDevice::Read(std::string& readData)
{
ErrorCode.clear();
if(!(Interface.is_open()||(!Interface.is_open()&&Open())))
{
if(!ErrorCode)
{
ErrorCode=boost::system::errc::make_error_code(boost::system::errc::no_such_device);
}
return false;
}
const std::size_t requestedSize=readData.size();
if(requestedSize==0)
{
std::size_t available=getAvailableBytes();
if(available > 0)
{
readData.resize(available);
}
else
{
return true;
}
}
Clear(readData);
const std::size_t availableBytes=getAvailableBytes();
if(availableBytes > 0)
{
const std::size_t bytesToRead=std::min(availableBytes, requestedSize);
std::string buffer(bytesToRead, '\0');
std::size_t bytesRead=0;
try
{
bytesRead=Interface.read_some(boost::asio::buffer(buffer), ErrorCode);
if(ErrorCode)
{
return false;
}
Resize(buffer, bytesRead);
readData.append(buffer);
if(readData.size() >=requestedSize)
{
return true;
}
}
catch(...)
{
ErrorCode=boost::system::errc::make_error_code(boost::system::errc::io_error);
return false;
}
}
const std::size_t remainingBytes=requestedSize - readData.size();
if(remainingBytes > 0)
{
std::string buffer(remainingBytes, '\0');
if(Timeout==std::chrono::milliseconds::zero())
{
try
{
std::size_t bytesRead=boost::asio::read(Interface, boost::asio::buffer(buffer),
boost::asio::transfer_at_least(remainingBytes), ErrorCode);
if(ErrorCode&&ErrorCode!=boost::asio::error::eof)
{
return !readData.empty();
}
buffer.resize(bytesRead);
readData.append(buffer);
}
catch(...)
{
ErrorCode=boost::system::errc::make_error_code(boost::system::errc::io_error);
return !readData.empty();
}
}
else
{
boost::optional<boost::system::error_code> timerResult, readResult;
boost::asio::steady_timer timer(Service, Timeout);
std::size_t bytesRead=0;
timer.expires_after(Timeout);
timer.async_wait([&](const boost::system::error_code& state)
{
timerResult.reset(state);
});
boost::asio::async_read(Interface, boost::asio::buffer(buffer, remainingBytes),
boost::asio::transfer_at_least(1), [&](const boost::system::error_code& state, std::size_t bytes)
{
readResult.reset(state);
bytesRead=bytes;
});
Service.restart();
while(Service.run_one())
{
if(readResult)
{
timer.cancel();
}
else if(timerResult)
{
Interface.cancel(ErrorCode);
if(ErrorCode)
{
return !readData.empty();
}
}
}
if(readResult&&*readResult&&*readResult!=boost::asio::error::eof)
{
return !readData.empty();
}
if(bytesRead > 0)
{
buffer.resize(bytesRead);
readData.append(buffer);
}
}
}
return !readData.empty()||requestedSize==0;
}
bool LANDevice::Read(std::string& readData, char readUntil)
{
ErrorCode.clear();
if(!(Interface.is_open()||(!Interface.is_open()&&Open())))
{
if(!ErrorCode)
{
ErrorCode=boost::system::errc::make_error_code(boost::system::errc::no_such_device);
}
return false;
}
Clear(readData);
const std::size_t availableBytes=getAvailableBytes();
if(availableBytes > 0)
{
std::string buffer(availableBytes, '\0');
try
{
std::size_t bytesRead=Interface.read_some(boost::asio::buffer(buffer), ErrorCode);
if(ErrorCode)
{
return false;
}
Resize(buffer, bytesRead);
size_t terminatorPos=buffer.find(readUntil);
if(terminatorPos!=std::string::npos)
{
readData.append(buffer, 0, terminatorPos + 1);
return true;
}
readData.append(buffer);
}
catch(...)
{
ErrorCode=boost::system::errc::make_error_code(boost::system::errc::io_error);
return false;
}
}
if(Timeout==std::chrono::milliseconds::zero())
{
while(true)
{
try
{
char singleChar;
size_t bytesRead=boost::asio::read(Interface, boost::asio::buffer(&singleChar, 1), ErrorCode);
if(ErrorCode)
{
return !readData.empty();
}
if(bytesRead > 0)
{
readData.push_back(singleChar);
if(singleChar==readUntil)
{
return true;
}
}
}
catch(...)
{
ErrorCode=boost::system::errc::make_error_code(boost::system::errc::io_error);
return !readData.empty();
}
}
}
else
{
boost::asio::steady_timer timer(Service, Timeout);
bool timeoutOccurred=false;
timer.expires_after(Timeout);
timer.async_wait([&](const boost::system::error_code& state)
{
if(!state)
{
timeoutOccurred=true;
Interface.cancel(ErrorCode);
}
});
while(!timeoutOccurred)
{
boost::optional<boost::system::error_code> readResult;
char singleChar;
bool charRead=false;
Interface.async_read_some(boost::asio::buffer(&singleChar, 1),
[&](const boost::system::error_code& state, std::size_t bytes)
{
readResult.reset(state);
charRead=(bytes > 0);
});
Service.restart();
Service.run_one();
if(!readResult||*readResult)
{
break;
}
if(charRead)
{
readData.push_back(singleChar);
if(singleChar==readUntil)
{
timer.cancel();
return true;
}
}
}
}
return !readData.empty();
}
bool LANDevice::Write(const std::string& writeData)
{
ErrorCode.clear();
if(writeData.empty())
{
return true;
}
if(!(Interface.is_open()||(!Interface.is_open()&&Open())))
{
if(!ErrorCode)
{
ErrorCode=boost::system::errc::make_error_code(boost::system::errc::no_such_device);
}
return false;
}
size_t bytesWritten=0;
try
{
if(Timeout==std::chrono::milliseconds::zero())
{
bytesWritten=boost::asio::write(Interface, boost::asio::buffer(writeData), ErrorCode);
if(ErrorCode)
{
return false;
}
}
else
{
boost::asio::steady_timer timer(Service, Timeout);
bool writeCompleted=false;
boost::asio::async_write(Interface, boost::asio::buffer(writeData),
[&](const boost::system::error_code& state, size_t bytes)
{
ErrorCode=state;
bytesWritten=bytes;
writeCompleted=true;
timer.cancel();
});
timer.async_wait([&](const boost::system::error_code& state)
{
if(!writeCompleted&&!state)
{
Interface.cancel(ErrorCode);
}
});
Service.restart();
Service.run();
if(!writeCompleted||ErrorCode)
{
return false;
}
}
}
catch(...)
{
ErrorCode=boost::system::errc::make_error_code(boost::system::errc::io_error);
return false;
}
return bytesWritten==writeData.size();
}
bool LANDevice::WriteRead(const std::string& writeData, std::string& readData,
const std::chrono::milliseconds pauseDuration)
{
ErrorCode.clear();
if(!Write(writeData))
{
return false;
}
BlockThread(pauseDuration);
if(!Write("\n"))
{
return false;
}
BlockThread(pauseDuration);
return Read(readData);
}
bool LANDevice::WriteRead(const std::string& writeData, std::string& readData, char readUntil,
const std::chrono::milliseconds pauseDuration)
{
ErrorCode.clear();
if(!Write(writeData))
{
return false;
}
BlockThread(pauseDuration);
if(!Write("\n"))
{
return false;
}
BlockThread(pauseDuration);
return Read(readData, readUntil);
}
std::size_t LANDevice::getAvailableBytes() const
{
if(Interface.is_open())
{
boost::asio::socket_base::bytes_readable command;
boost::system::error_code tempError;
const_cast<boost::asio::ip::tcp::socket&>(Interface).io_control(command, tempError);
if(!tempError)
{
return command.get();
}
}
return 0;
}
std::string LANDevice::getAddress() const
{
return Address;
}
std::uint16_t LANDevice::getPort() const
{
return Port;
}
bool LANDevice::getEndpoint(std::string& address, std::uint16_t& port) const
{
address.assign(Address);
port=Port;
return true;
}
bool LANDevice::getEndpoint(std::uint16_t& port, std::string& address) const
{
address.assign(Address);
port=Port;
return true;
}
boost::system::error_code LANDevice::getErrorCode() const
{
return ErrorCode;
}
std::chrono::milliseconds LANDevice::getTimeout() const
{
return Timeout;
}
bool LANDevice::setAddress(const std::string& address)
{
ErrorCode.clear();
if(!isValidAddress(address))
{
ErrorCode=boost::system::errc::make_error_code(boost::system::errc::invalid_argument);
return false;
}
if(isOpened())
{
if(!Close())
{
return false;
}
}
Address.assign(address=="localhost" ? "127.0.0.1" : address);
return true;
}
bool LANDevice::setPort(const std::uint16_t port)
{
ErrorCode.clear();
if(!isValidPort(port))
{
ErrorCode=boost::system::errc::make_error_code(boost::system::errc::invalid_argument);
return false;
}
if(isOpened())
{
if(!Close())
{
return false;
}
}
Port=port;
return true;
}
bool LANDevice::setEndpoint(std::uint16_t port, const std::string& address)
{
return setEndpoint(address, port);
}
bool LANDevice::setEndpoint(const std::string& address, std::uint16_t port)
{
ErrorCode.clear();
if(!isValidEndpoint(address, port))
{
ErrorCode=boost::system::errc::make_error_code(boost::system::errc::invalid_argument);
return false;
}
if(isOpened())
{
if(!Close())
{
return false;
}
}
Address.assign(address=="localhost" ? "127.0.0.1" : address);
Port=port;
return true;
}
bool LANDevice::setTimeout(std::chrono::milliseconds waitTimeMs)
{
ErrorCode.clear();
if(!isValidTimeout(waitTimeMs))
{
ErrorCode=boost::system::errc::make_error_code(boost::system::errc::invalid_argument);
return false;
}
Timeout=waitTimeMs;
return true;
}
bool LANDevice::setTimeout(std::chrono::milliseconds::rep waitTimeMs)
{
return setTimeout(std::chrono::milliseconds(waitTimeMs));
}
std::string LANDevice::toString() const
{
if(ErrorCode)
{
return Format("LAN device: \"{}:{}\" with timeout of {} ms. with error code \"{}\"",
Address, Port, Timeout.count(), ErrorCode.message());
}
return Format("LAN device: \"{}:{}\" with timeout of {} ms. without an error code",
Address, Port, Timeout.count());
}
bool LANDevice::isClosed() const
{
return !Interface.is_open();
}
bool LANDevice::isOpened() const
{
return Interface.is_open();
}
bool LANDevice::isValid() const
{
return isValidTimeout(Timeout)&&isValidAddress(Address)&&isValidPort(Port)&&!ErrorCode;
}
std::vector<std::string> LANDevice::getActiveSystemInterfaces()
{
std::vector<std::string> interfaces;
return interfaces;
}
std::string LANDevice::getDefaultAddress()
{
return std::string{};
}
std::uint16_t LANDevice::getDefaultPort()
{
return 9100;
}
bool LANDevice::getDefaultEndpoint(std::string& address, std::uint16_t& port)
{
address=getDefaultAddress();
port=getDefaultPort();
return true;
}
bool LANDevice::getDefaultEndpoint(std::uint16_t& port, std::string& address)
{
address=getDefaultAddress();
port=getDefaultPort();
return true;
}
std::chrono::milliseconds LANDevice::getDefaultTimeout()
{
return std::chrono::milliseconds::zero();
}
bool LANDevice::isValidAddress(const std::string& address)
{
if(address.empty())
{
return false;
}
if(address=="localhost")
{
return true;
}
return std::regex_match(address, std::regex(R"(^(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?)"
R"([0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$)"));
}
bool LANDevice::isValidPort(std::uint16_t port)
{
return port <=65535;
}
bool LANDevice::isValidEndpoint(const std::string& address, std::uint16_t port)
{
return isValidAddress(address)&&isValidPort(port);
}
bool LANDevice::isValidEndpoint(std::uint16_t port, const std::string& address)
{
return isValidAddress(address)&&isValidPort(port);
}
bool LANDevice::isValidTimeout(std::chrono::milliseconds durationMs)
{
return durationMs >=std::chrono::milliseconds::zero();
}
bool LANDevice::isValidTimeout(std::chrono::milliseconds::rep durationMs)
{
return durationMs >=0;
}
}
```
## File: DeviceInterfaceDriver/LANDevice.hpp
```
#ifndef LANDevice_H
#define LANDevice_H
#include <boost/asio.hpp>
#include "Device.hpp"
#include "Utility.hpp"
namespace Cognitive
{
class LANDevice : public Device
{
public:
LANDevice();
~LANDevice();
LANDevice(LANDevice&&moveValue);
LANDevice& operator=(LANDevice&&moveValue);
LANDevice(const LANDevice&)=delete;
LANDevice& operator=(const LANDevice&)=delete;
bool Close();
bool Flush();
bool Open();
bool Reopen();
bool Reset();
bool Read(std::string& readData);
bool Read(std::string& readData, char readUntil);
bool Write(const std::string& writeData);
bool WriteRead(const std::string& writeData, std::string& readData,
const std::chrono::milliseconds pauseDuration=std::chrono::milliseconds{50});
bool WriteRead(const std::string& writeData, std::string& readData, char readUntil,
const std::chrono::milliseconds pauseDuration=std::chrono::milliseconds{50});
std::size_t getAvailableBytes() const;
std::string getAddress() const;
std::uint16_t getPort() const;
bool getEndpoint(std::string& address, std::uint16_t& port) const;
bool getEndpoint(std::uint16_t& port, std::string& address) const;
boost::system::error_code getErrorCode() const;
std::chrono::milliseconds getTimeout() const;
bool setAddress(const std::string& address);
bool setPort(const std::uint16_t port);
bool setEndpoint(const std::string& address, std::uint16_t port);
bool setEndpoint(std::uint16_t port, const std::string& address);
bool setTimeout(std::chrono::milliseconds waitTimeMs);
bool setTimeout(std::chrono::milliseconds::rep waitTimeMs);
bool isClosed() const;
bool isOpened() const;
bool isValid() const;
std::string toString() const;
static std::vector<std::string> getActiveSystemInterfaces();
static std::string getDefaultAddress();
static std::uint16_t getDefaultPort();
static bool getDefaultEndpoint(std::string& address, std::uint16_t& port);
static bool getDefaultEndpoint(std::uint16_t& port, std::string& address);
static std::chrono::milliseconds getDefaultTimeout();
static bool isValidAddress(const std::string& address);
static bool isValidPort(std::uint16_t port);
static bool isValidEndpoint(const std::string& address, std::uint16_t port);
static bool isValidEndpoint(std::uint16_t port, const std::string& address);
static bool isValidTimeout(std::chrono::milliseconds durationMs);
static bool isValidTimeout(std::chrono::milliseconds::rep durationMs);
private:
boost::asio::io_context Service;
boost::asio::ip::tcp::socket Interface;
boost::system::error_code ErrorCode;
std::chrono::milliseconds Timeout;
std::string Address;
std::uint16_t Port;
};
}
#endif
```
## File: DeviceInterfaceDriver/LPTDevice.cpp
```cpp
#include "LPTDevice.hpp"
#include <boost/optional.hpp>
#include <regex>
#include <windows.h>
namespace Cognitive
{
LPTDevice::LPTDevice() :
Service{},
Interface{Service},
ErrorCode{},
Timeout{getDefaultTimeout()},
PortName{getDefaultPortName()}
{
}
LPTDevice::~LPTDevice()
{
Close();
Reset();
}
LPTDevice::LPTDevice(LPTDevice&&moveValue) :
Service{},
Interface{Service},
ErrorCode{moveValue.ErrorCode},
Timeout{std::exchange(moveValue.Timeout, getDefaultTimeout())},
PortName{std::move(moveValue.PortName)}
{
moveValue.ErrorCode.clear();
if(moveValue.Interface.is_open())
{
if(Interface.is_open())
{
Interface.close(ErrorCode);
}
PortName=std::move(moveValue.PortName);
if(!Open())
{
ErrorCode=boost::system::errc::make_error_code(boost::system::errc::io_error);
}
moveValue.Interface.close();
}
}
LPTDevice& LPTDevice::operator=(LPTDevice&&moveValue)
{
if(this!=&moveValue)
{
Close();
ErrorCode=moveValue.ErrorCode;
Timeout=std::exchange(moveValue.Timeout, getDefaultTimeout());
PortName=std::move(moveValue.PortName);
moveValue.ErrorCode.clear();
if(moveValue.Interface.is_open())
{
if(!Open())
{
ErrorCode=boost::system::errc::make_error_code(boost::system::errc::io_error);
}
moveValue.Interface.close();
}
}
return *this;
}
bool LPTDevice::Close()
{
ErrorCode.clear();
if(!Interface.is_open())
{
return true;
}
Interface.cancel(ErrorCode);
auto closeLambda=[&]()
{
Interface.close(ErrorCode);
};
const bool success=ExecuteWithTimeout(Timeout, closeLambda);
return success&&!ErrorCode;
}
bool LPTDevice::Flush()
{
ErrorCode.clear();
if(!Interface.is_open()&&!Open())
{
if(!ErrorCode)
{
ErrorCode=boost::system::errc::make_error_code(boost::system::errc::no_such_device);
}
return false;
}
std::string newline="\n";
if(!Write(newline))
{
return false;
}
return true;
}
bool LPTDevice::Open()
{
ErrorCode.clear();
if(!isValid())
{
ErrorCode=boost::system::errc::make_error_code(boost::system::errc::invalid_argument);
return false;
}
if(Interface.is_open())
{
return true;
}
if(Interface.is_open())
{
Interface.close(ErrorCode);
if(ErrorCode)
{
return false;
}
}
const std::string prefix("\\\\.\\");
const std::string portName(PortName.starts_with(prefix) ? PortName : (prefix + PortName));
HANDLE nativePortHandle=CreateFile(
portName.c_str(),
GENERIC_READ | GENERIC_WRITE,
FILE_SHARE_READ | FILE_SHARE_WRITE,
nullptr,
OPEN_EXISTING,
FILE_FLAG_OVERLAPPED,
nullptr
);
if(nativePortHandle==INVALID_HANDLE_VALUE)
{
ErrorCode=boost::system::errc::make_error_code(boost::system::errc::no_such_device);
return false;
}
if(Interface.assign(nativePortHandle, ErrorCode))
{
CloseHandle(nativePortHandle);
return false;
}
return true;
}
bool LPTDevice::Reopen()
{
ErrorCode.clear();
if(isOpened()&&!Close())
{
return false;
}
return Open();
}
bool LPTDevice::Reset()
{
ErrorCode.clear();
if(Interface.is_open())
{
Interface.close(ErrorCode);
}
Timeout=getDefaultTimeout();
PortName.assign(getDefaultPortName());
return !ErrorCode;
}
bool LPTDevice::Read(std::string& readData)
{
ErrorCode.clear();
if(!(Interface.is_open()||(!Interface.is_open()&&Open())))
{
if(!ErrorCode)
{
ErrorCode=boost::system::errc::make_error_code(boost::system::errc::no_such_device);
}
return false;
}
const std::size_t requestedSize=readData.size();
if(requestedSize==0)
{
return true;
}
readData.clear();
const std::size_t availableBytes=getAvailableBytes();
if(availableBytes > 0)
{
const std::size_t bytesToRead=std::min(availableBytes, requestedSize);
std::string buffer(bytesToRead, '\0');
boost::system::error_code errorCode;
try
{
std::size_t bytesRead=Interface.read_some(boost::asio::buffer(buffer), errorCode);
if(errorCode)
{
ErrorCode=errorCode;
return false;
}
buffer.resize(bytesRead);
readData.append(buffer);
if(readData.size() >=requestedSize)
{
return true;
}
}
catch(...)
{
ErrorCode=boost::system::errc::make_error_code(boost::system::errc::io_error);
return false;
}
}
const std::size_t remainingBytes=requestedSize - readData.size();
if(remainingBytes > 0)
{
if(Timeout==std::chrono::milliseconds::zero())
{
const std::size_t remainingBytes=requestedSize - readData.size();
std::string buffer(remainingBytes, '\0');
boost::system::error_code errorCode;
try
{
std::size_t bytesRead=boost::asio::read(Interface, boost::asio::buffer(buffer),
boost::asio::transfer_at_least(remainingBytes), errorCode);
if(errorCode&&errorCode!=boost::asio::error::eof)
{
ErrorCode=errorCode;
return !readData.empty();
}
buffer.resize(bytesRead);
readData.append(buffer);
return !readData.empty();
}
catch(...)
{
ErrorCode=boost::system::errc::make_error_code(boost::system::errc::io_error);
return !readData.empty();
}
}
else
{
boost::asio::steady_timer timer(Service);
std::string buffer(remainingBytes, '\0');
boost::optional<boost::system::error_code> timerResult, readResult;
std::size_t bytesRead=0;
auto waitLambda=[&](const boost::system::error_code& state)
{
timerResult.reset(state);
};
auto readLambda=[&](const boost::system::error_code& state, std::size_t bytes)
{
readResult.reset(state);
bytesRead=bytes;
};
timer.expires_after(Timeout);
timer.async_wait(waitLambda);
boost::asio::async_read(Interface, boost::asio::buffer(buffer, remainingBytes),
boost::asio::transfer_at_least(1), readLambda);
Service.restart();
while(Service.run_one())
{
if(readResult)
{
timer.cancel();
}
else if(timerResult)
{
Interface.cancel(ErrorCode);
if(ErrorCode)
{
return !readData.empty();
}
}
}
if(readResult&&*readResult&&*readResult!=boost::asio::error::eof)
{
ErrorCode=*readResult;
return !readData.empty();
}
if(bytesRead > 0)
{
buffer.resize(bytesRead);
readData.append(buffer);
}
}
}
return !readData.empty()||requestedSize==0;
}
bool LPTDevice::Read(std::string& readData, char readUntil)
{
ErrorCode.clear();
if(!(Interface.is_open()||(!Interface.is_open()&&Open())))
{
if(!ErrorCode)
{
ErrorCode=boost::system::errc::make_error_code(boost::system::errc::no_such_device);
}
return false;
}
Clear(readData);
const std::size_t availableBytes=getAvailableBytes();
if(availableBytes > 0)
{
std::string buffer(availableBytes, '\0');
boost::system::error_code errorCode;
try
{
std::size_t bytesRead=Interface.read_some(boost::asio::buffer(buffer), errorCode);
if(errorCode)
{
ErrorCode=errorCode;
return false;
}
size_t terminatorPos=Resize(buffer, bytesRead).find(readUntil);
if(terminatorPos!=std::string::npos)
{
readData.append(buffer, 0, terminatorPos + 1);
return true;
}
readData.append(buffer);
}
catch(...)
{
ErrorCode=boost::system::errc::make_error_code(boost::system::errc::io_error);
return false;
}
}
if(Timeout==std::chrono::milliseconds::zero())
{
while(true)
{
boost::system::error_code errorCode;
char singleChar;
try
{
size_t bytesRead=boost::asio::read(Interface, boost::asio::buffer(&singleChar, 1), errorCode);
if(errorCode)
{
ErrorCode=errorCode;
return !readData.empty();
}
if(bytesRead > 0)
{
readData.push_back(singleChar);
if(singleChar==readUntil)
{
return true;
}
}
}
catch(...)
{
ErrorCode=boost::system::errc::make_error_code(boost::system::errc::io_error);
return !readData.empty();
}
}
}
else
{
boost::asio::steady_timer timer(Service);
bool timeoutOccurred=false;
auto waitLambda=[&](const boost::system::error_code& state)
{
if(!state)
{
timeoutOccurred=true;
Interface.cancel(ErrorCode);
}
};
timer.expires_after(Timeout);
timer.async_wait(waitLambda);
while(!timeoutOccurred)
{
boost::optional<boost::system::error_code> readResult;
char singleChar;
bool charRead=false;
auto readLambda=[&](const boost::system::error_code& state, std::size_t bytes)
{
readResult.reset(state);
charRead=(bytes > 0);
};
Interface.async_read_some(boost::asio::buffer(&singleChar, 1), readLambda);
Service.restart();
Service.run_one();
if(!readResult||*readResult)
{
ErrorCode=*readResult;
break;
}
if(charRead)
{
readData.push_back(singleChar);
if(singleChar==readUntil)
{
timer.cancel();
return true;
}
}
}
}
return !readData.empty();
}
bool LPTDevice::Write(const std::string& writeData)
{
ErrorCode.clear();
if(writeData.empty())
{
return true;
}
if(!(Interface.is_open()||(!Interface.is_open()&&Open())))
{
if(!ErrorCode)
{
ErrorCode=boost::system::errc::make_error_code(boost::system::errc::no_such_device);
}
return false;
}
if(Timeout==std::chrono::milliseconds::zero())
{
try
{
size_t bytesWritten=boost::asio::write(Interface, boost::asio::buffer(writeData), ErrorCode);
if(ErrorCode)
{
return false;
}
return bytesWritten==writeData.size();
}
catch(...)
{
ErrorCode=boost::system::errc::make_error_code(boost::system::errc::io_error);
return false;
}
}
else
{
boost::asio::steady_timer timer(Service);
boost::optional<boost::system::error_code> timerResult, writeResult;
size_t bytesWritten=0;
timer.expires_after(Timeout);
auto waitLambda=[&](const boost::system::error_code& state)
{
timerResult.reset(state);
};
auto writeLambda=[&](const boost::system::error_code& state, size_t bytes)
{
writeResult.reset(state);
bytesWritten=bytes;
};
timer.async_wait(waitLambda);
boost::asio::async_write(Interface, boost::asio::buffer(writeData), writeLambda);
Service.restart();
Service.run();
if(writeResult&&*writeResult)
{
ErrorCode=*writeResult;
return false;
}
if(timerResult&&!writeResult)
{
Interface.cancel(ErrorCode);
ErrorCode=boost::system::errc::make_error_code(boost::system::errc::timed_out);
return false;
}
return bytesWritten==writeData.size();
}
}
bool LPTDevice::WriteRead(const std::string& writeData, std::string& readData,
const std::chrono::milliseconds pauseDuration)
{
ErrorCode.clear();
if(!Write(writeData))
{
return false;
}
BlockThread(pauseDuration);
if(!Write("\n"))
{
return false;
}
BlockThread(pauseDuration);
return Read(readData);
}
bool LPTDevice::WriteRead(const std::string& writeData, std::string& readData, char readUntil,
const std::chrono::milliseconds pauseDuration)
{
ErrorCode.clear();
if(!Write(writeData))
{
return false;
}
BlockThread(pauseDuration);
if(!Write("\n"))
{
return false;
}
BlockThread(pauseDuration);
return Read(readData, readUntil);
}
std::size_t LPTDevice::getAvailableBytes() const
{
return 0;
}
std::string LPTDevice::getPortName() const
{
return PortName;
}
boost::system::error_code LPTDevice::getErrorCode() const
{
return ErrorCode;
}
std::chrono::milliseconds LPTDevice::getTimeout() const
{
return Timeout;
}
bool LPTDevice::setPortName(const std::string& portName)
{
ErrorCode.clear();
if(!isValidPortName(portName))
{
ErrorCode=boost::system::errc::make_error_code(boost::system::errc::invalid_argument);
return false;
}
if(isOpened())
{
if(!Close())
{
return false;
}
}
PortName.assign(portName);
return true;
}
bool LPTDevice::setTimeout(std::chrono::milliseconds waitTimeMs)
{
ErrorCode.clear();
if(!isValidTimeout(waitTimeMs))
{
ErrorCode=boost::system::errc::make_error_code(boost::system::errc::invalid_argument);
return false;
}
Timeout=waitTimeMs;
return true;
}
bool LPTDevice::setTimeout(std::chrono::milliseconds::rep waitTimeMs)
{
return setTimeout(std::chrono::milliseconds(waitTimeMs));
}
bool LPTDevice::isClosed() const
{
return !Interface.is_open();
}
bool LPTDevice::isOpened() const
{
return Interface.is_open();
}
bool LPTDevice::isValid() const
{
return isValidTimeout(Timeout)&&isValidPortName(PortName)&&!ErrorCode;
}
std::string LPTDevice::toString() const
{
if(ErrorCode)
{
return Format("LPT device: \"{}\" with timeout of {} ms. and error code \"{}\"",
PortName, Timeout.count(), ErrorCode.message());
}
return Format("LPT device: \"{}\" with timeout of {} ms. without an error code",
PortName, Timeout.count());
}
std::vector<std::string> LPTDevice::getActiveSystemPorts()
{
std::vector<std::string> validPorts;
std::string nameBuffer(0x3FFF, '\0'), validName;
for(std::size_t index=1; index <=256; ++index)
{
validName.assign("LPT" + std::to_string(index));
if(QueryDosDevice(validName.c_str(), nameBuffer.data(), static_cast<DWORD>(nameBuffer.size())))
{
validPorts.emplace_back(std::move(validName));
}
}
Clear(nameBuffer);
Clear(validName);
return validPorts;
}
std::string LPTDevice::getDefaultPortName()
{
return std::string{};
}
std::chrono::milliseconds LPTDevice::getDefaultTimeout()
{
return std::chrono::milliseconds::zero();
}
bool LPTDevice::isValidPortName(const std::string& portName)
{
if(portName.empty())
{
return false;
}
return std::regex_match(portName, std::regex("^(\\\\\\\\[.]\\\\)?LPT([1-9]|[1-8][0-9]"
"|9[0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])$", std::regex_constants::icase));
}
bool LPTDevice::isValidTimeout(std::chrono::milliseconds durationMs)
{
return durationMs >=std::chrono::milliseconds::zero();
}
bool LPTDevice::isValidTimeout(std::chrono::milliseconds::rep durationMs)
{
return durationMs >=0;
}
}
```
## File: DeviceInterfaceDriver/LPTDevice.hpp
```
#ifndef LPTDevice_H
#define LPTDevice_H
#include <boost/asio.hpp>
#include "Device.hpp"
#include "Utility.hpp"
namespace Cognitive
{
class LPTDevice : public Device
{
public:
LPTDevice();
~LPTDevice();
LPTDevice(LPTDevice&&moveValue);
LPTDevice& operator=(LPTDevice&&moveValue);
LPTDevice(const LPTDevice&)=delete;
LPTDevice& operator=(const LPTDevice&)=delete;
bool Close();
bool Flush();
bool Open();
bool Reopen();
bool Reset();
bool Read(std::string& readData);
bool Read(std::string& readData, char readUntil);
bool Write(const std::string& writeData);
bool WriteRead(const std::string& writeData, std::string& readData,
const std::chrono::milliseconds pauseDuration=std::chrono::milliseconds{50});
bool WriteRead(const std::string& writeData, std::string& readData, char readUntil,
const std::chrono::milliseconds pauseDuration=std::chrono::milliseconds{50});
std::size_t getAvailableBytes() const;
std::string getPortName() const;
boost::system::error_code getErrorCode() const;
std::chrono::milliseconds getTimeout() const;
bool setPortName(const std::string& portName);
bool setTimeout(std::chrono::milliseconds waitTimeMs);
bool setTimeout(std::chrono::milliseconds::rep waitTimeMs);
bool isClosed() const;
bool isOpened() const;
bool isValid() const;
std::string toString() const;
static std::vector<std::string> getActiveSystemPorts();
static std::string getDefaultPortName();
static std::chrono::milliseconds getDefaultTimeout();
static bool isValidPortName(const std::string& portName);
static bool isValidTimeout(std::chrono::milliseconds durationMs);
static bool isValidTimeout(std::chrono::milliseconds::rep durationMs);
private:
boost::asio::io_context Service;
boost::asio::windows::stream_handle Interface;
boost::system::error_code ErrorCode;
std::chrono::milliseconds Timeout;
std::string PortName;
};
}
#endif
```
## File: DeviceInterfaceDriver/USBDevice.cpp
```cpp
#include "USBDevice.hpp"
#include <guiddef.h>
#include <windows.h>
#include <setupapi.h>
#include <shlwapi.h>
#include <algorithm>
#include <array>
#include <atomic>
#include <format>
#include <map>
#include <memory>
#include <mutex>
#include <regex>
#include <span>
#include <string_view>
#include <thread>
#define _PRTCLS_
#define _SPOOLER_MOD_
namespace Cognitive
{
#if defined _PRTCLS_
static constexpr const GUID GUID_CLASS_TPG_BULK{0xC12127C7,
0x8258, 0x4929, {0x85, 0x74, 0x42, 0x78, 0xB9, 0x46, 0xCD, 0x69}};
static constexpr const GUID GUID_CLASS_PTR_BULK{0x28D78FAD,
0x5A12, 0x11D1, {0xAE, 0x5B, 0x00, 0x00, 0xF8, 0x03, 0xA8, 0xC2}};
#else
static constexpr const GUID GUID_CLASS_COM_BULK{0xC12127C7,
0x8258, 0x4929, {0x85, 0x74, 0x42, 0x78, 0xB9, 0x46, 0xCD, 0x69}};
#endif
enum class USBDeviceType
{
NativeType,
PrinterClassType
};
static constexpr std::size_t USB_MAX_READ{4096};
class CircularBuffer
{
public:
CircularBuffer(std::size_t size=12);
~CircularBuffer()=default;
CircularBuffer(const CircularBuffer&)=delete;
CircularBuffer(CircularBuffer&&) noexcept;
CircularBuffer& operator=(const CircularBuffer&)=delete;
CircularBuffer& operator=(CircularBuffer&&) noexcept;
std::size_t PutBytes(std::span<const std::byte> data);
std::size_t GetBytes(std::span<std::byte> destination);
std::size_t ReadyBytes() const noexcept;
private:
void PutByte(std::byte byte);
std::byte GetByte();
std::unique_ptr<std::byte[]> Buffer;
std::mutex Mutex;
std::size_t DataLength{0}, MaxLength{0}, NextInputLength{0}, NextOutputLength{0};
};
#ifdef _SPOOLER_MOD_
class SpoolerManager
{
public:
SpoolerManager()=default;
~SpoolerManager();
SpoolerManager(const SpoolerManager&)=delete;
SpoolerManager(SpoolerManager&&)=delete;
SpoolerManager& operator=(const SpoolerManager&)=delete;
SpoolerManager& operator=(SpoolerManager&&)=delete;
bool StopSpooler();
bool StartSpooler();
private:
SC_HANDLE SpoolerService{nullptr};
SERVICE_STATUS ServiceStatus{};
};
#endif
class USBCommunicator
{
public:
USBCommunicator()=default;
~USBCommunicator();
USBCommunicator(const USBCommunicator&)=delete;
USBCommunicator& operator=(const USBCommunicator&)=delete;
USBCommunicator(USBCommunicator&&) noexcept;
USBCommunicator& operator=(USBCommunicator&&) noexcept;
bool Initialize(std::int32_t deviceType=-1);
bool Close();
std::size_t ReadyBytes() const;
#if defined _PRTCLS_
bool getUSBDeviceFileName(std::int32_t index, std::string& outName);
HANDLE OpenDevice(LPGUID pGuid, std::string& outName);
HANDLE OpenDevice(
HDEVINFO hardwareDeviceInfo, PSP_INTERFACE_DEVICE_DATA deviceInfoData, std::string& outName);
HANDLE OpenFile(std::int32_t index, std::string_view filename);
bool ReceiveData();
bool getData(std::span<std::byte> buffer, std::size_t& bytesRead, std::chrono::milliseconds timeout);
bool getPowerStatus() const noexcept;
bool Reopen();
#else
bool getUSBDeviceFileName(std::string& outName);
HANDLE OpenDevice(LPGUID pGuid, std::string& outName);
HANDLE OpenDevice(HDEVINFO hardwareDeviceInfo, PSP_INTERFACE_DEVICE_DATA deviceInfoData, std::string& outName);
HANDLE OpenFile(std::string_view filename);
#endif
#ifdef _SPOOLER_MOD_
bool StartSpooler();
bool StopSpooler();
#endif
public:
std::atomic_bool FirstConnectFlag{false};
std::string DeviceName{};
std::int32_t DeviceType{-1};
#if defined _PRTCLS_
private:
std::atomic_bool ReadThreadActive{false}, ContinueFlag{false}, PowerStatusFlag{false}, HandlesValid{false};
HANDLE ReadHandle{INVALID_HANDLE_VALUE}, WriteHandle{INVALID_HANDLE_VALUE},
QuitEvent{nullptr}, DataEvent{nullptr}, ReadThreadEnded{nullptr};
std::jthread WorkerThread;
std::unique_ptr<CircularBuffer> Buffer;
#ifdef _SPOOLER_MOD_
SpoolerManager Spooler;
#endif
void receiverThread(std::stop_token stopToken);
#endif
friend class DeviceManager;
};
static std::int32_t ProbeDevice(std::string& result);
class DeviceManager
{
public:
static DeviceManager& Instance();
std::size_t AddDevice(const std::string& path);
bool RemoveDevice(std::size_t deviceId);
bool Read(std::size_t deviceId, std::span<std::byte> buffer, std::size_t& bytesRead,
std::chrono::milliseconds timeout=std::chrono::milliseconds(100));
bool Write(std::size_t deviceId, std::span<const std::byte> data,
std::chrono::milliseconds timeout=std::chrono::milliseconds(100));
std::size_t ReadyBytes(std::size_t deviceId);
std::vector<std::string> getActiveDevicePaths() const;
private:
DeviceManager()=default;
~DeviceManager()=default;
DeviceManager(const DeviceManager&)=delete;
DeviceManager(DeviceManager&&)=delete;
DeviceManager& operator=(const DeviceManager&)=delete;
DeviceManager& operator=(DeviceManager&&)=delete;
std::mutex Mutex;
std::map<std::size_t, std::unique_ptr<USBCommunicator>>Devices;
std::size_t NextId{1};
};
CircularBuffer::CircularBuffer(std::size_t size)
{
size=std::clamp<std::size_t>(size, 6, 16);
MaxLength=(1<<size) - 1;
Buffer=std::make_unique<std::byte[]>(MaxLength + 1);
}
CircularBuffer::CircularBuffer(CircularBuffer&&other) noexcept : Buffer(std::move(other.Buffer)),
DataLength(std::exchange(other.DataLength, 0)), MaxLength(std::exchange(other.MaxLength, 0)),
NextInputLength(std::exchange(other.NextInputLength, 0)), NextOutputLength(std::exchange(other.NextOutputLength, 0))
{
}
CircularBuffer& CircularBuffer::operator=(CircularBuffer&&other) noexcept
{
if(this!=&other)
{
std::scoped_lock lock(Mutex, other.Mutex);
Buffer=std::move(other.Buffer);
DataLength=std::exchange(other.DataLength, 0);
MaxLength=std::exchange(other.MaxLength, 0);
NextInputLength=std::exchange(other.NextInputLength, 0);
NextOutputLength=std::exchange(other.NextOutputLength, 0);
}
return *this;
}
std::size_t CircularBuffer::PutBytes(std::span<const std::byte> data)
{
std::lock_guard<std::mutex> lock(Mutex);
std::size_t bytesToPut=std::min(data.size(), (MaxLength + 1) - DataLength);
for(std::size_t index=0; index < bytesToPut; ++index)
{
PutByte(data[index]);
}
return bytesToPut;
}
std::size_t CircularBuffer::GetBytes(std::span<std::byte> destination)
{
std::lock_guard<std::mutex> lock(Mutex);
std::size_t bytesToGet=std::min(destination.size(), DataLength);
for(std::size_t index=0; index < bytesToGet; ++index)
{
destination[index]=GetByte();
}
return bytesToGet;
}
std::size_t CircularBuffer::ReadyBytes() const noexcept
{
return DataLength;
}
void CircularBuffer::PutByte(std::byte byte)
{
if(DataLength < MaxLength + 1)
{
Buffer[NextInputLength++]=byte;
NextInputLength &=MaxLength;
DataLength++;
}
}
std::byte CircularBuffer::GetByte()
{
std::byte byte{0};
if(DataLength > 0)
{
byte=Buffer[NextOutputLength++];
NextOutputLength &=MaxLength;
DataLength--;
}
return byte;
}
#ifdef _SPOOLER_MOD_
SpoolerManager::~SpoolerManager()
{
if(SpoolerService!=nullptr)
{
CloseServiceHandle(SpoolerService);
}
}
bool SpoolerManager::StopSpooler()
{
SC_HANDLE schSCManager=OpenSCManager(nullptr, nullptr, SC_MANAGER_ALL_ACCESS);
if(!schSCManager)
{
return false;
}
SpoolerService=OpenService(schSCManager, "spooler", SERVICE_ALL_ACCESS);
CloseServiceHandle(schSCManager);
if(!SpoolerService)
{
return false;
}
if(!ControlService(SpoolerService, SERVICE_CONTROL_STOP, &ServiceStatus))
{
return false;
}
constexpr std::int32_t MAX_WAIT_COUNT=60;
std::int32_t waitCount=0;
while(QueryServiceStatus(SpoolerService, &ServiceStatus)&&waitCount < MAX_WAIT_COUNT)
{
if(ServiceStatus.dwCurrentState==SERVICE_STOP_PENDING)
{
BlockThread(1000);
waitCount++;
}
else
{
break;
}
}
return (ServiceStatus.dwCurrentState==SERVICE_STOPPED);
}
bool SpoolerManager::StartSpooler()
{
if(!SpoolerService)
{
return false;
}
if(!StartService(SpoolerService, 0, nullptr))
{
return false;
}
BlockThread(1000);
while(QueryServiceStatus(SpoolerService, &ServiceStatus))
{
if(ServiceStatus.dwCurrentState!=SERVICE_RUNNING)
{
BlockThread(1000);
}
else
{
break;
}
}
return (ServiceStatus.dwCurrentState==SERVICE_RUNNING);
}
#endif
USBCommunicator::~USBCommunicator()
{
Close();
}
USBCommunicator::USBCommunicator(USBCommunicator&&other) noexcept : FirstConnectFlag(other.FirstConnectFlag.load()),
DeviceName(std::move(other.DeviceName)), DeviceType(std::exchange(other.DeviceType, -1))
{
#if defined _PRTCLS_
ReadThreadActive=other.ReadThreadActive.load();
ContinueFlag=other.ContinueFlag.load();
PowerStatusFlag=other.PowerStatusFlag.load();
HandlesValid=other.HandlesValid.load();
ReadHandle=std::exchange(other.ReadHandle, INVALID_HANDLE_VALUE);
WriteHandle=std::exchange(other.WriteHandle, INVALID_HANDLE_VALUE);
QuitEvent=std::exchange(other.QuitEvent, nullptr);
DataEvent=std::exchange(other.DataEvent, nullptr);
ReadThreadEnded=std::exchange(other.ReadThreadEnded, nullptr);
Buffer=std::move(other.Buffer);
#endif
}
USBCommunicator& USBCommunicator::operator=(USBCommunicator&&other) noexcept
{
if(this!=&other)
{
Close();
DeviceType=std::exchange(other.DeviceType, -1);
FirstConnectFlag.store(other.FirstConnectFlag.load());
DeviceName=std::move(other.DeviceName);
#if defined _PRTCLS_
ReadThreadActive.store(other.ReadThreadActive.load());
ContinueFlag.store(other.ContinueFlag.load());
PowerStatusFlag.store(other.PowerStatusFlag.load());
HandlesValid.store(other.HandlesValid.load());
ReadHandle=std::exchange(other.ReadHandle, INVALID_HANDLE_VALUE);
WriteHandle=std::exchange(other.WriteHandle, INVALID_HANDLE_VALUE);
QuitEvent=std::exchange(other.QuitEvent, nullptr);
DataEvent=std::exchange(other.DataEvent, nullptr);
ReadThreadEnded=std::exchange(other.ReadThreadEnded, nullptr);
Buffer=std::move(other.Buffer);
if(other.WorkerThread.joinable())
{
WorkerThread=std::move(other.WorkerThread);
}
#endif
}
return *this;
}
bool USBCommunicator::Initialize(std::int32_t deviceType)
{
Close();
#if defined _PRTCLS_
if(deviceType < 0)
{
std::string deviceInfo;
DeviceType=ProbeDevice(deviceInfo);
}
else
{
DeviceType=deviceType;
}
Buffer=std::make_unique<CircularBuffer>();
QuitEvent=CreateEvent(nullptr, TRUE, FALSE, nullptr);
if(!QuitEvent)
return false;
ReadThreadEnded=CreateEvent(nullptr, FALSE, FALSE, nullptr);
if(!ReadThreadEnded)
{
CloseHandle(QuitEvent);
QuitEvent=nullptr;
return false;
}
DataEvent=CreateEvent(nullptr, TRUE, FALSE, nullptr);
if(!DataEvent)
{
CloseHandle(QuitEvent);
CloseHandle(ReadThreadEnded);
QuitEvent=nullptr;
ReadThreadEnded=nullptr;
return false;
}
std::string outName;
if(!getUSBDeviceFileName(DeviceType, outName))
{
Close();
return false;
}
DeviceName=outName;
const std::string readPath=DeviceName + "\\PIPE00";
ReadHandle=CreateFile(readPath.c_str(), GENERIC_READ | GENERIC_WRITE,
FILE_SHARE_READ | FILE_SHARE_WRITE, nullptr, OPEN_EXISTING, FILE_FLAG_OVERLAPPED, nullptr);
if(ReadHandle==INVALID_HANDLE_VALUE)
{
Close();
return false;
}
const std::string writePath=DeviceName + "\\PIPE01";
WriteHandle=CreateFile(writePath.c_str(), GENERIC_READ | GENERIC_WRITE,
FILE_SHARE_READ | FILE_SHARE_WRITE, nullptr, OPEN_EXISTING, 0, nullptr);
if(WriteHandle==INVALID_HANDLE_VALUE)
{
Close();
return false;
}
ContinueFlag=true;
WorkerThread=std::jthread([this](std::stop_token stopToken) { receiverThread(std::move(stopToken)); });
HandlesValid=true;
return WorkerThread.joinable();
#else
std::string outName;
if(!getUSBDeviceFileName(outName))
{
return false;
}
DeviceName=outName;
DeviceType=NativeType;
return true;
#endif
}
bool USBCommunicator::Close()
{
#if defined _PRTCLS_
if(QuitEvent)
{
SetEvent(QuitEvent);
}
if(WorkerThread.joinable())
{
WorkerThread.request_stop();
if(ReadThreadEnded)
{
WaitForSingleObject(ReadThreadEnded, INFINITE);
}
WorkerThread.join();
}
if(ReadHandle!=INVALID_HANDLE_VALUE)
{
CloseHandle(ReadHandle);
ReadHandle=INVALID_HANDLE_VALUE;
}
if(WriteHandle!=INVALID_HANDLE_VALUE)
{
CloseHandle(WriteHandle);
WriteHandle=INVALID_HANDLE_VALUE;
}
if(QuitEvent)
{
CloseHandle(QuitEvent);
QuitEvent=nullptr;
}
if(DataEvent)
{
CloseHandle(DataEvent);
DataEvent=nullptr;
}
if(ReadThreadEnded)
{
CloseHandle(ReadThreadEnded);
ReadThreadEnded=nullptr;
}
Buffer.reset();
HandlesValid=false;
ReadThreadActive=false;
#endif
return true;
}
std::size_t USBCommunicator::ReadyBytes() const
{
#if defined _PRTCLS_
return Buffer ? Buffer->ReadyBytes() : 0;
#else
return 0;
#endif
}
#if defined _PRTCLS_
bool USBCommunicator::getUSBDeviceFileName(std::int32_t index, std::string& outName)
{
LPGUID pGuid=nullptr;
switch(index)
{
case 0:
default:
{
pGuid=(LPGUID)&GUID_CLASS_TPG_BULK;
break;
}
case 1:
{
pGuid=(LPGUID)&GUID_CLASS_PTR_BULK;
break;
}
}
HANDLE hDev=OpenDevice(pGuid, outName);
if(hDev!=INVALID_HANDLE_VALUE&&hDev!=nullptr)
{
CloseHandle(hDev);
return true;
}
return false;
}
HANDLE USBCommunicator::OpenDevice(LPGUID pGuid, std::string& outName)
{
HANDLE hOut=nullptr;
HDEVINFO hardwareDeviceInfo=SetupDiGetClassDevs(pGuid, nullptr, nullptr, DIGCF_PRESENT | DIGCF_INTERFACEDEVICE);
if(hardwareDeviceInfo==INVALID_HANDLE_VALUE)
{
return (HANDLE)1;
}
SP_INTERFACE_DEVICE_DATA deviceInfoData{ .cbSize=sizeof(SP_INTERFACE_DEVICE_DATA) };
for(DWORD index=0;; ++index)
{
if(!SetupDiEnumDeviceInterfaces(hardwareDeviceInfo, nullptr, pGuid, index, &deviceInfoData))
{
if(GetLastError()==ERROR_NO_MORE_ITEMS)
{
break;
}
continue;
}
hOut=OpenDevice(hardwareDeviceInfo, &deviceInfoData, outName);
if(hOut!=INVALID_HANDLE_VALUE)
{
if(StrStrI(outName.c_str(), "VID_1840&PID_0100")!=nullptr)
{
SetupDiDestroyDeviceInfoList(hardwareDeviceInfo);
return hOut;
}
if(hOut!=nullptr&&hOut!=INVALID_HANDLE_VALUE)
{
CloseHandle(hOut);
hOut=nullptr;
}
Clear(outName);
}
}
SetupDiDestroyDeviceInfoList(hardwareDeviceInfo);
return hOut;
}
HANDLE USBCommunicator::OpenDevice(HDEVINFO hardwareDeviceInfo,
PSP_INTERFACE_DEVICE_DATA deviceInfoData, std::string& outName)
{
DWORD requiredLength=0;
SetupDiGetInterfaceDeviceDetail(hardwareDeviceInfo, deviceInfoData, nullptr,
0, &requiredLength, nullptr);
std::unique_ptr<BYTE[]> buffer=std::make_unique<BYTE[]>(requiredLength);
PSP_INTERFACE_DEVICE_DETAIL_DATA detailData=reinterpret_cast<PSP_INTERFACE_DEVICE_DETAIL_DATA>(buffer.get());
if(!detailData)
{
return INVALID_HANDLE_VALUE;
}
detailData->cbSize=sizeof(SP_INTERFACE_DEVICE_DETAIL_DATA);
if(!SetupDiGetInterfaceDeviceDetail(hardwareDeviceInfo, deviceInfoData,
detailData, requiredLength, &requiredLength, nullptr))
{
return INVALID_HANDLE_VALUE;
}
outName=detailData->DevicePath;
return CreateFile(detailData->DevicePath, GENERIC_READ | GENERIC_WRITE,
FILE_SHARE_READ | FILE_SHARE_WRITE, nullptr, OPEN_EXISTING, 0, nullptr);
}
HANDLE USBCommunicator::OpenFile(std::int32_t index, std::string_view filename)
{
std::string deviceName;
if(!getUSBDeviceFileName(index, deviceName))
{
return INVALID_HANDLE_VALUE;
}
std::string fullPath=deviceName + "\\" + std::string(filename);
return CreateFile(fullPath.c_str(), GENERIC_READ | GENERIC_WRITE,
FILE_SHARE_READ | FILE_SHARE_WRITE, nullptr, OPEN_EXISTING, 0, nullptr);
}
bool USBCommunicator::ReceiveData()
{
if(ReadHandle==INVALID_HANDLE_VALUE||!Buffer)
{
return false;
}
return true;
}
void USBCommunicator::receiverThread(std::stop_token stopToken)
{
ReadThreadActive=true;
PowerStatusFlag=true;
HANDLE overlappedEvent=CreateEvent(nullptr, TRUE, FALSE, nullptr);
if(!overlappedEvent)
{
ReadThreadActive=false;
PowerStatusFlag=false;
return;
}
std::array<std::byte, USB_MAX_READ> inBuffer{};
std::stop_callback stopCallback(stopToken, [this]()
{
ContinueFlag=false;
if(QuitEvent)
{
SetEvent(QuitEvent);
}
if(ReadHandle!=INVALID_HANDLE_VALUE)
{
CancelIo(ReadHandle);
}
});
OVERLAPPED overlapped{.hEvent=overlappedEvent};
const std::array<HANDLE, 2> waitHandles={overlappedEvent, QuitEvent};
ContinueFlag=true;
while(ContinueFlag&&!stopToken.stop_requested())
{
overlapped.Offset=overlapped.OffsetHigh=0;
ResetEvent(overlappedEvent);
DWORD bytesRead=0;
BOOL result=ReadFile(ReadHandle, inBuffer.data(), static_cast<DWORD>(inBuffer.size()), &bytesRead, &overlapped);
if(!result)
{
const DWORD error=GetLastError();
if(error==ERROR_IO_PENDING)
{
DWORD waitResult=WaitForMultipleObjects(static_cast<DWORD>(waitHandles.size()),
waitHandles.data(), FALSE, INFINITE);
if(waitResult==WAIT_OBJECT_0)
{
if(GetOverlappedResult(ReadHandle, &overlapped, &bytesRead, FALSE)&&bytesRead > 0)
{
Buffer->PutBytes({inBuffer.data(), bytesRead});
SetEvent(DataEvent);
}
}
else if(waitResult==WAIT_OBJECT_0 + 1)
{
ContinueFlag=false;
CancelIo(ReadHandle);
SetEvent(ReadThreadEnded);
break;
}
}
else if(error==ERROR_ACCESS_DENIED||error==ERROR_INVALID_HANDLE)
{
PowerStatusFlag=false;
if(Reopen())
{
PowerStatusFlag=true;
}
else
{
if(WaitForSingleObject(QuitEvent, 500)==WAIT_OBJECT_0)
{
ContinueFlag=false;
CancelIo(ReadHandle);
SetEvent(ReadThreadEnded);
break;
}
}
}
}
else if(bytesRead > 0)
{
Buffer->PutBytes({inBuffer.data(), bytesRead});
SetEvent(DataEvent);
}
if(ContinueFlag)
{
BlockThread(25);
}
}
CloseHandle(overlappedEvent);
ReadThreadActive=false;
PowerStatusFlag=false;
SetEvent(ReadThreadEnded);
}
bool USBCommunicator::getData(std::span<std::byte> buffer, std::size_t& bytesRead, std::chrono::milliseconds timeout)
{
bytesRead=0;
if(!Buffer||buffer.empty())
{
return false;
}
ResetEvent(DataEvent);
bytesRead=Buffer->GetBytes(buffer);
if(bytesRead > 0)
{
return true;
}
const std::array<HANDLE, 2> waitHandles={DataEvent, QuitEvent};
DWORD waitResult=WaitForMultipleObjects(static_cast<DWORD>(waitHandles.size()),
waitHandles.data(), FALSE, static_cast<DWORD>(timeout.count()));
if(waitResult==WAIT_OBJECT_0)
{
bytesRead=Buffer->GetBytes(buffer);
return bytesRead > 0;
}
else if(waitResult==WAIT_OBJECT_0 + 1)
{
SetEvent(ReadThreadEnded);
ContinueFlag=false;
return false;
}
else if(waitResult==WAIT_TIMEOUT)
{
return false;
}
return false;
}
bool USBCommunicator::getPowerStatus() const noexcept
{
return PowerStatusFlag;
}
bool USBCommunicator::Reopen()
{
if(ReadHandle!=INVALID_HANDLE_VALUE)
{
CloseHandle(ReadHandle);
ReadHandle=INVALID_HANDLE_VALUE;
}
if(WriteHandle!=INVALID_HANDLE_VALUE)
{
CloseHandle(WriteHandle);
WriteHandle=INVALID_HANDLE_VALUE;
}
HandlesValid=false;
std::string deviceName;
if(!getUSBDeviceFileName(DeviceType, deviceName))
{
return false;
}
DeviceName=deviceName;
const std::string readPath=DeviceName + "\\PIPE00";
ReadHandle=CreateFile(readPath.c_str(), GENERIC_READ | GENERIC_WRITE,
FILE_SHARE_READ | FILE_SHARE_WRITE, nullptr, OPEN_EXISTING, FILE_FLAG_OVERLAPPED, nullptr);
if(ReadHandle==INVALID_HANDLE_VALUE)
{
return false;
}
const std::string writePath=DeviceName + "\\PIPE01";
WriteHandle=CreateFile(writePath.c_str(), GENERIC_READ | GENERIC_WRITE,
FILE_SHARE_READ | FILE_SHARE_WRITE, nullptr, OPEN_EXISTING, 0, nullptr);
if(WriteHandle==INVALID_HANDLE_VALUE)
{
CloseHandle(ReadHandle);
ReadHandle=INVALID_HANDLE_VALUE;
return false;
}
PurgeComm(WriteHandle, PURGE_TXCLEAR);
PurgeComm(WriteHandle, PURGE_RXCLEAR);
HandlesValid=true;
return true;
}
#else
bool USBCommunicator::getUSBDeviceFileName(std::string& outName)
{
HANDLE hDev=OpenDevice((LPGUID)&GUID_CLASS_COM_BULK, outName);
if(hDev!=INVALID_HANDLE_VALUE)
{
CloseHandle(hDev);
return true;
}
return false;
}
HANDLE USBCommunicator::OpenDevice(LPGUID pGuid, std::string& outName)
{
HANDLE hOut=INVALID_HANDLE_VALUE;
HDEVINFO hardwareDeviceInfo=SetupDiGetClassDevs(pGuid, nullptr, nullptr, DIGCF_PRESENT | DIGCF_INTERFACEDEVICE);
if(hardwareDeviceInfo==INVALID_HANDLE_VALUE)
{
return (HANDLE)1;
}
SP_INTERFACE_DEVICE_DATA deviceInfoData{};
deviceInfoData.cbSize=sizeof(SP_INTERFACE_DEVICE_DATA);
for(DWORD index=0;; ++index)
{
if(!SetupDiEnumDeviceInterfaces(hardwareDeviceInfo, nullptr, pGuid, index, &deviceInfoData))
{
if(GetLastError()==ERROR_NO_MORE_ITEMS)
{
break;
}
continue;
}
hOut=OpenDevice(hardwareDeviceInfo, &deviceInfoData, outName);
if(hOut!=INVALID_HANDLE_VALUE)
{
break;
}
}
SetupDiDestroyDeviceInfoList(hardwareDeviceInfo);
return hOut;
}
HANDLE USBCommunicator::OpenDevice(HDEVINFO hardwareDeviceInfo,
PSP_INTERFACE_DEVICE_DATA deviceInfoData, std::string& outName)
{
DWORD requiredLength=0;
SetupDiGetInterfaceDeviceDetail(hardwareDeviceInfo, deviceInfoData, nullptr, 0, &requiredLength, nullptr);
std::unique_ptr<BYTE[]> buffer=std::make_unique<BYTE[]>(requiredLength);
PSP_INTERFACE_DEVICE_DETAIL_DATA detailData=reinterpret_cast<PSP_INTERFACE_DEVICE_DETAIL_DATA>(buffer.GetBytes());
if(!detailData)
{
return INVALID_HANDLE_VALUE;
}
detailData->cbSize=sizeof(SP_INTERFACE_DEVICE_DETAIL_DATA);
if(!SetupDiGetInterfaceDeviceDetail(hardwareDeviceInfo,
deviceInfoData, detailData, requiredLength, &requiredLength, nullptr))
{
return INVALID_HANDLE_VALUE;
}
outName=detailData->DevicePath;
return CreateFile(detailData->DevicePath, GENERIC_READ | GENERIC_WRITE,
FILE_SHARE_READ | FILE_SHARE_WRITE, nullptr, OPEN_EXISTING, 0, nullptr);
}
HANDLE USBCommunicator::OpenFile(std::string_view filename)
{
std::string deviceName;
if(!getUSBDeviceFileName(deviceName))
{
return INVALID_HANDLE_VALUE;
}
std::string fullPath=deviceName + "\\" + std::string(filename);
return CreateFile(fullPath.c_str(), GENERIC_READ | GENERIC_WRITE,
FILE_SHARE_READ | FILE_SHARE_WRITE, nullptr, OPEN_EXISTING, 0, nullptr);
}
#endif
#ifdef _SPOOLER_MOD_
bool USBCommunicator::StopSpooler()
{
#if defined _PRTCLS_
return Spooler.StopSpooler();
#else
return false;
#endif
}
bool USBCommunicator::StartSpooler()
{
#if defined _PRTCLS_
return Spooler.StartSpooler();
#else
return false;
#endif
}
#endif
std::int32_t ProbeDevice(std::string& result)
{
USBCommunicator usbComm;
std::int32_t retVal=-1;
HANDLE hUsb=nullptr;
#if defined _PRTCLS_
{
std::string devicePath;
if(usbComm.getUSBDeviceFileName(0, devicePath))
{
hUsb=usbComm.OpenFile(0, "PIPE00");
if(hUsb!=INVALID_HANDLE_VALUE)
{
result="Native USB";
retVal=static_cast<std::int32_t>(USBDeviceType::NativeType);
CloseHandle(hUsb);
return retVal;
}
}
}
{
std::string devicePath;
if(usbComm.getUSBDeviceFileName(1, devicePath))
{
hUsb=usbComm.OpenFile(1, "PIPE00");
if(hUsb!=INVALID_HANDLE_VALUE)
{
result="Printer Class USB";
retVal=static_cast<std::int32_t>(USBDeviceType::PrinterClassType);
CloseHandle(hUsb);
return retVal;
}
}
}
#else
{
std::string devicePath;
if(usbComm.getUSBDeviceFileName(devicePath))
{
hUsb=usbComm.OpenFile("PIPE00");
if(hUsb!=INVALID_HANDLE_VALUE)
{
result="Native USB";
retVal=NativeType;
CloseHandle(hUsb);
return retVal;
}
}
}
#endif
result="Unknown USB type";
return retVal;
}
DeviceManager& DeviceManager::Instance()
{
static DeviceManager Instance;
return Instance;
}
std::size_t DeviceManager::AddDevice(const std::string& path)
{
std::unique_lock<std::mutex> lock(Mutex);
for(const auto& [id, device] : Devices)
{
if(device->DeviceName==path)
{
return id;
}
}
auto device=std::make_unique<USBCommunicator>();
if(!device)
{
return 0;
}
if(!device->Initialize())
{
return 0;
}
std::size_t id=NextId++;
Devices[id]=std::move(device);
return id;
}
bool DeviceManager::RemoveDevice(std::size_t deviceId)
{
std::unique_lock<std::mutex> lock(Mutex);
auto it=Devices.find(deviceId);
if(it==Devices.end())
{
return false;
}
it->second->Close();
Devices.erase(it);
return true;
}
bool DeviceManager::Read(
std::size_t deviceId, std::span<std::byte> buffer, std::size_t& bytesRead, std::chrono::milliseconds timeout)
{
std::unique_lock<std::mutex> lock(Mutex);
auto it=Devices.find(deviceId);
if(it==Devices.end())
{
return false;
}
#if defined _PRTCLS_
return it->second->getData(buffer, bytesRead, timeout);
#else
bytesRead=0;
return false;
#endif
}
bool DeviceManager::Write(std::size_t deviceId, std::span<const std::byte> data, std::chrono::milliseconds timeout)
{
std::unique_lock lock(Mutex);
auto it=Devices.find(deviceId);
if(it==Devices.end())
{
return false;
}
if(it->second->WriteHandle==INVALID_HANDLE_VALUE)
{
return false;
}
OVERLAPPED overlapped{};
HANDLE overlappedEvent=CreateEvent(nullptr, TRUE, FALSE, nullptr);
if(overlappedEvent==nullptr)
{
return false;
}
overlapped.hEvent=overlappedEvent;
DWORD bytesWritten=0;
bool success=false;
if(WriteFile(it->second->WriteHandle, data.data(), static_cast<DWORD>(data.size()), &bytesWritten, &overlapped))
{
success=(bytesWritten==data.size());
}
else if(GetLastError()==ERROR_IO_PENDING)
{
DWORD waitResult=WaitForSingleObject(overlappedEvent, static_cast<DWORD>(timeout.count()));
if(waitResult==WAIT_OBJECT_0)
{
if(GetOverlappedResult(it->second->WriteHandle, &overlapped, &bytesWritten, FALSE))
{
success=(bytesWritten==data.size());
}
}
}
CloseHandle(overlappedEvent);
return success;
}
std::size_t DeviceManager::ReadyBytes(std::size_t deviceId)
{
std::unique_lock lock(Mutex);
auto it=Devices.find(deviceId);
if(it==Devices.end())
{
return 0;
}
return it->second->ReadyBytes();
}
std::vector<std::string> DeviceManager::getActiveDevicePaths() const
{
const std::array<const GUID*, 2> guidsToCheck{&GUID_CLASS_PTR_BULK, &GUID_CLASS_TPG_BULK};
std::vector<std::string> paths;
for(const GUID* pGuid : guidsToCheck)
{
HDEVINFO hardwareDeviceInfo=SetupDiGetClassDevs(pGuid, nullptr, nullptr, DIGCF_PRESENT | DIGCF_INTERFACEDEVICE);
if(hardwareDeviceInfo==INVALID_HANDLE_VALUE)
continue;
SP_INTERFACE_DEVICE_DATA deviceInfoData{.cbSize=sizeof(SP_INTERFACE_DEVICE_DATA)};
for(DWORD index=0;; ++index)
{
if(!SetupDiEnumDeviceInterfaces(hardwareDeviceInfo, nullptr, pGuid, index, &deviceInfoData))
{
if(GetLastError()==ERROR_NO_MORE_ITEMS)
break;
else
continue;
}
DWORD requiredSize=0;
SetupDiGetInterfaceDeviceDetail(hardwareDeviceInfo, &deviceInfoData, nullptr, 0, &requiredSize, nullptr);
if(requiredSize==0)
continue;
std::unique_ptr<uint8_t[]> buffer=std::make_unique<uint8_t[]>(requiredSize);
PSP_INTERFACE_DEVICE_DETAIL_DATA detailData=reinterpret_cast<PSP_INTERFACE_DEVICE_DETAIL_DATA>(buffer.get());
if(detailData==nullptr)
continue;
detailData->cbSize=sizeof(SP_INTERFACE_DEVICE_DETAIL_DATA);
if(!SetupDiGetInterfaceDeviceDetail(hardwareDeviceInfo,
&deviceInfoData, detailData, requiredSize, nullptr, nullptr))
{
continue;
}
HANDLE testHandle=CreateFile(detailData->DevicePath, GENERIC_READ | GENERIC_WRITE,
FILE_SHARE_READ | FILE_SHARE_WRITE, nullptr, OPEN_EXISTING, 0, nullptr);
if(testHandle!=INVALID_HANDLE_VALUE)
{
CloseHandle(testHandle);
paths.push_back(detailData->DevicePath);
}
}
SetupDiDestroyDeviceInfoList(hardwareDeviceInfo);
}
return paths;
}
USBDevice::USBDevice() : Interface(0), ErrorCode(), Timeout(getDefaultTimeout()), DevicePath(getDefaultDevicePath())
{
}
USBDevice::~USBDevice()
{
Close();
Reset();
}
USBDevice::USBDevice(USBDevice&&moveValue) : Interface(std::exchange(moveValue.Interface, 0)),
ErrorCode(moveValue.ErrorCode), Timeout(std::exchange(moveValue.Timeout, getDefaultTimeout())),
DevicePath(std::move(moveValue.DevicePath))
{
moveValue.ErrorCode.clear();
}
USBDevice& USBDevice::operator=(USBDevice&&moveValue)
{
if(this!=&moveValue)
{
if(!Close())
{
}
else
{
ErrorCode=moveValue.ErrorCode;
moveValue.ErrorCode.clear();
}
Interface=std::exchange(moveValue.Interface, 0);
Timeout=std::exchange(moveValue.Timeout, getDefaultTimeout());
DevicePath=std::move(moveValue.DevicePath);
}
return *this;
}
bool USBDevice::Close()
{
if(!isOpened())
return true;
bool result=DeviceManager::Instance().RemoveDevice(Interface);
if(!result)
ErrorCode=boost::system::errc::make_error_code(boost::system::errc::io_error);
return result;
}
bool USBDevice::Flush()
{
if(!isOpened()&&!Open())
return false;
std::string buffer(getAvailableBytes(), '\0');
if(buffer.empty())
return true;
std::size_t bytesRead=0;
bool success=DeviceManager::Instance().Read(Interface, StringToByteSpan(buffer), bytesRead);
if(!success)
ErrorCode=boost::system::errc::make_error_code(boost::system::errc::io_error);
return success;
}
bool USBDevice::Open()
{
ErrorCode.clear();
if(!isValid())
{
ErrorCode=boost::system::errc::make_error_code(boost::system::errc::invalid_argument);
return false;
}
if(isOpened())
return true;
Interface=DeviceManager::Instance().AddDevice(DevicePath);
if(Interface==0)
{
ErrorCode=boost::system::errc::make_error_code(boost::system::errc::no_such_device);
return false;
}
return true;
}
bool USBDevice::Reopen()
{
ErrorCode.clear();
if(isOpened()&&!Close())
return false;
return Open();
}
bool USBDevice::Reset()
{
Interface=0;
ErrorCode.clear();
Timeout=getDefaultTimeout();
DevicePath=getDefaultDevicePath();
return true;
}
bool USBDevice::Read(std::string& readData)
{
ErrorCode.clear();
if(!isOpened()&&!Open())
{
if(!ErrorCode)
{
ErrorCode=boost::system::errc::make_error_code(boost::system::errc::no_such_device);
}
return false;
}
if(readData.empty())
{
std::size_t available=getAvailableBytes();
if(available==0)
{
ErrorCode=boost::system::errc::make_error_code(
boost::system::errc::resource_unavailable_try_again);
return false;
}
Resize(readData, available);
}
std::size_t bytesRead=0;
bool success=DeviceManager::Instance().Read(Interface, StringToByteSpan(readData), bytesRead, Timeout);
if(success&&bytesRead > 0)
{
Resize(readData, bytesRead);
return true;
}
Clear(readData);
if(bytesRead==0)
ErrorCode=boost::system::errc::make_error_code(boost::system::errc::resource_unavailable_try_again);
else if(bytesRead!=0)
ErrorCode=boost::system::errc::make_error_code(boost::system::errc::io_error);
return false;
}
bool USBDevice::Read(std::string& readData, char readUntil)
{
ErrorCode.clear();
if(!isOpened()&&!Open())
{
if(!ErrorCode)
{
ErrorCode=boost::system::errc::make_error_code(boost::system::errc::no_such_device);
}
return false;
}
Clear(readData);
bool delimiterFound=false;
while(!delimiterFound)
{
if(getAvailableBytes()==0)
{
if(!readData.empty())
{
return true;
}
ErrorCode=boost::system::errc::make_error_code(boost::system::errc::resource_unavailable_try_again);
return false;
}
std::string singleByte(1, '\0');
std::size_t bytesRead=0;
bool success=DeviceManager::Instance().Read(Interface, StringToByteSpan(singleByte), bytesRead, Timeout);
if(!success)
{
ErrorCode=boost::system::errc::make_error_code(boost::system::errc::io_error);
return !readData.empty();
}
if(bytesRead==0)
{
return !readData.empty();
}
readData.push_back(singleByte[0]);
if(singleByte[0]==readUntil)
{
delimiterFound=true;
break;
}
}
return true;
}
bool USBDevice::Write(const std::string& writeData)
{
ErrorCode.clear();
if(writeData.empty())
return true;
if(!isOpened()&&!Open())
{
if(!ErrorCode)
{
ErrorCode=boost::system::errc::make_error_code(boost::system::errc::no_such_device);
}
return false;
}
bool success=DeviceManager::Instance().Write(Interface, StringToConstByteSpan(writeData), Timeout);
if(!success)
{
ErrorCode=boost::system::errc::make_error_code(boost::system::errc::io_error);
}
return success;
}
bool USBDevice::WriteRead(const std::string& writeData, std::string& readData,
char readUntil, const std::chrono::milliseconds pauseDuration)
{
ErrorCode.clear();
if(!Write(writeData))
{
return false;
}
BlockThread(pauseDuration);
if(!Write("\n"))
{
return false;
}
BlockThread(pauseDuration);
return Read(readData, readUntil);
}
bool USBDevice::WriteRead(const std::string& writeData,
std::string& readData, const std::chrono::milliseconds pauseDuration)
{
ErrorCode.clear();
if(!Write(writeData))
{
return false;
}
BlockThread(pauseDuration);
if(!Write("\n"))
{
return false;
}
BlockThread(pauseDuration);
return Read(readData);
}
std::size_t USBDevice::getAvailableBytes() const
{
if(!isOpened())
return 0;
return DeviceManager::Instance().ReadyBytes(Interface);
}
const std::string& USBDevice::getDevicePath() const
{
return DevicePath;
}
boost::system::error_code USBDevice::getErrorCode() const
{
return ErrorCode;
}
std::chrono::milliseconds USBDevice::getTimeout() const
{
return Timeout;
}
bool USBDevice::setDevicePath(const std::string& devicePath)
{
ErrorCode.clear();
if(!isValidDevicePath(devicePath))
{
ErrorCode=boost::system::errc::make_error_code(boost::system::errc::invalid_argument);
return false;
}
if(isOpened())
{
if(!Close())
{
return false;
}
}
DevicePath=devicePath;
return true;
}
bool USBDevice::setTimeout(std::chrono::milliseconds waitTimeMs)
{
ErrorCode.clear();
if(!isValidTimeout(waitTimeMs))
{
ErrorCode=boost::system::errc::make_error_code(boost::system::errc::invalid_argument);
return false;
}
Timeout=waitTimeMs;
return true;
}
bool USBDevice::setTimeout(std::chrono::milliseconds::rep waitTimeMs)
{
return setTimeout(std::chrono::milliseconds(waitTimeMs));
}
bool USBDevice::isClosed() const
{
return !isOpened();
}
bool USBDevice::isOpened() const
{
if(Interface==0)
return false;
return DeviceManager::Instance().ReadyBytes(Interface) >=0;
}
bool USBDevice::isValid() const
{
if(!isValidDevicePath(DevicePath)||!isValidTimeout(Timeout))
{
return false;
}
return !ErrorCode;
}
std::string USBDevice::toString() const
{
if(ErrorCode)
{
return Format("USB device: \"{}\" with timeout of {} ms. and error code of \"{}\"",
DevicePath, Timeout.count(), ErrorCode.message());
}
return Format("USB device: \"{}\" with timeout of {} ms. and without error code", DevicePath, Timeout.count());
}
std::vector<std::string> USBDevice::getActiveSystemDevices()
{
return DeviceManager::Instance().getActiveDevicePaths();
}
std::vector<std::string> USBDevice::getActiveSystemDevices(uint16_t vendorId, uint16_t productId)
{
std::vector<std::string> allDevices{getActiveSystemDevices()};
if(vendorId==0&&productId==0)
return allDevices;
std::vector<std::string> matchingDevices;
std::string vidPidPattern=Format("VID_{:04X}&PID_{:04X}", vendorId, productId);
for(const std::string& device : allDevices)
{
if(isValidDevicePath(device))
{
std::string deviceUpper=device;
std::transform(deviceUpper.begin(), deviceUpper.end(), deviceUpper.begin(),::toupper);
std::string patternUpper=vidPidPattern;
std::transform(patternUpper.begin(), patternUpper.end(), patternUpper.begin(),::toupper);
if(deviceUpper.find(patternUpper)!=std::string::npos)
{
matchingDevices.push_back(device);
}
}
}
return matchingDevices;
}
std::string USBDevice::getDefaultDevicePath()
{
return std::string{};
}
std::chrono::milliseconds USBDevice::getDefaultTimeout()
{
return std::chrono::milliseconds::zero();
}
bool USBDevice::isValidDevicePath(const std::string& devicePath)
{
if(devicePath.size() < 54)
return false;
return std::regex_match(devicePath, std::regex("^\\\\\\\\\\?\\\\USB#VID_[0-9A-F]{4}&PID_[0-9A-F]{4}#.*#"
"\\{[0-9A-F]{8}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{12}\\}$", std::regex_constants::icase));
}
bool USBDevice::isValidTimeout(std::chrono::milliseconds durationMs)
{
return durationMs.count() >=0;
}
bool USBDevice::isValidTimeout(std::chrono::milliseconds::rep durationMs)
{
return durationMs >=0;
}
}
```
## File: DeviceInterfaceDriver/USBDevice.hpp
```
#ifndef USBDevice_H
#define USBDevice_H
#include <boost/asio.hpp>
#include "Device.hpp"
#include "Utility.hpp"
namespace Cognitive
{
class USBDevice : public Device
{
public:
USBDevice();
~USBDevice();
USBDevice(USBDevice&&moveValue);
USBDevice& operator=(USBDevice&&moveValue);
USBDevice(const USBDevice&)=delete;
USBDevice& operator=(const USBDevice&)=delete;
bool Close();
bool Flush();
bool Open();
bool Reopen();
bool Reset();
bool Read(std::string& readData);
bool Read(std::string& readData, char readUntil);
bool Write(const std::string& writeData);
bool WriteRead(const std::string& writeData, std::string& readData,
const std::chrono::milliseconds pauseDuration=std::chrono::milliseconds{50});
bool WriteRead(const std::string& writeData, std::string& readData, char readUntil,
const std::chrono::milliseconds pauseDuration=std::chrono::milliseconds{50});
std::size_t getAvailableBytes() const;
const std::string& getDevicePath() const;
boost::system::error_code getErrorCode() const;
std::chrono::milliseconds getTimeout() const;
bool setDevicePath(const std::string& devicePath);
bool setTimeout(std::chrono::milliseconds waitTimeMs);
bool setTimeout(std::chrono::milliseconds::rep waitTimeMs);
bool isClosed() const;
bool isOpened() const;
bool isValid() const;
std::string toString() const;
static std::vector<std::string> getActiveSystemDevices();
static std::vector<std::string> getActiveSystemDevices(uint16_t vendorId, uint16_t productId);
static std::string getDefaultDevicePath();
static std::chrono::milliseconds getDefaultTimeout();
static bool isValidDevicePath(const std::string& devicePath);
static bool isValidTimeout(std::chrono::milliseconds durationMs);
static bool isValidTimeout(std::chrono::milliseconds::rep durationMs);
public:
std::size_t Interface;
boost::system::error_code ErrorCode;
std::chrono::milliseconds Timeout;
std::string DevicePath;
};
}
#endif
```
## File: DeviceInterfaceDriver/Utility.cpp
```cpp
#include "Utility.hpp"
#include <format>
#include <random>
bool Cognitive::BlockThread(std::chrono::milliseconds duration)
{
if(duration > std::chrono::milliseconds::zero())
{
return (std::this_thread::sleep_for(duration), true);
}
return false;
}
bool Cognitive::BlockThread(std::chrono::milliseconds::rep duration)
{
return BlockThread(std::chrono::milliseconds{duration});
}
std::span<std::byte> Cognitive::StringToByteSpan(std::string& input)
{
return std::span<std::byte>{reinterpret_cast<std::byte*>(input.data()), input.size()};
}
std::span<const std::byte> Cognitive::StringToConstByteSpan(const std::string& input)
{
return {reinterpret_cast<const std::byte*>(input.data()), input.size()};
}
std::string Cognitive::AddNewlines(const std::string& input)
{
return '\n' + input + '\n';
}
std::string Cognitive::TrimNewlines(const std::string& input)
{
const std::size_t start=input.find_first_not_of('\n');
return (start==std::string::npos) ? std::string{} : input.substr(start, input.find_last_not_of('\n') - start + 1);
}
std::vector<std::string> Cognitive::SplitLines(const std::string& input)
{
std::vector<std::string> lines;
std::size_t start=0, end=0;
while((end=input.find('\n', start))!=std::string::npos)
{
lines.push_back(input.substr(start, end - std::exchange(start, end + 1)));
}
if(start < input.size())
{
lines.push_back(input.substr(start));
}
return lines;
}
```
## File: DeviceInterfaceDriver/Utility.hpp
```
#ifndef Utility_H
#define Utility_H
#include <array>
#include <chrono>
#include <cstdint>
#include <filesystem>
#include <format>
#include <future>
#include <print>
#include <span>
#include <string>
#include <system_error>
#include <thread>
namespace Cognitive
{
template <typename F, typename... V> bool ExecuteWithTimeout(std::chrono::milliseconds wait, F&&function, V&&... inputs);
template <typename... V> std::string Format(const std::string& format, V&&... inputs);
template <typename... V> std::string ErrorFormat(std::int32_t line, const std::string& function,
const std::string& path, const std::string& format, V&&... inputs);
template <typename... V> bool Error(V&&... inputs);
template <typename T> T& Clear(T& container);
template <typename T> T& Resize(T& container, std::size_t length);
template <typename T> T& Shrink(T& container);
extern bool BlockThread(std::chrono::milliseconds duration);
extern bool BlockThread(std::chrono::milliseconds::rep duration);
extern std::span<std::byte> StringToByteSpan(std::string& input);
extern std::span<const std::byte> StringToConstByteSpan(const std::string& input);
extern std::string AddNewlines(const std::string& input);
extern std::string TrimNewlines(const std::string& input);
extern std::vector<std::string> SplitLines(const std::string& input);
}
template <typename F, typename... V> bool Cognitive::ExecuteWithTimeout(std::chrono::milliseconds maxWaitTime, F&&function, V&&... inputValues)
{
if(maxWaitTime.count()==0)
{
function(std::forward<V>(inputValues)...);
return true;
}
auto future=std::async(std::launch::async, std::forward<F>(function), std::forward<V>(inputValues)...);
if(future.wait_for(maxWaitTime)==std::future_status::ready)
{
future.get();
return true;
}
return false;
}
template <typename... V> std::string Cognitive::Format(const std::string& format, V&&... inputs)
{
return std::vformat(format, std::make_format_args(inputs...));
}
template <typename... V> std::string Cognitive::ErrorFormat(std::int32_t line, const std::string& function,
const std::string& path, const std::string& format, V&&... inputs)
{
const std::string formatString{"[ {:%m/%d/%Y %H:%M:%S} ] - " + format + " (line #{} in function {}() in file \"{}\")\n\n"};
const std::chrono::system_clock::time_point currentTime{std::chrono::system_clock::from_time_t(time(nullptr))};
const std::string fileName{std::filesystem::path(path).filename().string()};
return Format(formatString, currentTime, inputs..., line, function, fileName);
}
template <typename... V> bool Cognitive::Error(V&&... inputs)
{
return (std::print(stderr, "{}", ErrorFormat(inputs...)), false);
}
template <typename T> T& Cognitive::Clear(T& container)
{
return (container.clear(), Shrink(container));
}
template <typename T> T& Cognitive::Resize(T& container, std::size_t length)
{
return (container.resize(length), Shrink(container));
}
template <typename T> T& Cognitive::Shrink(T& container)
{
return (container.shrink_to_fit(), container);
}
#endif
```
````
````Showcase.html
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<title>Cognitive LLC Printer Administrator</title>
<style>
:root {
--bg-face: #f0f0f0;
--bg-window: #ffffff;
--text-main: #000000;
--text-secondary: #666666;
--border-light: #ffffff;
--border-shadow: #a0a0a0;
--border-dark: #696969;
--group-text: #0046d5;
--status-red: #ff0000;
--status-green: #008000;
--accent-primary: #0078d7;
--accent-hover: #005a9e;
--font-family: 'Tahoma', 'Segoe UI', sans-serif;
--font-size-base: 11px;
--font-size-small: 9px;
--border-radius: 3px;
--button-height: 20px;
--spacing-xs: 2px;
--spacing-sm: 4px;
--spacing-md: 8px;
--spacing-lg: 12px;
--z-base: 1;
--z-dropdown: 100;
--z-modal: 1000;
--container-size: min(88vh, 88vw);
}
/* Light Mode (Default) - Clean modern look merged with classic elements */
[data-theme="light_mode"] {
--bg-face: #f0f0f0;
--bg-window: #ffffff;
--text-main: #000000;
--text-secondary: #666666;
--border-light: #ffffff;
--border-shadow: #a0a0a0;
--border-dark: #696969;
--group-text: #0046d5;
--accent-primary: #0078d7;
--accent-hover: #005a9e;
--font-family: 'Segoe UI', 'Tahoma', sans-serif;
--border-radius: 3px;
}
/* Dark Mode - Modern dark interface */
[data-theme="dark_mode"] {
--bg-face: #1e1e1e;
--bg-window: #252526;
--text-main: #cccccc;
--text-secondary: #888888;
--border-light: #3e3e42;
--border-shadow: #2b2b2b;
--border-dark: #1e1e1e;
--group-text: #4fc3f7;
--accent-primary: #0e639c;
--accent-hover: #1177bb;
--font-family: 'Segoe UI', sans-serif;
}
/* Glassmorphism - Sleek transparent UI with frosted glass effects */
[data-theme="glassmorphism"] {
--bg-face: rgba(255, 255, 255, 0.15);
--bg-window: rgba(255, 255, 255, 0.25);
--text-main: #1a1a2e;
--text-secondary: #4a4a6a;
--border-light: rgba(255, 255, 255, 0.4);
--border-shadow: rgba(200, 200, 220, 0.3);
--border-dark: rgba(150, 150, 180, 0.4);
--group-text: #6366f1;
--accent-primary: #8b5cf6;
--accent-hover: #7c3aed;
--font-family: 'Segoe UI', system-ui, sans-serif;
--border-radius: 12px;
--glass-blur: blur(20px);
--glass-saturate: saturate(180%);
}
/* Legacy Style - Windows XP/2000 aesthetic with chiseled borders */
[data-theme="legacy_style"] {
--bg-face: #d4d0c8;
--bg-window: #ffffff;
--text-main: #000000;
--text-secondary: #505050;
--border-light: #ffffff;
--border-shadow: #808080;
--border-dark: #404040;
--group-text: #000080;
--accent-primary: #0a246a;
--accent-hover: #316ac5;
--font-family: 'MS Sans Serif', 'Tahoma', sans-serif;
--border-radius: 0px;
--button-gradient: linear-gradient(180deg, #ffffff 0%, #d4d0c8 50%, #c0c0c0 100%);
}
/* Space - Animated starfield with cosmic dark theme */
[data-theme="space"] {
--bg-face: #0a0a1a;
--bg-window: #12122a;
--text-main: #e0e0ff;
--text-secondary: #8888bb;
--border-light: #2a2a4a;
--border-shadow: #1a1a3a;
--border-dark: #0a0a2a;
--group-text: #00d4ff;
--accent-primary: #6366f1;
--accent-hover: #818cf8;
--status-red: #ff4444;
--status-green: #44ff88;
--font-family: 'Segoe UI', sans-serif;
--border-radius: 6px;
--glow-color: rgba(99, 102, 241, 0.5);
}
/* Nebula - Cosmic gradients with aurora-like animations */
[data-theme="nebula"] {
--bg-face: #1a0a2e;
--bg-window: #2a1a3e;
--text-main: #f0e6ff;
--text-secondary: #b8a8d8;
--border-light: #4a2a6e;
--border-shadow: #3a1a5e;
--border-dark: #2a0a4e;
--group-text: #ff6ec7;
--accent-primary: #bf5af2;
--accent-hover: #da8fff;
--status-red: #ff4466;
--status-green: #66ffaa;
--font-family: 'Segoe UI', sans-serif;
--border-radius: 8px;
--nebula-gradient: linear-gradient(135deg, #1a0a2e 0%, #2a1a4e 25%, #3a2a6e 50%, #2a1a4e 75%, #1a0a2e 100%);
--aurora-glow: 0 0 20px rgba(191, 90, 242, 0.3);
}
/* High Contrast - Maximum visibility for accessibility */
[data-theme="high_contrast"] {
--bg-face: #000000;
--bg-window: #000000;
--text-main: #ffffff;
--text-secondary: #ffff00;
--border-light: #ffffff;
--border-shadow: #ffffff;
--border-dark: #ffffff;
--group-text: #00ff00;
--accent-primary: #1aebff;
--accent-hover: #00ffff;
--status-red: #ff0000;
--status-green: #00ff00;
--font-family: 'Segoe UI', sans-serif;
--border-radius: 0px;
}
* {
box-sizing: border-box;
}
body {
font-family: var(--font-family);
font-size: var(--font-size-base);
background-color: #2a2a2a;
color: var(--text-main);
margin: 0;
padding: 0;
height: 100vh;
width: 100vw;
overflow: hidden;
user-select: none;
-webkit-user-select: none;
-moz-user-select: none;
display: flex;
align-items: center;
justify-content: center;
}
.app-wrapper {
width: var(--container-size);
height: var(--container-size);
background: var(--bg-face);
box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
border: 2px solid var(--border-dark);
display: flex;
flex-direction: column;
transition: all 0.3s ease;
position: relative;
overflow: hidden;
}
/* Glassmorphism Special Effects */
[data-theme="glassmorphism"] .app-wrapper {
background: linear-gradient(135deg, #a8c0ff 0%, #c8b6ff 50%, #e8d5ff 100%);
}
[data-theme="glassmorphism"] .app-container {
background: rgba(255, 255, 255, 0.25);
backdrop-filter: blur(20px);
-webkit-backdrop-filter: blur(20px);
}
[data-theme="glassmorphism"] .app-header {
background: rgba(255, 255, 255, 0.3);
backdrop-filter: blur(20px);
-webkit-backdrop-filter: blur(20px);
border-bottom: 1px solid rgba(255, 255, 255, 0.4);
}
[data-theme="glassmorphism"] .sidebar-panel,
[data-theme="glassmorphism"] .main-panel {
background: rgba(255, 255, 255, 0.2);
backdrop-filter: blur(20px);
-webkit-backdrop-filter: blur(20px);
}
[data-theme="glassmorphism"] .group-box {
background: rgba(255, 255, 255, 0.15);
border: 1px solid rgba(255, 255, 255, 0.3);
box-shadow: 0 4px 16px rgba(0, 0, 0, 0.1);
}
[data-theme="glassmorphism"] .tab-item {
background: rgba(255, 255, 255, 0.2);
backdrop-filter: blur(10px);
-webkit-backdrop-filter: blur(10px);
}
[data-theme="glassmorphism"] .tab-item.active {
background: rgba(139, 92, 246, 0.4);
color: white;
}
[data-theme="glassmorphism"] button {
background: rgba(255, 255, 255, 0.3);
backdrop-filter: blur(10px);
-webkit-backdrop-filter: blur(10px);
border: 1px solid rgba(255, 255, 255, 0.4);
}
[data-theme="glassmorphism"] button:hover {
background: rgba(139, 92, 246, 0.3);
}
/* Space Theme - Animated Starfield Background */
[data-theme="space"] .app-wrapper {
background: radial-gradient(ellipse at center, #1a1a3a 0%, #0a0a1a 100%);
}
[data-theme="space"] .app-wrapper::before {
content: '';
position: absolute;
top: 0;
left: 0;
right: 0;
bottom: 0;
background-image: 
radial-gradient(2px 2px at 20px 30px, rgba(255,255,255,0.8), transparent),
radial-gradient(2px 2px at 40px 70px, rgba(255,255,255,0.6), transparent),
radial-gradient(1px 1px at 90px 40px, rgba(255,255,255,0.9), transparent),
radial-gradient(2px 2px at 130px 80px, rgba(255,255,255,0.5), transparent),
radial-gradient(1px 1px at 160px 120px, rgba(255,255,255,0.7), transparent),
radial-gradient(2px 2px at 200px 50px, rgba(99,102,241,0.8), transparent),
radial-gradient(1px 1px at 250px 150px, rgba(255,255,255,0.6), transparent),
radial-gradient(2px 2px at 300px 100px, rgba(255,255,255,0.8), transparent),
radial-gradient(1px 1px at 350px 200px, rgba(129,140,248,0.7), transparent),
radial-gradient(2px 2px at 400px 80px, rgba(255,255,255,0.5), transparent);
background-size: 450px 250px;
animation: space-twinkle 4s ease-in-out infinite alternate, space-drift 60s linear infinite;
pointer-events: none;
z-index: 0;
}
[data-theme="space"] .app-container {
position: relative;
z-index: 1;
background: rgba(18, 18, 42, 0.9);
}
[data-theme="space"] .group-box {
box-shadow: 0 0 15px var(--glow-color);
border: 1px solid rgba(99, 102, 241, 0.3);
}
[data-theme="space"] .tab-item.active {
box-shadow: 0 0 10px var(--glow-color);
}
[data-theme="space"] .status-box {
box-shadow: 0 0 8px rgba(255, 68, 68, 0.5);
}
[data-theme="space"] .status-box.connected {
box-shadow: 0 0 8px rgba(68, 255, 136, 0.5);
}
@keyframes space-twinkle {
0% { opacity: 0.7; }
50% { opacity: 1; }
100% { opacity: 0.8; }
}
@keyframes space-drift {
0% { background-position: 0 0; }
100% { background-position: 450px 250px; }
}
@keyframes space-particle-float {
0%, 100% { transform: translateY(0) translateX(0); opacity: 0.5; }
25% { transform: translateY(-10px) translateX(5px); opacity: 1; }
50% { transform: translateY(-5px) translateX(-3px); opacity: 0.8; }
75% { transform: translateY(-15px) translateX(8px); opacity: 0.6; }
}
/* Nebula Theme - Cosmic Gradients with Aurora Effects */
[data-theme="nebula"] .app-wrapper {
background: var(--nebula-gradient);
position: relative;
}
[data-theme="nebula"] .app-wrapper::before {
content: '';
position: absolute;
top: 0;
left: 0;
right: 0;
bottom: 0;
background: 
radial-gradient(ellipse at 20% 20%, rgba(191, 90, 242, 0.3) 0%, transparent 50%),
radial-gradient(ellipse at 80% 30%, rgba(255, 110, 199, 0.2) 0%, transparent 40%),
radial-gradient(ellipse at 40% 80%, rgba(99, 102, 241, 0.25) 0%, transparent 45%),
radial-gradient(ellipse at 70% 70%, rgba(168, 85, 247, 0.2) 0%, transparent 35%);
animation: nebula-pulse 8s ease-in-out infinite alternate;
pointer-events: none;
z-index: 0;
}
[data-theme="nebula"] .app-wrapper::after {
content: '';
position: absolute;
top: 0;
left: 0;
right: 0;
bottom: 0;
background: linear-gradient(45deg, 
transparent 0%, 
rgba(191, 90, 242, 0.1) 25%, 
transparent 50%, 
rgba(255, 110, 199, 0.1) 75%, 
transparent 100%);
background-size: 200% 200%;
animation: nebula-aurora 12s ease-in-out infinite;
pointer-events: none;
z-index: 0;
}
[data-theme="nebula"] .app-container {
position: relative;
z-index: 1;
background: rgba(42, 26, 62, 0.85);
}
[data-theme="nebula"] .app-header {
background: rgba(42, 26, 62, 0.9);
box-shadow: var(--aurora-glow);
}
[data-theme="nebula"] .group-box {
background: rgba(58, 26, 94, 0.5);
box-shadow: var(--aurora-glow);
border: 1px solid rgba(191, 90, 242, 0.3);
}
[data-theme="nebula"] .tab-item.active {
background: linear-gradient(135deg, rgba(191, 90, 242, 0.6), rgba(255, 110, 199, 0.4));
box-shadow: var(--aurora-glow);
}
[data-theme="nebula"] button {
background: linear-gradient(135deg, rgba(74, 42, 110, 0.8), rgba(58, 26, 94, 0.9));
border: 1px solid rgba(191, 90, 242, 0.4);
}
[data-theme="nebula"] button:hover {
background: linear-gradient(135deg, rgba(191, 90, 242, 0.5), rgba(168, 85, 247, 0.5));
box-shadow: var(--aurora-glow);
}
@keyframes nebula-pulse {
0% { opacity: 0.6; transform: scale(1); }
50% { opacity: 0.9; transform: scale(1.02); }
100% { opacity: 0.7; transform: scale(1); }
}
@keyframes nebula-aurora {
0% { background-position: 0% 50%; }
50% { background-position: 100% 50%; }
100% { background-position: 0% 50%; }
}
/* Legacy Style Special Effects - Windows XP/2000 Chiseled Look */
[data-theme="legacy_style"] button {
background: var(--button-gradient);
border-width: 2px;
border-style: solid;
border-color: #ffffff #404040 #404040 #ffffff;
}
[data-theme="legacy_style"] button:active:not(:disabled) {
border-color: #404040 #ffffff #ffffff #404040;
}
[data-theme="legacy_style"] .group-box {
border-width: 2px;
border-style: groove;
border-color: #808080;
}
[data-theme="legacy_style"] input[type="text"],
[data-theme="legacy_style"] input[type="number"],
[data-theme="legacy_style"] select,
[data-theme="legacy_style"] textarea {
border-width: 2px;
border-style: inset;
border-color: #808080;
}
[data-theme="legacy_style"] .app-header {
background: linear-gradient(180deg, #0a246a 0%, #a6caf0 100%);
color: white;
}
[data-theme="legacy_style"] .header-logo,
[data-theme="legacy_style"] .header-logo span {
color: white !important;
text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
}
[data-theme="legacy_style"] .tab-item.active {
border-width: 2px;
border-style: solid;
border-color: #ffffff #404040 #d4d0c8 #ffffff;
}
.app-container {
width: 100%;
height: 100%;
display: flex;
flex-direction: column;
background: var(--bg-face);
transition: background-color 0.3s, color 0.3s;
}
/* Cognitive Layout (Default) - Standard sidebar-left layout similar to JAdmin */
[data-layout="cognitive"] .workspace-content {
flex-direction: row;
}
[data-layout="cognitive"] .sidebar-panel {
order: 1;
width: 300px;
min-width: 300px;
height: auto;
border-right: 1px solid var(--border-shadow);
border-bottom: none;
}
[data-layout="cognitive"] .main-panel {
order: 2;
flex: 1;
width: auto;
height: auto;
}
/* Minimal Layout - Ultra-clean, content-focused with vertical tabs on left edge */
[data-layout="minimal"] .app-header {
padding: var(--spacing-sm) var(--spacing-md);
min-height: 40px;
}
[data-layout="minimal"] .header-branding {
gap: var(--spacing-sm);
}
[data-layout="minimal"] .header-logo {
font-size: 14px;
}
[data-layout="minimal"] .header-logo span:first-child {
font-size: 16px !important;
}
[data-layout="minimal"] .header-controls {
gap: var(--spacing-sm);
}
[data-layout="minimal"] .header-controls .control-group label {
font-size: 9px;
}
[data-layout="minimal"] .tab-folder {
flex-direction: column;
position: absolute;
left: 0;
top: 100px;
width: 32px;
padding: var(--spacing-xs);
background: var(--bg-face);
border-right: 1px solid var(--border-shadow);
border-bottom: none;
z-index: 10;
opacity: 0.3;
transition: opacity 0.3s, width 0.3s;
}
[data-layout="minimal"] .tab-folder:hover {
opacity: 1;
width: auto;
min-width: 100px;
}
[data-layout="minimal"] .tab-item {
writing-mode: horizontal-tb;
padding: 4px 6px;
margin: 1px 0;
font-size: 9px;
border-radius: var(--border-radius);
border: 1px solid transparent;
white-space: nowrap;
overflow: hidden;
text-overflow: ellipsis;
max-width: 24px;
transition: max-width 0.3s;
}
[data-layout="minimal"] .tab-folder:hover .tab-item {
max-width: 200px;
}
[data-layout="minimal"] .tab-item.active {
background: var(--accent-primary);
color: white;
border-color: var(--accent-primary);
}
[data-layout="minimal"] .workspace-content {
flex-direction: row;
margin-left: 32px;
}
[data-layout="minimal"] .sidebar-panel {
order: 1;
width: 240px;
min-width: 200px;
height: auto;
border-right: 1px solid var(--border-shadow);
border-bottom: none;
padding: var(--spacing-sm);
}
[data-layout="minimal"] .main-panel {
order: 2;
flex: 1;
width: auto;
height: auto;
padding: var(--spacing-sm);
}
[data-layout="minimal"] .group-box {
margin: var(--spacing-sm) 0;
padding: var(--spacing-sm);
}
[data-layout="minimal"] .section-title {
font-size: 10px;
}
[data-layout="minimal"] button {
height: 18px;
font-size: 9px;
padding: 1px 6px;
}
/* Border Options - No borders is default (Windows Store/Update style) */
.app-wrapper {
border: none;
}
[data-borders="true"] .app-wrapper {
border: 2px solid var(--border-dark);
}
/* Legacy Layout Compatibility */
[data-layout="sidebar_left"] .workspace-content {
flex-direction: row;
}
[data-layout="sidebar_left"] .sidebar-panel {
order: 1;
width: 300px;
min-width: 300px;
height: auto;
border-right: 1px solid var(--border-shadow);
border-bottom: none;
}
[data-layout="sidebar_left"] .main-panel {
order: 2;
flex: 1;
width: auto;
height: auto;
}
.app-header {
background: var(--bg-face);
padding: var(--spacing-md);
display: flex;
align-items: center;
justify-content: space-between;
border-bottom: 1px solid var(--border-shadow);
flex-shrink: 0;
min-height: 60px;
gap: var(--spacing-md);
flex-wrap: wrap;
}
.header-logo {
font-size: 18px;
font-weight: bold;
color: var(--text-main);
font-family: 'Arial Black', sans-serif;
display: flex;
flex-direction: column;
line-height: 1.2;
}
.header-logo .logo-tpg {
color: #cc0000;
display: inline;
}
.header-logo .logo-subtitle {
font-size: var(--font-size-small);
font-family: var(--font-family);
font-weight: normal;
color: var(--text-secondary);
}
.header-controls {
display: flex;
align-items: center;
gap: var(--spacing-md);
flex-wrap: wrap;
}
.control-group {
display: flex;
align-items: center;
gap: var(--spacing-sm);
}
.control-group label {
display: flex;
align-items: center;
gap: var(--spacing-sm);
white-space: nowrap;
margin: 0;
}
.header-center-spacer {
flex: 1;
}
.header-right-spacer {
flex: 1;
}
.heartbeat-centered {
justify-content: center;
}
.status-box {
min-width: 150px;
height: 32px;
background-color: var(--status-red);
color: white !important;
display: flex;
align-items: center;
padding: 0 10px;
font-weight: bold;
font-size: var(--font-size-base);
border: 2px solid var(--border-dark);
border-top-color: var(--border-shadow);
border-left-color: var(--border-shadow);
cursor: pointer;
position: relative;
user-select: none;
}
.status-box.connected {
background-color: var(--status-green);
}
.status-box:hover {
opacity: 0.9;
}
.status-menu {
position: absolute;
top: 100%;
right: 0;
background: var(--bg-window);
border: 1px solid var(--border-dark);
box-shadow: 2px 2px 4px rgba(0,0,0,0.2);
min-width: 200px;
z-index: var(--z-dropdown);
display: none;
}
.status-menu.visible {
display: block;
}
.status-menu-item {
padding: 5px 10px;
cursor: pointer;
border-bottom: 1px solid var(--border-light);
font-size: 10px;
background: var(--bg-window);
color: var(--text-main);
}
.status-menu-item:hover {
background: var(--accent-primary);
color: white;
}
[data-theme="dark_mode"] .status-menu-item:hover,
[data-theme="high_contrast"] .status-menu-item:hover,
[data-theme="space"] .status-menu-item:hover,
[data-theme="nebula"] .status-menu-item:hover {
color: var(--bg-window);
}
.tab-folder {
display: flex;
padding: var(--spacing-xs) var(--spacing-xs) 0 var(--spacing-xs);
background: var(--bg-face);
border-bottom: 1px solid var(--border-shadow);
flex-shrink: 0;
overflow-x: auto;
overflow-y: hidden;
scroll-behavior: smooth;
scrollbar-width: thin;
scrollbar-color: var(--border-shadow) var(--bg-face);
}
.tab-folder::-webkit-scrollbar {
height: 6px;
}
.tab-folder::-webkit-scrollbar-track {
background: var(--bg-face);
}
.tab-folder::-webkit-scrollbar-thumb {
background: var(--border-shadow);
border-radius: 3px;
}
.tab-folder::-webkit-scrollbar-thumb:hover {
background: var(--border-dark);
}
.tab-item {
padding: 3px 8px;
margin-right: var(--spacing-xs);
background: var(--bg-face);
border: 1px solid var(--border-shadow);
border-bottom: none;
border-top-left-radius: var(--border-radius);
border-top-right-radius: var(--border-radius);
cursor: pointer;
position: relative;
top: 1px;
color: var(--text-main);
font-size: 10px;
white-space: nowrap;
transition: background-color 0.2s;
}
.tab-item:hover {
background: var(--border-light);
}
.tab-item.active {
background: var(--bg-window);
border-left: 1px solid var(--border-light);
border-top: 1px solid var(--border-light);
border-right: 1px solid var(--border-dark);
z-index: var(--z-base);
font-weight: bold;
}
.tab-item.dragging {
opacity: 0.5;
}
.workspace {
flex: 1;
background: var(--bg-window);
display: none;
overflow: hidden;
}
.workspace.visible {
display: flex;
flex-direction: column;
}
.workspace-content {
flex: 1;
display: flex;
overflow: hidden;
transition: all 0.3s ease;
}
.sidebar-panel {
display: flex;
flex-direction: column;
padding: var(--spacing-md);
overflow-y: auto;
background: var(--bg-window);
transition: all 0.3s ease;
}
.main-panel {
display: flex;
flex-direction: column;
padding: var(--spacing-md);
overflow-y: auto;
background: var(--bg-window);
gap: var(--spacing-md);
transition: all 0.3s ease;
}
.group-box {
border: 1px solid var(--border-shadow);
border-radius: var(--border-radius);
margin-top: var(--spacing-md);
margin-bottom: var(--spacing-md);
padding: var(--spacing-md);
position: relative;
}
.group-title {
position: absolute;
top: -7px;
left: 8px;
background: var(--bg-window);
padding: 0 3px;
color: var(--group-text);
font-size: var(--font-size-base);
}
button {
font-family: var(--font-family);
font-size: 10px;
background: var(--bg-face);
border: 1px solid var(--border-dark);
border-top-color: var(--border-light);
border-left-color: var(--border-light);
border-right-color: var(--border-dark);
border-bottom-color: var(--border-dark);
border-radius: var(--border-radius);
padding: 2px 8px;
min-width: 60px;
height: var(--button-height);
color: var(--text-main);
cursor: pointer;
transition: transform 0.1s, background-color 0.2s;
}
button:hover:not(:disabled) {
background: var(--border-light);
}
button:active:not(:disabled) {
border: 1px solid var(--border-shadow);
border-right-color: var(--border-light);
border-bottom-color: var(--border-light);
transform: translate(1px, 1px);
}
button:disabled {
color: var(--text-secondary);
opacity: 0.6;
cursor: not-allowed;
}
button:focus {
outline: 2px solid var(--accent-primary);
outline-offset: 2px;
}
input[type="text"],
input[type="number"],
input[type="password"],
select,
textarea {
border: 1px solid #7f9db9;
padding: 2px 4px;
font-family: var(--font-family);
font-size: 10px;
background: var(--bg-window);
color: var(--text-main);
border-radius: var(--border-radius);
}
input:focus,
select:focus,
textarea:focus {
outline: 2px solid var(--accent-primary);
outline-offset: 1px;
}
input[readonly] {
background: var(--bg-face);
color: var(--text-secondary);
}
input:disabled,
select:disabled {
background: var(--bg-face);
color: var(--text-secondary);
opacity: 0.6;
}
label {
display: inline-flex;
align-items: center;
margin-right: var(--spacing-md);
white-space: nowrap;
cursor: pointer;
}
input[type="checkbox"],
input[type="radio"] {
margin: 0 var(--spacing-sm) 0 0;
cursor: pointer;
}
.row {
display: flex;
align-items: center;
margin-bottom: var(--spacing-sm);
gap: var(--spacing-sm);
flex-wrap: wrap;
}
.fill {
flex: 1;
min-width: 0;
}
.grid-2 {
display: grid;
grid-template-columns: auto 1fr;
gap: var(--spacing-sm);
align-items: center;
}
textarea {
font-size: 10px;
resize: vertical;
}
table {
width: 100%;
border-collapse: collapse;
border: 1px solid var(--border-dark);
background: var(--bg-window);
table-layout: fixed;
font-size: 10px;
}
th {
background: var(--bg-face);
text-align: left;
padding: var(--spacing-sm);
border-bottom: 1px solid var(--border-dark);
font-weight: normal;
border-right: 1px solid var(--border-shadow);
}
td {
padding: var(--spacing-sm);
border-bottom: 1px solid var(--border-light);
white-space: nowrap;
overflow: hidden;
text-overflow: ellipsis;
}
tr:hover {
background: var(--border-light);
}
tr.selected {
background: var(--accent-primary);
color: white;
}
.progress-container {
border: 1px solid var(--border-dark);
height: 16px;
background: var(--bg-window);
position: relative;
border-radius: var(--border-radius);
overflow: hidden;
}
.progress-bar {
height: 100%;
background: var(--accent-primary);
width: 0%;
transition: width 0.3s;
}
.printer-list {
border: 1px solid var(--border-dark);
background: var(--bg-window);
flex: 1;
overflow-y: auto;
border-radius: var(--border-radius);
}
.printer-item {
padding: 5px;
border-bottom: 1px solid var(--border-light);
display: flex;
justify-content: space-between;
align-items: center;
cursor: pointer;
transition: background-color 0.2s;
}
.printer-item:hover {
background: var(--border-light);
}
.printer-item.selected {
background: var(--accent-primary);
color: white;
}
.printer-item-left {
display: flex;
align-items: center;
gap: 5px;
}
.printer-status {
width: 10px;
height: 10px;
border-radius: 50%;
background: var(--status-red);
flex-shrink: 0;
}
.printer-status.connected {
background: var(--status-green);
}
.printer-item-port {
font-size: var(--font-size-small);
color: var(--text-secondary);
}
.printer-item.selected .printer-item-port {
color: rgba(255, 255, 255, 0.8);
}
.multi-select-dropdown {
border: 1px solid #7f9db9;
background: var(--bg-window);
min-height: 24px;
padding: var(--spacing-xs);
cursor: pointer;
position: relative;
display: flex;
flex-wrap: wrap;
gap: var(--spacing-xs);
border-radius: var(--border-radius);
}
.multi-select-tag {
background: var(--accent-primary);
color: white;
padding: 1px 5px;
border-radius: var(--border-radius);
font-size: var(--font-size-small);
display: flex;
align-items: center;
gap: 3px;
}
.multi-select-tag-remove {
cursor: pointer;
font-weight: bold;
padding: 0 2px;
}
.multi-select-tag-remove:hover {
background: rgba(255, 255, 255, 0.3);
border-radius: 2px;
}
.multi-select-options {
position: absolute;
top: 100%;
left: 0;
right: 0;
background: var(--bg-window);
border: 1px solid #7f9db9;
max-height: 200px;
overflow-y: auto;
z-index: var(--z-dropdown);
display: none;
border-radius: var(--border-radius);
box-shadow: 2px 2px 8px rgba(0,0,0,0.2);
}
.multi-select-options.visible {
display: block;
}
.multi-select-option {
padding: 3px 5px;
cursor: pointer;
font-size: 10px;
}
.multi-select-option:hover {
background: var(--border-light);
}
.multi-select-option.selected {
background: var(--accent-primary);
color: white;
}
#cpl a[data-category] {
cursor: pointer;
color: var(--accent-primary);
padding: 2px 4px;
border-radius: var(--border-radius);
text-decoration: none;
}
#cpl a[data-category]:hover {
background: var(--accent-primary);
color: #fff;
}
#cpl a[data-category].active {
background: var(--accent-secondary);
color: #000;
font-weight: bold;
}
[data-theme="dark_mode"] #cpl a[data-category].active,
[data-theme="high_contrast"] #cpl a[data-category].active,
[data-theme="space"] #cpl a[data-category].active,
[data-theme="nebula"] #cpl a[data-category].active {
color: #fff;
}
.cpl-command-card {
background: var(--bg-face);
border: 1px solid var(--border-shadow);
padding: var(--spacing-md);
margin-bottom: var(--spacing-md);
border-radius: var(--border-radius);
}
.cpl-command-title {
font-weight: bold;
color: var(--group-text);
margin-bottom: 3px;
}
.cpl-command-syntax {
font-family: 'Courier New', monospace;
font-size: var(--font-size-small);
background: var(--bg-window);
padding: 3px;
border: 1px solid var(--border-light);
margin: 3px 0;
border-radius: var(--border-radius);
}
.cpl-command-desc {
font-size: var(--font-size-small);
color: var(--text-secondary);
line-height: 1.3;
}
.cpl-response {
font-size: var(--font-size-small);
color: var(--text-secondary);
margin-top: 3px;
padding: 2px 0;
}
.cpl-response .response-bytes {
color: var(--accent-primary);
font-weight: 500;
}
.cpl-example-response {
font-size: var(--font-size-small);
margin-top: 2px;
padding: 2px 0;
}
.cpl-example-response code {
font-family: 'Courier New', monospace;
background: var(--bg-face);
padding: 2px 6px;
border-radius: 3px;
color: var(--accent-secondary);
font-weight: 500;
}
/* Automated Tests Tab Styles */
.autotest-suite {
border-bottom: 1px solid var(--border-light);
}
.autotest-suite:last-child {
border-bottom: none;
}
.autotest-suite-header {
display: flex;
align-items: center;
padding: 8px var(--spacing-md);
background: var(--bg-face);
cursor: pointer;
user-select: none;
transition: background-color 0.2s;
}
.autotest-suite-header:hover {
background: var(--border-light);
}
.autotest-suite-toggle {
width: 16px;
font-size: 10px;
color: var(--text-secondary);
transition: transform 0.2s;
}
.autotest-suite.expanded .autotest-suite-toggle {
transform: rotate(90deg);
}
.autotest-suite-title {
flex: 1;
font-weight: bold;
font-size: 11px;
}
.autotest-suite-status {
font-size: 10px;
padding: 2px 8px;
border-radius: 10px;
background: var(--bg-window);
}
.autotest-suite-status.passed {
background: rgba(0, 128, 0, 0.2);
color: var(--status-green);
}
.autotest-suite-status.failed {
background: rgba(255, 0, 0, 0.2);
color: var(--status-red);
}
.autotest-suite-status.running {
background: rgba(0, 120, 215, 0.2);
color: var(--accent-primary);
}
.autotest-suite-content {
padding: 0;
background: var(--bg-window);
}
.autotest-item {
display: flex;
align-items: center;
justify-content: space-between;
padding: 4px var(--spacing-md) 4px 28px;
font-size: 10px;
border-bottom: 1px solid var(--border-light);
}
.autotest-item:last-child {
border-bottom: none;
}
.autotest-item:hover {
background: var(--border-light);
}
.autotest-item label {
display: flex;
align-items: center;
gap: var(--spacing-sm);
cursor: pointer;
flex: 1;
}
.autotest-status {
font-size: 9px;
padding: 1px 6px;
border-radius: 8px;
min-width: 50px;
text-align: center;
}
.autotest-status.passed {
background: rgba(0, 128, 0, 0.15);
color: var(--status-green);
}
.autotest-status.failed {
background: rgba(255, 0, 0, 0.15);
color: var(--status-red);
}
.autotest-status.running {
background: rgba(0, 120, 215, 0.15);
color: var(--accent-primary);
animation: pulse 1s ease-in-out infinite;
}
.autotest-status.skipped {
background: rgba(128, 128, 128, 0.15);
color: var(--text-secondary);
}
@keyframes pulse {
0%, 100% { opacity: 1; }
50% { opacity: 0.5; }
}
[data-theme="dark_mode"] .cpl-example-response code,
[data-theme="high_contrast"] .cpl-example-response code,
[data-theme="space"] .cpl-example-response code,
[data-theme="nebula"] .cpl-example-response code {
background: #333;
color: #7df;
}
.cpl-example {
font-family: 'Courier New', monospace;
font-size: var(--font-size-small);
background: #fffbf0;
padding: 3px;
border-left: 3px solid #ffcc00;
margin-top: 3px;
border-radius: var(--border-radius);
}
[data-theme="dark_mode"] .cpl-example,
[data-theme="high_contrast"] .cpl-example,
[data-theme="space"] .cpl-example,
[data-theme="nebula"] .cpl-example {
background: var(--bg-face);
border-left-color: var(--accent-primary);
}
.debug-console {
border: 1px solid var(--border-dark);
background: #000;
color: #0f0;
font-family: 'Courier New', monospace;
font-size: var(--font-size-small);
padding: 5px;
overflow-y: auto;
height: 300px;
white-space: pre-wrap;
border-radius: var(--border-radius);
}
.log-trace { color: #888; }
.log-info { color: #0f0; }
.log-warning { color: #ff0; }
.log-error { color: #f00; }
.log-exception { color: #f0f; font-weight: bold; }
a {
color: var(--accent-primary);
text-decoration: underline;
cursor: pointer;
}
a:hover {
color: var(--accent-hover);
}
.canvas-wrapper {
flex: 1;
border: 2px solid var(--border-dark);
background: #f9f9f9;
position: relative;
overflow: auto;
border-radius: var(--border-radius);
}
[data-theme="dark_mode"] .canvas-wrapper,
[data-theme="high_contrast"] .canvas-wrapper,
[data-theme="space"] .canvas-wrapper,
[data-theme="nebula"] .canvas-wrapper {
background: var(--bg-face);
}
#canvas_el {
background: white;
cursor: crosshair;
display: block;
}
.designer-sidebar {
width: 180px;
min-width: 180px;
border-right: 1px solid var(--border-shadow);
padding: var(--spacing-md);
overflow-y: auto;
display: flex;
flex-direction: column;
gap: var(--spacing-md);
}
.designer-main {
flex: 1;
display: flex;
flex-direction: column;
padding: var(--spacing-md);
overflow: hidden;
gap: var(--spacing-sm);
}
.designer-controls {
display: flex;
justify-content: space-between;
align-items: center;
margin-bottom: 5px;
flex-wrap: wrap;
gap: var(--spacing-sm);
}
.compact-header-row {
display: flex;
align-items: center;
gap: var(--spacing-sm);
padding: var(--spacing-sm) 0;
margin-bottom: var(--spacing-sm);
flex-wrap: wrap;
}
.element-dialog {
padding: var(--spacing-md);
border: 1px solid var(--border-dark);
border-radius: var(--border-radius);
background: var(--bg-face);
color: var(--text-main);
box-shadow: 0 4px 12px rgba(0,0,0,0.3);
}
.element-dialog::backdrop {
background: rgba(0,0,0,0.5);
}
.element-dialog input, .element-dialog select {
background: var(--bg-field);
color: var(--text-main);
border: 1px solid var(--border-shadow);
padding: 4px;
}
.designer-button-row {
display: flex;
gap: var(--spacing-sm);
flex-wrap: wrap;
}
.designer-button-row button {
flex: 1;
min-width: 80px;
}
.sr-only {
position: absolute;
width: 1px;
height: 1px;
padding: 0;
margin: -1px;
overflow: hidden;
clip: rect(0, 0, 0, 0);
white-space: nowrap;
border-width: 0;
}
@media (max-width: 768px) {
.app-wrapper {
width: 100vw;
height: 100vh;
}
.app-header {
flex-direction: column;
align-items: stretch;
}
.header-controls {
flex-direction: column;
align-items: stretch;
}
[data-layout="cognitive"] .workspace-content,
[data-layout="sidebar_left"] .workspace-content {
flex-direction: column;
}
[data-layout="cognitive"] .sidebar-panel,
[data-layout="sidebar_left"] .sidebar-panel {
width: 100%;
height: 250px;
border: none;
border-bottom: 1px solid var(--border-shadow);
}
[data-layout="minimal"] .tab-folder {
position: relative;
left: 0;
top: 0;
width: 100%;
flex-direction: row;
opacity: 1;
}
[data-layout="minimal"] .workspace-content {
margin-left: 0;
flex-direction: column;
}
[data-layout="minimal"] .sidebar-panel {
width: 100%;
height: 200px;
}
.designer-sidebar {
width: 100%;
height: 200px;
border-right: none;
border-bottom: 1px solid var(--border-shadow);
}
}
.loading-spinner {
display: inline-block;
width: 14px;
height: 14px;
border: 2px solid var(--border-shadow);
border-top-color: var(--accent-primary);
border-radius: 50%;
animation: spin 0.8s linear infinite;
}
@keyframes spin {
to { transform: rotate(360deg); }
}
.section-title {
font-weight: bold;
margin-bottom: 5px;
color: var(--text-main);
}
.button-row {
display: flex;
gap: var(--spacing-sm);
margin-top: var(--spacing-md);
flex-wrap: wrap;
}
.button-row button {
flex: 1;
min-width: 80px;
}
select.compact {
height: 18px;
font-size: var(--font-size-small);
padding: 0 2px;
}
.server-dashboard {
display: grid;
grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
gap: var(--spacing-md);
padding: var(--spacing-md);
overflow-y: auto;
height: 100%;
}
.dashboard-card {
background: var(--bg-window);
border: 1px solid var(--border-shadow);
border-radius: var(--border-radius);
padding: var(--spacing-md);
display: flex;
flex-direction: column;
}
.dashboard-card-title {
font-weight: bold;
color: var(--group-text);
margin-bottom: var(--spacing-sm);
padding-bottom: var(--spacing-sm);
border-bottom: 1px solid var(--border-light);
font-size: 12px;
}
.dashboard-card-content {
flex: 1;
overflow: hidden;
}
.stat-grid {
display: grid;
grid-template-columns: repeat(2, 1fr);
gap: var(--spacing-sm);
}
.stat-item {
text-align: center;
padding: var(--spacing-sm);
background: var(--bg-face);
border-radius: var(--border-radius);
}
.stat-value {
font-size: 20px;
font-weight: bold;
color: var(--accent-primary);
}
.stat-label {
font-size: var(--font-size-small);
color: var(--text-secondary);
}
.chart-area {
height: 120px;
background: var(--bg-face);
border-radius: var(--border-radius);
position: relative;
overflow: hidden;
}
.chart-bar {
position: absolute;
bottom: 0;
width: 8px;
background: var(--accent-primary);
transition: height 0.3s ease;
border-radius: 2px 2px 0 0;
}
.chart-line {
position: absolute;
bottom: 0;
width: 100%;
height: 100%;
}
.chart-line svg {
width: 100%;
height: 100%;
}
.gauge-container {
display: flex;
justify-content: space-around;
padding: var(--spacing-sm);
}
.gauge {
width: 60px;
height: 60px;
position: relative;
}
.gauge-bg {
fill: none;
stroke: var(--border-shadow);
stroke-width: 6;
}
.gauge-fill {
fill: none;
stroke: var(--accent-primary);
stroke-width: 6;
stroke-linecap: round;
transition: stroke-dasharray 0.5s ease;
}
.gauge-text {
position: absolute;
top: 50%;
left: 50%;
transform: translate(-50%, -50%);
font-size: 11px;
font-weight: bold;
}
.gauge-label {
text-align: center;
font-size: var(--font-size-small);
color: var(--text-secondary);
margin-top: 2px;
}
.status-indicator {
display: inline-block;
width: 10px;
height: 10px;
border-radius: 50%;
margin-right: 5px;
}
.status-healthy { background: var(--status-green); }
.status-warning { background: #f0ad4e; }
.status-critical { background: var(--status-red); }
.log-feed {
height: 150px;
overflow-y: auto;
font-family: monospace;
font-size: var(--font-size-small);
background: #1a1a1a;
color: #0f0;
padding: var(--spacing-sm);
border-radius: var(--border-radius);
}
.log-entry {
padding: 2px 0;
border-bottom: 1px solid #333;
}
.ticket-list {
max-height: 120px;
overflow-y: auto;
}
.ticket-item {
padding: var(--spacing-sm);
border-bottom: 1px solid var(--border-light);
font-size: var(--font-size-small);
display: flex;
justify-content: space-between;
align-items: center;
}
.ticket-priority-high { border-left: 3px solid var(--status-red); }
.ticket-priority-medium { border-left: 3px solid #f0ad4e; }
.ticket-priority-low { border-left: 3px solid var(--status-green); }
.printer-grid {
display: grid;
grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
gap: var(--spacing-xs);
}
.printer-tile {
text-align: center;
padding: var(--spacing-sm);
background: var(--bg-face);
border-radius: var(--border-radius);
font-size: var(--font-size-small);
}
.printer-tile-icon {
font-size: 20px;
margin-bottom: 2px;
}
[data-role="customer"] .role-factory,
[data-role="customer"] .role-technician,
[data-role="customer"] .role-admin { display: none !important; }
[data-role="factory"] .role-technician,
[data-role="factory"] .role-admin { display: none !important; }
[data-role="technician"] .role-admin { display: none !important; }
[data-role="server"] .client-interface { display: none !important; }
[data-role]:not([data-role="server"]) .server-interface { display: none !important; }
.wifi-config-panel {
transition: opacity 0.3s, max-height 0.3s;
overflow: hidden;
}
.wifi-config-panel.hidden {
max-height: 0;
opacity: 0;
padding: 0;
margin: 0;
border: none;
}
.header-branding {
display: flex;
align-items: center;
gap: var(--spacing-md);
}
.role-selector {
display: flex;
flex-direction: column;
gap: 2px;
}
.role-selector label {
font-size: var(--font-size-small);
color: var(--text-secondary);
margin: 0;
}
</style>
</head>
<body data-theme="light_mode" data-layout="cognitive" data-borders="false">
<div class="app-wrapper">
<div class="app-container">
<div class="app-header">
<div class="header-branding">
<div class="header-logo">
<span style="font-size:22px;">COGNITIVE <span class="logo-tpg">LLC</span></span>
<span class="logo-subtitle" id="app_subtitle">Printer Administrator</span>
</div>
<div class="role-selector">
<label for="role_selector">Role:</label>
<select id="role_selector" class="compact" style="width:130px;">
<option value="admin">Administrator</option>
<option value="technician">Repair Technician</option>
<option value="factory">Factory Worker</option>
<option value="customer">Customer</option>
<option value="server">Server Backend</option>
</select>
</div>
</div>
<div class="header-controls">
<div class="control-group">
<label for="theme_selector">Theme:</label>
<select id="theme_selector" class="compact">
<option value="light_mode">Light Mode</option>
<option value="dark_mode">Dark Mode</option>
<option value="glassmorphism">Glassmorphism</option>
<option value="legacy_style">Legacy Style</option>
<option value="space">Space</option>
<option value="nebula">Nebula</option>
<option value="high_contrast">High Contrast</option>
</select>
</div>
<div class="control-group">
<label for="layout_selector">Layout:</label>
<select id="layout_selector" class="compact">
<option value="cognitive">Cognitive</option>
<option value="minimal">Minimal</option>
</select>
</div>
<div class="control-group">
<label><input type="checkbox" id="chk_borders"> Borders</label>
</div>
<div class="control-group header-center-spacer"></div>
<div class="control-group heartbeat-centered">
<label><input type="checkbox" id="chk_heart"> Heartbeat</label>
</div>
<div class="control-group header-right-spacer"></div>
<div id="status_box" class="status-box" tabindex="0" role="button" aria-label="Connection Status">
0 Connected
<div class="status-menu" id="status_menu" role="menu">
<div class="status-menu-item" role="menuitem" tabindex="0">Connect All</div>
<div class="status-menu-item" role="menuitem" tabindex="0">Disconnect All</div>
<div class="status-menu-item" role="menuitem" tabindex="0">Connect Selected</div>
<div class="status-menu-item" role="menuitem" tabindex="0">Disconnect Selected</div>
</div>
</div>
</div>
</div>
<div class="tab-folder" id="tab-bar" role="tablist"></div>
<div id="conn" class="workspace visible" role="tabpanel">
<div class="workspace-content">
<div class="sidebar-panel">
<div class="section-title">Printer Manager</div>
<div class="printer-list" id="printer_list" role="listbox" aria-label="Printer List"></div>
<div class="button-row">
<button id="btn_add_printer">Add Printer</button>
<button id="btn_remove_printer">Remove</button>
</div>
<div class="row">
<button id="btn_scan_devices" class="fill">Auto-Scan Devices</button>
</div>
<div class="row">
<button id="btn_connect_selected" class="fill">Connect Selected</button>
</div>
<div class="group-box">
<span class="group-title">Quick Actions</span>
<button id="btn_connect_all" style="width:100%; margin-bottom:3px;">Connect All</button>
<button id="btn_disconnect_all" style="width:100%;">Disconnect All</button>
</div>
</div>
<div class="main-panel">
<div class="group-box">
<span class="group-title">Connection Parameters</span>
<div style="padding:var(--spacing-md);">
<div style="font-weight:bold; color:var(--text-secondary); margin-bottom:var(--spacing-md);">Connection Type</div>
<div style="display:flex; flex-direction:column; gap:6px; margin-bottom:15px;">
<label><input type="radio" name="ct" value="ser" checked> Serial Connection</label>
<label><input type="radio" name="ct" value="usb"> USB Direct Connection</label>
<label><input type="radio" name="ct" value="net"> Network Connection (Ethernet/WiFi)</label>
<label><input type="radio" name="ct" value="bt"> Bluetooth Connection</label>
<label><input type="radio" name="ct" value="par"> Parallel Port Connection</label>
</div>
<div id="p_ser">
<div class="grid-2" style="max-width:350px; margin-bottom:15px;">
<span style="text-align:right;">Com Port:</span>
<select id="com_list" class="fill">
<option>COM1</option>
<option>COM2</option>
<option>COM3</option>
<option>COM4</option>
<option>COM5</option>
</select>
<span style="text-align:right;">Baud Rate:</span>
<select id="baud">
<option>9600</option>
<option>19200</option>
<option>38400</option>
<option>57600</option>
<option selected>115200</option>
</select>
<span style="text-align:right;">Stop Bits:</span>
<select id="stop_bits">
<option selected>1</option>
<option>2</option>
</select>
<span style="text-align:right;">Buffer Size:</span>
<input type="number" id="ser_buffer" value="4096" min="512" max="65536">
</div>
<div style="margin-left:85px;">
<label><input type="checkbox" id="xon_xoff"> XON/XOFF Flow Control</label><br>
<label><input type="checkbox" id="dumb_terminal"> Dumb Terminal Mode</label>
</div>
</div>
<div id="p_net" style="display:none;">
<div class="grid-2" style="max-width:350px;">
<span style="text-align:right;">IP Address:</span>
<input type="text" id="net_ip" value="192.168.1.10">
<span style="text-align:right;">Port:</span>
<input type="text" id="net_port" value="9100">
<span style="text-align:right;">Net Mask:</span>
<input type="text" id="net_mask" value="255.255.255.0">
<span style="text-align:right;">Gateway:</span>
<input type="text" id="net_gateway" value="192.168.1.1">
<span style="text-align:right;">RTEL Port:</span>
<input type="text" id="rtel_port" value="9100">
<span style="text-align:right;">Buffer Size:</span>
<input type="number" id="net_buffer" value="4096" min="512" max="65536">
</div>
<div style="margin-top:var(--spacing-sm);">
<label><input type="checkbox" id="net_dhcp" checked> Use DHCP</label>
<label style="margin-left:15px;"><input type="checkbox" id="net_lpd"> Enable LPD</label>
</div>
</div>
<div id="p_bt" style="display:none;">
<div class="grid-2" style="max-width:350px;">
<span style="text-align:right;">Bluetooth Device:</span>
<select id="bt_device" class="fill">
<option>Device 1</option>
<option>Device 2</option>
</select>
<span style="text-align:right;">Bluetooth COM:</span>
<input type="text" id="bt_com" value="COM5">
</div>
<button id="btn_scan_bluetooth" style="margin-top:var(--spacing-md);">Scan Bluetooth Devices</button>
</div>
<div id="p_par" style="display:none;">
<div class="grid-2" style="max-width:350px;">
<span style="text-align:right;">Parallel Port:</span>
<select id="par_port" class="fill">
<option>LPT1</option>
<option>LPT2</option>
</select>
</div>
</div>
<div id="p_usb" style="display:none;">
<div style="padding:var(--spacing-md); color:var(--text-secondary); font-size:var(--font-size-small);">
USB connections are automatically detected. No additional configuration required.
</div>
</div>
</div>
</div>
<div class="group-box" id="wifi_panel" style="display:none;">
<span class="group-title">WiFi Configuration</span>
<div class="grid-2" style="margin-bottom:var(--spacing-md);">
<span style="text-align:right;">SSID:</span>
<input type="text" id="wifi_ssid" class="fill" placeholder="Network Name">
<span style="text-align:right;">Password:</span>
<input type="password" id="wifi_pass" class="fill">
<span style="text-align:right;">Security:</span>
<select id="wifi_sec" class="fill">
<option>WPA2-PSK</option>
<option>WPA3</option>
<option>WEP</option>
<option>Open</option>
</select>
</div>
<div>
<label><input type="checkbox" id="wifi_dhcp" checked> Use DHCP</label>
</div>
<div class="grid-2" id="wifi_static" style="display:none; margin-top:var(--spacing-md);">
<span style="text-align:right;">IP Address:</span>
<input type="text" class="fill" value="192.168.1.100">
<span style="text-align:right;">Subnet Mask:</span>
<input type="text" class="fill" value="255.255.255.0">
<span style="text-align:right;">Gateway:</span>
<input type="text" class="fill" value="192.168.1.1">
<span style="text-align:right;">DNS Server:</span>
<input type="text" class="fill" value="8.8.8.8">
</div>
<div class="button-row">
<button id="btn_scan_wifi">Scan Networks</button>
<button id="btn_apply_wifi">Apply WiFi Config</button>
</div>
<div class="group-box" style="margin-top:var(--spacing-md);">
<span class="group-title">Available Networks</span>
<div style="height:120px; overflow-y:auto; border:1px solid var(--border-dark); background:var(--bg-window); padding:5px;" id="wifi_list">
<div style="color:var(--text-secondary); font-size:10px;">Click "Scan Networks" to discover</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="print" class="workspace" role="tabpanel">
<div class="workspace-content">
<div class="main-panel">
<div class="compact-header-row">
<span style="font-size:var(--font-size-small);">Target:</span>
<div id="print_target" class="multi-select-dropdown" style="flex:1; max-width:200px;" tabindex="0">
<span style="color:var(--text-secondary); font-size:var(--font-size-small);">Select...</span>
</div>
</div>
<div style="display:flex; gap:20px; flex-wrap:wrap;">
<div style="flex:1; min-width:350px;">
<div class="grid-2" style="margin-top:var(--spacing-sm);">
<span style="text-align:right;">Print Speed:</span>
<div class="row" style="margin:0;">
<select class="fill" id="print_speed">
<option>High</option>
<option selected>Normal</option>
<option>Low</option>
</select>
<button id="btn_apply_print_speed">Apply</button>
</div>
<span style="text-align:right;">No-Media-Out (In):</span>
<div class="row" style="margin:0;">
<input type="number" class="fill" id="no_media" value="12" min="1" max="100">
<button id="btn_apply_no_media">Apply</button>
</div>
<span style="text-align:right;">Debug Report Level:</span>
<div class="row" style="margin:0;">
<select class="fill" id="debug_level">
<option>0 - Silent</option>
<option selected>1 - Standard</option>
<option>2 - Verbose</option>
</select>
<button id="btn_apply_debug_level">Apply</button>
</div>
</div>
<div style="margin-top:var(--spacing-lg);" class="grid-2">
<label style="text-align:right;"><input type="checkbox" id="auto_reprint"> Enable Automatic Reprint</label>
<button id="btn_apply_auto_reprint">Apply</button>
<label style="text-align:right;"><input type="checkbox" id="aux_power"> Auxiliary Power On</label>
<button id="btn_apply_aux_power">Apply</button>
</div>
<div class="grid-2" style="margin-top:var(--spacing-md);">
<span style="text-align:right;">Media Adjust:</span>
<div class="row" style="margin:0;">
<input type="number" class="fill" id="media_adjust" value="0" min="-100" max="100">
<button id="btn_apply_media_adjust">Apply</button>
</div>
<span style="text-align:right;">Pitch (DPI):</span>
<div class="row" style="margin:0;">
<select class="fill" id="pitch">
<option selected>203</option>
<option>300</option>
</select>
<button id="btn_apply_pitch">Apply</button>
</div>
</div>
<div class="group-box" style="margin-top:var(--spacing-md);">
<span class="group-title">Real-Time Clock</span>
<div class="grid-2">
<span style="text-align:right;">Time (HH:MM:SS):</span>
<div class="row" style="margin:0;">
<input type="text" id="rtc_time" class="fill" placeholder="12:00:00">
<button id="btn_refresh_time"></button>
</div>
<span style="text-align:right;">Date:</span>
<div class="row" style="margin:0;">
<input type="date" id="rtc_date" class="fill">
<button id="btn_apply_datetime">Apply</button>
</div>
</div>
</div>
</div>
<div style="flex:1; min-width:250px; display:flex; flex-direction:column; gap:var(--spacing-md);">
<div class="group-box">
<span class="group-title">Darkness</span>
<div class="row">
<input type="number" id="darkness_val" style="width:60px" value="0" min="-200" max="200">
<button id="btn_apply_darkness">Apply</button>
</div>
<div style="display:flex; align-items:center; gap:5px;">
<button id="btn_darkness_down"></button>
<input type="range" id="darkness_slider" min="-200" max="200" value="0" style="flex:1;">
<button id="btn_darkness_up"></button>
</div>
</div>
<div class="group-box">
<span class="group-title">Primary Language</span>
<label><input type="radio" name="lang" value="auto" checked> Auto (CPL/ZPL)</label><br>
<label><input type="radio" name="lang" value="cpl"> CPL</label><br>
<label><input type="radio" name="lang" value="zpl"> ZPL</label><br>
<label><input type="radio" name="lang" value="epl"> EPL</label>
<div style="text-align:right; margin-top:var(--spacing-md);">
<button id="btn_apply_language">Apply</button>
</div>
</div>
<div class="group-box">
<span class="group-title">Thermal Mode</span>
<label><input type="radio" name="tm" value="dt" checked> Direct Thermal</label><br>
<label><input type="radio" name="tm" value="tt"> Thermal Transfer</label>
<div style="text-align:right; margin-top:var(--spacing-md);">
<button id="btn_apply_thermal_mode">Apply</button>
</div>
</div>
</div>
</div>
<div style="text-align:center; margin-top:var(--spacing-lg);">
<button id="btn_refresh_printer_settings">Refresh Settings</button>
<button id="btn_print_test_label">Print Test Label</button>
</div>
</div>
</div>
</div>
<div id="pos" class="workspace" role="tabpanel">
<div class="workspace-content">
<div class="main-panel" style="overflow:hidden;">
<div style="display:flex; gap:var(--spacing-md); height:100%;">
<div style="flex:1; overflow-y:auto; padding-right:var(--spacing-md);">
<div class="compact-header-row" style="margin-bottom:var(--spacing-md);">
<span style="font-size:var(--font-size-small);">Target:</span>
<div id="pos_target" class="multi-select-dropdown" style="flex:1; max-width:200px;" tabindex="0">
<span style="color:var(--text-secondary); font-size:var(--font-size-small);">Select...</span>
</div>
</div>
<div class="grid-2" style="max-width:400px;">
<span style="text-align:right;">Print Width (Inches):</span>
<div class="row" style="margin:0;">
<input type="text" class="fill" value="4.09">
<button>Apply</button>
</div>
<span style="text-align:right;">Label Length (Dots):</span>
<div class="row" style="margin:0;">
<input type="text" class="fill" value="">
<button>Apply</button>
</div>
</div>
<div class="grid-2" style="max-width:400px; margin-top:var(--spacing-md);">
<label style="text-align:right;"><input type="checkbox"> Enable Auto-Recalibration</label>
<button>Apply</button>
<label style="text-align:right;"><input type="checkbox"> Enable Automatic TOF</label>
<button>Apply</button>
</div>
<div class="group-box" style="max-width:400px;">
<span class="group-title">Indexing</span>
<label><input type="checkbox" checked> Indexing On</label>
<div class="row" style="margin-top:var(--spacing-md);">
<label><input type="radio" name="idx"> Bar</label>
<button>Apply</button>
</div>
<div class="row">
<label><input type="radio" name="idx" checked> Gap</label>
<button id="btn_calibrate_sensor">Calibrate</button>
</div>
<div class="row">
<label><input type="radio" name="idx"> Notch</label>
</div>
</div>
<div class="group-box" style="max-width:400px;">
<span class="group-title">TOF Adjustment (Motor Steps)</span>
<div class="row">
<input type="text" class="fill" value="0">
<button>Apply</button>
</div>
<p style="font-size:var(--font-size-small); color:var(--text-secondary); margin-top:4px; line-height:1.3;">
Moves label top margin down the page.
</p>
</div>
<div class="group-box" style="max-width:400px;">
<span class="group-title">Shift-Left (Hundredths of Inch)</span>
<div class="row">
<input type="text" class="fill" value="0">
<button>Apply</button>
</div>
<p style="font-size:var(--font-size-small); color:var(--text-secondary); margin-top:4px; line-height:1.3;">
Moves image leftward across label.
</p>
</div>
<div class="group-box" style="max-width:400px;">
<span class="group-title">Label Presentation</span>
<label><input type="checkbox" id="enable_presentation"> Enable Label Presentation</label>
<div class="grid-2" style="margin-top:var(--spacing-sm);">
<span style="text-align:right;">Advance (dots):</span>
<div class="row" style="margin:0;">
<input type="number" id="present_advance" class="fill" value="0" min="0" max="999">
<button id="btn_apply_advance">Apply</button>
</div>
<span style="text-align:right;">Retract (dots):</span>
<div class="row" style="margin:0;">
<input type="number" id="present_retract" class="fill" value="0" min="0" max="999">
<button id="btn_apply_retract">Apply</button>
</div>
<span style="text-align:right;">Time (ms):</span>
<div class="row" style="margin:0;">
<input type="number" id="present_time" class="fill" value="0" min="0" max="9999">
<button id="btn_apply_present_time">Apply</button>
</div>
</div>
</div>
<div style="text-align:center; margin-top:var(--spacing-lg);">
<button id="btn_refresh_positioning">Refresh</button>
<button id="btn_pos_test_label">Print Test Label</button>
</div>
</div>
<div style="flex:1; display:flex; flex-direction:column; align-items:center; justify-content:center; padding:var(--spacing-sm); border-left:1px solid var(--border-shadow);">
<span style="font-size:var(--font-size-small); font-weight:bold; margin-bottom:var(--spacing-xs);">Reference</span>
<img src="data:image/png;base64,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" alt="Label Positioning Reference" style="width:100%; height:auto; max-height:calc(100% - 20px); object-fit:contain; border:1px solid var(--border-shadow); border-radius:3px;" onerror="this.style.display='none'">
</div>
</div>
</div>
</div>
</div>
<div id="fonts" class="workspace" role="tabpanel">
<div class="workspace-content">
<div class="main-panel">
<div class="compact-header-row">
<span style="font-size:var(--font-size-small);">Target:</span>
<div id="fonts_target" class="multi-select-dropdown" style="flex:1; max-width:200px;" tabindex="0">
<span style="color:var(--text-secondary); font-size:var(--font-size-small);">Select...</span>
</div>
</div>
<div style="flex:1; border:1px solid var(--border-dark); overflow:auto; background:var(--bg-window);">
<table id="obj_table">
<thead>
<tr>
<th style="width:100px">Name</th>
<th style="width:100px">Type</th>
<th style="width:80px">Storage</th>
<th style="width:80px">Size</th>
<th>Description</th>
</tr>
</thead>
<tbody></tbody>
</table>
</div>
<div class="button-row">
<button id="btn_send_objects">Send Objects</button>
<button id="btn_delete_objects">Delete Selected</button>
<button id="btn_load_objects">Refresh</button>
</div>
</div>
</div>
</div>
<div id="prof" class="workspace" role="tabpanel">
<div class="workspace-content">
<div class="main-panel">
<div class="compact-header-row">
<span style="font-size:var(--font-size-small);">Target:</span>
<div id="prof_target" class="multi-select-dropdown" style="flex:1; max-width:200px;" tabindex="0">
<span style="color:var(--text-secondary); font-size:var(--font-size-small);">Select...</span>
</div>
</div>
<textarea id="prof_txt" style="flex:1; font-family:monospace; white-space:pre;"></textarea>
<div class="button-row">
<button id="btn_get_profile">Get Printer Profile</button>
<button id="btn_apply_profile">Apply Profile to Printer(s)</button>
<button id="btn_save_profile">Save to File</button>
<button id="btn_load_profile_file">Load from File</button>
</div>
</div>
</div>
</div>
<div id="firm" class="workspace" role="tabpanel">
<div class="workspace-content">
<div class="main-panel">
<div class="compact-header-row">
<span style="font-size:var(--font-size-small);">Target:</span>
<div id="firm_target" class="multi-select-dropdown" style="flex:1; max-width:200px;" tabindex="0">
<span style="color:var(--text-secondary); font-size:var(--font-size-small);">Select...</span>
</div>
</div>
<div class="group-box">
<span class="group-title">Firmware Info</span>
<div class="grid-2" style="max-width:400px;">
<span style="text-align:right;">Part Number:</span>
<strong id="fw_part">-</strong>
<span style="text-align:right;">Version:</span>
<strong id="fw_ver">-</strong>
<span style="text-align:right;">Release Date:</span>
<span id="fw_date">-</span>
</div>
<div style="text-align:right; margin-top:var(--spacing-md);">
<button id="btn_refresh_firmware">Refresh</button>
</div>
</div>
<div class="group-box">
<span class="group-title">Upgrade Firmware</span>
<div class="row" style="margin-bottom:var(--spacing-md);">
<span style="width:100px;">Firmware File:</span>
<input type="text" id="fw_file" readonly class="fill">
<button id="btn_browse_firmware">Browse</button>
</div>
<div id="fw_comparison" style="display:none; margin-bottom:var(--spacing-md); padding:var(--spacing-sm); border:1px solid var(--border-dark); border-radius:var(--border-radius); background:var(--bg-face);">
<div class="grid-2" style="max-width:300px; font-size:var(--font-size-small);">
<span style="text-align:right;">New Version:</span>
<strong id="fw_new_ver">-</strong>
<span style="text-align:right;">New Release Date:</span>
<span id="fw_new_date">-</span>
</div>
</div>
<div id="fw_downgrade_warning" style="display:none; margin-bottom:var(--spacing-md); padding:var(--spacing-sm); border:1px solid var(--status-red); border-radius:var(--border-radius); background:#fff0f0; color:var(--status-red); font-size:var(--font-size-small);">
 <strong>Warning:</strong> You are about to downgrade the firmware. This may cause loss of functionality or data. Only proceed if instructed by technical support.
</div>
<button id="btn_update_firmware">Update Firmware</button>
<div class="row" style="margin-top:var(--spacing-md);">
<span style="width:100px">Progress:</span>
<div class="progress-container" style="flex:1;">
<div class="progress-bar" id="fw_prog"></div>
</div>
</div>
<div id="fw_restart_msg" style="display:none; margin-top:var(--spacing-md); padding:var(--spacing-sm); border:1px solid var(--status-green); border-radius:var(--border-radius); background:#f0fff0; color:var(--status-green); font-size:var(--font-size-small);">
 Firmware update complete. Please restart the printer for changes to take effect.
</div>
</div>
<div class="group-box">
<span class="group-title">CPR (Configuration Parameter Record)</span>
<button id="btn_load_cpr">Load CPR File</button>
<button id="btn_save_cpr">Save CPR</button>
</div>
</div>
</div>
</div>
<div id="mfg" class="workspace" role="tabpanel">
<div class="workspace-content">
<div class="main-panel">
<div style="display:flex; gap:var(--spacing-md); flex-wrap:wrap;">
<div style="width:340px; display:flex; flex-direction:column; gap:var(--spacing-md);">
<div class="section-title">Unit Under Test:</div>
<div style="display:flex; gap:15px;">
<label><input type="checkbox" id="mfg_board_test"> Board Test Mode</label>
<label><input type="checkbox" id="mfg_disable_licenses"> Disable Licenses</label>
</div>
<div class="grid-2">
<span style="text-align:right;">Model Number:</span>
<div class="row" style="margin:0;">
<button id="btn_scan_barcode">Scan</button>
<input type="text" id="mfg_model" class="fill">
</div>
<span style="text-align:right;">Serial Number:</span>
<input type="text" id="mfg_serial" class="fill">
<span style="text-align:right;">MAC Address:</span>
<input type="text" id="mfg_mac" class="fill">
</div>
<label><input type="checkbox" id="mfg_specify_sn_mac"> Specify S/N & MAC manually</label>
<div style="display:flex; flex-direction:column; gap:5px;">
<label><input type="checkbox" id="mfg_prompt_fw"> Prompt for firmware download</label>
<div class="grid-2">
<label style="text-align:right; justify-content:flex-end;"><input type="checkbox" id="mfg_serial_port" checked> Serial Port:</label>
<input type="text" id="mfg_serial_val" value="COM3">
<label style="text-align:right; justify-content:flex-end;"><input type="checkbox" id="mfg_bt_port"> Bluetooth COM:</label>
<input type="text" id="mfg_bt_val">
<label style="text-align:right; justify-content:flex-end;"><input type="checkbox" id="mfg_parallel"> Parallel Port:</label>
<input type="text" id="mfg_parallel_val">
<label style="text-align:right; justify-content:flex-end;"><input type="checkbox" id="mfg_network"> IP Address:</label>
<input type="text" id="mfg_ip_val">
</div>
<label><input type="checkbox" id="mfg_usb_b" checked> USB Direct Connect (USB-B)</label>
<label><input type="checkbox" id="mfg_usb_a"> USB-A</label>
</div>
<div class="grid-2">
<span style="text-align:right;">Print-head:</span>
<select id="mfg_printhead" class="fill">
<option value="auto">Automatic</option>
<option value="203">203 DPI</option>
<option value="300">300 DPI</option>
</select>
</div>
<div class="group-box">
<span class="group-title">Peripherals:</span>
<div class="grid-2">
<label style="text-align:right;"><input type="checkbox" id="mfg_scanner" checked> Scanner:</label>
<input type="text" id="mfg_scanner_val">
<label style="text-align:right;"><input type="checkbox" id="mfg_sn_printer" checked> S/N Label Printer:</label>
<input type="text" id="mfg_sn_printer_val" value="USB">
<label style="text-align:right;"><input type="checkbox" id="mfg_box_printer"> Box Label Printer:</label>
<input type="text" id="mfg_box_printer_val">
</div>
<div class="button-row">
<button id="btn_print_serial_label">Print S/N Label</button>
<button id="btn_print_box_label">Print Box Label</button>
</div>
</div>
<div class="group-box">
<span class="group-title">Test Options:</span>
<div style="display:flex; flex-direction:column; gap:3px;">
<label><input type="checkbox" id="mfg_autorun"> Auto-run after scan</label>
<label><input type="checkbox" id="mfg_tg_mode"> TG (Test Group) Mode</label>
</div>
</div>
</div>
<div style="flex:1; display:flex; flex-direction:column;">
<div class="section-title">Test Sequence</div>
<div style="flex:1; border:1px solid var(--border-dark); background:var(--bg-window); overflow-y:auto; padding:5px; font-size:var(--font-size-small);" id="test_sequence">
<div class="row"><span style="flex:1">1. Initial Setup</span><span id="test_1" style="color:var(--text-secondary);">Pending</span></div>
<div class="row"><span style="flex:1">2. Firmware Load</span><label style="font-size:10px;"><input type="checkbox" id="skip_test_2"> Skip</label><span id="test_2" style="color:var(--text-secondary);">Pending</span></div>
<div class="row"><span style="flex:1">3. Printer Identification</span><span id="test_3" style="color:var(--text-secondary);">Pending</span></div>
<div class="row"><span style="flex:1">4. Font Loading</span><label style="font-size:10px;"><input type="checkbox" id="skip_test_4"> Skip</label><span id="test_4" style="color:var(--text-secondary);">Pending</span></div>
<div class="row"><span style="flex:1">5. CPR Download</span><label style="font-size:10px;"><input type="checkbox" id="skip_test_5"> Skip</label><span id="test_5" style="color:var(--text-secondary);">Pending</span></div>
<div class="row"><span style="flex:1">6. Control Panel Test</span><span id="test_6" style="color:var(--text-secondary);">Pending</span></div>
<div class="row"><span style="flex:1">7. Connection Interfaces</span><span id="test_7" style="color:var(--text-secondary);">Pending</span></div>
<div class="row"><span style="flex:1">8. Print-Head Up/Down</span><span id="test_8" style="color:var(--text-secondary);">Pending</span></div>
<div class="row"><span style="flex:1">9. Feed Button Test</span><span id="test_9" style="color:var(--text-secondary);">Pending</span></div>
<div class="row"><span style="flex:1">10. Peeler Test</span><span id="test_10" style="color:var(--text-secondary);">Pending</span></div>
<div class="row"><span style="flex:1">11. Tone Check</span><span id="test_11" style="color:var(--text-secondary);">Pending</span></div>
<div class="row"><span style="flex:1">12. RTC Setup</span><span id="test_12" style="color:var(--text-secondary);">Pending</span></div>
<div class="row"><span style="flex:1">13. Calibration & Indexing</span><span id="test_13" style="color:var(--text-secondary);">Pending</span></div>
<div class="row"><span style="flex:1">14. Backup Memory</span><span id="test_14" style="color:var(--text-secondary);">Pending</span></div>
<div class="row"><span style="flex:1">15. Print Quality</span><span id="test_15" style="color:var(--text-secondary);">Pending</span></div>
<div class="row"><span style="flex:1">16. Print Head Test</span><span id="test_16" style="color:var(--text-secondary);">Pending</span></div>
<div class="row"><span style="flex:1">17. Ribbon Wrinkle</span><span id="test_17" style="color:var(--text-secondary);">Pending</span></div>
<div class="row"><span style="flex:1">18. Self-Test</span><span id="test_18" style="color:var(--text-secondary);">Pending</span></div>
<div class="row"><span style="flex:1">19. Final Settings</span><span id="test_19" style="color:var(--text-secondary);">Pending</span></div>
<div class="row"><span style="flex:1">20. Shipping Label</span><span id="test_20" style="color:var(--text-secondary);">Pending</span></div>
</div>
<div class="button-row">
<button id="btn_start_test">Start</button>
<button id="btn_run_next">Run Next</button>
<button id="btn_rerun_test">Re-run</button>
<button id="btn_stop_test">Abort</button>
</div>
<div class="button-row">
<button id="btn_enable_pcl">Enable PCL</button>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="edit" class="workspace" role="tabpanel">
<div class="workspace-content">
<div class="main-panel">
<div style="display:flex; height:100%; gap:var(--spacing-md); flex-wrap:wrap;">
<div style="flex:1; min-width:300px; display:flex; flex-direction:column;">
<div style="display:flex; justify-content:space-between; margin-bottom:5px;">
<span>CPL Script Input</span>
<button id="btn_insert_template" style="height:18px; min-width:60px;">Templates</button>
</div>
<textarea id="cpl_in" style="flex:1;">! 0 100 100 1
TEXT 3 0 10 10 Hello World
END</textarea>
<div class="row" style="margin-top:var(--spacing-sm); align-items:center;">
<span style="font-size:var(--font-size-small);">Target:</span>
<div id="script_target" class="multi-select-dropdown" style="flex:1; max-width:180px;" tabindex="0">
<span style="color:var(--text-secondary); font-size:var(--font-size-small);">Select...</span>
</div>
</div>
<div class="button-row">
<button id="btn_send_script">Send</button>
<button id="btn_save_script">Save Script</button>
<button id="btn_load_script">Load Script</button>
<button id="btn_clear_script">Clear</button>
</div>
<div class="group-box" style="margin-top:var(--spacing-md);">
<span class="group-title">Timer Settings</span>
<div class="grid-2" style="max-width:250px; margin-bottom:var(--spacing-sm);">
<span style="text-align:right;">Interval (secs):</span>
<input type="number" id="timer_interval" value="5" min="1" max="3600" style="width:60px;">
<span style="text-align:right;">Repeat:</span>
<input type="number" id="timer_repeat" value="1" min="1" max="9999" style="width:60px;">
<span style="text-align:right;">Current:</span>
<span id="timer_current" style="font-weight:bold;">0 / 0</span>
</div>
<div class="button-row">
<button id="btn_timer_start">Start</button>
<button id="btn_timer_pause" disabled>Pause</button>
<button id="btn_timer_resume" disabled>Resume</button>
<button id="btn_timer_stop" disabled>Stop</button>
</div>
</div>
</div>
<div style="flex:1; min-width:300px; display:flex; flex-direction:column;">
<span style="margin-bottom:5px;">Printer Output</span>
<textarea id="cpl_out" readonly style="flex:1; background:var(--bg-face);"></textarea>
<div class="button-row" style="justify-content:flex-end;">
<button id="btn_view_variables">View Variables</button>
<button id="btn_view_status">View Status</button>
<button id="btn_clear_output">Clear Output</button>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="pcl" class="workspace" role="tabpanel">
<div class="workspace-content">
<div class="main-panel" style="overflow:hidden;">
<div style="display:flex; gap:var(--spacing-md); height:100%;">
<div style="flex:0 0 auto; display:flex; flex-direction:column; padding:var(--spacing-sm); border-right:1px solid var(--border-shadow);">
<div class="group-box" style="margin:0; flex:1; display:flex; flex-direction:column;">
<span class="group-title">Label Window Within Standard Page</span>
<span style="font-size:var(--font-size-small); font-style:italic; color:var(--text-secondary);">(0,0)</span>
<div style="flex:1; display:flex; align-items:center; justify-content:center; padding:var(--spacing-sm);">
<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAATYAAAGQCAIAAACrm9sNAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAACxMAAAsTAQCanBgAAAAYdEVYdFNvZnR3YXJlAFBhaW50Lk5FVCA1LjEuM4y7MyAAAAC2ZVhJZklJKgAIAAAABQAaAQUAAQAAAEoAAAAbAQUAAQAAAFIAAAAoAQMAAQAAAAIAAAAxAQIAEAAAAFoAAABphwQAAQAAAGoAAAAAAAAASRkBAOgDAABJGQEA6AMAAFBhaW50Lk5FVCA1LjEuMwADAACQBwAEAAAAMDIzMAGgAwABAAAAAQAAAAWgBAABAAAAlAAAAAAAAAACAAEAAgAEAAAAUjk4AAIABwAEAAAAMDEwMAAAAADInY6tb+sRQQAAK+FJREFUeF7t3Ad8jdfjx/HEVqP2VtQsLa3atH61R6uoqlIUNcofbc2irdWi1PjVKrFXVBG7tWrv0ahdYksIYiYx8//knsdtKvgpwkl836++0nPOc55zn9x7v885J7nhGRYW5iEitorl/F9ErKSIilhNERWxmiIqYjVFNLoKDQ1t0aKFU5GYSxGNrm7cuLF69WqnIjGXIipiNUVUxGqKqIjVFFERqymiIlZTREWspoiKWO1fR3TNmjVZsmTJlClT5syZKRw5csQ5cA+3bt26efOmU/HwCAsLu3HjBoVBgwZNnTrVNN7V9evXndLDYoQSJUrwiBEv4A7dunX77bffnIqIff51REuVKkUsmzRp0qtXLwqk1DlwDyNHjhwwYIBT8fA4fPhw+fLlKVy+fDk4ONg03lWOHDmc0sMinIGBgcuXL2/atKnTFMnFixevXr3qVETs83gWuhcuXCAJOH78ONVNmzYxVRJCX19fqgcPHjx16pSrY7igoKDdu3eb8h9//MFZzLSUTZxAgSqNGzZscPUKxynnz5+nsG7dOr4yIMNS4CE4ZdWqVZTPnDmzf//+AwcO0EL2YsWKVbx4cdr9/f0PHTpEwbh27Roddu7c6dRdF7xy5UpTPnHiRPhFLF/ON0XVPFxAQICfnx8FLvjKlSvh/USeiMcQUSbDCRMmTHahcOzYMWYt8kkqunbtSoft27czeZrOIF3mfb927dqJEydylre3N9WjR4+6Bzl79iwhnzdvnuuMcH379t2xYweFDz/8kK/Lli3z8vJav379pEmTzFlz585l2JYtW5oxx48fz0KXMp0JsznXMB34unnzZqoMZQbx8fHhFuP+XhiB76JevXr0WbJkydixYyl07tyZ6wwfReSJeAwRZXLr378/K16QE+aZFi1aDBkyZNasWXXr1qVDrVq1ihYtajojT548n3zyCQVy2KpVK976X375JdXnnnvODEILkY4XL963337rOuNvDNuoUaNx48aZKjErU6YM/fv16/fNN9/QcunSpUqVKtHCRtfMumBx/u6775oymFTZozZs2JD5nOrp06e5lQwcOJB9KUnmFsPpmDFjxrlz5+jAep4pNE6cONu2bXMNIPLkPJ6Fbvz48TO7NG/e/NVXX/30008HDx48c+ZME9F7qVatWvbs2U2ZTBI8M0jChAlNY2QM27hx4zFjxjj1SLgXED+ncg/t27dnscrauEKFClSZltOlS2cO3RURZR6OGzfu1q1bnSaRJ+XxRDRNmjQkB7z12csRVBaKzI3MS06P/4VtJDOVGYSJ1GmNoFOnTqw8f/jhBx6LhfTGjRubNGniHPuXmMM//vjjmzdvjho1ymm6B09PTx6Rx+XRud3s27fvvffee+GFF5zDIlHvMUSUzJDGXC5sIF955ZUNGzaULFny5ZdfZtHLXu7ChQvz5883nTNlytS6dWve8abqRue3337bDMLGj5Zff/21cuXK5ijy5cvHVFawYMEECRLkyJGDSPO1R48e3As4pWzZsnPmzHG6/lPx4sULFSr0448/OnUPj7Zt2xYuXJgdcs2aNZ2m20qXLs063FxGhw4d0qdPzyPyuDx6tmzZLl68SD4TJUrk9LbbyJEj+S7MD9KMpUuX9u7d26k8DTyTd72xsjxp166dU5E7hD0UoginEhZ269atUBfTePXqVdN47do1CtevX2fKCu/nQpmWiCOY/rSbQcC57nY3RjPtZgR3I/3dI0RsN50R8bFgrtb0jHhtZhB6ui4h1LS7vwtE7PzUsevOmzevU7kbvhHWC4sWLaLMZa9cuZIVivv5efJ4JtetW1enTh2nfhvXyUWyOXLq8k/6Rzqjq8uXL7Px3rVrl1O/m759+7LN/uCDDzZv3uzl5WV+vm1wIrsSliRZs2bdu3dvRhfafX19uVUlTpyY/FNlH25+Yfb666/Hjh37/Pnz+/fvz5w5M+uL3bt3s5CJFy8eN4vAwECGOn78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" alt="PCL Paper Diagram" style="max-width:100%; max-height:100%; object-fit:contain;">
</div>
</div>
</div>
<div style="flex:1; overflow-y:auto; padding-left:var(--spacing-md);">
<div class="compact-header-row">
<span style="font-size:var(--font-size-small);">Target:</span>
<div id="pcl_target" class="multi-select-dropdown" style="flex:1; max-width:200px;" tabindex="0">
<span style="color:var(--text-secondary); font-size:var(--font-size-small);">Select...</span>
</div>
</div>
<div class="group-box">
<span class="group-title">Label Window Parameters</span>
<p style="font-size:var(--font-size-small); color:var(--text-secondary); margin-bottom:var(--spacing-md); line-height:1.4;">
These parameters define the label area within a PCL page. Use PJL commands to configure the windowing area for label printing.
</p>
<div class="grid-2" style="max-width:400px;">
<span style="text-align:right;">Label Origin X (dots):</span>
<input type="number" id="pcl_origin_x" value="0" min="0" class="fill">
<span style="text-align:right;">Label Origin Y (dots):</span>
<input type="number" id="pcl_origin_y" value="0" min="0" class="fill">
<span style="text-align:right;">Label Width (dots):</span>
<input type="number" id="pcl_width" value="812" min="1" class="fill">
<span style="text-align:right;">Label Length (dots):</span>
<input type="number" id="pcl_length" value="1218" min="1" class="fill">
</div>
<div class="button-row" style="margin-top:var(--spacing-md);">
<button id="btn_apply_pcl_window">Apply Window</button>
<button id="btn_refresh_pcl_window">Refresh</button>
</div>
</div>
<div class="group-box">
<span class="group-title">PJL Commands</span>
<textarea id="pjl_commands" style="width:100%; height:150px; font-family:monospace; font-size:var(--font-size-small);">@PJL SET LPARM:CPL LABEL ORIGIN X = 0
@PJL SET LPARM:CPL LABEL ORIGIN Y = 0
@PJL SET LPARM:CPL LABEL WIDTH = 812
@PJL SET LPARM:CPL LABEL LENGTH = 1218</textarea>
<div class="button-row" style="margin-top:var(--spacing-md);">
<button id="btn_load_pjl">Load PJL File</button>
<button id="btn_save_pjl">Save PJL File</button>
<button id="btn_send_pjl">Send PJL to Printer</button>
</div>
</div>
<div class="group-box">
<span class="group-title">Print PCL File</span>
<div class="row">
<span style="width:100px;">PCL File:</span>
<input type="text" id="pcl_file" readonly class="fill" placeholder="No file selected">
<button id="btn_browse_pcl">Browse</button>
</div>
<div class="button-row" style="margin-top:var(--spacing-md);">
<button id="btn_send_pcl">Send PCL to Printer</button>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="autotest" class="workspace" role="tabpanel">
<div class="workspace-content">
<div class="main-panel" style="overflow:hidden;">
<div style="display:flex; gap:var(--spacing-md); height:100%;">
<div style="width:280px; min-width:280px; border-right:1px solid var(--border-shadow); padding:var(--spacing-md); overflow-y:auto; display:flex; flex-direction:column;">
<div class="section-title">Test Configuration</div>
<div class="group-box" style="margin-top:var(--spacing-sm);">
<span class="group-title">Test Target</span>
<div style="display:flex; flex-direction:column; gap:var(--spacing-sm);">
<label><input type="radio" name="autotest_target" value="printer" checked> External Printer(s)</label>
<label><input type="radio" name="autotest_target" value="cadmin"> CAdmin Application</label>
<label><input type="radio" name="autotest_target" value="both"> Both</label>
</div>
</div>
<div class="group-box">
<span class="group-title">Printer Selection</span>
<select id="autotest_printer_select" multiple style="width:100%; height:80px; font-size:var(--font-size-small);">
</select>
<label style="margin-top:var(--spacing-sm);"><input type="checkbox" id="autotest_all_printers"> Select All Connected</label>
</div>
<div class="group-box">
<span class="group-title">Test Options</span>
<div style="display:flex; flex-direction:column; gap:var(--spacing-xs);">
<label><input type="checkbox" id="autotest_verbose" checked> Verbose Logging</label>
<label><input type="checkbox" id="autotest_stop_on_fail"> Stop on First Failure</label>
<label><input type="checkbox" id="autotest_generate_report" checked> Generate Report</label>
<label><input type="checkbox" id="autotest_continuous"> Continuous Mode</label>
</div>
<div class="grid-2" style="margin-top:var(--spacing-sm);">
<span>Timeout (sec):</span>
<input type="number" id="autotest_timeout" value="30" min="5" max="300" style="width:60px;">
<span>Retry Count:</span>
<input type="number" id="autotest_retries" value="3" min="0" max="10" style="width:60px;">
</div>
</div>
<div class="button-row" style="margin-top:auto;">
<button id="btn_autotest_run_all" style="flex:2;">Run All Tests</button>
<button id="btn_autotest_run_selected">Run Selected</button>
</div>
<div class="button-row">
<button id="btn_autotest_stop" disabled>Stop</button>
<button id="btn_autotest_reset">Reset</button>
<button id="btn_autotest_export">Export Results</button>
</div>
</div>
<div style="flex:1; display:flex; flex-direction:column; min-width:0; padding:var(--spacing-md);">
<div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:var(--spacing-sm);">
<span class="section-title" style="margin:0;">Test Suites</span>
<div style="display:flex; gap:var(--spacing-sm); align-items:center;">
<span id="autotest_progress_text" style="font-size:var(--font-size-small); color:var(--text-secondary);">0 / 0 tests</span>
<div class="progress-container" style="width:150px; height:12px;">
<div class="progress-bar" id="autotest_progress" style="width:0%;"></div>
</div>
</div>
</div>
<div style="flex:1; overflow-y:auto; border:1px solid var(--border-shadow); background:var(--bg-window); border-radius:var(--border-radius);">
<div class="autotest-suite" data-suite="printer">
<div class="autotest-suite-header" onclick="toggleAutoTestSuite('printer')">
<span class="autotest-suite-toggle"></span>
<span class="autotest-suite-title">Printer Hardware Tests</span>
<span class="autotest-suite-status" id="suite_printer_status"></span>
</div>
<div class="autotest-suite-content" id="suite_printer_content" style="display:none;">
<div class="autotest-item" data-test="printer_connect"><label><input type="checkbox" checked> Connection Test</label><span class="autotest-status"></span></div>
<div class="autotest-item" data-test="printer_identify"><label><input type="checkbox" checked> Printer Identification</label><span class="autotest-status"></span></div>
<div class="autotest-item" data-test="printer_status"><label><input type="checkbox" checked> Status Query</label><span class="autotest-status"></span></div>
<div class="autotest-item" data-test="printer_sensors"><label><input type="checkbox" checked> Sensor Check</label><span class="autotest-status"></span></div>
<div class="autotest-item" data-test="printer_head"><label><input type="checkbox" checked> Print Head Test</label><span class="autotest-status"></span></div>
<div class="autotest-item" data-test="printer_motor"><label><input type="checkbox" checked> Motor Function</label><span class="autotest-status"></span></div>
<div class="autotest-item" data-test="printer_feed"><label><input type="checkbox" checked> Media Feed Test</label><span class="autotest-status"></span></div>
<div class="autotest-item" data-test="printer_calibration"><label><input type="checkbox" checked> Calibration Check</label><span class="autotest-status"></span></div>
</div>
</div>
<div class="autotest-suite" data-suite="communication">
<div class="autotest-suite-header" onclick="toggleAutoTestSuite('communication')">
<span class="autotest-suite-toggle"></span>
<span class="autotest-suite-title">Communication Tests</span>
<span class="autotest-suite-status" id="suite_communication_status"></span>
</div>
<div class="autotest-suite-content" id="suite_communication_content" style="display:none;">
<div class="autotest-item" data-test="comm_serial"><label><input type="checkbox" checked> Serial Port</label><span class="autotest-status"></span></div>
<div class="autotest-item" data-test="comm_usb"><label><input type="checkbox" checked> USB Interface</label><span class="autotest-status"></span></div>
<div class="autotest-item" data-test="comm_ethernet"><label><input type="checkbox" checked> Ethernet/Network</label><span class="autotest-status"></span></div>
<div class="autotest-item" data-test="comm_bluetooth"><label><input type="checkbox" checked> Bluetooth</label><span class="autotest-status"></span></div>
<div class="autotest-item" data-test="comm_wifi"><label><input type="checkbox" checked> WiFi</label><span class="autotest-status"></span></div>
<div class="autotest-item" data-test="comm_latency"><label><input type="checkbox" checked> Latency Test</label><span class="autotest-status"></span></div>
<div class="autotest-item" data-test="comm_throughput"><label><input type="checkbox" checked> Throughput Test</label><span class="autotest-status"></span></div>
</div>
</div>
<div class="autotest-suite" data-suite="printing">
<div class="autotest-suite-header" onclick="toggleAutoTestSuite('printing')">
<span class="autotest-suite-toggle"></span>
<span class="autotest-suite-title">Print Quality Tests</span>
<span class="autotest-suite-status" id="suite_printing_status"></span>
</div>
<div class="autotest-suite-content" id="suite_printing_content" style="display:none;">
<div class="autotest-item" data-test="print_text"><label><input type="checkbox" checked> Text Rendering</label><span class="autotest-status"></span></div>
<div class="autotest-item" data-test="print_barcode"><label><input type="checkbox" checked> Barcode Generation</label><span class="autotest-status"></span></div>
<div class="autotest-item" data-test="print_graphics"><label><input type="checkbox" checked> Graphics Printing</label><span class="autotest-status"></span></div>
<div class="autotest-item" data-test="print_alignment"><label><input type="checkbox" checked> Alignment Test</label><span class="autotest-status"></span></div>
<div class="autotest-item" data-test="print_density"><label><input type="checkbox" checked> Density Test</label><span class="autotest-status"></span></div>
<div class="autotest-item" data-test="print_speed"><label><input type="checkbox" checked> Speed Test</label><span class="autotest-status"></span></div>
</div>
</div>
<div class="autotest-suite" data-suite="firmware">
<div class="autotest-suite-header" onclick="toggleAutoTestSuite('firmware')">
<span class="autotest-suite-toggle"></span>
<span class="autotest-suite-title">Firmware & Memory Tests</span>
<span class="autotest-suite-status" id="suite_firmware_status"></span>
</div>
<div class="autotest-suite-content" id="suite_firmware_content" style="display:none;">
<div class="autotest-item" data-test="fw_version"><label><input type="checkbox" checked> Firmware Version</label><span class="autotest-status"></span></div>
<div class="autotest-item" data-test="fw_checksum"><label><input type="checkbox" checked> Firmware Checksum</label><span class="autotest-status"></span></div>
<div class="autotest-item" data-test="fw_flash"><label><input type="checkbox" checked> Flash Memory</label><span class="autotest-status"></span></div>
<div class="autotest-item" data-test="fw_ram"><label><input type="checkbox" checked> RAM Test</label><span class="autotest-status"></span></div>
<div class="autotest-item" data-test="fw_eeprom"><label><input type="checkbox" checked> EEPROM Test</label><span class="autotest-status"></span></div>
<div class="autotest-item" data-test="fw_config"><label><input type="checkbox" checked> Configuration Integrity</label><span class="autotest-status"></span></div>
</div>
</div>
<div class="autotest-suite" data-suite="cadmin">
<div class="autotest-suite-header" onclick="toggleAutoTestSuite('cadmin')">
<span class="autotest-suite-toggle"></span>
<span class="autotest-suite-title">CAdmin Application Tests</span>
<span class="autotest-suite-status" id="suite_cadmin_status"></span>
</div>
<div class="autotest-suite-content" id="suite_cadmin_content" style="display:none;">
<div class="autotest-item" data-test="cadmin_ui"><label><input type="checkbox" checked> UI Rendering</label><span class="autotest-status"></span></div>
<div class="autotest-item" data-test="cadmin_tabs"><label><input type="checkbox" checked> Tab Navigation</label><span class="autotest-status"></span></div>
<div class="autotest-item" data-test="cadmin_themes"><label><input type="checkbox" checked> Theme Switching</label><span class="autotest-status"></span></div>
<div class="autotest-item" data-test="cadmin_layouts"><label><input type="checkbox" checked> Layout Changes</label><span class="autotest-status"></span></div>
<div class="autotest-item" data-test="cadmin_roles"><label><input type="checkbox" checked> Role Permissions</label><span class="autotest-status"></span></div>
<div class="autotest-item" data-test="cadmin_state"><label><input type="checkbox" checked> State Persistence</label><span class="autotest-status"></span></div>
<div class="autotest-item" data-test="cadmin_cpl"><label><input type="checkbox" checked> CPL Parsing</label><span class="autotest-status"></span></div>
<div class="autotest-item" data-test="cadmin_designer"><label><input type="checkbox" checked> Label Designer</label><span class="autotest-status"></span></div>
<div class="autotest-item" data-test="cadmin_multiselect"><label><input type="checkbox" checked> Multi-Select Controls</label><span class="autotest-status"></span></div>
<div class="autotest-item" data-test="cadmin_logging"><label><input type="checkbox" checked> Logging System</label><span class="autotest-status"></span></div>
</div>
</div>
<div class="autotest-suite" data-suite="integration">
<div class="autotest-suite-header" onclick="toggleAutoTestSuite('integration')">
<span class="autotest-suite-toggle"></span>
<span class="autotest-suite-title">Integration Tests</span>
<span class="autotest-suite-status" id="suite_integration_status"></span>
</div>
<div class="autotest-suite-content" id="suite_integration_content" style="display:none;">
<div class="autotest-item" data-test="int_connect_cycle"><label><input type="checkbox" checked> Connect/Disconnect Cycle</label><span class="autotest-status"></span></div>
<div class="autotest-item" data-test="int_multi_printer"><label><input type="checkbox" checked> Multi-Printer Operations</label><span class="autotest-status"></span></div>
<div class="autotest-item" data-test="int_profile_load"><label><input type="checkbox" checked> Profile Load/Save</label><span class="autotest-status"></span></div>
<div class="autotest-item" data-test="int_firmware_check"><label><input type="checkbox" checked> Firmware Version Check</label><span class="autotest-status"></span></div>
<div class="autotest-item" data-test="int_batch_print"><label><input type="checkbox" checked> Batch Print Job</label><span class="autotest-status"></span></div>
<div class="autotest-item" data-test="int_stress"><label><input type="checkbox" checked> Stress Test</label><span class="autotest-status"></span></div>
<div class="autotest-item" data-test="int_error_recovery"><label><input type="checkbox" checked> Error Recovery</label><span class="autotest-status"></span></div>
</div>
</div>
<div class="autotest-suite" data-suite="stress">
<div class="autotest-suite-header" onclick="toggleAutoTestSuite('stress')">
<span class="autotest-suite-toggle"></span>
<span class="autotest-suite-title">Stress & Performance Tests</span>
<span class="autotest-suite-status" id="suite_stress_status"></span>
</div>
<div class="autotest-suite-content" id="suite_stress_content" style="display:none;">
<div class="autotest-item" data-test="stress_rapid_commands"><label><input type="checkbox" checked> Rapid Command Sequence</label><span class="autotest-status"></span></div>
<div class="autotest-item" data-test="stress_large_labels"><label><input type="checkbox" checked> Large Label Processing</label><span class="autotest-status"></span></div>
<div class="autotest-item" data-test="stress_memory_leak"><label><input type="checkbox" checked> Memory Leak Detection</label><span class="autotest-status"></span></div>
<div class="autotest-item" data-test="stress_concurrent"><label><input type="checkbox" checked> Concurrent Operations</label><span class="autotest-status"></span></div>
<div class="autotest-item" data-test="stress_long_run"><label><input type="checkbox" checked> Long Duration Test</label><span class="autotest-status"></span></div>
</div>
</div>
</div>
<div style="margin-top:var(--spacing-md); display:flex; flex-direction:column; gap:var(--spacing-sm);">
<div style="display:flex; justify-content:space-between; align-items:center;">
<span style="font-weight:bold;">Test Output</span>
<div style="display:flex; gap:var(--spacing-sm);">
<span id="autotest_summary" style="font-size:var(--font-size-small);">
<span style="color:var(--status-green);">Passed: 0</span> |
<span style="color:var(--status-red);">Failed: 0</span> |
<span style="color:var(--text-secondary);">Skipped: 0</span>
</span>
<button id="btn_autotest_clear_log" style="height:18px; min-width:40px;">Clear</button>
</div>
</div>
<div class="debug-console" id="autotest_log" style="height:150px; font-size:9px;"></div>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="about" class="workspace" role="tabpanel">
<div class="workspace-content">
<div class="main-panel" style="overflow:hidden;">
<div style="display:flex; flex-direction:column; gap:var(--spacing-md); padding:var(--spacing-sm); height:100%;">
<div style="text-align:center; padding:var(--spacing-md); border-bottom:1px solid var(--border-shadow);">
<span class="logo" style="font-size:16px;">Cognitive<span>LLC</span></span>
<h1 style="color: #cc0000; font-family:sans-serif; margin:var(--spacing-sm) 0 0 0; font-size:24px;">COGNITIVE <span style="color:var(--text-main)">LLC</span></h1>
<p style="font-size:14px; font-weight:bold; margin:var(--spacing-xs) 0;">Printer Administrator</p>
<p style="font-size:11px; margin:2px 0;">Version 2.1.0</p>
<p style="font-size:10px; color:var(--text-secondary); margin:var(--spacing-sm) 0 2px 0;">Lincolnshire, IL 60069</p>
<p style="font-size:10px; color:var(--text-secondary); margin:2px 0;">1-800-732-8950</p>
<p style="font-size:9px; color:var(--text-secondary); margin-top:var(--spacing-sm);"> 2025 Cognitive LLC</p>
</div>
<div style="flex:1; display:flex; flex-direction:column; min-width:0; min-height:0;">
<div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;">
<span style="font-weight:bold;">Debug Console</span>
<div style="display:flex; gap:5px; align-items:center;">
<span style="font-size:var(--font-size-small);">Log Level:</span>
<select id="log_level" class="compact">
<option value="0">All</option>
<option value="1">Trace</option>
<option value="2">Info</option>
<option value="3">Warning</option>
<option value="4">Error</option>
<option value="5">Exception</option>
</select>
<input type="text" id="log_search" placeholder="Search..." style="width:100px; font-size:var(--font-size-small); height:18px;">
<button id="btn_clear_logs" style="height:18px; min-width:40px;">Clear</button>
<button id="btn_export_logs" style="height:18px; min-width:40px;">Export</button>
</div>
</div>
<div class="debug-console" id="debug_console" style="flex:1; min-height:150px;"></div>
</div>
</div>
</div>
</div>
</div>
<div id="cpl" class="workspace" role="tabpanel">
<div class="workspace-content">
<div style="width:200px; border-right:1px solid var(--border-shadow); padding:var(--spacing-md); overflow-y:auto;">
<input type="text" id="cpl_search" placeholder="Search..." style="width:100%; margin-bottom:5px;">
<div style="font-weight:bold; margin:5px 0;">Categories</div>
<div style="display:flex; flex-direction:column; gap:var(--spacing-xs); font-size:10px;">
<a tabindex="0" data-category="all">All Commands</a>
<a tabindex="0" data-category="header">Header & Format</a>
<a tabindex="0" data-category="control">Control & Layout</a>
<a tabindex="0" data-category="text">Text & Fonts</a>
<a tabindex="0" data-category="graphics">Graphics & Drawing</a>
<a tabindex="0" data-category="barcode">Barcodes</a>
<a tabindex="0" data-category="system">System Commands</a>
<a tabindex="0" data-category="variable">Variables</a>
<a tabindex="0" data-category="network">Network</a>
<a tabindex="0" data-category="bluetooth">Bluetooth</a>
<a tabindex="0" data-category="object">Object Management</a>
<a tabindex="0" data-category="menu">Menu System</a>
<a tabindex="0" data-category="time">Time & Date</a>
<a tabindex="0" data-category="query">Query Commands</a>
</div>
</div>
<div style="flex:1; overflow-y:auto; padding:var(--spacing-md);" id="cpl_content"></div>
</div>
</div>
<div id="designer" class="workspace" role="tabpanel">
<div class="workspace-content">
<div class="designer-sidebar">
<div style="font-weight:bold; margin-bottom:var(--spacing-md);">Elements</div>
<button id="btn_add_text" style="width:100%; margin-bottom:3px;">Add Text</button>
<button id="btn_add_barcode" style="width:100%; margin-bottom:3px;">Add Barcode</button>
<button id="btn_add_box" style="width:100%; margin-bottom:3px;">Add Box</button>
<button id="btn_add_line" style="width:100%; margin-bottom:3px;">Add Line</button>
<button id="btn_add_circle" style="width:100%; margin-bottom:3px;">Add Circle</button>
<button id="btn_add_ellipse" style="width:100%; margin-bottom:10px;">Add Ellipse</button>
<div style="font-weight:bold; margin:var(--spacing-md) 0 5px 0;">Label Size</div>
<div class="grid-2" style="font-size:var(--font-size-small);">
<span>Width (dots):</span>
<input type="number" id="label_w" value="812" style="width:70px;">
<span>Height (dots):</span>
<input type="number" id="label_h" value="406" style="width:70px;">
</div>
<div id="element_props" style="margin-top:15px; padding-top:var(--spacing-md); border-top:1px solid var(--border-shadow);">
<div style="font-weight:bold; margin-bottom:5px;">Properties</div>
<div style="font-size:var(--font-size-small); color:var(--text-secondary);">Select an element</div>
</div>
</div>
<div class="designer-main">
<div class="designer-controls">
<span style="font-weight:bold;">Canvas</span>
<div style="display:flex; align-items:center; gap:var(--spacing-sm);">
<span style="font-size:var(--font-size-small);">Target:</span>
<select id="designer_target" style="width:120px; font-size:var(--font-size-small);"></select>
</div>
</div>
<div class="designer-button-row">
<button id="btn_clear_canvas">Clear</button>
<button id="btn_generate_cpl">Generate CPL</button>
<button id="btn_send_label">Send to Printer</button>
<button id="btn_save_label">Save Label</button>
<button id="btn_load_label">Load Label</button>
</div>
<div class="canvas-wrapper">
<canvas id="canvas_el" width="812" height="406"></canvas>
</div>
<textarea id="generated_cpl" readonly style="height:100px; margin-top:5px; font-family:monospace; font-size:var(--font-size-small);"></textarea>
</div>
</div>
</div>
<dialog id="dlg_add_text" class="element-dialog">
<form method="dialog">
<div style="font-weight:bold; margin-bottom:var(--spacing-md);">Add Text Element</div>
<div class="grid-2" style="gap:var(--spacing-sm); margin-bottom:var(--spacing-md);">
<label>Text:</label>
<input type="text" id="dlg_text_value" value="Sample Text" style="width:200px;">
<label>Font:</label>
<select id="dlg_text_font">
<option value="TEXT 0">TEXT 0 (5x7)</option>
<option value="TEXT 1">TEXT 1 (8x11)</option>
<option value="TEXT 2">TEXT 2 (12x16)</option>
<option value="TEXT 3" selected>TEXT 3 (18x24)</option>
<option value="TEXT 4">TEXT 4 (24x32)</option>
<option value="TEXT 5">TEXT 5 (30x40)</option>
</select>
<label>X Position:</label>
<input type="number" id="dlg_text_x" value="50" style="width:80px;">
<label>Y Position:</label>
<input type="number" id="dlg_text_y" value="50" style="width:80px;">
</div>
<div class="button-row">
<button type="submit" value="ok">Add</button>
<button type="submit" value="cancel">Cancel</button>
</div>
</form>
</dialog>
<dialog id="dlg_add_barcode" class="element-dialog">
<form method="dialog">
<div style="font-weight:bold; margin-bottom:var(--spacing-md);">Add Barcode Element</div>
<div class="grid-2" style="gap:var(--spacing-sm); margin-bottom:var(--spacing-md);">
<label>Barcode Type:</label>
<select id="dlg_bc_type">
<option value="CODE128">Code 128</option>
<option value="CODE39">Code 39</option>
<option value="EAN13">EAN-13</option>
<option value="EAN8">EAN-8</option>
<option value="UPCA">UPC-A</option>
<option value="UPCE">UPC-E</option>
<option value="ITF">Interleaved 2 of 5</option>
<option value="CODABAR">Codabar</option>
<option value="QR">QR Code</option>
<option value="DATAMATRIX">DataMatrix</option>
<option value="PDF417">PDF417</option>
</select>
<label>Data:</label>
<input type="text" id="dlg_bc_data" value="12345678" style="width:200px;">
<label>Height:</label>
<input type="number" id="dlg_bc_height" value="50" style="width:80px;">
<label>Narrow Bar:</label>
<input type="number" id="dlg_bc_narrow" value="2" min="1" max="10" style="width:80px;">
<label>X Position:</label>
<input type="number" id="dlg_bc_x" value="50" style="width:80px;">
<label>Y Position:</label>
<input type="number" id="dlg_bc_y" value="100" style="width:80px;">
</div>
<div class="button-row">
<button type="submit" value="ok">Add</button>
<button type="submit" value="cancel">Cancel</button>
</div>
</form>
</dialog>
<div id="image" class="workspace" role="tabpanel">
<div class="workspace-content">
<div class="main-panel">
<div class="compact-header-row" style="margin-bottom:var(--spacing-md);">
<span style="font-size:var(--font-size-small);">Source:</span>
<div id="img_src" class="multi-select-dropdown" style="flex:1; max-width:180px;" tabindex="0">
<span style="color:var(--text-secondary); font-size:var(--font-size-small);">Select...</span>
</div>
<span style="margin-left:var(--spacing-md); font-size:var(--font-size-small);">Target:</span>
<div id="img_target" class="multi-select-dropdown" style="flex:1; max-width:180px;" tabindex="0">
<span style="color:var(--text-secondary); font-size:var(--font-size-small);">Select...</span>
</div>
</div>
<div style="display:flex; gap:20px; flex-wrap:wrap;">
<div style="flex:1; min-width:350px; display:flex; flex-direction:column;">
<div class="group-box" style="flex:0;">
<span class="group-title">Image Extraction</span>
<div class="grid-2" style="margin-bottom:var(--spacing-md);">
<span style="text-align:right;">Memory Region:</span>
<select id="img_region" class="fill">
<option value="all">Complete Image</option>
<option value="flash">Flash Only</option>
<option value="config">Config Only</option>
</select>
<span style="text-align:right;">Start Address:</span>
<input type="text" id="img_addr" value="0x00400000" class="fill">
<span style="text-align:right;">Length (bytes):</span>
<input type="text" id="img_len" value="524288" class="fill">
</div>
<div class="button-row">
<button id="btn_extract_image">Extract Image</button>
<button id="btn_save_image">Save to File</button>
</div>
<div class="row" style="margin-top:var(--spacing-md);">
<span style="width:100px;">Progress:</span>
<div class="progress-container" style="flex:1;">
<div class="progress-bar" id="img_prog"></div>
</div>
</div>
</div>
<div class="group-box" style="flex:1; margin-top:var(--spacing-md); display:flex; flex-direction:column;">
<span class="group-title">Extracted Data (Hex Preview)</span>
<textarea id="img_data" readonly style="flex:1; font-family:'Courier New',monospace; font-size:8px; background:var(--bg-face);"></textarea>
</div>
</div>
<div style="flex:1; min-width:350px; display:flex; flex-direction:column;">
<div class="group-box" style="flex:0;">
<span class="group-title">Image Deployment</span>
<div class="grid-2" style="margin-bottom:var(--spacing-md);">
<span style="text-align:right;">Image File:</span>
<div class="row" style="margin:0;">
<input type="text" id="img_file" readonly class="fill">
<button id="btn_load_image_file">Browse</button>
</div>
</div>
<div style="margin:var(--spacing-md) 0; padding:8px; background:#fff3cd; border:1px solid #ffc107; font-size:var(--font-size-small); border-radius:var(--border-radius);">
<strong> Warning:</strong> Deploying overwrites ALL data on target printer(s).
</div>
<div class="button-row">
<button id="btn_deploy_image">Deploy Image</button>
<button id="btn_verify_image">Verify</button>
</div>
<div class="row" style="margin-top:var(--spacing-md);">
<span style="width:100px;">Progress:</span>
<div class="progress-container" style="flex:1;">
<div class="progress-bar" id="deploy_prog"></div>
</div>
</div>
</div>
<div class="group-box" style="margin-top:var(--spacing-md);">
<span class="group-title">Bootloader Recovery</span>
<div style="font-size:var(--font-size-small); margin-bottom:var(--spacing-md); line-height:1.4;">
<strong>Recovery Steps:</strong><br>
1. Power off printer<br>
2. Hold FEED button<br>
3. Power on (hold 5 sec)<br>
4. Release - LED blinks<br>
5. Click Enter Bootloader
</div>
<div class="button-row">
<button id="btn_enter_bootloader">Enter Bootloader</button>
<button id="btn_check_bootloader">Check Status</button>
<button id="btn_send_bootloader_cmd">Send Command</button>
</div>
<div id="bootloader_status" style="margin-top:var(--spacing-md); padding:5px; border:1px solid var(--border-shadow); background:var(--bg-face); min-height:60px; font-size:var(--font-size-small);">
<div style="color:var(--text-secondary);">Bootloader status will appear here...</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="server_dashboard" class="workspace server-interface" role="tabpanel">
<div class="server-dashboard">
<div class="dashboard-card">
<div class="dashboard-card-title">Server Statistics</div>
<div class="dashboard-card-content">
<div class="stat-grid">
<div class="stat-item"><div class="stat-value" id="stat_uptime">0d 0h</div><div class="stat-label">Uptime</div></div>
<div class="stat-item"><div class="stat-value" id="stat_jobs_today">0</div><div class="stat-label">Jobs Today</div></div>
<div class="stat-item"><div class="stat-value" id="stat_response">0ms</div><div class="stat-label">Avg Response</div></div>
<div class="stat-item"><div class="stat-value" id="stat_success">0%</div><div class="stat-label">Success Rate</div></div>
</div>
</div>
</div>
<div class="dashboard-card">
<div class="dashboard-card-title">System Resources</div>
<div class="dashboard-card-content">
<div class="gauge-container">
<div>
<div class="gauge"><svg viewBox="0 0 36 36"><path class="gauge-bg" d="M18 2.0845 a 15.9155 15.9155 0 0 1 0 31.831 a 15.9155 15.9155 0 0 1 0 -31.831"></path><path class="gauge-fill" id="gauge_cpu" stroke-dasharray="0, 100" d="M18 2.0845 a 15.9155 15.9155 0 0 1 0 31.831 a 15.9155 15.9155 0 0 1 0 -31.831"></path></svg><div class="gauge-text" id="gauge_cpu_text">0%</div></div>
<div class="gauge-label">CPU</div>
</div>
<div>
<div class="gauge"><svg viewBox="0 0 36 36"><path class="gauge-bg" d="M18 2.0845 a 15.9155 15.9155 0 0 1 0 31.831 a 15.9155 15.9155 0 0 1 0 -31.831"></path><path class="gauge-fill" id="gauge_mem" stroke-dasharray="0, 100" d="M18 2.0845 a 15.9155 15.9155 0 0 1 0 31.831 a 15.9155 15.9155 0 0 1 0 -31.831"></path></svg><div class="gauge-text" id="gauge_mem_text">0%</div></div>
<div class="gauge-label">Memory</div>
</div>
<div>
<div class="gauge"><svg viewBox="0 0 36 36"><path class="gauge-bg" d="M18 2.0845 a 15.9155 15.9155 0 0 1 0 31.831 a 15.9155 15.9155 0 0 1 0 -31.831"></path><path class="gauge-fill" id="gauge_disk" stroke-dasharray="0, 100" d="M18 2.0845 a 15.9155 15.9155 0 0 1 0 31.831 a 15.9155 15.9155 0 0 1 0 -31.831"></path></svg><div class="gauge-text" id="gauge_disk_text">0%</div></div>
<div class="gauge-label">Disk</div>
</div>
</div>
</div>
</div>
<div class="dashboard-card">
<div class="dashboard-card-title">Network Traffic</div>
<div class="dashboard-card-content">
<div class="chart-area" id="network_chart"></div>
<div style="display:flex;justify-content:space-between;font-size:9px;color:var(--text-secondary);margin-top:4px;">
<span>In: <span id="net_in">0</span> KB/s</span>
<span>Out: <span id="net_out">0</span> KB/s</span>
</div>
</div>
</div>
<div class="dashboard-card">
<div class="dashboard-card-title">Connected Printers (<span id="printer_count">0</span>)</div>
<div class="dashboard-card-content">
<div class="printer-grid" id="server_printer_grid"></div>
</div>
</div>
<div class="dashboard-card">
<div class="dashboard-card-title">Active Print Jobs</div>
<div class="dashboard-card-content">
<div class="chart-area" id="jobs_chart"></div>
<div style="display:flex;justify-content:space-around;font-size:9px;margin-top:4px;">
<span><span class="status-indicator status-healthy"></span>Complete: <span id="jobs_complete">0</span></span>
<span><span class="status-indicator status-warning"></span>Pending: <span id="jobs_pending">0</span></span>
<span><span class="status-indicator status-critical"></span>Failed: <span id="jobs_failed">0</span></span>
</div>
</div>
</div>
<div class="dashboard-card">
<div class="dashboard-card-title">Support Tickets</div>
<div class="dashboard-card-content">
<div style="display:flex;gap:var(--spacing-md);margin-bottom:var(--spacing-sm);">
<div class="stat-item" style="flex:1;"><div class="stat-value" id="tickets_open" style="font-size:16px;">0</div><div class="stat-label">Open</div></div>
<div class="stat-item" style="flex:1;"><div class="stat-value" id="tickets_closed" style="font-size:16px;">0</div><div class="stat-label">Closed</div></div>
</div>
<div class="ticket-list" id="ticket_list"></div>
</div>
</div>
<div class="dashboard-card" style="grid-column: span 2;">
<div class="dashboard-card-title">Live Server Log</div>
<div class="dashboard-card-content">
<div class="log-feed" id="server_log"></div>
</div>
</div>
<div class="dashboard-card">
<div class="dashboard-card-title">Error Rate (24h)</div>
<div class="dashboard-card-content">
<div class="chart-area" id="error_chart"></div>
<div style="text-align:center;margin-top:4px;font-size:10px;">
<span class="status-indicator" id="error_status"></span>
<span id="error_rate_text">0.0% error rate</span>
</div>
</div>
</div>
</div>
</div>
<div id="status-announcer" class="sr-only" role="status" aria-live="polite" aria-atomic="true"></div>
</div>
</div>
<script>
(function() {
'use strict';
const State = {
printers: [],
printerCounter: 0,
selectedPrinterIds: [],
lastSelectedIndex: -1,
multiSelectStates: {},
labelElements: [],
selectedElement: null,
draggedTab: null,
logMessages: [],
logLevel: 0,
activeIntervals: [],
currentRole: 'admin',
serverDashboardInterval: null,
serverUptime: 0,
networkData: [],
heartbeatInterval: null,
scriptTimer: null
};
const MfgTest = {
totalSteps: 20,
currentStep: 0,
running: false,
aborted: false,
testInterval: null,
tests: [
{ name: 'Initial Setup', fn: 'initialSetup' },
{ name: 'Firmware Load', fn: 'firmwareLoad', skippable: true },
{ name: 'Printer Identification', fn: 'printerIdentification' },
{ name: 'Font Loading', fn: 'fontLoading', skippable: true },
{ name: 'CPR Download', fn: 'cprDownload', skippable: true },
{ name: 'Control Panel Test', fn: 'controlPanelTest' },
{ name: 'Connection Interfaces', fn: 'connectionInterfaces' },
{ name: 'Print-Head Up/Down', fn: 'printHeadUpDown' },
{ name: 'Feed Button Test', fn: 'feedButtonTest' },
{ name: 'Peeler Test', fn: 'peelerTest' },
{ name: 'Tone Check', fn: 'toneCheck' },
{ name: 'RTC Setup', fn: 'rtcSetup' },
{ name: 'Calibration & Indexing', fn: 'calibration' },
{ name: 'Backup Memory', fn: 'backupMemory' },
{ name: 'Print Quality', fn: 'printQuality' },
{ name: 'Print Head Test', fn: 'printHeadTest' },
{ name: 'Ribbon Wrinkle', fn: 'ribbonWrinkle' },
{ name: 'Self-Test', fn: 'selfTest' },
{ name: 'Final Settings', fn: 'finalSettings' },
{ name: 'Shipping Label', fn: 'shippingLabel' }
],
setStatus(step, status, color) {
const elem = $(`test_${step}`);
if (elem) {
elem.textContent = status;
elem.style.color = color;
}
},
reset() {
this.currentStep = 0;
this.running = false;
this.aborted = false;
for (let i = 1; i <= this.totalSteps; i++) {
this.setStatus(i, 'Pending', 'var(--text-secondary)');
}
},
start() {
this.reset();
this.running = true;
this.aborted = false;
this.currentStep = 1;
this.runCurrentStep();
},
runNext() {
if (this.currentStep < this.totalSteps && !this.running) {
this.currentStep++;
this.runCurrentStep();
}
},
runCurrentStep() {
if (this.aborted || this.currentStep > this.totalSteps) {
this.running = false;
if (!this.aborted) {
announce('All tests completed');
log(2, 'Manufacturing test sequence completed');
}
return;
}
const stepNum = this.currentStep;
const testDef = this.tests[stepNum - 1];
if (testDef.skippable && $(`skip_test_${stepNum}`)?.checked) {
this.setStatus(stepNum, 'Skipped', '#888888');
log(2, `Test ${stepNum} (${testDef.name}) skipped`);
this.currentStep++;
setTimeout(() => this.runCurrentStep(), 100);
return;
}
this.setStatus(stepNum, 'Running...', '#0000ff');
log(1, `Test ${stepNum} (${testDef.name}) running...`);
this.executeTest(testDef.fn, stepNum).then(result => {
if (this.aborted) return;
if (result.success) {
this.setStatus(stepNum, 'Passed', '#008000');
log(2, `Test ${stepNum} (${testDef.name}) passed`);
} else {
this.setStatus(stepNum, result.status || 'Failed', '#ff0000');
log(4, `Test ${stepNum} (${testDef.name}) failed: ${result.error || 'Unknown error'}`);
}
this.currentStep++;
if (this.running) {
setTimeout(() => this.runCurrentStep(), 300);
}
});
},
abort() {
this.aborted = true;
this.running = false;
clearIntervals();
},
enablePCL() {
log(2, 'Sending PCL enable command...');
return this.backend_enablePCL();
},
async executeTest(testFn, stepNum) {
return new Promise(resolve => {
setTimeout(() => {
const result = this[`backend_${testFn}`]?.() || { success: true };
resolve(result);
}, 500 + Math.random() * 500);
});
},
backend_initialSetup() {
// TODO: Initialize connection to UUT (Unit Under Test)
// - Open serial/USB/network connection
// - Query printer model and capabilities
// - Verify communication
log(1, '[BACKEND] Initial setup - establishing connection to UUT');
return { success: true };
},
backend_firmwareLoad() {
// TODO: Download firmware to printer
// - Check current firmware version
// - Compare with target version
// - Stream firmware file to printer
// - Verify download complete
log(1, '[BACKEND] Firmware load - streaming firmware to printer');
return { success: true };
},
backend_printerIdentification() {
// TODO: Set printer identification
// - Program serial number
// - Program MAC address
// - Set model number
// - Store in printer EEPROM
const serial = $('mfg_serial')?.value || 'SN000000';
const mac = $('mfg_mac')?.value || '00:00:00:00:00:00';
log(1, `[BACKEND] Printer ID - S/N: ${serial}, MAC: ${mac}`);
return { success: true };
},
backend_fontLoading() {
// TODO: Download fonts to printer
// - Load standard font set
// - Load optional fonts based on model
// - Verify font storage
log(1, '[BACKEND] Font loading - downloading font files');
return { success: true };
},
backend_cprDownload() {
// TODO: Download Configuration Parameter Record
// - Load default CPR for model
// - Apply customer-specific CPR if specified
// - Verify CPR stored
log(1, '[BACKEND] CPR download - loading configuration parameters');
return { success: true };
},
backend_controlPanelTest() {
// TODO: Test front panel buttons and LEDs
// - Prompt operator to press each button
// - Verify LED indicators function
// - Check LCD display if present
log(1, '[BACKEND] Control panel test - verifying buttons and LEDs');
return { success: true };
},
backend_connectionInterfaces() {
// TODO: Test all communication interfaces
// - Test serial port loopback
// - Test USB enumeration
// - Test Ethernet connectivity
// - Test Bluetooth pairing if equipped
log(1, '[BACKEND] Interface test - verifying communication ports');
return { success: true };
},
backend_printHeadUpDown() {
// TODO: Test print head mechanism
// - Command head up
// - Verify head up sensor
// - Command head down
// - Verify head down sensor
log(1, '[BACKEND] Print head up/down test');
return { success: true };
},
backend_feedButtonTest() {
// TODO: Test feed button functionality
// - Prompt operator to press feed button
// - Verify button press detected
// - Verify media feeds
log(1, '[BACKEND] Feed button test');
return { success: true };
},
backend_peelerTest() {
// TODO: Test label peeler if equipped
// - Enable peeler mode
// - Print test label
// - Verify peeler sensor detects label taken
log(1, '[BACKEND] Peeler test');
return { success: true };
},
backend_toneCheck() {
// TODO: Test audible alert
// - Sound beeper at various frequencies
// - Verify operator can hear tones
log(1, '[BACKEND] Tone check - testing audible alerts');
return { success: true };
},
backend_rtcSetup() {
// TODO: Set real-time clock
// - Sync RTC to current time
// - Verify RTC is running
// - Check battery backup
log(1, '[BACKEND] RTC setup - setting real-time clock');
return { success: true };
},
backend_calibration() {
// TODO: Calibrate media sensors
// - Run gap/bar/notch calibration
// - Set TOF (Top of Form)
// - Verify indexing accuracy
log(1, '[BACKEND] Calibration - calibrating media sensors');
return { success: true };
},
backend_backupMemory() {
// TODO: Test backup memory
// - Write test pattern to flash/EEPROM
// - Read back and verify
// - Test battery-backed RAM if present
log(1, '[BACKEND] Backup memory test');
return { success: true };
},
backend_printQuality() {
// TODO: Print quality test
// - Print test pattern
// - Analyze print quality (manual or automated)
// - Check for voids, streaks, uniformity
log(1, '[BACKEND] Print quality test');
return { success: true };
},
backend_printHeadTest() {
// TODO: Test print head elements
// - Print head element test pattern
// - Check for bad dots
// - Record head resistance
log(1, '[BACKEND] Print head element test');
return { success: true };
},
backend_ribbonWrinkle() {
// TODO: Test ribbon handling (thermal transfer)
// - Check ribbon path
// - Print test for wrinkle detection
// - Verify ribbon tension
log(1, '[BACKEND] Ribbon wrinkle test');
return { success: true };
},
backend_selfTest() {
// TODO: Run printer self-test
// - Trigger printer's internal self-test
// - Capture self-test output
// - Verify all parameters in range
log(1, '[BACKEND] Self-test');
return { success: true };
},
backend_finalSettings() {
// TODO: Apply final production settings
// - Set production defaults
// - Clear test modes
// - Lock configuration if required
log(1, '[BACKEND] Final settings');
return { success: true };
},
backend_shippingLabel() {
// TODO: Print shipping/identification labels
// - Print S/N label
// - Print box label
// - Print QA label if required
log(1, '[BACKEND] Shipping label');
return { success: true };
},
backend_enablePCL() {
// TODO: Enable PCL mode on printer
// - Send PCL enable command sequence
// - Verify PCL mode active
log(1, '[BACKEND] Enabling PCL mode');
announce('PCL mode enabled');
return { success: true };
}
};
const ROLES = {
admin: { name: 'Administrator', subtitle: 'Printer Administrator', tabs: ['conn', 'print', 'pos', 'fonts', 'prof', 'firm', 'mfg', 'edit', 'pcl', 'cpl', 'designer', 'image', 'autotest', 'about'] },
technician: { name: 'Repair Technician', subtitle: 'Printer Repair Technician', tabs: ['conn', 'print', 'pos', 'fonts', 'prof', 'firm', 'edit', 'pcl', 'cpl', 'designer', 'about'] },
factory: { name: 'Factory Worker', subtitle: 'Factory Production Console', tabs: ['conn', 'print', 'pos', 'mfg', 'edit', 'cpl', 'about'] },
customer: { name: 'Customer', subtitle: 'Printer Status Viewer', tabs: ['conn', 'about'] },
server: { name: 'Server Backend', subtitle: 'Server Monitoring Dashboard', tabs: ['autotest'] }
};
const TAB_ORDER = [
'conn', 'print', 'pos', 'fonts', 'prof', 'firm', 'mfg', 'edit', 'pcl', 'cpl', 'designer', 'image', 'autotest', 'about'
];
const TAB_NAMES = {
conn: 'Connection Settings',
print: 'Printer Settings',
pos: 'Label Positioning',
fonts: 'Fonts and Objects',
prof: 'Profile Management',
firm: 'Firmware Upgrade',
mfg: 'Manufacturing Test',
edit: 'Script Editor',
pcl: 'PCL Windowing',
about: 'About',
cpl: 'CPL Reference',
designer: 'Label Designer',
image: 'Image & Recovery',
autotest: 'Automated Tests'
};
const CPL_DB = {
header: [
{cmd: "!", short: "HEADER", params: "n LAR Length Quantity", desc: "Header line - defines label format parameters", example: "! 0 100 200 1\nSTRING 12x16 10 10 Hello\nEND"},
{cmd: "!!", short: "FORCED HEADER", params: "n LAR Length Quantity", desc: "Forced header variant that overwrites prior header", example: "!! 0 100 200 1"},
{cmd: "!#", short: "BACKGROUND HEADER", params: "n LAR Length Quantity", desc: "Sets background graphics mode for repeated printing", example: "!# 0 100 200 5\nSTRING 12x16 10 10 Background\nEND"},
{cmd: "!*", short: "CLEAR BACKGROUND", params: "", desc: "Clears background graphics buffer", example: "!*"},
{cmd: "@", short: "FOREGROUND GRAPHIC", params: "", desc: "Enter foreground graphics mode", example: "@"},
{cmd: "#", short: "BACKGROUND GRAPHIC", params: "", desc: "Enter background graphics mode", example: "#"},
{cmd: "!A", short: "HEADER AUTO", params: "0 LAR len qty", desc: "Automatic header variant", example: "!A 0 100 200 1"},
{cmd: "!+", short: "HEADER PLUS", params: "0 LAR len qty", desc: "Header with plus options (background image present)", example: "!+ 0 100 200 5"},
{cmd: "!P", short: "PASSWORD HEADER", params: "xx 0 LAR len qty", desc: "Password-protected header variant (xx=password bytes)", example: "!P01 0 100 200 1"},
{cmd: "END", short: "E", params: "", desc: "End of label format - terminates and prints", example: "TEXT 3 0 10 10 Sample\nEND"},
{cmd: "XENH_END", short: "", params: "", desc: "Enhanced end marker for virtual formats", example: "XENH_END"},
{cmd: "ENHEND", short: "ENHANCED END", params: "", desc: "Enhanced end for special label processing", example: "! 0 100 100 1\nSTRING 12x16 10 10 Enhanced\nENHEND"},
{cmd: "NOPRINTEND", short: "END NO PRINT", params: "", desc: "Terminates format without printing", example: "! 0 100 100 1\nSTRING 12x16 10 10 Test\nNOPRINTEND"},
{cmd: "STORE FORMAT", short: "", params: "name", desc: "Store current format to memory", example: "STORE FORMAT LABEL1"},
{cmd: "STORE ENHANCED FORMAT", short: "", params: "name", desc: "Stores enhanced format with variable placeholders", example: "STORE ENHANCED FORMAT LABEL2"},
{cmd: "RECALL FORMAT", short: "", params: "name [data]", desc: "Recalls and executes stored label format", example: "RECALL FORMAT LABEL1"}
],
control: [
{cmd: "ADJUST", short: "A", params: "[ID] nnn", desc: "Increments/decrements a variable for serial numbering", example: "BARCODE CODE39 150 30 30 TEST20\nADJUST -01", response: "none", responseBytes: 0},
{cmd: "ADJUST_DUP", short: "AP", params: "nnn", desc: "Prints non-incremented duplicates of incremented labels", example: "STRING 8X8 0 0 1000\nADJUST 0001\nADJUST_DUP 2", response: "none", responseBytes: 0},
{cmd: "AREA_CLEAR", short: "AR", params: "x y w h", desc: "Clears a rectangular area for replotting", example: "AREA_CLEAR 50 50 200 100", response: "none", responseBytes: 0},
{cmd: "BEEP", short: "", params: "[duration 0-60] [volume 0-3]", desc: "Activates beeper (duration:0-60 sec, volume:0 to BEEPER_ENTRIES-1)", example: "BEEP 2 5", response: "none", responseBytes: 0},
{cmd: "DELIMIT", short: "", params: "char 0x21-0xFF", desc: "Sets field delimiter character (ASCII 0x21-0xFF)", example: "DELIMIT ,", response: "none", responseBytes: 0},
{cmd: "HALT", short: "H", params: "[time 0-255] [count 0-255]", desc: "Pauses printing (time:0-255 sec, count:0-255)", example: "HALT TIME 5", response: "none", responseBytes: 0},
{cmd: "INDEX", short: "I", params: "", desc: "Forces form feed to next gap/mark", example: "INDEX", response: "none", responseBytes: 0},
{cmd: "NOINDEX", short: "N", params: "", desc: "Disables label indexing for this label", example: "NOINDEX", response: "none", responseBytes: 0},
{cmd: "JUSTIFY", short: "J", params: "LEFT|CENTER|RIGHT", desc: "Sets text justification (LEFT, CENTER, RIGHT)", example: "JUSTIFY CENTER", response: "none", responseBytes: 0},
{cmd: "KEYBOARD_MODE", short: "", params: "mode", desc: "Keyboard mode selection (SERIAL, etc.)", example: "KEYBOARD_MODE SERIAL", response: "none", responseBytes: 0},
{cmd: "LINK", short: "", params: "object target", desc: "Links formats/objects together", example: "LINK format target", response: "none", responseBytes: 0},
{cmd: "MULTIPLE", short: "M", params: "1-9", desc: "Prints multiple copies horizontally (1-9)", example: "MULTIPLE 2", response: "none", responseBytes: 0},
{cmd: "OFFSET", short: "", params: "x y", desc: "Sets coordinate offset for subsequent commands", example: "OFFSET 10 20", response: "none", responseBytes: 0},
{cmd: "PITCH", short: "P", params: "0-65535", desc: "Sets resolution (0-65535, typically 100/200/300)", example: "PITCH 200", response: "none", responseBytes: 0},
{cmd: "PRINT_LABEL", short: "", params: "name [options]", desc: "Invoke stored label format for printing", example: "PRINT_LABEL myformat", response: "none", responseBytes: 0},
{cmd: "PROMPTS", short: "", params: "\"text\"", desc: "Display prompt text for menu system", example: "PROMPTS \"Enter value\"", response: "none", responseBytes: 0},
{cmd: "QUANTITY", short: "QY", params: "0-65535", desc: "Sets number of copies to print (0-65535)", example: "QUANTITY 5", response: "none", responseBytes: 0},
{cmd: "R90", short: "R9", params: "", desc: "Rotate output 90 degrees", example: "R90", response: "none", responseBytes: 0},
{cmd: "R180", short: "R1", params: "", desc: "Rotate output 180 degrees", example: "R180", response: "none", responseBytes: 0},
{cmd: "R270", short: "R2", params: "", desc: "Rotate output 270 degrees", example: "R270", response: "none", responseBytes: 0},
{cmd: "SECURITY BARCODE", short: "", params: "data", desc: "Security barcoding when feature is enabled", example: "SECURITY BARCODE ...", response: "none", responseBytes: 0},
{cmd: "TERMINAL", short: "", params: "DEFAULT|RS232|LCD_PANEL|USB|RTEL|DISCOVER", desc: "Select terminal/display port (DEFAULT|RS232|LCD_PANEL|USB|RTEL|DISCOVER)", example: "TERMINAL DEFAULT", response: "none", responseBytes: 0},
{cmd: "TEST_LABEL", short: "", params: "[Y] [H]", desc: "Print diagnostic test label", example: "TEST_LABEL 1 Y H", response: "none", responseBytes: 0},
{cmd: "VARIABLES", short: "", params: "ON|OFF", desc: "Enable/disable processing of variable blocks", example: "VARIABLES ON", response: "none", responseBytes: 0},
{cmd: "WIDTH", short: "W", params: "n|?", desc: "Sets logical print width (0-65535 dots)", example: "WIDTH 400", response: "ASCII + optional CRLF on query", responseBytes: "18-19", exampleResponse: "WIDTH = 400 (812 dots)"},
{cmd: "BARCODER", short: "BR", params: "", desc: "Enable/adjust internal barcode rendering mode", example: "BARCODER ENABLE"}
],
text: [
{cmd: "STRING", short: "S", params: "font (mods) x y data", desc: "Prints text using bitmap fonts (5X7, 8X8, 10X14, 12X16, 18X23, 24X31)", example: "STRING 12x16 10 10 Hello World"},
{cmd: "TEXT", short: "T", params: "font (mods) x y data", desc: "Prints text using CG Triumvirate fonts (0-6)", example: "TEXT 3 0 50 100 Hello World"},
{cmd: "ULTRA_FONT", short: "U", params: "TnnnXmmm IGz(B,E,R) x y data", desc: "Prints using TrueType vector fonts with size/bold/rotation", example: "ULTRA_FONT T10X15 IGz(2,1,0) 10 10 Ultra"},
{cmd: "ROTATE", short: "R", params: "angle (mods) x y data", desc: "Rotates STRING text (90, 180, 270 degrees)", example: "ROTATE 90 0 100 50 Vertical"},
{cmd: "DOUBLE", short: "", params: "font(mods) x y mtid chars", desc: "Renders double-byte characters (Chinese, Japanese)", example: "DOUBLE 3(1,0,2,2) 10 10 1234 "},
{cmd: "THAI", short: "", params: "fontID(mods) x y chars", desc: "Renders Thai text with specified formatting", example: "THAI 3(0,0,1,1) 10 10 "},
{cmd: "COMMENT", short: "C", params: "text", desc: "Adds comments for documentation (not printed)", example: "COMMENT This is a comment"},
{cmd: "DATASKIP", short: "DP", params: "count", desc: "Skips specified number of characters in data stream", example: "DATASKIP 5"},
{cmd: "DATASKIP UNTIL", short: "", params: "char count", desc: "Skip input until character appears count times", example: "DATASKIP UNTIL , 3"},
{cmd: "DATASKIP LOOPUNTIL", short: "", params: "char count", desc: "Loop skipping until character criteria is met", example: "DATASKIP LOOPUNTIL ; 2"},
{cmd: "DEFINE_VAR", short: "DR", params: "name type length", desc: "Define format variable (type: X,A,N,#,F#; length: 1-254)", example: "DEFINE_VAR price # 8"},
{cmd: "MICR", short: "", params: "text params", desc: "MICR text printing for checks/documents", example: "MICR TEXT 123456789"}
],
graphics: [
{cmd: "DRAW_BOX", short: "D", params: "x y w h [thick]", desc: "Draws hollow rectangle outline", example: "DRAW_BOX 50 50 200 100 2"},
{cmd: "DRAW_LINE", short: "DL", params: "x1 y1 x2 y2 [thick] [color]", desc: "Draws line between points (color: B/W)", example: "DRAW_LINE 10 10 200 200 3 B"},
{cmd: "DRAW_CIRCLE", short: "DC", params: "x y dia [thick] [color]", desc: "Draws circle outline", example: "DRAW_CIRCLE 100 100 50 2 B"},
{cmd: "DRAW_ELLIPSE", short: "DE", params: "x y w h [thick] [color]", desc: "Draws ellipse outline", example: "DRAW_ELLIPSE 100 100 80 50 2 B"},
{cmd: "FILL_BOX", short: "F", params: "x y w h", desc: "Draws filled black rectangle", example: "FILL_BOX 50 50 200 100"},
{cmd: "DRAW_SYMBOL", short: "SYMBOL", params: "x y symbol", desc: "Draws predefined symbol (A-E)", example: "DRAW_SYMBOL 10 10 A"},
{cmd: "GRAPHIC", short: "G", params: "[type] x y [w h] data", desc: "Renders PCX/BMP graphic data at coordinates", example: "GRAPHIC PCX 50 50"},
{cmd: "GRAPHIC STORE", short: "", params: "type loc name", desc: "Saves image to printer memory (loc: R/F)", example: "GRAPHIC STORE PCX F LOGO1"},
{cmd: "GRAPHIC RECALL", short: "!R G", params: "name x y", desc: "Places stored image on label", example: "GRAPHIC RECALL LOGO1 50 50"}
],
barcode: [
{cmd: "BARCODE", short: "B", params: "[Rot] type [mods] x y h data", desc: "Standard 1D barcodes (module size 1-10)", example: "BARCODE CODE128 0 50 100 80 12345678"},
{cmd: "BARCODE CODE39", short: "", params: "x y h data", desc: "Code 39 alphanumeric barcode", example: "BARCODE CODE39 10 10 50 ABC123"},
{cmd: "BARCODE CODE128", short: "", params: "x y h data", desc: "Code 128 high-density barcode", example: "BARCODE CODE128 10 10 50 TEST12345"},
{cmd: "BARCODE EAN13", short: "", params: "x y h data", desc: "EAN-13 retail barcode (13 digits)", example: "BARCODE EAN13 10 10 50 5901234123457"},
{cmd: "BARCODE UPCA", short: "", params: "x y h data", desc: "UPC-A retail barcode (12 digits)", example: "BARCODE UPCA 10 10 50 012345678905"},
{cmd: "BARCODE I2OF5", short: "", params: "x y h data", desc: "Interleaved 2 of 5 numeric barcode", example: "BARCODE I2OF5 10 10 50 12345678"},
{cmd: "BARCODE CODABAR", short: "", params: "x y h data", desc: "Codabar for libraries/blood banks", example: "BARCODE CODABAR 10 10 50 A12345B"},
{cmd: "BARCODE QR", short: "", params: "x y cell [model] bytes data", desc: "2D QR Code (cell=1-10, model=1/2)", example: "BARCODE QR 50 50 3 2 20 https://example.com"},
{cmd: "BARCODE DATAMATRIX", short: "DM", params: "(fmt,ecc,rows,cols,cell,bytes) x y data", desc: "2D Data Matrix (fmt: 0=Square, 1=Rect)", example: "BARCODE DATAMATRIX (0,0,0,0,3,10) 50 50 TEST123"},
{cmd: "BARCODE PDF417", short: "", params: "x y aspect ec r:c bytes T M data", desc: "2D PDF417 stacked barcode", example: "BARCODE PDF417 50 50 3 2 0:0 20 0 0 DATA"},
{cmd: "BARCODE MICROPDF", short: "", params: "x y params data", desc: "2D MicroPDF417 compact version", example: "BARCODE MICROPDF 10 10 \"DATA\""},
{cmd: "BARCODE AZTEC", short: "", params: "(ECP,Size,Lay,ID,E,M) x y bytes data", desc: "2D Aztec Code", example: "BARCODE AZTEC (0,0,0,0,0,0) 50 50 15 AZTEC123"},
{cmd: "BARCODE RSS", short: "", params: "x y params data", desc: "RSS/GS1 DataBar symbology", example: "BARCODE RSS 10 10 \"DATA\""},
{cmd: "BARCODE UPS", short: "", params: "x y w h data", desc: "UPS MaxiCode for shipping", example: "BARCODE UPS 10 10 100 50 1Z12345678"},
{cmd: "BARCODE_FONT", short: "", params: "font", desc: "Select font for barcode human-readable text", example: "BARCODE_FONT TEXT"},
{cmd: "BSTRING", short: "BARCODE_FONT_STRING", params: "fontID(spacing,rotation,xmult,ymult) x y data", desc: "Barcode using string font", example: "BSTRING 3(0,0,1,1) 10 10 CODE128DATA"},
{cmd: "BTEXT", short: "BARCODE_FONT_TEXT", params: "fontID(spacing,rotation,xmult,ymult) x y data", desc: "Barcode using text font", example: "BTEXT 3(0,0,1,1) 10 10 CODE128DATA"},
{cmd: "BULTRA", short: "BARCODE_FONT_ULTRA", params: "fontID(mods) x y data", desc: "Barcode using ultra font", example: "BULTRA 3(0,0,1,1) 10 10 CODE128DATA"}
],
system: [
{cmd: "!RESET", short: "", params: "", desc: "Soft reboots the printer", example: "!RESET", response: "none", responseBytes: 0},
{cmd: "!STATUS", short: "", params: "", desc: "Returns printer status (Ready, Paper Out, Head Open)", example: "!STATUS", response: "Variable ASCII + optional CRLF", responseBytes: "variable", exampleResponse: "Ready"},
{cmd: "!CAL", short: "", params: "[mode]", desc: "Runs media sensor calibration (0=Normal, 3=Mesh)", example: "!CAL 0", response: "none", responseBytes: 0},
{cmd: "!DUMP DATAFLASH", short: "", params: "len addr", desc: "Hex dump of Flash memory", example: "!DUMP DATAFLASH 256 0x400000", response: "Hex ASCII data", responseBytes: "variable"},
{cmd: "!DUMP IMAGE", short: "", params: "", desc: "Hex dump of print buffer (raster data)", example: "!DUMP IMAGE", response: "Binary/ASCII data", responseBytes: "variable"},
{cmd: "!DUMP USERVARS", short: "", params: "", desc: "Lists all user-configurable variable settings", example: "!DUMP USERVARS", response: "ASCII variable list", responseBytes: "variable"},
{cmd: "!DUMP FACTORYAVARS", short: "", params: "", desc: "Displays factory variable memory area", example: "!DUMP FACTORYAVARS", response: "ASCII variable list", responseBytes: "variable"},
{cmd: "!DUMP FACTORYBVARS", short: "", params: "", desc: "Displays factory backup variable memory", example: "!DUMP FACTORYBVARS", response: "ASCII variable list", responseBytes: "variable"},
{cmd: "!DUMP MEMORY", short: "", params: "size addr", desc: "Displays RAM memory contents for debugging", example: "!DUMP MEMORY 20 0x20123456", response: "Hex ASCII data", responseBytes: "variable"},
{cmd: "!GET INDEX", short: "!QI", params: "", desc: "Returns current Gap Sensor voltage/value", example: "!GET INDEX", response: "ASCII config + optional CRLF", responseBytes: "variable", exampleResponse: "INDEX: GAP DT 50 50 100 200"},
{cmd: "!GET STATUS", short: "", params: "", desc: "Returns printer status byte", example: "!GET STATUS", response: "1-2 bytes", responseBytes: "1-2", exampleResponse: "00"},
{cmd: "!GET TOF", short: "", params: "", desc: "Retrieves current Top of Form setting", example: "!GET TOF", response: "ASCII value", responseBytes: "variable", exampleResponse: "TOF = 120"},
{cmd: "!GET SHIFT", short: "", params: "", desc: "Retrieves current print shift/offset settings", example: "!GET SHIFT", response: "ASCII value", responseBytes: "variable", exampleResponse: "SHIFT = 10"},
{cmd: "!LOAD C_BIN", short: "", params: "", desc: "Enters firmware update mode", example: "!LOAD C_BIN"},
{cmd: "!TEST", short: "", params: "[type]", desc: "Runs printer self-test", example: "!TEST", response: "none", responseBytes: 0},
{cmd: "!IDENTIFY", short: "", params: "", desc: "Returns printer model and firmware version", example: "!IDENTIFY", response: "Variable ASCII + optional CRLF", responseBytes: "variable", exampleResponse: "BT200 V1.2.3"},
{cmd: "!!", short: "DOUBLE BANG", params: "x dottime maxY numlbls", desc: "Executes internal test patterns for manufacturing", example: "!! 1 10 100 5"},
{cmd: "!ERASE EVENTLOG", short: "", params: "", desc: "Clears the printer's event log", example: "!ERASE EVENTLOG"},
{cmd: "!ERASE SECTOR", short: "", params: "[A|B]", desc: "Erases specified flash memory sector", example: "!ERASE SECTORA"},
{cmd: "!HISTORY DISABLE", short: "", params: "", desc: "Disables all history tracking", example: "!HISTORY DISABLE"},
{cmd: "!HISTORY ENABLE", short: "", params: "hexvalue", desc: "Enables specific history tracking with bitmask", example: "!HISTORY ENABLE 0xFF"},
{cmd: "!HISTORY INIT", short: "", params: "hexvalue", desc: "Initializes history system with parameters", example: "!HISTORY INIT 0x00"},
{cmd: "!HISTORY OUTPUT", short: "", params: "enable/disable", desc: "Enables/disables history output logging", example: "!HISTORY OUTPUT ENABLE"},
{cmd: "!LOAD INCHCOUNT", short: "", params: "nnn", desc: "Loads inch count value for factory tracking", example: "!LOAD INCHCOUNT 1000", response: "none", responseBytes: 0},
{cmd: "!LOAD LICENSE", short: "", params: "\"key\"", desc: "Loads software license key (manufacturing)", example: "!LOAD LICENSE \"ABC123-DEF456\"", response: "none", responseBytes: 0},
{cmd: "!LOAD MAC", short: "", params: "addr", desc: "Sets the network interface MAC address", example: "!LOAD MAC 00:11:22:33:44:55", response: "none", responseBytes: 0},
{cmd: "!LOAD MODELNUMBER", short: "", params: "model", desc: "Sets the printer's model number", example: "!LOAD MODELNUMBER BT200", response: "none", responseBytes: 0},
{cmd: "!LOAD SERIALNUMBER", short: "", params: "serial", desc: "Sets the printer's serial number", example: "!LOAD SERIALNUMBER ABC123456", response: "none", responseBytes: 0},
{cmd: "!LOAD OOBVARS", short: "", params: "", desc: "Loads out-of-box variables to factory defaults", example: "!LOAD OOBVARS", response: "none", responseBytes: 0},
{cmd: "!PRINT TESTLABEL", short: "", params: "", desc: "Prints comprehensive test label with config", example: "!PRINT TESTLABEL", response: "none", responseBytes: 0},
{cmd: "!SET HOST_NAME", short: "", params: "\"hostname\"", desc: "Sets network host name for printer", example: "!SET HOST_NAME \"PRINTER001\"", response: "none", responseBytes: 0},
{cmd: "!SET INDEX", short: "", params: "FeedType PrintMode R% T% Gain WhiteLevel", desc: "Sets comprehensive index sensor parameters", example: "!SET INDEX GAP DIRECT 50 50 100 200", response: "none", responseBytes: 0},
{cmd: "!SET PEELER", short: "", params: "power 0-100 gain 0-3 time 0-65535", desc: "Configures label peeler operation mode", example: "!SET PEELER 80 2 500", response: "none", responseBytes: 0},
{cmd: "!SET PRINTHEAD", short: "", params: "parameters", desc: "Configures print head specifications (mfg)", example: "!SET PRINTHEAD 203,832", response: "none", responseBytes: 0},
{cmd: "!SET SHIFT", short: "", params: "value", desc: "Sets global print position shift/offset", example: "!SET SHIFT 10", response: "none", responseBytes: 0},
{cmd: "!SET TIME", short: "", params: "YYYY MM DD hh mm ss", desc: "Sets the printer's internal clock", example: "!SET TIME 2024 12 25 14 30 00", response: "none", responseBytes: 0},
{cmd: "!SET TOF", short: "", params: "nnn", desc: "Sets the Top of Form value", example: "!SET TOF 100", response: "none", responseBytes: 0},
{cmd: "!SHOW AD", short: "", params: "", desc: "Displays A/D converter readings for diagnostics", example: "!SHOW AD", response: "Variable ASCII + optional CRLF", responseBytes: "variable", exampleResponse: "AD0: 512 AD1: 384 AD2: 256"},
{cmd: "!SHOW EVENTLOG", short: "", params: "", desc: "Displays printer's event log for troubleshooting", example: "!SHOW EVENTLOG", response: "Variable ASCII lines", responseBytes: "variable"},
{cmd: "!SHOW HEAP", short: "", params: "", desc: "Shows heap memory allocation statistics", example: "!SHOW HEAP", response: "Variable ASCII + optional CRLF", responseBytes: "variable", exampleResponse: "Heap Free: 32768 Used: 16384"},
{cmd: "!SHOW HISTORY", short: "!QH", params: "", desc: "Displays command history buffer for debugging", example: "!SHOW HISTORY", response: "Variable ASCII + optional CRLF", responseBytes: "variable"},
{cmd: "!SHOW HOST_NAME", short: "", params: "", desc: "Displays the printer's network hostname", example: "!SHOW HOST_NAME", response: "ASCII + optional CRLF", responseBytes: "variable", exampleResponse: "PRINTER001"},
{cmd: "!SHOW INCHCOUNT", short: "", params: "", desc: "Shows cumulative count of inches printed", example: "!SHOW INCHCOUNT", response: "Variable ASCII + optional CRLF", responseBytes: "variable", exampleResponse: "123456"},
{cmd: "!SHOW MAC", short: "", params: "", desc: "Displays the Ethernet MAC address", example: "!SHOW MAC", response: "17 ASCII bytes XX:XX:XX:XX:XX:XX", responseBytes: 17, exampleResponse: "00:11:22:33:44:55"},
{cmd: "!SHOW MEMORY", short: "", params: "", desc: "Displays current memory usage statistics", example: "!SHOW MEMORY", response: "Variable ASCII + optional CRLF", responseBytes: "variable", exampleResponse: "Total: 65536 Free: 32768"},
{cmd: "!SHOW MODELNUMBER", short: "", params: "", desc: "Displays the printer model number", example: "!SHOW MODELNUMBER", response: "4-29 ASCII bytes + optional CRLF", responseBytes: "4-29", exampleResponse: "BT200"},
{cmd: "!SHOW PRINTHEAD", short: "", params: "", desc: "Displays print head type, resolution, width", example: "!SHOW PRINTHEAD", response: "Variable ASCII + optional CRLF", responseBytes: "variable", exampleResponse: "DPI: 203 Width: 832"},
{cmd: "!SHOW SERIALNUMBER", short: "", params: "", desc: "Displays the printer serial number", example: "!SHOW SERIALNUMBER", response: "6-20 ASCII bytes + optional CRLF", responseBytes: "6-20", exampleResponse: "ABC123456789"},
{cmd: "!SHOW STACK", short: "", params: "", desc: "Displays current stack status and usage", example: "!SHOW STACK", response: "Variable ASCII + optional CRLF", responseBytes: "variable", exampleResponse: "Stack: 2048/8192"},
{cmd: "!SHOW SECTORADDR", short: "!QSA", params: "", desc: "Displays flash memory sector architecture", example: "!SHOW SECTORADDR", response: "Variable ASCII + optional CRLF", responseBytes: "variable"},
{cmd: "DATA_TRACE_OPEN", short: "", params: "", desc: "Opens data trace for debugging", example: "DATA_TRACE_OPEN", response: "none", responseBytes: 0},
{cmd: "DATA_TRACE_CLOSE", short: "", params: "", desc: "Closes data trace", example: "DATA_TRACE_CLOSE", response: "none", responseBytes: 0},
{cmd: "TRACE_MARK", short: "", params: "", desc: "Adds a marker to trace buffer", example: "TRACE_MARK", response: "none", responseBytes: 0},
{cmd: "TRACE_FLUSH", short: "", params: "", desc: "Flushes trace buffer", example: "TRACE_FLUSH", response: "none", responseBytes: 0},
{cmd: "!DEV", short: "", params: "", desc: "Device diagnostics query", example: "!DEV", response: "Variable ASCII + optional CRLF", responseBytes: "variable", exampleResponse: "DEV: OK"},
{cmd: "!ERASE WARRANTYLOGS", short: "", params: "", desc: "Erases warranty logs from memory", example: "!ERASE WARRANTYLOGS", response: "none", responseBytes: 0},
{cmd: "!SET OEMIDENTIFIER", short: "", params: "oem", desc: "Sets OEM brand identifier (COGNITIVE,TALLYGENICOM,NONBRANDED,TALLYDASCOM)", example: "!SET OEMIDENTIFIER TALLYDASCOM", response: "none", responseBytes: 0},
{cmd: "!SET OEMMODELID", short: "", params: "id", desc: "Sets OEM model identifier string", example: "!SET OEMMODELID 7008-TT2", response: "none", responseBytes: 0},
{cmd: "!SET TRACEFLUSH", short: "", params: "", desc: "Flushes diagnostic trace buffers to storage", example: "!SET TRACEFLUSH", response: "none", responseBytes: 0},
{cmd: "!SET DATATRACEOPEN", short: "", params: "filename", desc: "Opens data trace file on USB storage", example: "!SET DATATRACEOPEN msg1.txt", response: "none", responseBytes: 0},
{cmd: "!SET DATATRACECLOSE", short: "", params: "", desc: "Closes data trace file", example: "!SET DATATRACECLOSE", response: "none", responseBytes: 0},
{cmd: "!SET MESSAGETRACEOPEN", short: "", params: "filename", desc: "Opens message trace file for diagnostics", example: "!SET MESSAGETRACEOPEN msg1.txt", response: "none", responseBytes: 0},
{cmd: "!SET MESSAGETRACECLOSE", short: "", params: "", desc: "Closes message trace file", example: "!SET MESSAGETRACECLOSE", response: "none", responseBytes: 0},
{cmd: "!SET OOBVARS", short: "", params: "", desc: "Applies out-of-box variables block to restore factory defaults", example: "!SET OOBVARS", response: "none", responseBytes: 0},
{cmd: "!PRINT", short: "", params: "item", desc: "Print diagnostic items (VERSION, CONFIG, etc.)", example: "!PRINT VERSION"},
{cmd: "!SHOW", short: "", params: "item", desc: "Show internal data (MAC, MEMORY, CONFIG, etc.)", example: "!SHOW MAC", response: "ASCII + optional CRLF", responseBytes: "variable"},
{cmd: "!HISTORY", short: "", params: "", desc: "Print history information to host", example: "!HISTORY", response: "Variable ASCII + optional CRLF", responseBytes: "variable"},
{cmd: "EVENTLOG", short: "", params: "ENABLE|DISABLE|INIT|OUTPUT", desc: "Control and output event logs for diagnostics", example: "EVENTLOG OUTPUT", response: "Variable ASCII lines", responseBytes: "variable"},
{cmd: "LAST_RESULT", short: "", params: "", desc: "Returns last function result code", example: "LAST_RESULT", response: "ASCII code + optional CRLF", responseBytes: "variable", exampleResponse: "0"},
{cmd: "STATUS", short: "", params: "", desc: "Status operations for menu/variables", example: "STATUS READ", response: "ASCII", responseBytes: "variable"},
{cmd: "CONFIG", short: "", params: "read/write fields", desc: "General configuration read/write commands", example: "CONFIG READ", response: "ASCII", responseBytes: "variable"},
{cmd: "XCONFIG", short: "", params: "extended config", desc: "Extended configuration commands", example: "XCONFIG WRITE field value", response: "none", responseBytes: 0},
{cmd: "I2C", short: "", params: "device addr data", desc: "Direct I2C bus access (platform dependent)", example: "I2C READ 0x50 2", response: "Binary/ASCII", responseBytes: "variable"},
{cmd: "RFCARD", short: "", params: "operation", desc: "RF card reader operations", example: "RFCARD READ", response: "Variable", responseBytes: "variable"}
],
variable: [
{cmd: "VARIABLE ALLOCATE", short: "V ALLOCATE", params: "0-65535", desc: "Allocates memory for printer operations (0-65535)", example: "VARIABLE ALLOCATE 1024"},
{cmd: "VARIABLE AUDIO_FREQ", short: "", params: "n|?", desc: "Sets beeper audio frequency (Hz)", example: "VARIABLE AUDIO_FREQ 2000", response: "ASCII + CRLF on query", responseBytes: "variable", exampleResponse: "AUDIO_FREQ = 2000"},
{cmd: "VARIABLE AUTOCUT", short: "", params: "ON|OFF|?", desc: "Enable/disable automatic label cutting", example: "VARIABLE AUTOCUT ON"},
{cmd: "VARIABLE AUTO_TOF", short: "", params: "ON|OFF|?", desc: "Automatic top-of-form detection", example: "VARIABLE AUTO_TOF ON"},
{cmd: "VARIABLE AUX_POWER", short: "", params: "ON|OFF|?", desc: "Auxiliary power output control", example: "VARIABLE AUX_POWER ON"},
{cmd: "VARIABLE AUXPOWER", short: "", params: "ON|OFF|?", desc: "Alias for AUX_POWER", example: "VARIABLE AUXPOWER ON"},
{cmd: "VARIABLE BACKLIGHT", short: "", params: "ON|OFF|?", desc: "Adjusts LCD display backlight", example: "VARIABLE BACKLIGHT ON"},
{cmd: "VARIABLE BEEPER", short: "V BEEPER", params: "vol dur", desc: "Beeper settings (vol:0 to BEEPER_ENTRIES-1, dur:0-255)", example: "VARIABLE BEEPER 2 50"},
{cmd: "VARIABLE BEEPER VOLUME", short: "", params: "0-3|?", desc: "Beeper volume level", example: "VARIABLE BEEPER VOLUME 2", response: "ASCII + CRLF on query", responseBytes: "17", exampleResponse: "BEEPER VOLUME = 2"},
{cmd: "VARIABLE BEEPER DURATION", short: "", params: "0-255|?", desc: "Beeper duration in milliseconds", example: "VARIABLE BEEPER DURATION 100", response: "ASCII + CRLF on query", responseBytes: "19-21", exampleResponse: "BEEPER DURATION = 100"},
{cmd: "VARIABLE BUFFER_TIMED_RESET", short: "", params: "n", desc: "Buffer reset timeout (2-65535 seconds)", example: "VARIABLE BUFFER_TIMED_RESET 30"},
{cmd: "VARIABLE CENTRONICS_MODE", short: "", params: "mode", desc: "Centronics parallel port mode", example: "VARIABLE CENTRONICS_MODE 1"},
{cmd: "VARIABLE CODE_PAGE", short: "", params: "n", desc: "Character code page (0-65536)", example: "VARIABLE CODE_PAGE 850"},
{cmd: "VARIABLE COMM", short: "", params: "DSR|DTR settings", desc: "Serial port settings", example: "VARIABLE COMM DSR ON"},
{cmd: "VARIABLE COMPATIBLE", short: "", params: "type ON|OFF|?", desc: "Compatibility mode (ZPL, EPL)", example: "VARIABLE COMPATIBLE ZPL ON"},
{cmd: "VARIABLE CONTRAST", short: "", params: "level 0-255|?", desc: "LCD display contrast level", example: "VARIABLE CONTRAST 50", response: "ASCII + CRLF on query", responseBytes: "16-18", exampleResponse: "LCD CONTRAST = 128"},
{cmd: "VARIABLE CPL_COMMAND_MASK", short: "", params: "hex|?", desc: "32-bit hex mask for CPL commands", example: "VARIABLE CPL_COMMAND_MASK 0xFFFFFFFF", response: "ASCII + CRLF on query", responseBytes: "23", exampleResponse: "CPL_CMD_MASK = ffffffff"},
{cmd: "VARIABLE DARKNESS", short: "V D", params: "-200 to 813|?", desc: "Print head heat energy (-200 to 813)", example: "VARIABLE DARKNESS 100", response: "ASCII + CRLF on query", responseBytes: "variable", exampleResponse: "DARKNESS = 100"},
{cmd: "VARIABLE DIAGNOSTIC", short: "", params: "", desc: "Run diagnostic output", example: "VARIABLE DIAGNOSTIC"},
{cmd: "VARIABLE DEVICENAME", short: "", params: "name", desc: "Sets device name for Bluetooth/network", example: "VARIABLE DEVICENAME MyPrinter"},
{cmd: "VARIABLE DEVICEPIN", short: "", params: "pin", desc: "Sets device PIN", example: "VARIABLE DEVICEPIN 1234"},
{cmd: "VARIABLE DISCOVERABLE", short: "", params: "ON|OFF|?", desc: "Set discoverability mode", example: "VARIABLE DISCOVERABLE ON"},
{cmd: "VARIABLE ENCRYPTION", short: "", params: "ON|OFF|?", desc: "Enable/disable encryption", example: "VARIABLE ENCRYPTION ON"},
{cmd: "VARIABLE ENERGY", short: "", params: "n|?", desc: "Print energy level", example: "VARIABLE ENERGY 100", response: "ASCII + CRLF on query", responseBytes: "variable", exampleResponse: "ENERGY = 100"},
{cmd: "VARIABLE EPL_COMMAND_MASK", short: "", params: "hex|?", desc: "32-bit hex mask for EPL commands", example: "VARIABLE EPL_COMMAND_MASK 0x00000000", response: "ASCII + CRLF on query", responseBytes: "23", exampleResponse: "EPL_CMD_MASK = ffffffff"},
{cmd: "VARIABLE EPL_PREFIX", short: "", params: "prefix|?", desc: "EPL command prefix mode", example: "VARIABLE EPL_PREFIX STANDARD", response: "ASCII + CRLF on query", responseBytes: "variable", exampleResponse: "EPL_PREFIX = PREFIX"},
{cmd: "VARIABLE ERROR_LEVEL", short: "", params: "level|?", desc: "Error reporting level", example: "VARIABLE ERROR_LEVEL 1"},
{cmd: "VARIABLE FACTORY_RESTORE", short: "", params: "", desc: "Restores factory default settings", example: "VARIABLE FACTORY_RESTORE"},
{cmd: "VARIABLE FEED", short: "", params: "0-65535|?", desc: "Default feed distance (0-65535 dots)", example: "VARIABLE FEED 100", response: "ASCII + CRLF on query", responseBytes: "variable", exampleResponse: "FEED = 100"},
{cmd: "VARIABLE FEED_BUTTON", short: "", params: "mode", desc: "Manual feed button behavior", example: "VARIABLE FEED_BUTTON ENABLE"},
{cmd: "VARIABLE FEED_CONFIG", short: "", params: "F|C|L|N", desc: "Feed type and print mode config", example: "VARIABLE FEED_CONFIG F"},
{cmd: "VARIABLE FEED_SPEED", short: "", params: "speed", desc: "Media feed speed in milli-IPS", example: "VARIABLE FEED_SPEED 6000"},
{cmd: "VARIABLE FEED_TYPE", short: "", params: "type", desc: "Sensor type (GAP, BAR, NOTCH, CONTINUOUS)", example: "VARIABLE FEED_TYPE GAP"},
{cmd: "VARIABLE FORGET", short: "", params: "", desc: "Forget paired devices", example: "VARIABLE FORGET"},
{cmd: "VARIABLE GAP_SIZE", short: "", params: "0-100|?", desc: "Gap size between labels (0-100)", example: "VARIABLE GAP_SIZE 50", response: "ASCII + CRLF on query", responseBytes: "variable", exampleResponse: "GAP_SIZE = 50"},
{cmd: "VARIABLE HIGHSPEED", short: "", params: "", desc: "Enable high-speed mode", example: "VARIABLE HIGHSPEED"},
{cmd: "VARIABLE INDEX", short: "V I", params: "ON|OFF", desc: "Master gap/mark sensor enable", example: "VARIABLE INDEX ON"},
{cmd: "VARIABLE IRDA", short: "", params: "ON|OFF|?", desc: "IrDA interface enable", example: "VARIABLE IRDA ON"},
{cmd: "VARIABLE IRDA PROTOCOL", short: "", params: "p", desc: "IrDA protocol setting", example: "VARIABLE IRDA PROTOCOL 1"},
{cmd: "VARIABLE IRDA COMM", short: "", params: "baud", desc: "IrDA baud rate", example: "VARIABLE IRDA COMM 115200"},
{cmd: "VARIABLE KBLAYOUT", short: "", params: "mode", desc: "Keyboard layout (0-65535)", example: "VARIABLE KBLAYOUT 4"},
{cmd: "VARIABLE LABEL_LENGTH", short: "", params: "0-10000|?", desc: "Fixed label length (0-10000 dots)", example: "VARIABLE LABEL_LENGTH 800", response: "ASCII + CRLF on query", responseBytes: "variable", exampleResponse: "LABEL_LENGTH = 800"},
{cmd: "VARIABLE LANGUAGE", short: "", params: "type", desc: "Firmware language for status messages", example: "VARIABLE LANGUAGE EN"},
{cmd: "VARIABLE LCD CONTRAST", short: "", params: "0-255|?", desc: "LCD display contrast level", example: "VARIABLE LCD CONTRAST 128", response: "ASCII + CRLF on query", responseBytes: "16-18", exampleResponse: "LCD CONTRAST = 128"},
{cmd: "VARIABLE LOWSPEED", short: "", params: "", desc: "Enable low-speed mode", example: "VARIABLE LOWSPEED"},
{cmd: "VARIABLE LOW_BATTERY_IGNORE", short: "", params: "ON|OFF|?", desc: "Ignore low battery warnings", example: "VARIABLE LOW_BATTERY_IGNORE ON"},
{cmd: "VARIABLE MAX_WIDTH", short: "", params: "0-65535|?", desc: "Maximum printable width (0-65535 dots)", example: "VARIABLE MAX_WIDTH 832", response: "ASCII + CRLF on query", responseBytes: "variable", exampleResponse: "MAX_WIDTH = 832"},
{cmd: "VARIABLE MEASURE_LABEL", short: "", params: "ON|OFF|?", desc: "Auto-measure label length", example: "VARIABLE MEASURE_LABEL ON"},
{cmd: "VARIABLE MEDIA_ADJUST", short: "", params: "-3000 to 3000|?", desc: "Media sensor adjustment (-3000 to 3000)", example: "VARIABLE MEDIA_ADJUST 10", response: "ASCII + CRLF on query", responseBytes: "variable", exampleResponse: "MEDIA_ADJUST = 10"},
{cmd: "VARIABLE MENU_LANGUAGE", short: "", params: "lang|?", desc: "Menu language (ENGLISH|FRENCH|SPANISH|ITALIAN|PORTUGUESE|GERMAN)", example: "VARIABLE MENU_LANGUAGE ENGLISH"},
{cmd: "VARIABLE MIRROR_LABEL", short: "", params: "ON|OFF|?", desc: "Mirror the entire label horizontally", example: "VARIABLE MIRROR_LABEL ON"},
{cmd: "VARIABLE MODE", short: "V MODE", params: "n", desc: "Printer operating mode (0-3)", example: "VARIABLE MODE 1"},
{cmd: "VARIABLE NO_MEDIA", short: "", params: "ON|OFF|?", desc: "No media condition handling", example: "VARIABLE NO_MEDIA ON"},
{cmd: "VARIABLE NORMAL", short: "", params: "", desc: "Reset to normal/default values", example: "VARIABLE NORMAL"},
{cmd: "VARIABLE OEMIDENTIFIER", short: "", params: "oem", desc: "OEM identifier (COGNITIVE|TALLYGENICOM|NONBRANDED|TALLYDASCOM)", example: "VARIABLE OEMIDENTIFIER COGNITIVE"},
{cmd: "VARIABLE OEMMODELID", short: "", params: "id", desc: "OEM model identifier string", example: "VARIABLE OEMMODELID 7008-TT2"},
{cmd: "VARIABLE OFF_AFTER", short: "", params: "0-65535|?", desc: "Auto power-off timer (0-65535 sec)", example: "VARIABLE OFF_AFTER 300", response: "ASCII + CRLF on query", responseBytes: "variable", exampleResponse: "OFF_AFTER = 300"},
{cmd: "VARIABLE ON_TIME", short: "", params: "0-65535|?", desc: "Print head energizing time (0-65535)", example: "VARIABLE ON_TIME 2", response: "ASCII + CRLF on query", responseBytes: "variable", exampleResponse: "ON_TIME = 2"},
{cmd: "VARIABLE OOP_TLED", short: "", params: "DT|TT n", desc: "Out-of-paper LED timing (0-255)", example: "VARIABLE OOP_TLED DT 50"},
{cmd: "VARIABLE OVERRIDE", short: "", params: "ON|OFF|?", desc: "Override protected settings", example: "VARIABLE OVERRIDE ON"},
{cmd: "VARIABLE PITCH", short: "", params: "0-65535|?", desc: "Resolution/pitch (0-65535)", example: "VARIABLE PITCH 203", response: "ASCII + CRLF on query", responseBytes: "variable", exampleResponse: "PITCH = 203"},
{cmd: "VARIABLE PORT_WAIT", short: "", params: "n|?", desc: "Port send wait (0-2000 ms)", example: "VARIABLE PORT_WAIT 100", response: "ASCII + CRLF on query", responseBytes: "variable", exampleResponse: "PORT_WAIT = 100"},
{cmd: "VARIABLE POSITION", short: "", params: "pos", desc: "TOF position in motor steps", example: "VARIABLE POSITION 50"},
{cmd: "VARIABLE PRESENTLABEL", short: "", params: "ON|OFF|? adv|rev time", desc: "Label presentation mode for peeler", example: "VARIABLE PRESENTLABEL ON"},
{cmd: "VARIABLE PRINT_MODE", short: "", params: "AUTO|DT|TT|?", desc: "Print mode (TT=Transfer, DT=Direct)", example: "VARIABLE PRINT_MODE TT", response: "ASCII + CRLF on query", responseBytes: "15", exampleResponse: "PRINT_MODE = 1"},
{cmd: "VARIABLE PRINT_SPEED", short: "", params: "n|LOWSPEED|NORMAL|HIGHSPEED|?", desc: "Print speed setting", example: "VARIABLE PRINT_SPEED 4", response: "ASCII + CRLF on query", responseBytes: "15-23", exampleResponse: "PRINT_SPEED = HIGHSPEED"},
{cmd: "VARIABLE QS_DELAY", short: "", params: "n|?", desc: "Delay before !QS response (0-65535 ms)", example: "VARIABLE QS_DELAY 50", response: "ASCII + CRLF on query", responseBytes: "variable", exampleResponse: "QS_DELAY = 50"},
{cmd: "VARIABLE READ", short: "V READ", params: "name", desc: "Read variable value", example: "VARIABLE READ DARKNESS"},
{cmd: "VARIABLE RECALIBRATE", short: "", params: "ON|OFF|?", desc: "Initiate media calibration", example: "VARIABLE RECALIBRATE ON"},
{cmd: "VARIABLE REPORT_LEVEL", short: "", params: "0-2|?", desc: "Status report verbosity level", example: "VARIABLE REPORT_LEVEL 2", response: "ASCII + CRLF on query", responseBytes: "16", exampleResponse: "REPORT_LEVEL = 1"},
{cmd: "VARIABLE REPORT_TYPE", short: "", params: "0-2|?", desc: "Status report type format", example: "VARIABLE REPORT_TYPE STANDARD", response: "ASCII + CRLF on query", responseBytes: "15", exampleResponse: "REPORT_TYPE = 2"},
{cmd: "VARIABLE REPRINT", short: "", params: "ON|OFF|?", desc: "Enable label reprint functionality", example: "VARIABLE REPRINT ON"},
{cmd: "VARIABLE RESET", short: "", params: "", desc: "Reset printer variables to defaults", example: "VARIABLE RESET"},
{cmd: "VARIABLE ROTATE_LABEL", short: "", params: "ON|OFF|?", desc: "Rotate entire label", example: "VARIABLE ROTATE_LABEL ON"},
{cmd: "VARIABLE SCRIPT_INPUT_RESET", short: "", params: "n|?", desc: "Script input reset timer", example: "VARIABLE SCRIPT_INPUT_RESET 30"},
{cmd: "VARIABLE SHIFT_LEFT", short: "", params: "n|?", desc: "Horizontal image shift", example: "VARIABLE SHIFT_LEFT 5", response: "ASCII + CRLF on query", responseBytes: "variable", exampleResponse: "SHIFT_LEFT = 5"},
{cmd: "VARIABLE SLEEP_AFTER", short: "", params: "0-255|?", desc: "Auto sleep timer (0-255 sec)", example: "VARIABLE SLEEP_AFTER 15", response: "ASCII + CRLF on query", responseBytes: "variable", exampleResponse: "SLEEP_AFTER = 15"},
{cmd: "VARIABLE STATUS_CRLF", short: "", params: "ON|OFF|?", desc: "Append CRLF to status/query responses", example: "VARIABLE STATUS_CRLF ON", response: "ASCII + CRLF on query", responseBytes: "variable", exampleResponse: "STATUS_CRLF = ON"},
{cmd: "VARIABLE TERMINAL", short: "", params: "DEFAULT|RS232|LCD_PANEL|USB|RTEL|DISCOVER|?", desc: "Set/query terminal device", example: "VARIABLE TERMINAL RS232", response: "ASCII + CRLF on query", responseBytes: "variable", exampleResponse: "TERMINAL = RS232"},
{cmd: "VARIABLE TOF", short: "", params: "n|?", desc: "Top-of-form position offset", example: "VARIABLE TOF 50", response: "ASCII + CRLF on query", responseBytes: "variable", exampleResponse: "TOF = 50"},
{cmd: "VARIABLE TRACEMARK", short: "", params: "string", desc: "Add trace marker string", example: "VARIABLE TRACEMARK \"CHECKPOINT1\""},
{cmd: "VARIABLE TXTBFR", short: "", params: "txt [ovf]|?", desc: "Text buffer size (4096-65535)", example: "VARIABLE TXTBFR 8192", response: "ASCII + CRLF on query", responseBytes: "19-21", exampleResponse: "TXTBFR = 4096, 8192"},
{cmd: "VARIABLE USB_TXTBFR", short: "", params: "txt [ovf]|?", desc: "USB text buffer size (4096-65535)", example: "VARIABLE USB_TXTBFR 4096", response: "ASCII + CRLF on query", responseBytes: "variable", exampleResponse: "USB_TXTBFR = 4096, 0"},
{cmd: "VARIABLE USER_FEEDBACK", short: "", params: "ON|OFF|?", desc: "Enable unsolicited status messages", example: "VARIABLE USER_FEEDBACK ON", response: "ASCII + CRLF on query", responseBytes: "variable", exampleResponse: "USER_FEEDBACK = ON"},
{cmd: "VARIABLE WIDTH", short: "V W", params: "n|?", desc: "Label width (0-65535 dots)", example: "VARIABLE WIDTH 812", response: "ASCII + CRLF on query", responseBytes: "variable", exampleResponse: "WIDTH = 400 (812 dots)"},
{cmd: "VARIABLE WRITE", short: "V WRITE", params: "name value", desc: "Write variable value to storage", example: "VARIABLE WRITE DARKNESS 100"},
{cmd: "VARIABLE ZPL_COMMAND_MASK", short: "", params: "hex|?", desc: "32-bit hex mask for ZPL commands", example: "VARIABLE ZPL_COMMAND_MASK 0x00000000", response: "ASCII + CRLF on query", responseBytes: "23", exampleResponse: "ZPL_CMD_MASK = ffffffff"}
],
network: [
{cmd: "VARIABLE ETHERNET LINK", short: "", params: "?|AUTO|10|100 FULL|HALF", desc: "Query/set link state and parameters", example: "VARIABLE ETHERNET LINK ?", response: "ASCII + CRLF on query", responseBytes: "variable", exampleResponse: "EthernetLink = 100Mb/s, full duplex"},
{cmd: "VARIABLE ETHERNET DHCP", short: "", params: "ON|OFF|?", desc: "Enable/disable DHCP client with timeouts", example: "VARIABLE ETHERNET DHCP ON", response: "ASCII + CRLF on query", responseBytes: "variable", exampleResponse: "ETHERNET DHCP = ON"},
{cmd: "VARIABLE ETHERNET DHCP CRITERIA", short: "", params: "flags 0-3", desc: "DHCP criteria flags", example: "VARIABLE ETHERNET DHCP CRITERIA 1", response: "ASCII + CRLF on query", responseBytes: "variable", exampleResponse: "ETHERNET DHCP CRITERIA = 1"},
{cmd: "VARIABLE ETHERNET DHCP OFFERS", short: "", params: "count 0-30", desc: "DHCP offers limit", example: "VARIABLE ETHERNET DHCP OFFERS 2", response: "ASCII + CRLF on query", responseBytes: "variable", exampleResponse: "ETHERNET DHCP OFFERS = 2"},
{cmd: "VARIABLE ETHERNET DHCP TIMEOUT", short: "", params: "n 0-2147483647", desc: "DHCP timeout interval in ms", example: "VARIABLE ETHERNET DHCP TIMEOUT 120000", response: "ASCII + CRLF on query", responseBytes: "variable", exampleResponse: "ETHERNET DHCP TIMOUT = 120000"},
{cmd: "VARIABLE ETHERNET HTTP", short: "", params: "ON|OFF|?", desc: "HTTP server enable", example: "VARIABLE ETHERNET HTTP ON", response: "ASCII + CRLF on query", responseBytes: "variable", exampleResponse: "ETHERNET HTTP = ON"},
{cmd: "VARIABLE ETHERNET LPD", short: "", params: "ON|OFF|?", desc: "LPD print protocol enable", example: "VARIABLE ETHERNET LPD ON", response: "ASCII + CRLF on query", responseBytes: "variable", exampleResponse: "ETHERNET LPD = ON"},
{cmd: "VARIABLE ETHERNET JOBSOKINERROR", short: "", params: "ON|OFF|?", desc: "Report jobs OK in error mode", example: "VARIABLE ETHERNET JOBSOKINERROR ON", response: "ASCII + CRLF on query", responseBytes: "variable", exampleResponse: "ETHERNET JOBSOKINERROR = ON"},
{cmd: "VARIABLE ETHERNET RTEL", short: "", params: "ON|OFF|?", desc: "Remote telnet enable", example: "VARIABLE ETHERNET RTEL ON", response: "ASCII + CRLF on query", responseBytes: "variable", exampleResponse: "ETHERNET RTEL = ON"},
{cmd: "VARIABLE ETHERNET RTEL PORT", short: "", params: "port 1024-65535", desc: "RTEL port", example: "VARIABLE ETHERNET RTEL PORT 9100", response: "ASCII + CRLF on query", responseBytes: "variable", exampleResponse: "ETHERNET RTEL PORT = 9100"},
{cmd: "VARIABLE ETHERNET RTEL TIME", short: "", params: "time 0-900", desc: "RTEL timeout (0-900 sec)", example: "VARIABLE ETHERNET RTEL TIME 300", response: "ASCII + CRLF on query", responseBytes: "variable", exampleResponse: "ETHERNET RTEL TIMOUT = 300"},
{cmd: "VARIABLE ETHERNET SNMP CHECK", short: "", params: "ON|OFF|?", desc: "SNMP check enable", example: "VARIABLE ETHERNET SNMP CHECK ON", response: "ASCII + CRLF on query", responseBytes: "variable", exampleResponse: "ETHERNET SNMP CHECK ON"},
{cmd: "VARIABLE ETHERNET SNMP PRINT", short: "", params: "ON|OFF|?", desc: "SNMP print enable", example: "VARIABLE ETHERNET SNMP PRINT ON", response: "ASCII + CRLF on query", responseBytes: "variable", exampleResponse: "ETHERNET SNMP PRINT ON"},
{cmd: "VARIABLE ETHERNET SNMP ADDR", short: "", params: "community addr", desc: "SNMP address and community string", example: "VARIABLE ETHERNET SNMP ADDR public 192.168.1.100", response: "ASCII + CRLF on query", responseBytes: "variable", exampleResponse: "ETHERNET SNMP TRAP ADDRESS = 192.168.1.100"},
{cmd: "VARIABLE ETHERNET SNMP ACTIVE", short: "", params: "ON|OFF|?", desc: "SNMP active flag", example: "VARIABLE ETHERNET SNMP ACTIVE ON", response: "ASCII + CRLF on query", responseBytes: "variable", exampleResponse: "ETHERNET SNMP ACTIVE ON"},
{cmd: "VARIABLE ETHERNET TELNET", short: "", params: "ON|OFF|?", desc: "Enable/disable telnet service", example: "VARIABLE ETHERNET TELNET ON", response: "ASCII + CRLF on query", responseBytes: "variable", exampleResponse: "ETHERNET TELNET = ON"},
{cmd: "VARIABLE ETHERNET TELNET TIMEOUT", short: "", params: "seconds 0-900", desc: "Telnet connection idle timeout", example: "VARIABLE ETHERNET TELNET TIMEOUT 180", response: "ASCII + CRLF on query", responseBytes: "variable", exampleResponse: "ETHERNET TELNET TIMOUT = 180"},
{cmd: "VARIABLE ETHERNET IP", short: "V IPADDR", params: "a.b.c.d|?", desc: "Sets/queries static IP address", example: "VARIABLE ETHERNET IP 192.168.1.100", response: "ASCII + CRLF on query", responseBytes: "variable", exampleResponse: "ETHERNET IP ADDRESS = 192.168.1.50"},
{cmd: "VARIABLE ETHERNET NETMASK", short: "", params: "a.b.c.d|?", desc: "Sets/queries subnet mask", example: "VARIABLE ETHERNET NETMASK 255.255.255.0", response: "ASCII + CRLF on query", responseBytes: "variable", exampleResponse: "ETHERNET NETMASK = 255.255.255.0"},
{cmd: "VARIABLE ETHERNET GATEWAY", short: "", params: "a.b.c.d|?", desc: "Sets/queries default gateway", example: "VARIABLE ETHERNET GATEWAY 192.168.1.1", response: "ASCII + CRLF on query", responseBytes: "variable", exampleResponse: "ETHERNET GATEWAY = 192.168.1.1"},
{cmd: "VARIABLE ETHERNET RESET", short: "", params: "", desc: "Resets Ethernet module to defaults", example: "VARIABLE ETHERNET RESET", response: "none", responseBytes: 0},
{cmd: "VARIABLE ETHERNET FIRMWARE", short: "", params: "", desc: "Ethernet firmware operations/version query", example: "VARIABLE ETHERNET FIRMWARE", response: "none", responseBytes: 0},
{cmd: "VARIABLE ETHERNET SERVER", short: "", params: "address|?", desc: "Remote server address", example: "VARIABLE ETHERNET SERVER 192.168.1.200", response: "ASCII + CRLF on query", responseBytes: "variable", exampleResponse: "ETHERNET SERVER ADDRESS = 192.168.1.200"},
{cmd: "VARIABLE ETHERNET GARP", short: "", params: "time 0-10080|?", desc: "GARP interval (0-10080 minutes)", example: "VARIABLE ETHERNET GARP 60", response: "ASCII + CRLF on query", responseBytes: "variable", exampleResponse: "ETHERNET GARP TIME = 60"},
{cmd: "VARIABLE ETHERNET TXTBFR", short: "", params: "txt 4096-500000 [ovf 256-65535]|?", desc: "Ethernet text buffer sizes", example: "VARIABLE ETHERNET TXTBFR 8192 8192", response: "ASCII + CRLF on query", responseBytes: "variable", exampleResponse: "ETHERNET TXTBFR = 8192, 8192"},
{cmd: "!SET HOST_NAME", short: "!SET HOSTNAME", params: "hostname", desc: "Sets network host name for printer", example: "!SET HOST_NAME \"PRINTER001\"", response: "none", responseBytes: 0},
{cmd: "!SHOW HOST_NAME", short: "", params: "", desc: "Displays the printer's network hostname", example: "!SHOW HOST_NAME", response: "ASCII + optional CRLF", responseBytes: "variable", exampleResponse: "PRINTER001"},
{cmd: "!SHOW MAC", short: "", params: "", desc: "Displays the Ethernet MAC address", example: "!SHOW MAC", response: "17 ASCII bytes XX:XX:XX:XX:XX:XX", responseBytes: 17, exampleResponse: "00:11:22:33:44:55"},
{cmd: "!LOAD MAC", short: "", params: "addr", desc: "Sets the network interface MAC address", example: "!LOAD MAC 00:11:22:33:44:55", response: "none", responseBytes: 0}
],
bluetooth: [
{cmd: "VARIABLE BLUETOOTH CONFIGURE", short: "", params: "", desc: "Configure Bluetooth stack", example: "VARIABLE BLUETOOTH CONFIGURE", response: "none", responseBytes: 0},
{cmd: "VARIABLE BLUETOOTH LAST_RESULT", short: "", params: "", desc: "Return last BT operation result", example: "VARIABLE BLUETOOTH LAST_RESULT", response: "6 ASCII bytes [0xNN] + CRLF", responseBytes: 6, exampleResponse: "[0x00]", errorCodes: {0x00: "BLU_SUCCESS", 0x01: "BLU_NOT_ATTACHED", 0x02: "BLU_NO_RESPONSE", 0x03: "BLU_INCORRECT_RESPONSE", 0x04: "BLU_READ_ERROR", 0x05: "BLU_DISABLE_CONNECTIONS", 0x06: "BLU_HOST_EVENTS", 0x07: "BLU_WRITE_ERROR", 0x08: "BLU_ALLOCATION_ERROR", 0x09: "BLU_RECOVER_ERROR", 0x0A: "BLU_RESET_ERROR", 0x0B: "BLU_DEFAULT_ERROR", 0x0C: "BLU_OTHER_ERROR"}},
{cmd: "VARIABLE BLUETOOTH RESET", short: "", params: "", desc: "Reset Bluetooth module", example: "VARIABLE BLUETOOTH RESET", response: "none", responseBytes: 0},
{cmd: "VARIABLE BLUETOOTH DIAGNOSTIC", short: "", params: "", desc: "Bluetooth diagnostic output", example: "VARIABLE BLUETOOTH DIAGNOSTIC", response: "ASCII diagnostic data", responseBytes: "variable", exampleResponse: "BT Module: OK"},
{cmd: "VARIABLE BLUETOOTH DEVICENAME", short: "", params: "name", desc: "Sets Bluetooth discoverable name", example: "VARIABLE BLUETOOTH DEVICENAME MyPrinter", response: "none", responseBytes: 0},
{cmd: "VARIABLE BLUETOOTH DEVICEPIN", short: "", params: "pin", desc: "Sets Bluetooth pairing PIN", example: "VARIABLE BLUETOOTH DEVICEPIN 1234", response: "none", responseBytes: 0},
{cmd: "VARIABLE BLUETOOTH DISCOVERABLE", short: "", params: "ON|OFF|?", desc: "Controls discoverability", example: "VARIABLE BLUETOOTH DISCOVERABLE ON", response: "ASCII + CRLF on query", responseBytes: "variable", exampleResponse: "BLUETOOTH DISCOVERABLE = ON"},
{cmd: "VARIABLE BLUETOOTH SECURITY", short: "", params: "n", desc: "Security level (1-4)", example: "VARIABLE BLUETOOTH SECURITY 3", response: "none", responseBytes: 0},
{cmd: "VARIABLE BLUETOOTH ENCRYPTION", short: "", params: "ON|OFF|?", desc: "Enable/disable connection encryption", example: "VARIABLE BLUETOOTH ENCRYPTION ON", response: "ASCII + CRLF on query", responseBytes: "variable", exampleResponse: "BLUETOOTH ENCRYPTION = ON"},
{cmd: "VARIABLE BLUETOOTH FORGET", short: "", params: "", desc: "Forget paired devices", example: "VARIABLE BLUETOOTH FORGET", response: "none", responseBytes: 0},
{cmd: "VARIABLE BLUETOOTH DEFAULT", short: "", params: "", desc: "Reset BT config to default", example: "VARIABLE BLUETOOTH DEFAULT", response: "none", responseBytes: 0},
{cmd: "VARIABLE BLUETOOTH CLASS", short: "", params: "n", desc: "Device class (1-2)", example: "VARIABLE BLUETOOTH CLASS 2", response: "none", responseBytes: 0},
{cmd: "VARIABLE BLUETOOTH BDADDR", short: "", params: "?|ON|OFF", desc: "Query or enable BDADDR print", example: "VARIABLE BLUETOOTH BDADDR ?", response: "ASCII + CRLF on query", responseBytes: "12-17", exampleResponse: "BLUETOOTH BDADDR = 00A1B2C3D4E5"}
],
object: [
{cmd: "!S", short: "STORE", params: "d loc type name", desc: "Starts recording format (d=delimiter, loc=R/F, type=F)", example: "!S | F F LABEL1", response: "none", responseBytes: 0},
{cmd: "!R", short: "RECALL", params: "id", desc: "Recalls stored object into active buffer (id: 1-8 chars)", example: "!R format1", response: "none", responseBytes: 0},
{cmd: "!D", short: "DELETE", params: "id", desc: "Deletes single object by ID (1-8 chars)", example: "!D LABEL1", response: "none", responseBytes: 0},
{cmd: "!I", short: "INITIALIZE", params: "n", desc: "Delete objects in storage (n: 0-3)", example: "!I 3", response: "none", responseBytes: 0},
{cmd: "!F", short: "", params: "n", desc: "Delete ALL objects in storage (n: 0-3)", example: "!F 3", response: "none", responseBytes: 0},
{cmd: "!L", short: "LIST", params: "", desc: "Prints directory of stored objects", example: "!L", response: "Printed output", responseBytes: 0},
{cmd: "!LS", short: "OBJECT_LIST", params: "[LONG]", desc: "Lists stored objects; LONG adds extended details", example: "!LS LONG", response: "Variable ASCII + optional CRLF", responseBytes: "variable", exampleResponse: "LABEL1 F 256\nLABEL2 F 512"},
{cmd: "!R V", short: "RECALL VAR", params: "ID [HIDE]", desc: "Recalls stored variable value", example: "!R V COUNTER", response: "none", responseBytes: 0},
{cmd: "!R G", short: "RECALL GRAPHIC", params: "ID x y", desc: "Recalls stored graphic for printing", example: "!R G LOGO 10 10", response: "none", responseBytes: 0},
{cmd: "!OBJECT INFO", short: "!OI", params: "id type ver", desc: "Display stored object info (id:1-8, type:enum, ver:CRC)", example: "!OBJECT INFO uffonta 2 0x7DD7", response: "Variable ASCII + optional CRLF", responseBytes: "variable", exampleResponse: "Name: uffonta Type: 2 Size: 1024 CRC: 0x7DD7"},
{cmd: "!OBJECT MARK", short: "!OM", params: "id", desc: "Mark object for deletion (requires PACK)", example: "!OBJECT MARK uffonta", response: "none", responseBytes: 0},
{cmd: "!OBJECT MARK_TYPE", short: "!OMT", params: "type", desc: "Mark all objects of specified type for deletion", example: "!OBJECT MARK_TYPE 38", response: "none", responseBytes: 0},
{cmd: "!OBJECT PACK", short: "!OP", params: "", desc: "Pack storage, deleting marked objects", example: "!OBJECT PACK", response: "none", responseBytes: 0},
{cmd: "!OBJECT UPLOAD", short: "!OU", params: "loc id", desc: "Upload stored object to host", example: "!OBJECT UPLOAD 0 uffontb", response: "Binary object data", responseBytes: "variable"},
{cmd: "!OBJECT MEMORY_REMAINING", short: "", params: "", desc: "Reports available memory for object storage", example: "!OBJECT MEMORY_REMAINING", response: "Variable ASCII + optional CRLF", responseBytes: "variable", exampleResponse: "32768 bytes free"},
{cmd: "STORE FORMAT", short: "", params: "name", desc: "Store current format", example: "STORE FORMAT format1", response: "none", responseBytes: 0},
{cmd: "STORE FONT", short: "", params: "name", desc: "Store a font resource", example: "STORE FONT fontA", response: "none", responseBytes: 0},
{cmd: "RECALL FORMAT", short: "", params: "name", desc: "Recall stored label format", example: "RECALL FORMAT format1", response: "none", responseBytes: 0},
{cmd: "RECALL MENU", short: "", params: "name", desc: "Recall stored menu", example: "RECALL MENU setup", response: "none", responseBytes: 0},
{cmd: "RECALL VARIABLE", short: "", params: "name", desc: "Recall variable definitions", example: "RECALL VARIABLE price", response: "none", responseBytes: 0},
{cmd: "GRAPHIC STORE", short: "!S G", params: "name width height data", desc: "Stores graphic data in printer memory", example: "GRAPHIC STORE LOGO1 200 100 [data]", response: "none", responseBytes: 0},
{cmd: "GRAPHIC RECALL", short: "", params: "name x y", desc: "Recalls stored graphic for printing", example: "GRAPHIC RECALL LOGO1 10 10", response: "none", responseBytes: 0}
],
menu: [
{cmd: "MENU START", short: "", params: "[menuname]", desc: "Initiates menu system for user interaction", example: "MENU START MainMenu"},
{cmd: "MENU END", short: "MU END", params: "", desc: "Terminates menu system definition", example: "MENU END"},
{cmd: "MENU ITEM", short: "MU ITEM", params: "label [action]", desc: "Defines a menu item", example: "MENU ITEM \"Print Label\" PRINT"},
{cmd: "MENU ACTION", short: "MU ACTION", params: "itemname action", desc: "Defines action for menu item", example: "MENU ACTION Option1 PRINT"},
{cmd: "MENU CONTROL", short: "MU CONTROL", params: "can nxt prv sel", desc: "Key mappings for navigation", example: "MENU CONTROL ESC PGDN PGUP ENTER"},
{cmd: "MENU MESSAGE", short: "", params: "\"text\"", desc: "Display message in menu", example: "MENU MESSAGE \"Select option\""},
{cmd: "MENU EXIT", short: "MU EXIT", params: "", desc: "Menu exit point or action", example: "MENU EXIT"},
{cmd: "MENU DELAY", short: "", params: "ms", desc: "Menu delay in milliseconds", example: "MENU DELAY 100"},
{cmd: "MENU FLUSH", short: "", params: "", desc: "Flush menu system", example: "MENU FLUSH"},
{cmd: "RECALL MENU", short: "", params: "name", desc: "Activate stored menu", example: "RECALL MENU MainMenu"}
],
time: [
{cmd: "TIME SET", short: "TE SET", params: "y m d h min s", desc: "Set real-time clock (year:1970-2069, month:1-12, day:1-31, hour:0-23, min:0-59, sec:0-59)", example: "TIME SET 2025 11 24 14 30 00", response: "none", responseBytes: 0},
{cmd: "TIME ADD", short: "TE ADD", params: "y m d h min s", desc: "Add time offsets to current time", example: "TIME ADD 0 1 0 0 0 0", response: "none", responseBytes: 0},
{cmd: "TIME GET", short: "TE GET", params: "", desc: "Retrieves current printer time", example: "TIME GET", response: "Variable ASCII + optional CRLF", responseBytes: "variable", exampleResponse: "2025-01-15 14:30:00"},
{cmd: "TIME ?", short: "TE ?", params: "", desc: "Query current time and date", example: "TIME ?", response: "Variable ASCII + optional CRLF", responseBytes: "variable", exampleResponse: "2025-01-15 14:30:00"},
{cmd: "!SET TIME", short: "", params: "y m d h min s", desc: "Factory-set time via header command", example: "!SET TIME 2025 11 24 14 30 00", response: "none", responseBytes: 0},
{cmd: "VARIABLE DATE", short: "", params: "YYYY-MM-DD|?", desc: "Sets/queries printer's internal date", example: "VARIABLE DATE 2024-12-25", response: "ASCII + CRLF on query", responseBytes: "variable", exampleResponse: "DATE = 2024-12-25"},
{cmd: "VARIABLE TIME", short: "", params: "HH:MM:SS|?", desc: "Sets/queries printer's internal clock time", example: "VARIABLE TIME 14:30:00", response: "ASCII + CRLF on query", responseBytes: "variable", exampleResponse: "TIME = 14:30:00"}
],
query: [
{cmd: "!STATUS", short: "", params: "", desc: "Returns printer status (Ready, Paper Out, Head Open)", example: "!STATUS", response: "Variable ASCII + optional CRLF", responseBytes: "variable", exampleResponse: "Ready"},
{cmd: "!IDENTIFY", short: "", params: "", desc: "Returns printer model and firmware version", example: "!IDENTIFY", response: "Variable ASCII + optional CRLF", responseBytes: "variable", exampleResponse: "BT200 V1.2.3"},
{cmd: "!QS", short: "", params: "", desc: "Query status - returns 6-byte status code (R00000=Ready, H00000=Head open, P00000=Paper out, B00000=Busy)", example: "!QS", response: "6 ASCII bytes + optional CRLF", responseBytes: 6, exampleResponse: "R00000", statusCodes: {R: "Ready", H: "Head open", P: "Paper out", B: "Busy", E: "Error", W: "Waiting"}},
{cmd: "!QT", short: "", params: "", desc: "Query time - returns current date/time string", example: "!QT", response: "80 chars + optional CRLF", responseBytes: "80", exampleResponse: "2025-01-15 14:30:00"},
{cmd: "!QR", short: "", params: "", desc: "Query revision - returns firmware version with build date/time", example: "!QR", response: "80 chars + optional CRLF", responseBytes: "80", exampleResponse: "V1.2.3 Build Jan 15 2025 14:30:00"},
{cmd: "!QD", short: "", params: "", desc: "Query build date - returns firmware build date", example: "!QD", response: "Variable length + optional CRLF", responseBytes: "variable", exampleResponse: "Jan 15 2025"},
{cmd: "!QB", short: "", params: "", desc: "Query MCU/BIOS - returns bootloader/MCU information", example: "!QB", response: "Variable ASCII + optional CRLF", responseBytes: "variable", exampleResponse: "MCU: STM32F4 BIOS: V1.0"},
{cmd: "!QH", short: "", params: "", desc: "Query history - returns history log summary", example: "!QH", response: "Variable ASCII + optional CRLF", responseBytes: "variable", exampleResponse: "History entries: 42"},
{cmd: "!QI", short: "", params: "[gain] [byte1] [byte2]", desc: "Query index sensor - gain:0-7, bytes:0-255 for filtered queries", example: "!QI 3 10 25", response: "Settings string + optional CRLF", responseBytes: "variable", exampleResponse: "GAP: 128 MARK: 64 GAIN: 3"},
{cmd: "!QIB", short: "", params: "[mode]", desc: "Query index buffer - mode: D=display, I=initialize, R=reset, T=temp, O=out-of-paper", example: "!QIB D", response: "Comma-separated sensor values + optional CRLF", responseBytes: "variable", exampleResponse: "128,130,125,132,127,129"},
{cmd: "!QIC", short: "", params: "", desc: "Query inch count - returns cumulative inches printed", example: "!QIC", response: "Integer ASCII + optional CRLF", responseBytes: "variable", exampleResponse: "123456"},
{cmd: "!QSN", short: "", params: "", desc: "Query serial number - returns device serial (6-20 chars)", example: "!QSN", response: "Serial number + optional CRLF", responseBytes: "6-20", exampleResponse: "ABC123456789"},
{cmd: "!QMN", short: "", params: "", desc: "Query model number - returns device model (4-29 chars)", example: "!QMN", response: "Model number + optional CRLF", responseBytes: "4-29", exampleResponse: "BT200"},
{cmd: "!QM", short: "", params: "", desc: "Query memory - returns memory status summary", example: "!QM", response: "Variable ASCII + optional CRLF", responseBytes: "variable", exampleResponse: "Free: 65536 Used: 32768"},
{cmd: "!QSA", short: "", params: "", desc: "Query sector architecture - returns flash sector layout", example: "!QSA", response: "Variable ASCII + optional CRLF", responseBytes: "variable", exampleResponse: "Sector 0: 0x00000-0x0FFFF"},
{cmd: "!QSTACK", short: "", params: "", desc: "Query stack - returns current stack usage and status", example: "!QSTACK", response: "Variable ASCII + optional CRLF", responseBytes: "variable", exampleResponse: "Stack: 2048/8192"},
{cmd: "!GET TOF", short: "", params: "", desc: "Retrieves current Top of Form setting", example: "!GET TOF", response: "ASCII value", responseBytes: "variable", exampleResponse: "TOF = 120"},
{cmd: "!GET SHIFT", short: "", params: "", desc: "Retrieves current print shift/offset settings", example: "!GET SHIFT", response: "ASCII value", responseBytes: "variable", exampleResponse: "SHIFT = 10"},
{cmd: "!GET STATUS", short: "", params: "", desc: "Returns printer status byte", example: "!GET STATUS", response: "1-2 bytes", responseBytes: "1-2", exampleResponse: "00"},
{cmd: "!GET INDEX", short: "", params: "", desc: "Query index sensor configuration", example: "!GET INDEX", response: "ASCII config", responseBytes: "variable", exampleResponse: "INDEX: GAP DT 50 50 100 200"},
{cmd: "!GET PEELER", short: "", params: "", desc: "Get peeler configuration parameters", example: "!GET PEELER", response: "Variable ASCII + optional CRLF", responseBytes: "variable", exampleResponse: "PEELER = ENABLED"},
{cmd: "SET INDEX", short: "", params: "type mode a b c d", desc: "Factory index sensor configuration", example: "SET INDEX MARK DT 3 10 25 40", response: "none", responseBytes: 0},
{cmd: "SET TOF", short: "", params: "n", desc: "Factory TOF setting", example: "SET TOF 120", response: "none", responseBytes: 0},
{cmd: "GET TOF", short: "", params: "", desc: "Query factory TOF setting", example: "GET TOF", response: "ASCII value", responseBytes: "variable", exampleResponse: "TOF = 120"},
{cmd: "GET INDEX", short: "", params: "", desc: "Query index sensor configuration", example: "GET INDEX", response: "ASCII config", responseBytes: "variable", exampleResponse: "INDEX: GAP DT 50 50 100 200"},
{cmd: "WIDTH ?", short: "", params: "", desc: "Query current print width in dots", example: "WIDTH ?", response: "ASCII + optional CRLF", responseBytes: "variable", exampleResponse: "WIDTH = 400 (812 dots)"},
{cmd: "TIME ?", short: "TE ?", params: "", desc: "Query current time and date", example: "TIME ?", response: "Variable ASCII + optional CRLF", responseBytes: "variable", exampleResponse: "2025-01-15 14:30:00"}
]
};
function Backend_EnumerateSerialPorts() {
log(2, 'Backend_EnumerateSerialPorts() called - stub');
return Promise.resolve([
{name: 'COM1', description: 'Communications Port', manufacturer: 'Microsoft'},
{name: 'COM3', description: 'USB Serial Port', manufacturer: 'FTDI'},
{name: 'COM5', description: 'Prolific USB-to-Serial', manufacturer: 'Prolific'}
]);
}
function Backend_OpenSerialPort(portName, baudRate, parity, dataBits, stopBits) {
log(2, `Backend_OpenSerialPort(${portName}, ${baudRate}, ${parity}, ${dataBits}, ${stopBits}) called - stub`);
return Promise.resolve({success: true, handle: 1});
}
function Backend_CloseSerialPort(handle) {
log(2, `Backend_CloseSerialPort(${handle}) called - stub`);
return Promise.resolve({success: true});
}
function Backend_DiscoverNetworkPrinters(broadcastAddr, port, timeoutMs) {
log(2, `Backend_DiscoverNetworkPrinters(${broadcastAddr}, ${port}, ${timeoutMs}) called - stub`);
return Promise.resolve([]);
}
function Backend_OpenTcpConnection(ipAddress, port) {
log(2, `Backend_OpenTcpConnection(${ipAddress}, ${port}) called - stub`);
return Promise.resolve({success: true, handle: 2});
}
function Backend_CloseTcpConnection(handle) {
log(2, `Backend_CloseTcpConnection(${handle}) called - stub`);
return Promise.resolve({success: true});
}
function Backend_DiscoverBluetoothPrinters(timeoutMs) {
log(2, `Backend_DiscoverBluetoothPrinters(${timeoutMs}) called - stub`);
return Promise.resolve([]);
}
function Backend_OpenBluetoothConnection(address, pin) {
log(2, `Backend_OpenBluetoothConnection(${address}, ${pin ? '****' : 'no-pin'}) called - stub`);
return Promise.resolve({success: true, handle: 3});
}
function Backend_CloseBluetoothConnection(handle) {
log(2, `Backend_CloseBluetoothConnection(${handle}) called - stub`);
return Promise.resolve({success: true});
}
function Backend_EnumerateUsbPrinters() {
log(2, 'Backend_EnumerateUsbPrinters() called - stub');
return Promise.resolve([]);
}
function Backend_OpenUsbConnection(devicePath) {
log(2, `Backend_OpenUsbConnection(${devicePath}) called - stub`);
return Promise.resolve({success: true, handle: 4});
}
function Backend_CloseUsbConnection(handle) {
log(2, `Backend_CloseUsbConnection(${handle}) called - stub`);
return Promise.resolve({success: true});
}
function Backend_SendData(handle, data) {
const len = typeof data === 'string' ? data.length : data.byteLength;
log(2, `Backend_SendData(${handle}, ${len} bytes) called - stub`);
return Promise.resolve({success: true, bytesSent: len});
}
function Backend_ReceiveData(handle, maxBytes, timeoutMs) {
log(2, `Backend_ReceiveData(${handle}, ${maxBytes}, ${timeoutMs}) called - stub`);
return Promise.resolve({success: true, data: new Uint8Array(0)});
}
function Backend_SendCommand(handle, command, timeoutMs) {
log(2, `Backend_SendCommand(${handle}, "${command.substring(0, 50)}...", ${timeoutMs}) called - stub`);
return Promise.resolve({success: true, response: ''});
}
function Backend_GetPrinterStatus(handle) {
log(2, `Backend_GetPrinterStatus(${handle}) called - stub`);
return Promise.resolve({success: true, status: 0, statusText: 'Ready'});
}
function Backend_GetPrinterIdentity(handle) {
log(2, `Backend_GetPrinterIdentity(${handle}) called - stub`);
return Promise.resolve({success: true, model: 'Unknown', firmware: '0.0.0', serial: '000000'});
}
function Backend_GetPrinterVariables(handle) {
log(2, `Backend_GetPrinterVariables(${handle}) called - stub`);
return Promise.resolve({success: true, variables: {}});
}
function Backend_GetPrintHeadTemperature(handle) {
log(2, `Backend_GetPrintHeadTemperature(${handle}) called - stub`);
return Promise.resolve({success: true, tempCelsius: 25});
}
function Backend_GetMediaSensors(handle) {
log(2, `Backend_GetMediaSensors(${handle}) called - stub`);
return Promise.resolve({success: true, gapSensor: 128, markSensor: 64});
}
function Backend_GetPrintStatistics(handle) {
log(2, `Backend_GetPrintStatistics(${handle}) called - stub`);
return Promise.resolve({success: true, inchCount: 0, labelCount: 0, headLifePct: 100});
}
function Backend_SetVariable(handle, varName, value, saveToFlash) {
log(2, `Backend_SetVariable(${handle}, ${varName}, ${value}, ${saveToFlash}) called - stub`);
return Promise.resolve({success: true});
}
function Backend_CalibrateMedia(handle, mode) {
log(2, `Backend_CalibrateMedia(${handle}, ${mode}) called - stub`);
return Promise.resolve({success: true, gapThreshold: 128, markThreshold: 64});
}
function Backend_FactoryReset(handle, fullReset) {
log(2, `Backend_FactoryReset(${handle}, ${fullReset}) called - stub`);
return Promise.resolve({success: true});
}
function Backend_ResetPrinter(handle) {
log(2, `Backend_ResetPrinter(${handle}) called - stub`);
return Promise.resolve({success: true});
}
function Backend_GetFirmwareVersions(handle) {
log(2, `Backend_GetFirmwareVersions(${handle}) called - stub`);
return Promise.resolve({success: true, mainVersion: '1.0.0', bootVersion: '1.0.0'});
}
function Backend_UpdateFirmware(handle, firmwareData, progressCallback) {
log(2, `Backend_UpdateFirmware(${handle}, ${firmwareData.byteLength} bytes) called - stub`);
return Promise.resolve({success: false, error: 'Not implemented'});
}
function Backend_VerifyFirmware(firmwareData) {
log(2, `Backend_VerifyFirmware(${firmwareData.byteLength} bytes) called - stub`);
return Promise.resolve({success: true, version: '0.0.0', checksum: '00000000', compatible: false});
}
function Backend_PrintTestLabel(handle, testType) {
log(2, `Backend_PrintTestLabel(${handle}, ${testType}) called - stub`);
return Promise.resolve({success: true});
}
function Backend_PrintLabel(handle, cplData) {
log(2, `Backend_PrintLabel(${handle}, ${cplData.length} chars) called - stub`);
return Promise.resolve({success: true});
}
function Backend_FeedLabel(handle) {
log(2, `Backend_FeedLabel(${handle}) called - stub`);
return Promise.resolve({success: true});
}
function Backend_CancelPrint(handle) {
log(2, `Backend_CancelPrint(${handle}) called - stub`);
return Promise.resolve({success: true});
}
function Backend_ListObjects(handle, location) {
log(2, `Backend_ListObjects(${handle}, ${location}) called - stub`);
return Promise.resolve({success: true, objects: []});
}
function Backend_DownloadObject(handle, name, type, data, location) {
log(2, `Backend_DownloadObject(${handle}, ${name}, ${type}, ${data.byteLength} bytes, ${location}) called - stub`);
return Promise.resolve({success: true});
}
function Backend_DeleteObject(handle, name) {
log(2, `Backend_DeleteObject(${handle}, ${name}) called - stub`);
return Promise.resolve({success: true});
}
function Backend_GetMemoryInfo(handle) {
log(2, `Backend_GetMemoryInfo(${handle}) called - stub`);
return Promise.resolve({success: true, ramFree: 1048576, ramTotal: 2097152, flashFree: 4194304, flashTotal: 8388608});
}
function Backend_GetEventLog(handle) {
log(2, `Backend_GetEventLog(${handle}) called - stub`);
return Promise.resolve({success: true, events: []});
}
function Backend_ClearEventLog(handle) {
log(2, `Backend_ClearEventLog(${handle}) called - stub`);
return Promise.resolve({success: true});
}
function Backend_RunSelfTest(handle, testType) {
log(2, `Backend_RunSelfTest(${handle}, ${testType}) called - stub`);
return Promise.resolve({success: true, results: {}});
}
function Backend_GetAdcReadings(handle) {
log(2, `Backend_GetAdcReadings(${handle}) called - stub`);
return Promise.resolve({success: true, readings: {}});
}
function Backend_DumpMemory(handle, address, length) {
log(2, `Backend_DumpMemory(${handle}, 0x${address.toString(16)}, ${length}) called - stub`);
return Promise.resolve({success: true, data: new Uint8Array(length)});
}
function Backend_GetNetworkConfig(handle) {
log(2, `Backend_GetNetworkConfig(${handle}) called - stub`);
return Promise.resolve({success: true, dhcp: true, ip: '0.0.0.0', netmask: '255.255.255.0', gateway: '0.0.0.0', mac: '00:00:00:00:00:00', hostname: ''});
}
function Backend_SetNetworkConfig(handle, config) {
log(2, `Backend_SetNetworkConfig(${handle}, ${JSON.stringify(config)}) called - stub`);
return Promise.resolve({success: true});
}
function Backend_GetBluetoothConfig(handle) {
log(2, `Backend_GetBluetoothConfig(${handle}) called - stub`);
return Promise.resolve({success: true, name: '', pin: '0000', discoverable: false, paired: []});
}
function Backend_SetBluetoothConfig(handle, config) {
log(2, `Backend_SetBluetoothConfig(${handle}, ${JSON.stringify(config)}) called - stub`);
return Promise.resolve({success: true});
}
function Backend_ConvertImage(imageData, options) {
log(2, `Backend_ConvertImage(${imageData.byteLength} bytes, ${JSON.stringify(options)}) called - stub`);
return Promise.resolve({success: false, error: 'Not implemented'});
}
function Backend_GenerateBarcode(type, data, options) {
log(2, `Backend_GenerateBarcode(${type}, ${data}, ${JSON.stringify(options)}) called - stub`);
return Promise.resolve({success: false, error: 'Not implemented'});
}
function Backend_OpenFileDialog(filter, title) {
log(2, `Backend_OpenFileDialog(${filter}, ${title}) called - stub`);
return Promise.resolve({success: false, filePath: '', error: 'Not implemented'});
}
function Backend_ReadFile(filePath) {
log(2, `Backend_ReadFile(${filePath}) called - stub`);
return Promise.resolve({success: false, error: 'Not implemented'});
}
function Backend_SaveFile(filePath, data) {
log(2, `Backend_SaveFile(${filePath}, ${data.byteLength} bytes) called - stub`);
return Promise.resolve({success: false, error: 'Not implemented'});
}
function Backend_GetAppVersion() {
log(2, 'Backend_GetAppVersion() called - stub');
return Promise.resolve({version: '1.0.0-dev', buildDate: '2024-01-01', qtVersion: '6.x'});
}
function Backend_OpenExternalUrl(url) {
log(2, `Backend_OpenExternalUrl(${url}) called - stub`);
window.open(url, '_blank');
return Promise.resolve({success: true});
}
function Backend_ShowMessageBox(title, message, type) {
log(2, `Backend_ShowMessageBox(${title}, ${message}, ${type}) called - stub`);
alert(`${title}\n\n${message}`);
return Promise.resolve({button: 'ok'});
}
function Backend_LoadSerialNumber(handle, serialNumber) {
log(2, `Backend_LoadSerialNumber(${handle}, ${serialNumber}) called - stub`);
return Promise.resolve({success: true});
}
function Backend_LoadModelNumber(handle, modelNumber) {
log(2, `Backend_LoadModelNumber(${handle}, ${modelNumber}) called - stub`);
return Promise.resolve({success: true});
}
function Backend_LoadMacAddress(handle, macAddress) {
log(2, `Backend_LoadMacAddress(${handle}, ${macAddress}) called - stub`);
return Promise.resolve({success: true});
}
function Backend_LoadLicense(handle, licenseKey) {
log(2, `Backend_LoadLicense(${handle}, ${licenseKey}) called - stub`);
return Promise.resolve({success: true});
}
function Backend_RunMfgTest(handle, testSequence) {
log(2, `Backend_RunMfgTest(${handle}, ${testSequence}) called - stub`);
return Promise.resolve({success: true, passed: true, results: {}});
}
function $(id) {
return document.getElementById(id);
}
function escapeHtml(text) {
const div = document.createElement('div');
div.textContent = text;
return div.innerHTML;
}
function announce(message) {
const announcer = $('status-announcer');
if (announcer) {
announcer.textContent = message;
}
}
function log(level, message) {
const timestamp = new Date().toISOString().substring(11, 23);
State.logMessages.push({
level: level,
timestamp: timestamp,
message: message
});
updateDebugConsole();
}
function updateDebugConsole() {
const console = $('debug_console');
if (!console) return;
const searchTerm = $('log_search').value.toLowerCase();
const lines = [];
State.logMessages.forEach(entry => {
if (entry.level < State.logLevel) return;
if (searchTerm && !entry.message.toLowerCase().includes(searchTerm)) return;
let className = 'log-info';
let levelText = 'INFO';
if (entry.level === 1) { className = 'log-trace'; levelText = 'TRACE'; }
else if (entry.level === 2) { className = 'log-info'; levelText = 'INFO'; }
else if (entry.level === 3) { className = 'log-warning'; levelText = 'WARN'; }
else if (entry.level === 4) { className = 'log-error'; levelText = 'ERROR'; }
else if (entry.level === 5) { className = 'log-exception'; levelText = 'EXCPT'; }
lines.push(`<span class="${className}">[${entry.timestamp}] [${levelText}] ${escapeHtml(entry.message)}</span>`);
});
console.innerHTML = lines.join('\n');
console.scrollTop = console.scrollHeight;
}
function clearIntervals() {
State.activeIntervals.forEach(id => clearInterval(id));
State.activeIntervals = [];
}
function saveState() {
try {
const state = {
printers: State.printers,
printerCounter: State.printerCounter,
theme: document.body.dataset.theme,
layout: document.body.dataset.layout
};
localStorage.setItem('cognitivetpg_state', JSON.stringify(state));
log(1, 'State saved to localStorage');
} catch (e) {
log(4, 'Failed to save state: ' + e.message);
}
}
function loadState() {
try {
const stored = localStorage.getItem('cognitivetpg_state');
if (stored) {
const state = JSON.parse(stored);
State.printers = state.printers || [];
State.printerCounter = state.printerCounter || 0;
if (state.theme) {
document.body.dataset.theme = state.theme;
$('theme_selector').value = state.theme;
}
if (state.layout) {
document.body.dataset.layout = state.layout;
$('layout_selector').value = state.layout;
}
log(2, 'State loaded from localStorage');
return true;
}
} catch (e) {
log(4, 'Failed to load state: ' + e.message);
}
return false;
}
function createPrinter() {
State.printerCounter++;
return {
id: State.printerCounter,
name: `Printer ${State.printerCounter}`,
type: 'ser',
comPort: 'COM1',
ipAddress: '192.168.1.' + (10 + State.printerCounter),
port: 9100,
btDevice: 'Device 1',
btCom: 'COM5',
parPort: 'LPT1',
connected: false,
config: {
darkness: 0,
printSpeed: 'Normal',
noMedia: 12,
debugLevel: 0,
autoReprint: false,
auxPower: false,
mediaAdjust: 0,
pitch: 203,
language: 'auto',
thermalMode: 'dt',
baud: 115200,
stopBits: 1,
xonXoff: false
}
};
}
function addPrinter() {
const printer = createPrinter();
State.printers.push(printer);
updatePrinterList();
updatePrinterDropdowns();
selectPrinter(printer.id, false, false);
saveState();
announce(`Printer added: ${printer.name}`);
log(2, `Printer added: ${printer.name}`);
}
function removePrinter() {
if (State.selectedPrinterIds.length === 0) {
announce('No printer selected');
return;
}
const removedNames = State.printers.filter(p => State.selectedPrinterIds.includes(p.id)).map(p => p.name);
State.printers = State.printers.filter(p => !State.selectedPrinterIds.includes(p.id));
Object.keys(State.multiSelectStates).forEach(key => {
State.multiSelectStates[key] = State.multiSelectStates[key].filter(id =>
State.printers.some(p => p.id === id)
);
});
State.selectedPrinterIds = [];
State.lastSelectedIndex = -1;
updatePrinterList();
updatePrinterDropdowns();
updatePrinterStatus();
saveState();
announce(`Printers removed: ${removedNames.join(', ')}`);
log(2, `Printers removed: ${removedNames.join(', ')}`);
}
function selectPrinter(id, isCtrlClick, isShiftClick) {
const printerIndex = State.printers.findIndex(p => p.id === id);
if (printerIndex === -1) return;
if (isShiftClick && State.lastSelectedIndex !== -1) {
const start = Math.min(State.lastSelectedIndex, printerIndex);
const end = Math.max(State.lastSelectedIndex, printerIndex);
State.selectedPrinterIds = [];
for (let i = start; i <= end; i++) {
State.selectedPrinterIds.push(State.printers[i].id);
}
} else if (isCtrlClick) {
const idx = State.selectedPrinterIds.indexOf(id);
if (idx > -1) {
State.selectedPrinterIds.splice(idx, 1);
} else {
State.selectedPrinterIds.push(id);
}
State.lastSelectedIndex = printerIndex;
} else {
State.selectedPrinterIds = [id];
State.lastSelectedIndex = printerIndex;
}
updatePrinterList();
if (State.selectedPrinterIds.length === 1) {
loadPrinterConfig(State.selectedPrinterIds[0]);
}
}
function getPortDisplay(printer) {
switch(printer.type) {
case 'ser': return printer.comPort;
case 'net': return printer.ipAddress;
case 'bt': return printer.btCom;
case 'par': return printer.parPort;
case 'usb': return 'USB';
default: return 'N/A';
}
}
function updatePrinterList() {
const list = $('printer_list');
list.innerHTML = '';
State.printers.forEach(p => {
const div = document.createElement('div');
div.className = 'printer-item' + (State.selectedPrinterIds.includes(p.id) ? ' selected' : '');
div.setAttribute('role', 'option');
div.setAttribute('aria-selected', State.selectedPrinterIds.includes(p.id));
div.onclick = (e) => {
selectPrinter(p.id, e.ctrlKey || e.metaKey, e.shiftKey);
};
div.innerHTML = `
<div class="printer-item-left">
<div class="printer-status${p.connected ? ' connected' : ''}" role="img" aria-label="${p.connected ? 'Connected' : 'Disconnected'}"></div>
<span>${escapeHtml(p.name)}</span>
</div>
<span class="printer-item-port">${escapeHtml(getPortDisplay(p))}</span>
`;
list.appendChild(div);
});
// Update autotest printer list if function exists
if (typeof updateAutoTestPrinterList === 'function') {
updateAutoTestPrinterList();
}
}
function loadPrinterConfig(printerId) {
const printer = State.printers.find(p => p.id === printerId);
if (!printer) return;
document.querySelector(`input[name="ct"][value="${printer.type}"]`).checked = true;
uiConn();
if (printer.type === 'net') {
$('net_ip').value = printer.ipAddress;
$('net_port').value = printer.port;
} else if (printer.type === 'ser') {
$('com_list').value = printer.comPort;
$('baud').value = printer.config.baud;
$('stop_bits').value = printer.config.stopBits;
$('xon_xoff').checked = printer.config.xonXoff;
} else if (printer.type === 'bt') {
$('bt_com').value = printer.btCom;
} else if (printer.type === 'par') {
$('par_port').value = printer.parPort;
}
if ($('darkness_val')) $('darkness_val').value = printer.config.darkness;
if ($('darkness_slider')) $('darkness_slider').value = printer.config.darkness;
if ($('print_speed')) $('print_speed').value = printer.config.printSpeed;
if ($('no_media')) $('no_media').value = printer.config.noMedia;
if ($('debug_level')) $('debug_level').selectedIndex = printer.config.debugLevel;
if ($('auto_reprint')) $('auto_reprint').checked = printer.config.autoReprint;
if ($('aux_power')) $('aux_power').checked = printer.config.auxPower;
if ($('media_adjust')) $('media_adjust').value = printer.config.mediaAdjust;
if ($('pitch')) $('pitch').value = printer.config.pitch;
document.querySelectorAll('input[name="lang"]').forEach(radio => {
if (radio.value === printer.config.language) radio.checked = true;
});
document.querySelectorAll('input[name="tm"]').forEach(radio => {
if (radio.value === printer.config.thermalMode) radio.checked = true;
});
log(1, `Loaded configuration for: ${printer.name}`);
}
function updateSelectedPrinterConfig() {
if (State.selectedPrinterIds.length !== 1) return;
const printer = State.printers.find(p => p.id === State.selectedPrinterIds[0]);
if (!printer) return;
const connType = document.querySelector('input[name="ct"]:checked').value;
printer.type = connType;
if (connType === 'net') {
printer.ipAddress = $('net_ip').value;
printer.port = $('net_port').value;
} else if (connType === 'ser') {
printer.comPort = $('com_list').value;
printer.config.baud = parseInt($('baud').value);
printer.config.stopBits = parseInt($('stop_bits').value);
printer.config.xonXoff = $('xon_xoff').checked;
} else if (connType === 'bt') {
printer.btCom = $('bt_com').value;
} else if (connType === 'par') {
printer.parPort = $('par_port').value;
}
updatePrinterList();
saveState();
log(1, `Updated configuration for: ${printer.name}`);
}
function uiConn() {
const t = document.querySelector('input[name="ct"]:checked').value;
$('p_ser').style.display = (t === 'ser') ? 'block' : 'none';
$('p_net').style.display = (t === 'net') ? 'block' : 'none';
$('p_bt').style.display = (t === 'bt') ? 'block' : 'none';
$('p_par').style.display = (t === 'par') ? 'block' : 'none';
$('p_usb').style.display = (t === 'usb') ? 'block' : 'none';
updateSelectedPrinterConfig();
}
function connectSelectedPrinters() {
State.selectedPrinterIds.forEach(id => {
const printer = State.printers.find(p => p.id === id);
if (printer) {
printer.connected = true;
announce(`Connected to ${printer.name}`);
log(2, `Connected to printer: ${printer.name}`);
}
});
updatePrinterList();
updatePrinterDropdowns();
updatePrinterStatus();
saveState();
}
function disconnectSelectedPrinters() {
State.selectedPrinterIds.forEach(id => {
const printer = State.printers.find(p => p.id === id);
if (printer) {
printer.connected = false;
announce(`Disconnected from ${printer.name}`);
log(2, `Disconnected from printer: ${printer.name}`);
}
});
updatePrinterList();
updatePrinterDropdowns();
updatePrinterStatus();
saveState();
}
function connectAllPrinters() {
State.printers.forEach(p => {
p.connected = true;
log(2, `Connected to printer: ${p.name}`);
});
updatePrinterList();
updatePrinterDropdowns();
updatePrinterStatus();
saveState();
announce('All printers connected');
}
function disconnectAllPrinters() {
State.printers.forEach(p => {
p.connected = false;
log(2, `Disconnected from printer: ${p.name}`);
});
updatePrinterList();
updatePrinterDropdowns();
updatePrinterStatus();
saveState();
announce('All printers disconnected');
}
function updatePrinterStatus() {
const connCount = State.printers.filter(p => p.connected).length;
const box = $('status_box');
const textNode = box.childNodes[0];
textNode.textContent = `${connCount} Connected`;
box.setAttribute('aria-label', `${connCount} printers connected`);
if (connCount > 0) {
box.classList.add('connected');
} else {
box.classList.remove('connected');
}
}
function scanForDevices() {
announce('Scanning for devices...');
log(2, 'Scanning for devices...');
const newDevices = [
{type: 'ser', comPort: 'COM3', name: 'CXi4 Series'},
{type: 'net', ipAddress: '192.168.1.100', name: 'Ci Series'},
{type: 'usb', name: 'USB Printer'}
];
newDevices.forEach(dev => {
const printer = createPrinter();
printer.name = dev.name + ` ${printer.id}`;
printer.type = dev.type;
if (dev.comPort) printer.comPort = dev.comPort;
if (dev.ipAddress) printer.ipAddress = dev.ipAddress;
State.printers.push(printer);
log(2, `Device found: ${printer.name} at ${getPortDisplay(printer)}`);
});
updatePrinterList();
updatePrinterDropdowns();
saveState();
announce(`Found ${newDevices.length} device(s)`);
}
function initMultiSelects() {
const multiSelectIds = ['print_target', 'pos_target', 'fonts_target', 'prof_target', 'firm_target', 'img_src', 'img_target', 'script_target'];
multiSelectIds.forEach(id => {
State.multiSelectStates[id] = [];
});
}
function toggleMultiSelect(id) {
const dropdown = $(id);
let optionsDiv = dropdown.querySelector('.multi-select-options');
if (!optionsDiv) {
optionsDiv = document.createElement('div');
optionsDiv.className = 'multi-select-options';
State.printers.forEach(p => {
const opt = document.createElement('div');
opt.className = 'multi-select-option';
opt.textContent = p.name;
opt.dataset.printerId = p.id;
opt.onclick = (e) => {
e.stopPropagation();
toggleMultiSelectOption(id, p.id);
};
optionsDiv.appendChild(opt);
});
dropdown.appendChild(optionsDiv);
}
optionsDiv.classList.toggle('visible');
updateMultiSelectDisplay(id);
}
function toggleMultiSelectOption(dropdownId, printerId) {
const state = State.multiSelectStates[dropdownId];
const idx = state.indexOf(printerId);
if (idx > -1) {
state.splice(idx, 1);
} else {
state.push(printerId);
}
updateMultiSelectDisplay(dropdownId);
}
function updateMultiSelectDisplay(dropdownId) {
const dropdown = $(dropdownId);
const state = State.multiSelectStates[dropdownId];
const optionsDiv = dropdown.querySelector('.multi-select-options');
if (optionsDiv) {
optionsDiv.querySelectorAll('.multi-select-option').forEach(opt => {
const pid = parseInt(opt.dataset.printerId);
if (state.includes(pid)) {
opt.classList.add('selected');
} else {
opt.classList.remove('selected');
}
});
}
dropdown.innerHTML = '';
if (state.length === 0) {
const placeholder = document.createElement('span');
placeholder.style.color = 'var(--text-secondary)';
placeholder.style.fontSize = 'var(--font-size-small)';
placeholder.textContent = 'Select printer(s)...';
dropdown.appendChild(placeholder);
} else {
state.forEach(pid => {
const printer = State.printers.find(p => p.id === pid);
if (printer) {
const tag = document.createElement('div');
tag.className = 'multi-select-tag';
const removeBtn = document.createElement('span');
removeBtn.className = 'multi-select-tag-remove';
removeBtn.textContent = '';
removeBtn.onclick = (e) => {
e.stopPropagation();
removeMultiSelectTag(dropdownId, pid);
};
tag.appendChild(document.createTextNode(printer.name));
tag.appendChild(removeBtn);
dropdown.appendChild(tag);
}
});
}
if (optionsDiv) {
dropdown.appendChild(optionsDiv);
}
}
function removeMultiSelectTag(dropdownId, printerId) {
const state = State.multiSelectStates[dropdownId];
const idx = state.indexOf(printerId);
if (idx > -1) {
state.splice(idx, 1);
}
updateMultiSelectDisplay(dropdownId);
}
function updatePrinterDropdowns() {
const singleSelects = ['designer_target'];
singleSelects.forEach(id => {
const sel = $(id);
if (sel) {
sel.innerHTML = '';
State.printers.forEach(p => {
const opt = document.createElement('option');
opt.value = p.id;
opt.textContent = p.name + (p.connected ? ' (Connected)' : '');
sel.appendChild(opt);
});
}
});
Object.keys(State.multiSelectStates).forEach(id => {
const dropdown = $(id);
if (dropdown) {
const optionsDiv = dropdown.querySelector('.multi-select-options');
if (optionsDiv) {
optionsDiv.innerHTML = '';
State.printers.forEach(p => {
const opt = document.createElement('div');
opt.className = 'multi-select-option';
opt.textContent = p.name;
opt.dataset.printerId = p.id;
opt.onclick = (e) => {
e.stopPropagation();
toggleMultiSelectOption(id, p.id);
};
optionsDiv.appendChild(opt);
});
}
updateMultiSelectDisplay(id);
}
});
}
function renderTabs() {
console.log('[DEBUG renderTabs] Starting...');
const tabBar = $('tab-bar');
console.log('[DEBUG renderTabs] tabBar element:', tabBar);
if (!tabBar) {
    console.error('[DEBUG renderTabs] tab-bar element not found!');
    return;
}
tabBar.innerHTML = '';
const roleInfo = ROLES[State.currentRole];
console.log('[DEBUG renderTabs] currentRole:', State.currentRole, 'roleInfo:', roleInfo);
const allowedTabs = roleInfo ? roleInfo.tabs : TAB_ORDER;
console.log('[DEBUG renderTabs] allowedTabs:', allowedTabs);
if (State.currentRole === 'server') {
tabBar.style.display = 'none';
return;
} else {
tabBar.style.display = '';
}
let tabCount = 0;
TAB_ORDER.forEach(tabId => {
if (!allowedTabs.includes(tabId)) return;
const tab = document.createElement('div');
tab.className = 'tab-item';
tab.textContent = TAB_NAMES[tabId];
tab.dataset.tabId = tabId;
tab.draggable = true;
tab.setAttribute('role', 'tab');
tab.setAttribute('tabindex', '0');
tab.onclick = () => nav(tabId);
tab.onkeydown = (e) => {
if (e.key === 'Enter' || e.key === ' ') {
e.preventDefault();
nav(tabId);
}
};
tab.ondragstart = handleTabDragStart;
tab.ondragover = handleTabDragOver;
tab.ondrop = handleTabDrop;
tab.ondragend = handleTabDragEnd;
tabBar.appendChild(tab);
tabCount++;
});
console.log('[DEBUG renderTabs] Created', tabCount, 'tabs');
const firstTab = document.querySelector('.tab-item');
if (firstTab) firstTab.classList.add('active');
console.log('[DEBUG renderTabs] Complete');
}
function handleTabDragStart(e) {
State.draggedTab = this;
this.classList.add('dragging');
e.dataTransfer.effectAllowed = 'move';
}
function handleTabDragOver(e) {
e.preventDefault();
e.dataTransfer.dropEffect = 'move';
return false;
}
function handleTabDrop(e) {
e.stopPropagation();
if (State.draggedTab !== this) {
const draggedId = State.draggedTab.dataset.tabId;
const targetId = this.dataset.tabId;
const draggedIdx = TAB_ORDER.indexOf(draggedId);
const targetIdx = TAB_ORDER.indexOf(targetId);
TAB_ORDER.splice(draggedIdx, 1);
TAB_ORDER.splice(targetIdx, 0, draggedId);
renderTabs();
const activeTab = document.querySelector('.tab-item.active');
if (activeTab) {
nav(activeTab.dataset.tabId);
}
log(1, `Tab order changed: ${draggedId} moved to position ${targetIdx}`);
}
return false;
}
function handleTabDragEnd(e) {
this.classList.remove('dragging');
State.draggedTab = null;
}
function nav(id) {
document.querySelectorAll('.workspace').forEach(e => {
e.classList.remove('visible');
e.setAttribute('aria-hidden', 'true');
});
document.querySelectorAll('.tab-item').forEach(e => {
e.classList.remove('active');
e.setAttribute('aria-selected', 'false');
});
$(id).classList.add('visible');
$(id).setAttribute('aria-hidden', 'false');
const activeTab = document.querySelector(`.tab-item[data-tab-id="${id}"]`);
activeTab.classList.add('active');
activeTab.setAttribute('aria-selected', 'true');
announce(`Navigated to ${TAB_NAMES[id]}`);
log(1, `Navigated to tab: ${TAB_NAMES[id]}`);
}
function applyTheme(theme) {
document.body.dataset.theme = theme;
saveState();
announce(`Theme changed to ${theme}`);
log(2, `Theme changed to: ${theme}`);
}
function applyLayout(layout) {
document.body.dataset.layout = layout;
saveState();
announce(`Layout changed to ${layout}`);
log(2, `Layout changed to: ${layout}`);
}
function applyBorders(showBorders) {
document.body.dataset.borders = showBorders ? 'true' : 'false';
saveState();
announce(`Window borders ${showBorders ? 'enabled' : 'disabled'}`);
log(2, `Window borders: ${showBorders ? 'enabled' : 'disabled'}`);
}
// Automated Tests Functions
const AutoTest = {
running: false,
currentTest: null,
results: { passed: 0, failed: 0, skipped: 0 },
testQueue: [],
aborted: false,
testInterval: null,
reset() {
this.running = false;
this.currentTest = null;
this.results = { passed: 0, failed: 0, skipped: 0 };
this.testQueue = [];
this.aborted = false;
if (this.testInterval) clearInterval(this.testInterval);
document.querySelectorAll('.autotest-status').forEach(el => el.textContent = '');
document.querySelectorAll('.autotest-status').forEach(el => el.className = 'autotest-status');
document.querySelectorAll('.autotest-suite-status').forEach(el => {
el.textContent = '';
el.className = 'autotest-suite-status';
});
this.updateProgress(0, 0);
this.updateSummary();
},
updateProgress(current, total) {
const percent = total > 0 ? (current / total * 100) : 0;
$('autotest_progress').style.width = percent + '%';
$('autotest_progress_text').textContent = `${current} / ${total} tests`;
},
updateSummary() {
$('autotest_summary').innerHTML = `
<span style="color:var(--status-green);">Passed: ${this.results.passed}</span> |
<span style="color:var(--status-red);">Failed: ${this.results.failed}</span> |
<span style="color:var(--text-secondary);">Skipped: ${this.results.skipped}</span>
`;
},
logMessage(msg, type = 'info') {
const logEl = $('autotest_log');
const entry = document.createElement('div');
entry.className = `log-${type}`;
const timestamp = new Date().toISOString().substring(11, 23);
entry.textContent = `[${timestamp}] ${msg}`;
logEl.appendChild(entry);
logEl.scrollTop = logEl.scrollHeight;
},
getSelectedTests() {
const tests = [];
const target = document.querySelector('input[name="autotest_target"]:checked').value;
document.querySelectorAll('.autotest-item input[type="checkbox"]:checked').forEach(cb => {
const testItem = cb.closest('.autotest-item');
const testId = testItem.dataset.test;
const suite = testItem.closest('.autotest-suite').dataset.suite;
// Filter based on target selection
if (target === 'printer' && suite === 'cadmin') return;
if (target === 'cadmin' && !['cadmin'].includes(suite) && !testId.startsWith('cadmin')) return;
tests.push({ id: testId, suite: suite, element: testItem });
});
return tests;
},
async runTest(test) {
const statusEl = test.element.querySelector('.autotest-status');
statusEl.textContent = 'Running...';
statusEl.className = 'autotest-status running';
this.logMessage(`Running: ${test.id}`, 'info');
// Simulate test execution with realistic delays
const delay = 200 + Math.random() * 800;
await new Promise(resolve => setTimeout(resolve, delay));
if (this.aborted) {
statusEl.textContent = 'Skipped';
statusEl.className = 'autotest-status skipped';
this.results.skipped++;
return 'skipped';
}
// Execute actual test based on test ID
const result = await this.executeTestById(test.id);
if (result.success) {
statusEl.textContent = 'Passed';
statusEl.className = 'autotest-status passed';
this.results.passed++;
this.logMessage(` ${test.id}: ${result.message || 'OK'}`, 'info');
return 'passed';
} else {
statusEl.textContent = 'Failed';
statusEl.className = 'autotest-status failed';
this.results.failed++;
this.logMessage(` ${test.id}: ${result.message || 'Failed'}`, 'error');
return 'failed';
}
},
async executeTestById(testId) {
// CAdmin Application Tests
if (testId === 'cadmin_ui') {
const wrapper = document.querySelector('.app-wrapper');
const container = document.querySelector('.app-container');
return { success: wrapper && container, message: 'UI elements present' };
}
if (testId === 'cadmin_tabs') {
const tabs = document.querySelectorAll('.tab-item');
return { success: tabs.length > 0, message: `${tabs.length} tabs found` };
}
if (testId === 'cadmin_themes') {
const themeSelect = $('theme_selector');
const themes = themeSelect ? themeSelect.options.length : 0;
return { success: themes >= 5, message: `${themes} themes available` };
}
if (testId === 'cadmin_layouts') {
const layoutSelect = $('layout_selector');
const layouts = layoutSelect ? layoutSelect.options.length : 0;
return { success: layouts >= 2, message: `${layouts} layouts available` };
}
if (testId === 'cadmin_roles') {
const roleSelect = $('role_selector');
const roles = roleSelect ? roleSelect.options.length : 0;
return { success: roles >= 4, message: `${roles} roles configured` };
}
if (testId === 'cadmin_state') {
try {
const key = 'cognitivetpg_test_' + Date.now();
localStorage.setItem(key, 'test');
const val = localStorage.getItem(key);
localStorage.removeItem(key);
return { success: val === 'test', message: 'LocalStorage working' };
} catch (e) {
return { success: false, message: 'LocalStorage error' };
}
}
if (testId === 'cadmin_cpl') {
return { success: typeof CPL_DB === 'object' && Object.keys(CPL_DB).length > 0, message: 'CPL database loaded' };
}
if (testId === 'cadmin_designer') {
const canvas = $('canvas_el');
return { success: canvas && canvas.getContext, message: 'Canvas available' };
}
if (testId === 'cadmin_multiselect') {
const multiSelects = document.querySelectorAll('.multi-select-dropdown');
return { success: multiSelects.length > 0, message: `${multiSelects.length} multi-selects found` };
}
if (testId === 'cadmin_logging') {
const debugConsole = $('debug_console');
return { success: debugConsole !== null, message: 'Logging system ready' };
}
// Printer tests - simulate with random results for demo
const printerConnected = State.printers.some(p => p.connected);
if (testId.startsWith('printer_') || testId.startsWith('comm_') || testId.startsWith('print_') || testId.startsWith('fw_')) {
if (!printerConnected) {
return { success: false, message: 'No printer connected' };
}
// Simulate with 90% success rate
return { success: Math.random() > 0.1, message: 'Simulated test result' };
}
// Integration and stress tests
if (testId.startsWith('int_') || testId.startsWith('stress_')) {
return { success: Math.random() > 0.15, message: 'Simulated test result' };
}
return { success: true, message: 'Test completed' };
},
updateSuiteStatus(suite) {
const suiteEl = document.querySelector(`.autotest-suite[data-suite="${suite}"]`);
if (!suiteEl) return;
const items = suiteEl.querySelectorAll('.autotest-item');
let passed = 0, failed = 0, total = 0;
items.forEach(item => {
const status = item.querySelector('.autotest-status');
if (status.classList.contains('passed')) { passed++; total++; }
else if (status.classList.contains('failed')) { failed++; total++; }
else if (status.classList.contains('skipped')) { total++; }
});
const statusEl = suiteEl.querySelector('.autotest-suite-status');
if (total === 0) {
statusEl.textContent = '';
statusEl.className = 'autotest-suite-status';
} else if (failed > 0) {
statusEl.textContent = `${passed}/${total}`;
statusEl.className = 'autotest-suite-status failed';
} else if (passed === total) {
statusEl.textContent = `${passed}/${total}`;
statusEl.className = 'autotest-suite-status passed';
} else {
statusEl.textContent = `${passed}/${total}`;
statusEl.className = 'autotest-suite-status running';
}
},
async runAllTests() {
if (this.running) return;
this.reset();
this.running = true;
this.aborted = false;
$('btn_autotest_stop').disabled = false;
$('btn_autotest_run_all').disabled = true;
$('btn_autotest_run_selected').disabled = true;
const tests = this.getSelectedTests();
const total = tests.length;
let current = 0;
this.logMessage(`Starting ${total} tests...`, 'info');
this.logMessage(`Target: ${document.querySelector('input[name="autotest_target"]:checked').value}`, 'info');
const stopOnFail = $('autotest_stop_on_fail').checked;
for (const test of tests) {
if (this.aborted) {
this.logMessage('Tests aborted by user', 'warning');
break;
}
current++;
this.updateProgress(current, total);
const result = await this.runTest(test);
this.updateSummary();
this.updateSuiteStatus(test.suite);
if (stopOnFail && result === 'failed') {
this.logMessage('Stopping on first failure', 'warning');
break;
}
}
this.running = false;
$('btn_autotest_stop').disabled = true;
$('btn_autotest_run_all').disabled = false;
$('btn_autotest_run_selected').disabled = false;
const status = this.results.failed > 0 ? 'FAILED' : 'PASSED';
this.logMessage(`Test run complete: ${status}`, this.results.failed > 0 ? 'error' : 'info');
this.logMessage(`Results: ${this.results.passed} passed, ${this.results.failed} failed, ${this.results.skipped} skipped`, 'info');
if ($('autotest_generate_report').checked) {
this.logMessage('Report generated', 'info');
}
announce(`Tests complete: ${this.results.passed} passed, ${this.results.failed} failed`);
},
stop() {
this.aborted = true;
this.logMessage('Stopping tests...', 'warning');
}
};
function toggleAutoTestSuite(suite) {
const suiteEl = document.querySelector(`.autotest-suite[data-suite="${suite}"]`);
const content = $(`suite_${suite}_content`);
if (suiteEl && content) {
suiteEl.classList.toggle('expanded');
content.style.display = suiteEl.classList.contains('expanded') ? 'block' : 'none';
}
}
function setupAutoTestHandlers() {
$('btn_autotest_run_all').onclick = () => AutoTest.runAllTests();
$('btn_autotest_run_selected').onclick = () => AutoTest.runAllTests();
$('btn_autotest_stop').onclick = () => AutoTest.stop();
$('btn_autotest_reset').onclick = () => {
AutoTest.reset();
$('autotest_log').innerHTML = '';
announce('Tests reset');
};
$('btn_autotest_clear_log').onclick = () => {
$('autotest_log').innerHTML = '';
};
$('btn_autotest_export').onclick = () => {
const log = $('autotest_log').innerText;
const report = `CAdmin Automated Test Report\n` +
`Generated: ${new Date().toISOString()}\n` +
`====================================\n\n` +
`Results Summary:\n` +
`  Passed: ${AutoTest.results.passed}\n` +
`  Failed: ${AutoTest.results.failed}\n` +
`  Skipped: ${AutoTest.results.skipped}\n\n` +
`Test Log:\n` +
`------------------------------------\n` +
log;
const blob = new Blob([report], { type: 'text/plain' });
const a = document.createElement('a');
a.href = URL.createObjectURL(blob);
a.download = `autotest_report_${new Date().toISOString().replace(/[:.]/g, '-')}.txt`;
a.click();
announce('Report exported');
};
// Update printer list in autotest tab
$('autotest_all_printers').onchange = function() {
const select = $('autotest_printer_select');
if (this.checked) {
Array.from(select.options).forEach(opt => opt.selected = true);
} else {
Array.from(select.options).forEach(opt => opt.selected = false);
}
};
}
function updateAutoTestPrinterList() {
const select = $('autotest_printer_select');
if (!select) return;
select.innerHTML = '';
State.printers.filter(p => p.connected).forEach(p => {
const opt = document.createElement('option');
opt.value = p.id;
opt.textContent = `${p.name} (${p.port})`;
select.appendChild(opt);
});
}
function filterCPL(cat) {
const content = $('cpl_content');
content.innerHTML = '';
const h = document.createElement('h3');
h.textContent = cat === 'all' ? 'All CPL Commands' : cat.charAt(0).toUpperCase() + cat.slice(1) + ' Commands';
content.appendChild(h);
const categories = cat === 'all' ? Object.keys(CPL_DB) : [cat];
categories.forEach(category => {
if (!CPL_DB[category]) return;
CPL_DB[category].forEach(cmd => {
const div = document.createElement('div');
div.className = 'cpl-command-card';
div.innerHTML = `
<div class="cpl-command-title">${escapeHtml(cmd.cmd)}${cmd.short ? ` (${escapeHtml(cmd.short)})` : ''}</div>
<div class="cpl-command-syntax">${escapeHtml(cmd.cmd)} ${escapeHtml(cmd.params)}</div>
<div class="cpl-command-desc">${escapeHtml(cmd.desc)}</div>
${cmd.response ? `<div class="cpl-response"><strong>Response:</strong> ${escapeHtml(cmd.response)}${cmd.responseBytes ? ` <span class="response-bytes">[${cmd.responseBytes} bytes]</span>` : ''}</div>` : ''}
${cmd.exampleResponse ? `<div class="cpl-example-response"><strong>Example Response:</strong> <code>${escapeHtml(cmd.exampleResponse)}</code></div>` : ''}
${cmd.example ? `<div class="cpl-example">Example:\n${escapeHtml(cmd.example)}</div>` : ''}
`;
content.appendChild(div);
});
});
}
function searchCPL() {
const query = $('cpl_search').value.toLowerCase();
if (!query) {
filterCPL('all');
return;
}
const content = $('cpl_content');
content.innerHTML = '<h3>Search Results</h3>';
let found = false;
Object.keys(CPL_DB).forEach(category => {
CPL_DB[category].forEach(cmd => {
if (cmd.cmd.toLowerCase().includes(query) || cmd.desc.toLowerCase().includes(query) || (cmd.response && cmd.response.toLowerCase().includes(query))) {
found = true;
const div = document.createElement('div');
div.className = 'cpl-command-card';
div.innerHTML = `
<div class="cpl-command-title">${escapeHtml(cmd.cmd)}${cmd.short ? ` (${escapeHtml(cmd.short)})` : ''}</div>
<div class="cpl-command-syntax">${escapeHtml(cmd.cmd)} ${escapeHtml(cmd.params)}</div>
<div class="cpl-command-desc">${escapeHtml(cmd.desc)}</div>
${cmd.response ? `<div class="cpl-response"><strong>Response:</strong> ${escapeHtml(cmd.response)}${cmd.responseBytes ? ` <span class="response-bytes">[${cmd.responseBytes} bytes]</span>` : ''}</div>` : ''}
${cmd.exampleResponse ? `<div class="cpl-example-response"><strong>Example Response:</strong> <code>${escapeHtml(cmd.exampleResponse)}</code></div>` : ''}
${cmd.example ? `<div class="cpl-example">Example:\n${escapeHtml(cmd.example)}</div>` : ''}
`;
content.appendChild(div);
}
});
});
if (!found) {
content.innerHTML += '<p style="color:var(--text-secondary);">No commands found.</p>';
}
}
let canvasDragState = { dragging: false, resizing: false, startX: 0, startY: 0, origX: 0, origY: 0, origW: 0, origH: 0, resizeHandle: null };
function addLabelElement(type) {
const elem = {
type: type,
x: 50 + State.labelElements.length * 20,
y: 50 + State.labelElements.length * 15,
width: type === 'circle' ? 50 : (type === 'ellipse' ? 80 : 100),
height: type === 'circle' ? 50 : (type === 'ellipse' ? 50 : 30),
text: type === 'text' ? 'Sample Text' : '',
font: 'TEXT 3',
barcodeType: 'CODE128',
thickness: 2,
radius: type === 'circle' ? 25 : 0,
zIndex: State.labelElements.length
};
State.labelElements.push(elem);
State.selectedElement = elem;
renderCanvas();
updateProperties();
announce(`Added ${type} element to canvas`);
log(1, `Added ${type} element to canvas`);
}
function getElementAtPoint(x, y) {
for (let i = State.labelElements.length - 1; i >= 0; i--) {
const elem = State.labelElements[i];
let bounds;
if (elem.type === 'circle') {
bounds = { x: elem.x, y: elem.y, w: elem.radius * 2, h: elem.radius * 2 };
} else if (elem.type === 'text') {
bounds = { x: elem.x - 2, y: elem.y - 12, w: elem.width, h: 16 };
} else {
bounds = { x: elem.x, y: elem.y, w: elem.width, h: elem.height };
}
if (x >= bounds.x && x <= bounds.x + bounds.w && y >= bounds.y && y <= bounds.y + bounds.h) {
return elem;
}
}
return null;
}
function getResizeHandle(elem, x, y) {
if (!elem || elem.type === 'line') return null;
const handleSize = 8;
let bounds;
if (elem.type === 'circle') {
bounds = { x: elem.x, y: elem.y, w: elem.radius * 2, h: elem.radius * 2 };
} else if (elem.type === 'text') {
bounds = { x: elem.x - 2, y: elem.y - 12, w: elem.width, h: 16 };
} else {
bounds = { x: elem.x, y: elem.y, w: elem.width, h: elem.height };
}
const corners = [
{ name: 'se', x: bounds.x + bounds.w - handleSize/2, y: bounds.y + bounds.h - handleSize/2 },
{ name: 'sw', x: bounds.x - handleSize/2, y: bounds.y + bounds.h - handleSize/2 },
{ name: 'ne', x: bounds.x + bounds.w - handleSize/2, y: bounds.y - handleSize/2 },
{ name: 'nw', x: bounds.x - handleSize/2, y: bounds.y - handleSize/2 }
];
for (const corner of corners) {
if (x >= corner.x && x <= corner.x + handleSize && y >= corner.y && y <= corner.y + handleSize) {
return corner.name;
}
}
return null;
}
function bringToFront() {
if (State.selectedElement) {
const idx = State.labelElements.indexOf(State.selectedElement);
if (idx > -1) {
State.labelElements.splice(idx, 1);
State.labelElements.push(State.selectedElement);
State.selectedElement.zIndex = State.labelElements.length - 1;
renderCanvas();
announce('Element brought to front');
}
}
}
function sendToBack() {
if (State.selectedElement) {
const idx = State.labelElements.indexOf(State.selectedElement);
if (idx > -1) {
State.labelElements.splice(idx, 1);
State.labelElements.unshift(State.selectedElement);
State.labelElements.forEach((el, i) => el.zIndex = i);
renderCanvas();
announce('Element sent to back');
}
}
}
function duplicateElement() {
if (State.selectedElement) {
const copy = JSON.parse(JSON.stringify(State.selectedElement));
copy.x += 20;
copy.y += 20;
copy.zIndex = State.labelElements.length;
State.labelElements.push(copy);
State.selectedElement = copy;
renderCanvas();
updateProperties();
announce('Element duplicated');
}
}
function showContextMenu(x, y) {
let menu = $('canvas_context_menu');
if (!menu) {
menu = document.createElement('div');
menu.id = 'canvas_context_menu';
menu.style.cssText = 'position:fixed;background:var(--bg-window);border:1px solid var(--border-dark);box-shadow:2px 2px 5px rgba(0,0,0,0.2);z-index:1000;padding:2px 0;min-width:120px;font-size:var(--font-size-small);';
menu.innerHTML = `
<div class="ctx-item" data-action="front" style="padding:4px 12px;cursor:pointer;">Bring to Front</div>
<div class="ctx-item" data-action="back" style="padding:4px 12px;cursor:pointer;">Send to Back</div>
<div style="border-top:1px solid var(--border-shadow);margin:2px 0;"></div>
<div class="ctx-item" data-action="duplicate" style="padding:4px 12px;cursor:pointer;">Duplicate</div>
<div class="ctx-item" data-action="delete" style="padding:4px 12px;cursor:pointer;color:var(--status-red);">Delete</div>
`;
document.body.appendChild(menu);
menu.querySelectorAll('.ctx-item').forEach(item => {
item.onmouseenter = () => item.style.background = 'var(--accent-primary)';
item.onmouseleave = () => item.style.background = '';
item.onclick = () => {
const action = item.dataset.action;
if (action === 'front') bringToFront();
else if (action === 'back') sendToBack();
else if (action === 'duplicate') duplicateElement();
else if (action === 'delete') deleteElement();
hideContextMenu();
};
});
}
menu.style.left = x + 'px';
menu.style.top = y + 'px';
menu.style.display = 'block';
}
function hideContextMenu() {
const menu = $('canvas_context_menu');
if (menu) menu.style.display = 'none';
}
function renderCanvas() {
const canvas = $('canvas_el');
const ctx = canvas.getContext('2d');
ctx.clearRect(0, 0, canvas.width, canvas.height);
const sortedElements = [...State.labelElements].sort((a, b) => (a.zIndex || 0) - (b.zIndex || 0));
sortedElements.forEach(elem => {
const isSelected = elem === State.selectedElement;
ctx.strokeStyle = isSelected ? '#ff0000' : '#000000';
ctx.lineWidth = elem.thickness || 2;
if (elem.type === 'box') {
ctx.strokeRect(elem.x, elem.y, elem.width, elem.height);
} else if (elem.type === 'line') {
ctx.beginPath();
ctx.moveTo(elem.x, elem.y);
ctx.lineTo(elem.x + elem.width, elem.y + elem.height);
ctx.stroke();
} else if (elem.type === 'text') {
ctx.font = '12px Arial';
ctx.fillStyle = '#000';
ctx.fillText(elem.text, elem.x, elem.y);
ctx.strokeRect(elem.x - 2, elem.y - 12, elem.width, 16);
} else if (elem.type === 'barcode') {
ctx.fillStyle = '#000';
for (let i = 0; i < 10; i++) {
if (i % 2 === 0) ctx.fillRect(elem.x + i * 10, elem.y, 8, elem.height);
}
ctx.strokeRect(elem.x, elem.y, elem.width, elem.height);
} else if (elem.type === 'circle') {
ctx.beginPath();
ctx.arc(elem.x + elem.radius, elem.y + elem.radius, elem.radius, 0, Math.PI * 2);
ctx.stroke();
} else if (elem.type === 'ellipse') {
ctx.beginPath();
ctx.ellipse(elem.x + elem.width / 2, elem.y + elem.height / 2, elem.width / 2, elem.height / 2, 0, 0, Math.PI * 2);
ctx.stroke();
}
if (isSelected && elem.type !== 'line') {
ctx.fillStyle = '#0078d7';
const handleSize = 6;
let bounds;
if (elem.type === 'circle') {
bounds = { x: elem.x, y: elem.y, w: elem.radius * 2, h: elem.radius * 2 };
} else if (elem.type === 'text') {
bounds = { x: elem.x - 2, y: elem.y - 12, w: elem.width, h: 16 };
} else {
bounds = { x: elem.x, y: elem.y, w: elem.width, h: elem.height };
}
ctx.fillRect(bounds.x - handleSize/2, bounds.y - handleSize/2, handleSize, handleSize);
ctx.fillRect(bounds.x + bounds.w - handleSize/2, bounds.y - handleSize/2, handleSize, handleSize);
ctx.fillRect(bounds.x - handleSize/2, bounds.y + bounds.h - handleSize/2, handleSize, handleSize);
ctx.fillRect(bounds.x + bounds.w - handleSize/2, bounds.y + bounds.h - handleSize/2, handleSize, handleSize);
}
});
}
function updateProperties() {
const props = $('element_props');
if (!State.selectedElement) {
props.innerHTML = '<div style="font-weight:bold; margin-bottom:5px;">Properties</div><div style="font-size:var(--font-size-small); color:var(--text-secondary);">Select an element</div>';
return;
}
const elem = State.selectedElement;
props.innerHTML = `
<div style="font-weight:bold; margin-bottom:5px;">Properties - ${elem.type}</div>
<div class="grid-2" style="font-size:var(--font-size-small);">
<span>X:</span><input type="number" value="${elem.x}" id="prop_x" style="width:60px;">
<span>Y:</span><input type="number" value="${elem.y}" id="prop_y" style="width:60px;">
${elem.type === 'circle' ? `<span>Radius:</span><input type="number" value="${elem.radius}" id="prop_r" style="width:60px;">` : ''}
${(elem.type !== 'line' && elem.type !== 'circle') ? `<span>Width:</span><input type="number" value="${elem.width}" id="prop_w" style="width:60px;">` : ''}
${(elem.type !== 'line' && elem.type !== 'circle') ? `<span>Height:</span><input type="number" value="${elem.height}" id="prop_h" style="width:60px;">` : ''}
${elem.type === 'text' ? `<span>Text:</span><input type="text" value="${escapeHtml(elem.text)}" id="prop_text">` : ''}
</div>
<button id="btn_delete_element" style="width:100%; margin-top:var(--spacing-md);">Delete</button>
`;
$('prop_x').onchange = () => { elem.x = parseInt($('prop_x').value) || 0; renderCanvas(); };
$('prop_y').onchange = () => { elem.y = parseInt($('prop_y').value) || 0; renderCanvas(); };
if ($('prop_r')) $('prop_r').onchange = () => { elem.radius = parseInt($('prop_r').value) || 10; renderCanvas(); };
if ($('prop_w')) $('prop_w').onchange = () => { elem.width = parseInt($('prop_w').value) || 0; renderCanvas(); };
if ($('prop_h')) $('prop_h').onchange = () => { elem.height = parseInt($('prop_h').value) || 0; renderCanvas(); };
if ($('prop_text')) $('prop_text').onchange = () => { elem.text = $('prop_text').value; renderCanvas(); };
$('btn_delete_element').onclick = deleteElement;
}
function deleteElement() {
if (State.selectedElement) {
State.labelElements = State.labelElements.filter(e => e !== State.selectedElement);
State.selectedElement = null;
renderCanvas();
updateProperties();
announce('Element deleted');
log(1, 'Deleted element from canvas');
}
}
function clearCanvas() {
State.labelElements = [];
State.selectedElement = null;
renderCanvas();
updateProperties();
announce('Canvas cleared');
log(2, 'Canvas cleared');
}
function generateCPL() {
let cpl = '! 0 200 200 1\n';
State.labelElements.forEach(elem => {
if (elem.type === 'text') {
cpl += `TEXT 3 0 ${elem.x} ${elem.y} ${elem.text}\n`;
} else if (elem.type === 'barcode') {
cpl += `BARCODE ${elem.barcodeType} 0 ${elem.x} ${elem.y} ${elem.height} 123456789\n`;
} else if (elem.type === 'box') {
cpl += `DRAW_BOX ${elem.x} ${elem.y} ${elem.width} ${elem.height} ${elem.thickness}\n`;
} else if (elem.type === 'line') {
cpl += `DRAW_LINE ${elem.x} ${elem.y} ${elem.x + elem.width} ${elem.y + elem.height} ${elem.thickness}\n`;
} else if (elem.type === 'circle') {
cpl += `DRAW_ELLIPSE ${elem.x} ${elem.y} ${elem.radius * 2} ${elem.radius * 2} ${elem.thickness}\n`;
} else if (elem.type === 'ellipse') {
cpl += `DRAW_ELLIPSE ${elem.x} ${elem.y} ${elem.width} ${elem.height} ${elem.thickness}\n`;
}
});
cpl += 'END\n';
$('generated_cpl').value = cpl;
announce('CPL code generated');
log(2, 'CPL code generated');
}
function applyConfigToSelected(targetKey, configKey, getValue, logMessage) {
const targets = State.multiSelectStates[targetKey] || [];
if (targets.length === 0) {
announce('No printers selected');
return;
}
targets.forEach(id => {
const printer = State.printers.find(p => p.id === id);
if (printer) {
printer.config[configKey] = getValue();
log(2, `${logMessage} ${getValue()} to ${printer.name}`);
}
});
saveState();
announce(`${logMessage} applied to ${targets.length} printer(s)`);
}
function setupEventHandlers() {
$('role_selector').onchange = function() {
localStorage.setItem('cognitivetpg_role', this.value);
applyRole(this.value);
};
$('btn_add_printer').onclick = addPrinter;
$('btn_remove_printer').onclick = removePrinter;
$('btn_scan_devices').onclick = scanForDevices;
$('btn_connect_selected').onclick = connectSelectedPrinters;
$('btn_connect_all').onclick = connectAllPrinters;
$('btn_disconnect_all').onclick = disconnectAllPrinters;
$('btn_scan_bluetooth').onclick = () => {
announce('Scanning for Bluetooth devices...');
log(2, 'Scanning for Bluetooth devices...');
};
document.querySelectorAll('input[name="ct"]').forEach(radio => {
radio.onchange = () => {
uiConn();
updateWifiPanelVisibility();
};
});
['com_list', 'baud', 'stop_bits', 'xon_xoff', 'net_ip', 'net_port', 'bt_com', 'par_port'].forEach(id => {
const el = $(id);
if (el) {
el.onchange = updateSelectedPrinterConfig;
}
});
$('wifi_dhcp').onchange = function() {
$('wifi_static').style.display = this.checked ? 'none' : 'grid';
};
$('btn_scan_wifi').onclick = () => {
const list = $('wifi_list');
list.innerHTML = '<div style="color:var(--text-secondary);">Scanning...</div>';
announce('Scanning for WiFi networks...');
log(2, 'Scanning for WiFi networks...');
setTimeout(() => {
list.innerHTML = `
<div style="padding:3px; cursor:pointer; border-bottom:1px solid var(--border-light);" onclick="$('wifi_ssid').value='Office-Network';">Office-Network (WPA2) - Strong</div>
<div style="padding:3px; cursor:pointer; border-bottom:1px solid var(--border-light);" onclick="$('wifi_ssid').value='Guest-WiFi';">Guest-WiFi (Open) - Medium</div>
<div style="padding:3px; cursor:pointer; border-bottom:1px solid var(--border-light);" onclick="$('wifi_ssid').value='Production-5G';">Production-5G (WPA3) - Weak</div>
`;
announce('Found 3 WiFi networks');
log(2, 'Found 3 WiFi networks');
}, 1000);
};
$('btn_apply_wifi').onclick = () => {
announce('WiFi configuration applied');
log(2, 'WiFi configuration applied to selected printer(s)');
};
$('btn_apply_darkness').onclick = () => {
applyConfigToSelected('print_target', 'darkness', () => parseInt($('darkness_val').value), 'Applied darkness');
};
$('btn_darkness_down').onclick = () => {
const slider = $('darkness_slider');
const val = $('darkness_val');
let current = parseInt(slider.value);
current = Math.max(-200, current - 10);
slider.value = current;
val.value = current;
};
$('btn_darkness_up').onclick = () => {
const slider = $('darkness_slider');
const val = $('darkness_val');
let current = parseInt(slider.value);
current = Math.min(200, current + 10);
slider.value = current;
val.value = current;
};
$('darkness_slider').oninput = function() {
$('darkness_val').value = this.value;
};
$('darkness_val').onchange = function() {
let v = parseInt(this.value) || 0;
v = Math.max(-200, Math.min(200, v));
this.value = v;
$('darkness_slider').value = v;
};
$('btn_refresh_time').onclick = () => {
const now = new Date();
$('rtc_time').value = now.toTimeString().slice(0, 8);
$('rtc_date').value = now.toISOString().slice(0, 10);
announce('RTC refreshed from printer');
log(2, 'RTC time/date refreshed');
};
$('btn_apply_datetime').onclick = () => {
announce('RTC set to ' + $('rtc_time').value + ' ' + $('rtc_date').value);
log(2, 'RTC time/date applied: ' + $('rtc_time').value + ' ' + $('rtc_date').value);
};
$('btn_apply_print_speed').onclick = () => {
applyConfigToSelected('print_target', 'printSpeed', () => $('print_speed').value, 'Applied print speed');
};
$('btn_apply_no_media').onclick = () => {
applyConfigToSelected('print_target', 'noMedia', () => parseInt($('no_media').value), 'Applied no-media-out');
};
$('btn_apply_debug_level').onclick = () => {
applyConfigToSelected('print_target', 'debugLevel', () => $('debug_level').selectedIndex, 'Applied debug level');
};
$('btn_apply_auto_reprint').onclick = () => {
applyConfigToSelected('print_target', 'autoReprint', () => $('auto_reprint').checked, 'Applied auto-reprint');
};
$('btn_apply_aux_power').onclick = () => {
applyConfigToSelected('print_target', 'auxPower', () => $('aux_power').checked, 'Applied aux power');
};
$('btn_apply_media_adjust').onclick = () => {
applyConfigToSelected('print_target', 'mediaAdjust', () => parseInt($('media_adjust').value), 'Applied media adjust');
};
$('btn_apply_pitch').onclick = () => {
applyConfigToSelected('print_target', 'pitch', () => parseInt($('pitch').value), 'Applied pitch');
};
$('btn_apply_language').onclick = () => {
applyConfigToSelected('print_target', 'language', () => document.querySelector('input[name="lang"]:checked').value, 'Applied language');
};
$('btn_apply_thermal_mode').onclick = () => {
applyConfigToSelected('print_target', 'thermalMode', () => document.querySelector('input[name="tm"]:checked').value, 'Applied thermal mode');
};
$('btn_refresh_printer_settings').onclick = () => {
announce('Refreshing printer settings...');
log(2, 'Refreshing printer settings...');
};
$('btn_print_test_label').onclick = () => {
announce('Printing test label...');
log(2, 'Printing test label on selected printer(s)...');
};
$('btn_calibrate_sensor').onclick = () => {
announce('Calibrating sensor...');
log(2, 'Calibrating sensor...');
};
$('btn_refresh_positioning').onclick = () => {
announce('Refreshing positioning settings...');
log(2, 'Refreshing positioning settings...');
};
$('btn_pos_test_label').onclick = () => {
announce('Printing position test label...');
log(2, 'Printing position test label');
};
const applyPresEnable = $('btn_apply_pres_enable');
if (applyPresEnable) applyPresEnable.onclick = () => {
announce('Label presentation ' + ($('present_enable').checked ? 'enabled' : 'disabled'));
log(2, 'Label presentation setting applied');
};
const applyAdvance = $('btn_apply_advance');
if (applyAdvance) applyAdvance.onclick = () => {
announce('Advance distance set to ' + $('present_advance').value);
log(2, 'Advance distance applied: ' + $('present_advance').value);
};
const applyRetract = $('btn_apply_retract');
if (applyRetract) applyRetract.onclick = () => {
announce('Retract distance set to ' + $('present_retract').value);
log(2, 'Retract distance applied: ' + $('present_retract').value);
};
const applyPresentTime = $('btn_apply_present_time');
if (applyPresentTime) applyPresentTime.onclick = () => {
announce('Presentation time set to ' + $('present_time').value + 'ms');
log(2, 'Presentation time applied: ' + $('present_time').value + 'ms');
};
$('btn_load_objects').onclick = () => {
const tb = $('obj_table').querySelector('tbody');
tb.innerHTML = '';
for (let i = 0; i < 10; i++) {
const tr = document.createElement('tr');
tr.innerHTML = `<td>CP${10 + i}</td><td>Font</td><td>Flash</td><td>900</td><td>CodePage ${850 + i}</td>`;
tb.appendChild(tr);
}
announce('Objects loaded from printer');
log(2, 'Objects loaded from printer');
};
$('btn_send_objects').onclick = () => {
announce('Sending objects to selected printer(s)');
log(2, 'Sending objects to selected printer(s)');
};
$('btn_delete_objects').onclick = () => {
announce('Selected objects deleted');
log(2, 'Selected objects deleted');
};
$('btn_get_profile').onclick = () => {
$('prof_txt').value = '!! 0 0 0 0\n! 0 0 0 0\nVARIABLE DARKNESS 100\nVARIABLE WIDTH 812\nVARIABLE PRINT_SPEED 4\nVARIABLE INDEX ON\nVARIABLE FEED_TYPE GAP\n';
announce('Profile retrieved from printer');
log(2, 'Profile retrieved from printer');
};
$('btn_apply_profile').onclick = () => {
announce('Profile applied to selected printer(s)');
log(2, 'Profile applied to selected printer(s)');
};
$('btn_save_profile').onclick = () => {
const blob = new Blob([$('prof_txt').value], {type: 'text/plain'});
const url = URL.createObjectURL(blob);
const a = document.createElement('a');
a.href = url;
a.download = 'printer_profile.txt';
a.click();
URL.revokeObjectURL(url);
announce('Profile saved to file');
log(2, 'Profile saved to file');
};
$('btn_load_profile_file').onclick = () => {
announce('Load profile from file');
log(2, 'Load profile from file');
};
$('btn_refresh_firmware').onclick = () => {
$('fw_part').textContent = '195-170-409';
$('fw_ver').textContent = 'V4.09$';
$('fw_date').textContent = 'Jan 15 2020 15:00:00';
announce('Firmware info refreshed');
log(2, 'Firmware info refreshed');
};
$('btn_browse_firmware').onclick = () => {
$('fw_file').value = 'firmware_v4.10.bin';
announce('Firmware file selected');
log(2, 'Firmware file selected');
};
$('btn_update_firmware').onclick = () => {
announce('Firmware upgrade started');
log(2, 'Firmware upgrade started');
let w = 0;
const b = $('fw_prog');
const interval = setInterval(() => {
w += 1;
b.style.width = w + '%';
if (w >= 100) {
clearInterval(interval);
announce('Firmware upgrade completed');
log(2, 'Firmware upgrade completed');
}
}, 30);
State.activeIntervals.push(interval);
};
$('btn_load_cpr').onclick = () => {
announce('Load CPR file');
log(2, 'CPR file loaded');
};
$('btn_save_cpr').onclick = () => {
announce('Save CPR file');
log(2, 'CPR file saved');
};
$('btn_apply_pcl_window').onclick = () => {
const x = $('pcl_origin_x').value;
const y = $('pcl_origin_y').value;
const w = $('pcl_width').value;
const l = $('pcl_length').value;
$('pjl_commands').value = `@PJL SET LPARM:CPL LABEL ORIGIN X = ${x}\n@PJL SET LPARM:CPL LABEL ORIGIN Y = ${y}\n@PJL SET LPARM:CPL LABEL WIDTH = ${w}\n@PJL SET LPARM:CPL LABEL LENGTH = ${l}`;
announce('PCL window parameters applied');
log(2, `PCL window: X=${x}, Y=${y}, W=${w}, L=${l}`);
};
$('btn_refresh_pcl_window').onclick = () => {
announce('Refreshing PCL window parameters from printer');
log(2, 'Refreshing PCL window parameters');
};
$('btn_load_pjl').onclick = () => {
announce('Load PJL file');
log(2, 'Loading PJL file');
};
$('btn_save_pjl').onclick = () => {
const blob = new Blob([$('pjl_commands').value], {type: 'text/plain'});
const url = URL.createObjectURL(blob);
const a = document.createElement('a');
a.href = url;
a.download = 'pjl_commands.pjl';
a.click();
URL.revokeObjectURL(url);
announce('PJL file saved');
log(2, 'PJL file saved');
};
$('btn_send_pjl').onclick = () => {
announce('Sending PJL commands to printer');
log(2, 'Sending PJL commands: ' + $('pjl_commands').value.split('\n')[0] + '...');
};
$('btn_browse_pcl').onclick = () => {
$('pcl_file').value = 'sample_label.pcl';
announce('PCL file selected');
log(2, 'PCL file selected');
};
$('btn_send_pcl').onclick = () => {
announce('Sending PCL file to printer');
log(2, 'Sending PCL file to printer');
};
$('btn_scan_barcode').onclick = () => {
announce('Scan barcode for model number');
log(2, 'Scanning barcode for model number');
};
$('btn_print_serial_label').onclick = () => {
announce('Printing serial number label');
log(2, 'Printing serial number label');
};
$('btn_print_box_label').onclick = () => {
announce('Printing box label');
log(2, 'Printing box label');
};
$('btn_start_test').onclick = () => {
announce('Manufacturing test sequence started');
log(2, 'Manufacturing test sequence started');
MfgTest.start();
};
$('btn_run_next').onclick = () => {
MfgTest.runNext();
};
$('btn_rerun_test').onclick = () => {
announce('Test sequence reset');
log(2, 'Test sequence reset');
MfgTest.reset();
};
$('btn_stop_test').onclick = () => {
MfgTest.abort();
announce('Test sequence aborted');
log(3, 'Test sequence aborted');
};
$('btn_enable_pcl').onclick = () => {
announce('Enabling PCL mode on printer...');
log(2, 'Enabling PCL mode');
MfgTest.enablePCL();
};
$('btn_insert_template').onclick = () => {
announce('Insert CPL template');
log(2, 'Insert CPL template');
};
$('btn_send_script').onclick = () => {
const script = $('cpl_in').value;
$('cpl_out').value += '\n[SENT TO PRINTER(S)]\n' + script + '\n';
announce('Script sent to printer(s)');
log(2, 'Script sent to printer(s)');
};
$('btn_save_script').onclick = () => {
const blob = new Blob([$('cpl_in').value], {type: 'text/plain'});
const url = URL.createObjectURL(blob);
const a = document.createElement('a');
a.href = url;
a.download = 'cpl_script.txt';
a.click();
URL.revokeObjectURL(url);
announce('Script saved');
log(2, 'Script saved');
};
$('btn_load_script').onclick = () => {
announce('Load script');
log(2, 'Script loaded');
};
$('btn_clear_script').onclick = () => {
$('cpl_in').value = '';
announce('Script cleared');
};
$('btn_view_variables').onclick = () => {
$('cpl_out').value += '\n[VARIABLE DUMP]\nDARKNESS 100\nWIDTH 812\nPRINT_SPEED 4\n';
announce('Variables displayed');
log(2, 'Variables requested');
};
$('btn_view_status').onclick = () => {
$('cpl_out').value += '\n[STATUS]\nReady\nPaper Loaded\nHead Closed\n';
announce('Status displayed');
log(2, 'Status requested');
};
$('btn_clear_output').onclick = () => {
$('cpl_out').value = '';
announce('Output cleared');
};
let timerState = { interval: null, count: 0, paused: false };
$('btn_timer_start').onclick = () => {
const intervalSecs = parseInt($('timer_interval').value) || 5;
const repeat = parseInt($('timer_repeat').value) || 1;
timerState.count = 0;
timerState.paused = false;
$('btn_timer_start').disabled = true;
$('btn_timer_pause').disabled = false;
$('btn_timer_resume').disabled = true;
$('btn_timer_stop').disabled = false;
$('timer_current').textContent = `0 / ${repeat}`;
timerState.interval = setInterval(() => {
if (!timerState.paused) {
timerState.count++;
$('timer_current').textContent = `${timerState.count} / ${repeat}`;
const script = $('cpl_in').value;
$('cpl_out').value += `\n[TIMER ${timerState.count}/${repeat}]\n${script}\n`;
log(2, `Timer sent script (${timerState.count}/${repeat})`);
if (timerState.count >= repeat) {
clearInterval(timerState.interval);
$('btn_timer_start').disabled = false;
$('btn_timer_pause').disabled = true;
$('btn_timer_resume').disabled = true;
$('btn_timer_stop').disabled = true;
announce('Timer completed');
}
}
}, intervalSecs * 1000);
State.activeIntervals.push(timerState.interval);
announce(`Timer started: ${repeat} times every ${intervalSecs}s`);
log(2, `Timer started: ${repeat} repetitions at ${intervalSecs}s interval`);
};
$('btn_timer_pause').onclick = () => {
timerState.paused = true;
$('btn_timer_pause').disabled = true;
$('btn_timer_resume').disabled = false;
announce('Timer paused');
log(2, 'Timer paused');
};
$('btn_timer_resume').onclick = () => {
timerState.paused = false;
$('btn_timer_pause').disabled = false;
$('btn_timer_resume').disabled = true;
announce('Timer resumed');
log(2, 'Timer resumed');
};
$('btn_timer_stop').onclick = () => {
clearInterval(timerState.interval);
const idx = State.activeIntervals.indexOf(timerState.interval);
if (idx > -1) State.activeIntervals.splice(idx, 1);
$('btn_timer_start').disabled = false;
$('btn_timer_pause').disabled = true;
$('btn_timer_resume').disabled = true;
$('btn_timer_stop').disabled = true;
announce('Timer stopped');
log(2, 'Timer stopped');
};
$('log_level').onchange = () => {
State.logLevel = parseInt($('log_level').value);
updateDebugConsole();
};
$('log_search').oninput = updateDebugConsole;
$('btn_clear_logs').onclick = () => {
State.logMessages = [];
updateDebugConsole();
announce('Debug console cleared');
log(2, 'Debug console cleared');
};
$('btn_export_logs').onclick = () => {
let logText = '';
State.logMessages.forEach(entry => {
let levelText = 'INFO';
if (entry.level === 1) levelText = 'TRACE';
else if (entry.level === 3) levelText = 'WARN';
else if (entry.level === 4) levelText = 'ERROR';
else if (entry.level === 5) levelText = 'EXCPT';
logText += `[${entry.timestamp}] [${levelText}] ${entry.message}\n`;
});
const blob = new Blob([logText], {type: 'text/plain'});
const url = URL.createObjectURL(blob);
const a = document.createElement('a');
a.href = url;
a.download = `debug_log_${new Date().toISOString().replace(/[:.]/g, '-')}.txt`;
a.click();
URL.revokeObjectURL(url);
announce('Logs exported to file');
log(2, 'Logs exported to file');
};
$('cpl_search').oninput = searchCPL;
document.querySelectorAll('#cpl a[data-category]').forEach(link => {
link.onclick = () => {
document.querySelectorAll('#cpl a[data-category]').forEach(l => l.classList.remove('active'));
link.classList.add('active');
const cat = link.dataset.category;
filterCPL(cat);
};
link.onkeydown = (e) => {
if (e.key === 'Enter' || e.key === ' ') {
e.preventDefault();
document.querySelectorAll('#cpl a[data-category]').forEach(l => l.classList.remove('active'));
link.classList.add('active');
const cat = link.dataset.category;
filterCPL(cat);
}
};
});
$('btn_add_text').onclick = () => {
$('dlg_text_value').value = 'Sample Text';
$('dlg_text_x').value = 50 + State.labelElements.length * 20;
$('dlg_text_y').value = 50 + State.labelElements.length * 15;
$('dlg_add_text').showModal();
};
$('dlg_add_text').onclose = function() {
if (this.returnValue === 'ok') {
const elem = {
type: 'text',
x: parseInt($('dlg_text_x').value) || 50,
y: parseInt($('dlg_text_y').value) || 50,
width: 100,
height: 30,
text: $('dlg_text_value').value || 'Sample Text',
font: $('dlg_text_font').value || 'TEXT 3',
barcodeType: '',
thickness: 2,
radius: 0,
zIndex: State.labelElements.length
};
State.labelElements.push(elem);
State.selectedElement = elem;
renderCanvas();
updateProperties();
announce('Added text element to canvas');
log(1, 'Added text element: ' + elem.text);
}
};
$('btn_add_barcode').onclick = () => {
$('dlg_bc_data').value = '12345678';
$('dlg_bc_x').value = 50 + State.labelElements.length * 20;
$('dlg_bc_y').value = 100 + State.labelElements.length * 15;
$('dlg_add_barcode').showModal();
};
$('dlg_add_barcode').onclose = function() {
if (this.returnValue === 'ok') {
const bcType = $('dlg_bc_type').value;
const is2D = ['QR', 'DATAMATRIX', 'PDF417'].includes(bcType);
const elem = {
type: 'barcode',
x: parseInt($('dlg_bc_x').value) || 50,
y: parseInt($('dlg_bc_y').value) || 100,
width: is2D ? 80 : 150,
height: is2D ? 80 : parseInt($('dlg_bc_height').value) || 50,
text: $('dlg_bc_data').value || '12345678',
font: '',
barcodeType: bcType,
narrowBar: parseInt($('dlg_bc_narrow').value) || 2,
thickness: 2,
radius: 0,
zIndex: State.labelElements.length
};
State.labelElements.push(elem);
State.selectedElement = elem;
renderCanvas();
updateProperties();
announce('Added barcode element to canvas');
log(1, 'Added barcode: ' + bcType + ' = ' + elem.text);
}
};
$('btn_add_box').onclick = () => addLabelElement('box');
$('btn_add_line').onclick = () => addLabelElement('line');
$('btn_add_circle').onclick = () => addLabelElement('circle');
$('btn_add_ellipse').onclick = () => addLabelElement('ellipse');
$('btn_clear_canvas').onclick = clearCanvas;
$('btn_generate_cpl').onclick = generateCPL;
$('btn_send_label').onclick = () => {
generateCPL();
announce('Label sent to selected printer');
log(2, 'Label sent to selected printer');
};
$('btn_save_label').onclick = () => {
announce('Save label');
log(2, 'Label saved');
};
$('btn_load_label').onclick = () => {
announce('Load label');
log(2, 'Label loaded');
};
const canvas = $('canvas_el');
canvas.onmousedown = (e) => {
hideContextMenu();
const rect = canvas.getBoundingClientRect();
const x = e.clientX - rect.left;
const y = e.clientY - rect.top;
if (State.selectedElement) {
const handle = getResizeHandle(State.selectedElement, x, y);
if (handle) {
canvasDragState.resizing = true;
canvasDragState.resizeHandle = handle;
canvasDragState.startX = x;
canvasDragState.startY = y;
canvasDragState.origX = State.selectedElement.x;
canvasDragState.origY = State.selectedElement.y;
canvasDragState.origW = State.selectedElement.width || State.selectedElement.radius * 2;
canvasDragState.origH = State.selectedElement.height || State.selectedElement.radius * 2;
return;
}
}
const elem = getElementAtPoint(x, y);
State.selectedElement = elem;
renderCanvas();
updateProperties();
if (elem) {
canvasDragState.dragging = true;
canvasDragState.startX = x;
canvasDragState.startY = y;
canvasDragState.origX = elem.x;
canvasDragState.origY = elem.y;
}
};
canvas.onmousemove = (e) => {
const rect = canvas.getBoundingClientRect();
const x = e.clientX - rect.left;
const y = e.clientY - rect.top;
if (State.selectedElement && getResizeHandle(State.selectedElement, x, y)) {
canvas.style.cursor = 'nwse-resize';
} else if (getElementAtPoint(x, y)) {
canvas.style.cursor = 'move';
} else {
canvas.style.cursor = 'default';
}
if (canvasDragState.dragging && State.selectedElement) {
const dx = x - canvasDragState.startX;
const dy = y - canvasDragState.startY;
State.selectedElement.x = Math.max(0, canvasDragState.origX + dx);
State.selectedElement.y = Math.max(0, canvasDragState.origY + dy);
renderCanvas();
updateProperties();
}
if (canvasDragState.resizing && State.selectedElement) {
const dx = x - canvasDragState.startX;
const dy = y - canvasDragState.startY;
const handle = canvasDragState.resizeHandle;
const elem = State.selectedElement;
if (elem.type === 'circle') {
const newRadius = Math.max(10, (canvasDragState.origW / 2) + (dx + dy) / 2);
elem.radius = newRadius;
} else {
if (handle.includes('e')) elem.width = Math.max(20, canvasDragState.origW + dx);
if (handle.includes('w')) {
elem.x = canvasDragState.origX + dx;
elem.width = Math.max(20, canvasDragState.origW - dx);
}
if (handle.includes('s')) elem.height = Math.max(10, canvasDragState.origH + dy);
if (handle.includes('n')) {
elem.y = canvasDragState.origY + dy;
elem.height = Math.max(10, canvasDragState.origH - dy);
}
}
renderCanvas();
updateProperties();
}
};
canvas.onmouseup = () => {
canvasDragState.dragging = false;
canvasDragState.resizing = false;
};
canvas.onmouseleave = () => {
canvasDragState.dragging = false;
canvasDragState.resizing = false;
};
canvas.onwheel = (e) => {
if (State.selectedElement) {
e.preventDefault();
const delta = e.deltaY > 0 ? -5 : 5;
const elem = State.selectedElement;
if (elem.type === 'circle') {
elem.radius = Math.max(10, elem.radius + delta);
} else if (elem.type !== 'line') {
elem.width = Math.max(20, elem.width + delta);
elem.height = Math.max(10, elem.height + delta * (elem.height / elem.width || 1));
}
renderCanvas();
updateProperties();
}
};
canvas.oncontextmenu = (e) => {
e.preventDefault();
const rect = canvas.getBoundingClientRect();
const x = e.clientX - rect.left;
const y = e.clientY - rect.top;
const elem = getElementAtPoint(x, y);
if (elem) {
State.selectedElement = elem;
renderCanvas();
updateProperties();
showContextMenu(e.clientX, e.clientY);
} else {
hideContextMenu();
}
};
document.addEventListener('click', (e) => {
if (!e.target.closest('#canvas_context_menu')) {
hideContextMenu();
}
});
$('btn_extract_image').onclick = () => {
announce('Image extraction started');
log(2, 'Image extraction started');
const prog = $('img_prog');
let w = 0;
const interval = setInterval(() => {
w += 2;
prog.style.width = w + '%';
if (w >= 100) {
clearInterval(interval);
const idx = State.activeIntervals.indexOf(interval);
if (idx > -1) State.activeIntervals.splice(idx, 1);
$('img_data').value = '00400000: 4E 71 4E 71 FF FF 01 02 03 04 05 06 07 08\n00400010: 10 11 12 13 14 15 16 17 18 19 1A 1B 1C 1D\n00400020: A5 B6 C7 D8 E9 FA 0B 1C 2D 3E 4F 5A 6B 7C\n...';
announce('Image extraction completed');
log(2, 'Image extraction completed');
}
}, 30);
State.activeIntervals.push(interval);
};
$('btn_save_image').onclick = () => {
announce('Image saved: printer_image.bin');
log(2, 'Image saved: printer_image.bin');
};
$('btn_load_image_file').onclick = () => {
$('img_file').value = 'printer_image.bin';
announce('Image file loaded');
log(2, 'Image file loaded');
};
$('btn_deploy_image').onclick = () => {
if (!confirm('This will overwrite all data on target printer(s). Continue?')) return;
announce('Image deployment started - WARNING: This will overwrite all data');
log(3, 'Image deployment started - WARNING: This will overwrite all data');
const prog = $('deploy_prog');
let w = 0;
const interval = setInterval(() => {
w += 1;
prog.style.width = w + '%';
if (w >= 100) {
clearInterval(interval);
const idx = State.activeIntervals.indexOf(interval);
if (idx > -1) State.activeIntervals.splice(idx, 1);
announce('Image deployed successfully. Reset printer(s).');
log(2, 'Image deployed successfully');
}
}, 40);
State.activeIntervals.push(interval);
};
$('btn_verify_image').onclick = () => {
announce('Image verification: PASS - Checksums match');
log(2, 'Image verification: PASS');
};
$('btn_enter_bootloader').onclick = () => {
$('bootloader_status').innerHTML = '<div style="color:#008000;"> Bootloader command sent</div><div style="font-size:8px; margin-top:5px;">Printer in recovery mode.</div>';
announce('Bootloader command sent');
log(2, 'Bootloader command sent');
};
$('btn_check_bootloader').onclick = () => {
$('bootloader_status').innerHTML = '<div style="color:var(--text-secondary);">Checking...</div>';
announce('Checking bootloader status...');
log(2, 'Checking bootloader status...');
setTimeout(() => {
$('bootloader_status').innerHTML = '<div style="color:#008000;"> Bootloader Active</div><div style="font-size:8px;">Version: v2.4.1<br>Ready for upload</div>';
announce('Bootloader active - version v2.4.1');
log(2, 'Bootloader active - version v2.4.1');
}, 500);
};
$('btn_send_bootloader_cmd').onclick = () => {
const cmd = prompt('Enter bootloader command:');
if (cmd) {
$('bootloader_status').innerHTML += `<div style="margin-top:5px;">Sent: ${escapeHtml(cmd)}</div>`;
announce(`Bootloader command sent: ${cmd}`);
log(2, `Bootloader command sent: ${cmd}`);
}
};
$('theme_selector').onchange = function() {
applyTheme(this.value);
};
$('layout_selector').onchange = function() {
applyLayout(this.value);
};
$('chk_borders').onchange = function() {
applyBorders(this.checked);
};
// Setup Automated Tests handlers
setupAutoTestHandlers();
$('status_box').onclick = toggleStatusMenu;
$('status_box').onkeydown = (e) => {
if (e.key === 'Enter' || e.key === ' ') {
e.preventDefault();
toggleStatusMenu(e);
}
};
const statusMenuItems = $('status_menu').querySelectorAll('.status-menu-item');
statusMenuItems[0].onclick = (e) => { e.stopPropagation(); connectAllPrinters(); };
statusMenuItems[1].onclick = (e) => { e.stopPropagation(); disconnectAllPrinters(); };
statusMenuItems[2].onclick = (e) => { e.stopPropagation(); connectSelectedPrinters(); };
statusMenuItems[3].onclick = (e) => { e.stopPropagation(); disconnectSelectedPrinters(); };
$('chk_heart').onchange = function() {
if (this.checked) {
State.heartbeatInterval = setInterval(() => {
log(1, 'Heartbeat: Checking printer status...');
updatePrinterStatus();
}, 5000);
announce('Heartbeat monitoring enabled');
log(2, 'Heartbeat monitoring enabled (5 sec interval)');
} else {
if (State.heartbeatInterval) {
clearInterval(State.heartbeatInterval);
State.heartbeatInterval = null;
}
announce('Heartbeat monitoring disabled');
log(2, 'Heartbeat monitoring disabled');
}
};
['print_target', 'pos_target', 'fonts_target', 'prof_target', 'firm_target', 'img_src', 'img_target', 'script_target', 'pcl_target'].forEach(id => {
const elem = $(id);
if (elem) {
elem.onclick = () => toggleMultiSelect(id);
elem.onkeydown = (e) => {
if (e.key === 'Enter' || e.key === ' ') {
e.preventDefault();
toggleMultiSelect(id);
}
};
}
});
document.addEventListener('click', (e) => {
if (!e.target.closest('.multi-select-dropdown')) {
document.querySelectorAll('.multi-select-options').forEach(opt => {
opt.classList.remove('visible');
});
}
if (!e.target.closest('.status-box')) {
$('status_menu').classList.remove('visible');
}
});
}
function toggleStatusMenu(e) {
e.stopPropagation();
const menu = $('status_menu');
menu.classList.toggle('visible');
}
function applyRole(role) {
State.currentRole = role;
document.body.dataset.role = role;
const roleInfo = ROLES[role];
$('app_subtitle').textContent = roleInfo.subtitle;
document.title = `Cognitive LLC - ${roleInfo.subtitle}`;
renderTabs();
if (role === 'server') {
document.querySelectorAll('.workspace').forEach(e => {
e.classList.remove('visible');
e.setAttribute('aria-hidden', 'true');
});
$('server_dashboard').classList.add('visible');
$('server_dashboard').setAttribute('aria-hidden', 'false');
startServerDashboard();
} else {
stopServerDashboard();
$('server_dashboard').classList.remove('visible');
nav(roleInfo.tabs[0] || 'conn');
}
saveState();
announce(`Role changed to ${roleInfo.name}`);
log(2, `Role changed to: ${roleInfo.name}`);
}
function startServerDashboard() {
if (State.serverDashboardInterval) return;
State.serverUptime = Math.floor(Math.random() * 86400 * 30);
State.networkData = Array(20).fill(0).map(() => Math.random() * 100);
updateServerDashboard();
State.serverDashboardInterval = setInterval(updateServerDashboard, 2000);
State.activeIntervals.push(State.serverDashboardInterval);
}
function stopServerDashboard() {
if (State.serverDashboardInterval) {
clearInterval(State.serverDashboardInterval);
const idx = State.activeIntervals.indexOf(State.serverDashboardInterval);
if (idx > -1) State.activeIntervals.splice(idx, 1);
State.serverDashboardInterval = null;
}
}
function updateServerDashboard() {
State.serverUptime += 2;
const days = Math.floor(State.serverUptime / 86400);
const hours = Math.floor((State.serverUptime % 86400) / 3600);
$('stat_uptime').textContent = `${days}d ${hours}h`;
$('stat_jobs_today').textContent = Math.floor(Math.random() * 500 + 200);
$('stat_response').textContent = Math.floor(Math.random() * 50 + 10) + 'ms';
$('stat_success').textContent = (95 + Math.random() * 5).toFixed(1) + '%';
const cpu = Math.random() * 60 + 20;
const mem = Math.random() * 40 + 40;
const disk = Math.random() * 20 + 50;
$('gauge_cpu').setAttribute('stroke-dasharray', `${cpu}, 100`);
$('gauge_cpu_text').textContent = Math.floor(cpu) + '%';
$('gauge_mem').setAttribute('stroke-dasharray', `${mem}, 100`);
$('gauge_mem_text').textContent = Math.floor(mem) + '%';
$('gauge_disk').setAttribute('stroke-dasharray', `${disk}, 100`);
$('gauge_disk_text').textContent = Math.floor(disk) + '%';
State.networkData.shift();
State.networkData.push(Math.random() * 100);
const netChart = $('network_chart');
netChart.innerHTML = '';
const barWidth = netChart.offsetWidth / 20;
State.networkData.forEach((val, i) => {
const bar = document.createElement('div');
bar.className = 'chart-bar';
bar.style.left = (i * barWidth + 2) + 'px';
bar.style.height = val + '%';
bar.style.width = Math.max(barWidth - 4, 4) + 'px';
netChart.appendChild(bar);
});
$('net_in').textContent = Math.floor(Math.random() * 500 + 100);
$('net_out').textContent = Math.floor(Math.random() * 300 + 50);
const printerGrid = $('server_printer_grid');
const connectedCount = Math.floor(Math.random() * 15 + 5);
$('printer_count').textContent = connectedCount;
printerGrid.innerHTML = '';
for (let i = 0; i < connectedCount; i++) {
const status = Math.random() > 0.2 ? 'healthy' : (Math.random() > 0.5 ? 'warning' : 'critical');
const tile = document.createElement('div');
tile.className = 'printer-tile';
tile.innerHTML = `<div class="printer-tile-icon"></div><span class="status-indicator status-${status}"></span>P${i+1}`;
printerGrid.appendChild(tile);
}
const jobsChart = $('jobs_chart');
const complete = Math.floor(Math.random() * 200 + 100);
const pending = Math.floor(Math.random() * 30 + 5);
const failed = Math.floor(Math.random() * 5);
$('jobs_complete').textContent = complete;
$('jobs_pending').textContent = pending;
$('jobs_failed').textContent = failed;
const total = complete + pending + failed;
jobsChart.innerHTML = `<div style="display:flex;height:100%;align-items:flex-end;justify-content:space-around;padding:10px;">
<div style="width:30%;background:var(--status-green);height:${complete/total*100}%;border-radius:3px 3px 0 0;"></div>
<div style="width:30%;background:#f0ad4e;height:${pending/total*100}%;border-radius:3px 3px 0 0;"></div>
<div style="width:30%;background:var(--status-red);height:${Math.max(failed/total*100, 5)}%;border-radius:3px 3px 0 0;"></div>
</div>`;
const openTickets = Math.floor(Math.random() * 20 + 5);
const closedTickets = Math.floor(Math.random() * 100 + 50);
$('tickets_open').textContent = openTickets;
$('tickets_closed').textContent = closedTickets;
const ticketList = $('ticket_list');
ticketList.innerHTML = '';
const priorities = ['high', 'medium', 'low'];
const ticketTitles = ['Printer offline', 'Paper jam', 'Config issue', 'Network error', 'Firmware update', 'Calibration needed'];
for (let i = 0; i < 5; i++) {
const priority = priorities[Math.floor(Math.random() * 3)];
const title = ticketTitles[Math.floor(Math.random() * ticketTitles.length)];
const item = document.createElement('div');
item.className = `ticket-item ticket-priority-${priority}`;
item.innerHTML = `<span>#${1000 + i}: ${title}</span><span style="text-transform:uppercase;font-size:8px;">${priority}</span>`;
ticketList.appendChild(item);
}
const errorRate = Math.random() * 3;
const errorStatus = $('error_status');
errorStatus.className = 'status-indicator ' + (errorRate < 1 ? 'status-healthy' : (errorRate < 2 ? 'status-warning' : 'status-critical'));
$('error_rate_text').textContent = errorRate.toFixed(2) + '% error rate';
const errorChart = $('error_chart');
errorChart.innerHTML = `<div style="display:flex;flex-direction:column;height:100%;justify-content:space-around;padding:5px;">`;
for (let h = 0; h < 6; h++) {
const hourRate = Math.random() * 3;
const color = hourRate < 1 ? 'var(--status-green)' : (hourRate < 2 ? '#f0ad4e' : 'var(--status-red)');
errorChart.innerHTML += `<div style="display:flex;align-items:center;gap:5px;font-size:9px;"><span style="width:40px;">${(h*4)}:00</span><div style="flex:1;height:8px;background:var(--border-light);border-radius:4px;"><div style="width:${hourRate/3*100}%;height:100%;background:${color};border-radius:4px;"></div></div></div>`;
}
errorChart.innerHTML += '</div>';
const logFeed = $('server_log');
const logMessages = [
'[INFO] Print job #4521 completed successfully',
'[INFO] Printer P3 connected',
'[DEBUG] Heartbeat received from P7',
'[WARN] Low paper on Printer P12',
'[INFO] Configuration backup created',
'[DEBUG] Network latency: 23ms',
'[INFO] User admin logged in',
'[ERROR] Connection timeout on P5'
];
const timestamp = new Date().toISOString().substring(11, 19);
const msg = logMessages[Math.floor(Math.random() * logMessages.length)];
const entry = document.createElement('div');
entry.className = 'log-entry';
entry.textContent = `[${timestamp}] ${msg}`;
logFeed.appendChild(entry);
if (logFeed.children.length > 50) logFeed.removeChild(logFeed.firstChild);
logFeed.scrollTop = logFeed.scrollHeight;
}
function updateWifiPanelVisibility() {
const connType = document.querySelector('input[name="ct"]:checked');
const wifiPanel = $('wifi_panel');
if (wifiPanel) {
if (connType && connType.value === 'net') {
wifiPanel.classList.remove('hidden');
wifiPanel.style.display = '';
} else {
wifiPanel.classList.add('hidden');
wifiPanel.style.display = 'none';
}
}
}
function init() {
log(2, 'Application initializing...');
const stateLoaded = loadState();
if (!stateLoaded || State.printers.length === 0) {
for (let i = 0; i < 3; i++) {
addPrinter();
}
}
const savedRole = localStorage.getItem('cognitivetpg_role') || 'admin';
State.currentRole = savedRole;
$('role_selector').value = savedRole;
document.body.dataset.role = savedRole;
renderTabs();
initMultiSelects();
updatePrinterList();
updatePrinterDropdowns();
updatePrinterStatus();
filterCPL('all');
const allCmdLink = document.querySelector('#cpl a[data-category="all"]');
if (allCmdLink) allCmdLink.classList.add('active');
setupEventHandlers();
renderCanvas();
updateWifiPanelVisibility();
applyRole(savedRole);
// Enable horizontal mouse wheel scrolling in tab folder
const tabFolder = $('tab-bar');
if (tabFolder) {
tabFolder.addEventListener('wheel', function(e) {
if (e.deltaY !== 0) {
e.preventDefault();
this.scrollLeft += e.deltaY * 2;
}
}, { passive: false });
}
// Maintain square aspect ratio on window resize
function maintainAspectRatio() {
const wrapper = document.querySelector('.app-wrapper');
if (wrapper) {
const viewportMin = Math.min(window.innerWidth, window.innerHeight);
const size = Math.min(viewportMin * 0.88, viewportMin * 0.88);
document.documentElement.style.setProperty('--container-size', `${size}px`);
}
}
maintainAspectRatio();
window.addEventListener('resize', maintainAspectRatio);
log(2, 'Application initialized successfully');
announce('Application ready');
}
// Expose key functions to global scope for C++ backend integration
window.CAdmin = {
    init: init,
    renderTabs: renderTabs,
    nav: nav,
    applyTheme: applyTheme,
    applyLayout: applyLayout,
    applyBorders: applyBorders,
    applyRole: applyRole,
    addPrinter: addPrinter,
    updatePrinterList: updatePrinterList,
    log: log,
    // Automated test functions
    AutoTest: AutoTest,
    runAutoTests: () => AutoTest.runAllTests(),
    stopAutoTests: () => AutoTest.stop()
};
if (document.readyState === 'loading') {
document.addEventListener('DOMContentLoaded', init);
} else {
init();
}
window.addEventListener('beforeunload', () => {
clearIntervals();
saveState();
});
})();
</script>
</body>
</html>
````
````CPL_Reference
# Comprehensive CPL (Cognitive Programming Language) Command Reference Guide
## Table of Contents
1. [Header and Format Commands](#header-and-format-commands)
2. [Printing Control Commands](#printing-control-commands)
3. [Drawing and Graphics Commands](#drawing-and-graphics-commands)
4. [Barcode Commands](#barcode-commands)
5. [Text and Font Commands](#text-and-font-commands)
6. [Variable and Data Management Commands](#variable-and-data-management-commands)
7. [Printer Configuration Variables](#printer-configuration-variables)
8. [Object and Storage Commands](#object-and-storage-commands)
9. [Diagnostic and Internal Bang Commands](#diagnostic-and-internal-bang-commands)
10. [Menu and User Interface Commands](#menu-and-user-interface-commands)
11. [Network and Communication Commands](#network-and-communication-commands)
12. [Bluetooth Commands](#bluetooth-commands)
13. [Time and Date Commands](#time-and-date-commands)
14. [Query Commands](#query-commands)
---
## Header and Format Commands
Commands for defining label formats, headers, and storage/recall of formats. Sorted lexicographically.
### BACKGROUND HEADER
**Command name:** `!# n LAR Length Quantity` or `BACKGROUND HEADER`
**Alternative formats:** None
**Parameters (Inputs):**
- `n` - Head1Range (fixed value, often 0)
- `LAR` - Head2Range (length adjustment range)
- `Length` - Head3Range (label length)
- `Quantity` - Head4Range (number of labels)
**Outputs (Return values):** None (background configuration)
**Usage examples:**
```
!# 0 100 200 5
STRING 12x16 10 10 Background Label
END
```
**Description:** Sets background header for repeated printing on every label.
---
### CLEAR BACKGROUND HEADER
**Command name:** `!* n LAR Length Quantity` or `CLEAR BACKGROUND HEADER`
**Alternative formats:** None
**Parameters (Inputs):**
- `n` - Head1Range (fixed value, often 0)
- `LAR` - Head2Range (length adjustment range)
- `Length` - Head3Range (label length)
- `Quantity` - Head4Range (number of labels)
**Outputs (Return values):** None (background clearing)
**Usage examples:**
```
!* 0 100 200 1
STRING 12x16 10 10 Cleared Background
END
```
**Description:** Clears previously set background header.
---
### ENHANCED END
**Command name:** `ENHEND` or `ENHANCED END`
**Alternative formats:** None (virtual command - double-delimiter in enhanced stored format)
**Parameters (Inputs):** None
**Outputs (Return values):** Enhanced label termination
**Usage examples:**
```
! 0 100 100 1
STRING 12x16 10 10 Enhanced End
ENHEND
```
**Description:** Enhanced end command for special label processing in stored formats.
---
### END
**Command name:** `END`
**Alternative formats:** None
**Parameters (Inputs):** None
**Outputs (Return values):** Label termination
**Usage examples:**
```
! 0 100 100 1
STRING 12x16 10 10 Hello World
END
```
**Description:** Terminates a label format and initiates printing.
---
### END NO PRINT
**Command name:** `NOPRINTEND` or `END NO PRINT`
**Alternative formats:** `ENDNOPRINT`
**Parameters (Inputs):** None
**Outputs (Return values):** Label termination without printing
**Usage examples:**
```
! 0 100 100 1
STRING 12x16 10 10 Not Printed
NOPRINTEND
```
**Description:** Terminates label format without initiating printing.
---
### FOREGROUND GRAPHIC MODE
**Command name:** `@ header line` or `FOREGROUND GRAPHIC MODE`
**Alternative formats:** None (implicit in header)
**Parameters (Inputs):**
- Header parameters (e.g., `0 LAR LEN Quantity`)
**Outputs (Return values):** Foreground graphic mode setting
**Usage examples:**
```
!@ 0 100 200 1
[foreground graphic commands]
END
```
**Description:** Sets foreground graphic mode for header line rendering.
---
### HEADER
**Command name:** `! n LAR Length Quantity` or `HEADER`
**Alternative formats:** Standard header line only
**Parameters (Inputs):**
- `n` - Head1Range (fixed value, often 0)
- `LAR` - Head2Range (length adjustment range)
- `Length` - Head3Range (label length)
- `Quantity` - Head4Range (number of labels)
**Outputs (Return values):** None (configuration command)
**Usage examples:**
```
! 0 100 100 0
String 18x23 10 50 Hello World!
END
```
**Description:** Defines the header parameters for a label format, including number of labels, length adjustment, label length, and quantity.
---
### HEADER AUTO
**Command name:** `!A` or `HEADER AUTO`
**Alternative formats:** None
**Parameters (Inputs):** None
**Outputs (Return values):** None (configuration command)
**Usage examples:**
```
!A
STRING 12x16 10 10 Auto Header Test
END
```
**Description:** Automatic header configuration that calculates optimal parameters.
---
### HEADER PLUS
**Command name:** `!+ 0 LAR len quantity` or `HEADER PLUS`
**Alternative formats:** None
**Parameters (Inputs):**
- `0` - Fixed value
- `LAR` - Length adjustment range
- `len` - Label length
- `quantity` - Number of labels
**Outputs (Return values):** None (configuration command)
**Usage examples:**
```
!+ 0 100 200 5
STRING 12x16 10 10 Test Label
END
```
**Description:** Extended header command with additional parameters for label formatting.
---
### PASSWORD HEADER
**Command name:** `!Pxxy 0 LAR LEN Quantity` or `PASSWORD HEADER`
**Alternative formats:** None
**Parameters (Inputs):**
- `xxy` - Password digits (e.g., 123)
- `0` - Fixed value
- `LAR` - Head2Range (length adjustment range)
- `LEN` - Head3Range (label length)
- `Quantity` - Head4Range (number of labels)
**Outputs (Return values):** None (protected header)
**Usage examples:**
```
!P123 0 100 200 1
STRING 12x16 10 10 Protected Label
END
```
**Description:** Sets password-protected header for secure label formats.
---
### RECALL FORMAT
**Command name:** `RECALL FORMAT formatname [variable data]` or `RECALL FORMAT`
**Alternative formats:** None
**Parameters (Inputs):**
- `formatname` - Name of stored format
- `[variable data]` - Data for variable fields (optional)
**Outputs (Return values):** None (format execution)
**Usage examples:**
```
RECALL FORMAT LABEL1
END
```
```
RECALL FORMAT LABEL2 "Product Name","BARCODE123"
END
```
**Description:** Recalls and executes stored label format, optionally supplying variable data for enhanced formats.
---
### STORE ENHANCED FORMAT
**Command name:** `STORE ENHANCED FORMAT formatname` or `STORE ENHANCED FORMAT`
**Alternative formats:** None
**Parameters (Inputs):**
- `formatname` - Unique format identifier
- `[enhanced format data follows]` - Complete label format with variables
**Outputs (Return values):** Storage confirmation
**Usage examples:**
```
STORE ENHANCED FORMAT LABEL2
! 0 100 200 1
STRING 12x16 10 10 $FIELD1$
BARCODE CODE39 10 40 30 $FIELD2$
END
```
**Description:** Stores enhanced label format with variable field placeholders.
---
### STORE FORMAT
**Command name:** `STORE FORMAT formatname` or `STORE FORMAT`
**Alternative formats:** None
**Parameters (Inputs):**
- `formatname` - Unique format identifier
- `[format data follows]` - Complete label format definition
**Outputs (Return values):** Storage confirmation
**Usage examples:**
```
STORE FORMAT LABEL1
! 0 100 200 1
STRING 12x16 10 10 Stored Format
BARCODE CODE39 10 40 30 STOREDLBL
END
```
**Description:** Stores complete label format in memory for later recall.
---
## Printing Control Commands
Commands for controlling print flow, pauses, quantities, and adjustments. Sorted lexicographically.
### ADJUST
**Command name:** `ADJUST nnn` or `A nnn`
**Alternative formats:** `ADJUST ID nnn` or `A ID nnn`
**Parameters (Inputs):**
- `ID` (optional) - Variable identifier (IDSize)
- `nnn` - Adjustment value (IntRange, can be positive or negative)
**Outputs (Return values):** None (modification command)
**Usage examples:**
```
! 0 100 200 3
BARCODE CODE39 150 30 30 TEST20
ADJUST -01
STRING 12X16 150 65 ADJUST20
ADJUST 01
END
```
**Description:** Increments or decrements a variable value or numeric data on the preceding command line. Used for serial numbering and data progression.
---
### ADJUST DUPLICATE
**Command name:** `ADJUST_DUP nnn` or `AP nnn`
**Alternative formats:** None
**Parameters (Inputs):**
- `nnn` - Number of duplicate labels (UIntRange)
**Outputs (Return values):** None (print control command)
**Usage examples:**
```
! 0 100 50 2
STRING 8X8 0 0 1000
ADJUST 0001
ADJUST_DUP 2
END
```
**Description:** Prints non-incremented duplicates of incremented labels when used with ADJUST command.
---
### AREA CLEAR
**Command name:** `AREA_CLEAR x y w h` or `AR x y w h`
**Alternative formats:** None
**Parameters (Inputs):**
- `x` - X coordinate (BoxRange)
- `y` - Y coordinate (BoxRange)
- `w` - Width (BoxRange)
- `h` - Height (BoxRange)
**Outputs (Return values):** None (drawing command)
**Usage examples:**
```
AREA_CLEAR 50 50 200 100
STRING 12x16 60 60 Cleared Area Text
END
```
**Description:** Clears a rectangular area of a label for replotting.
---
### BACKGROUND GRAPHIC MODE
**Command name:** `# header line` or `BACKGROUND GRAPHIC MODE`
**Alternative formats:** None (implicit in background header)
**Parameters (Inputs):** Background header parameters
**Outputs (Return values):** Background graphic mode setting
**Usage examples:**
```
!# 0 100 200 5
[graphic commands for background]
END
```
**Description:** Sets background graphic mode for header line rendering.
---
### DELIMIT
**Command name:** `DELIMIT character` or `D character`
**Alternative formats:** None
**Parameters (Inputs):**
- `character` - Delimiter character
**Outputs (Return values):** None (format control)
**Usage examples:**
```
DELIMIT ,
STRING 12x16 10 10 Field1,Field2,Field3
END
```
**Description:** Sets field delimiter character for data parsing.
---
### HALT
**Command name:** `HALT`
**Alternative formats:** None
**Parameters (Inputs):** None
**Outputs (Return values):** Print pause
**Usage examples:**
```
! 0 100 100 3
STRING 12x16 10 10 Label 1
HALT
STRING 12x16 10 30 Label 2
END
```
**Description:** Pauses printing after current label, waiting for operator intervention.
---
### INDEX
**Command name:** `INDEX` or `I`
**Alternative formats:** None
**Parameters (Inputs):** None
**Outputs (Return values):** None (index control)
**Usage examples:**
```
INDEX
STRING 12x16 10 10 Indexed Label
END
```
**Description:** Enables label indexing for this label.
---
### JUSTIFY
**Command name:** `JUSTIFY where` or `J where`
**Alternative formats:** None
**Parameters (Inputs):**
- `where` - Justification: LEFT, CENTER, RIGHT, L, C, or R
**Outputs (Return values):** None (text alignment)
**Usage examples:**
```
JUSTIFY CENTER
STRING 12x16 10 10 Centered Text
END
```
**Description:** Sets text justification for subsequent text commands.
---
### MULTIPLE
**Command name:** `MULTIPLE nnn` or `M nnn`
**Alternative formats:** None
**Parameters (Inputs):**
- `nnn` - Multiple factor (MultipleRange: 2-9)
**Outputs (Return values):** None (print control)
**Usage examples:**
```
MULTIPLE 2
STRING 12x16 10 10 Double Size
END
```
**Description:** Multiplies subsequent dimensions by specified factor.
---
### NOINDEX
**Command name:** `NOINDEX` or `N`
**Alternative formats:** None
**Parameters (Inputs):** None
**Outputs (Return values):** None (index control)
**Usage examples:**
```
NOINDEX
STRING 12x16 10 10 Non-Indexed Label
END
```
**Description:** Disables label indexing for this label.
---
### OFFSET
**Command name:** `OFFSET ...`
**Alternative formats:** None
**Parameters (Inputs):** Various (e.g., `10 20` for x,y offsets)
**Outputs (Return values):** None (positioning)
**Usage examples:**
```
OFFSET 10 20
STRING 12x16 0 0 Offset Text
END
```
**Description:** Sets coordinate offset for subsequent commands (not supported in all models).
---
### PITCH
**Command name:** `PITCH pitch` or `P pitch`
**Alternative formats:** `VARIABLE PITCH pitch`
**Parameters (Inputs):**
- `pitch` - Print pitch setting (enumPitch: 100/200 for 203 DPI, 150/300 for 300 DPI)
**Outputs (Return values):** None (print density setting)
**Usage examples:**
```
PITCH 200
STRING 12x16 10 10 200 DPI Text
END
```
**Description:** Sets the print pitch/density for the printhead.
---
### PROMPTS
**Command name:** `PROMPTS ON/OFF/?`
**Alternative formats:** None
**Parameters (Inputs):**
- `ON/OFF/?` - Prompt control setting
**Outputs (Return values):** Current prompt status if queried
**Usage examples:**
```
PROMPTS ON
STRING 12x16 10 10 Enter Data:
END
```
**Description:** Controls user prompting during label printing.
---
### QUANTITY
**Command name:** `QUANTITY nnn`
**Alternative formats:** None
**Parameters (Inputs):**
- `nnn` - Number of labels to print
**Outputs (Return values):** None (print control)
**Usage examples:**
```
! 0 100 100 1
STRING 12x16 10 10 Test Label
QUANTITY 10
END
```
**Description:** Specifies the number of labels to print.
---
### WIDTH
**Command name:** `WIDTH width` or `W width`
**Alternative formats:** `VARIABLE WIDTH width`
**Parameters (Inputs):**
- `width` - Label width in user units (WidthRange: 0-65535)
**Outputs (Return values):** None (width setting)
**Usage examples:**
```
WIDTH 400
STRING 12x16 10 10 Wide Label
END
```
**Description:** Sets the label width for formatting purposes.
---
## Drawing and Graphics Commands
Commands for shapes, fills, symbols, and graphic rendering/storage. Sorted lexicographically.
### DRAW BOX
**Command name:** `DRAW_BOX x y w h` or `BOX x y w h`
**Alternative formats:** None
**Parameters (Inputs):**
- `x` - X coordinate (BoxRange)
- `y` - Y coordinate (BoxRange)
- `w` - Width (BoxRange)
- `h` - Height (BoxRange)
**Outputs (Return values):** None (drawing command)
**Usage examples:**
```
DRAW_BOX 10 10 100 50
STRING 12x16 20 25 Box Text
END
```
**Description:** Draws a rectangular box outline.
---
### DRAW CIRCLE
**Command name:** `DRAW_CIRCLE x y radius` or `CIRCLE x y radius`
**Alternative formats:** None
**Parameters (Inputs):**
- `x` - Center X coordinate (BoxRange)
- `y` - Center Y coordinate (BoxRange)
- `radius` - Circle radius (BoxRange)
**Outputs (Return values):** None (drawing command)
**Usage examples:**
```
DRAW_CIRCLE 50 50 25
STRING 12x16 35 45 Circle
END
```
**Description:** Draws a circle outline.
---
### DRAW ELLIPSE
**Command name:** `DRAW_ELLIPSE x y w h` or `ELLIPSE x y w h`
**Alternative formats:** None
**Parameters (Inputs):**
- `x` - X coordinate (BoxRange)
- `y` - Y coordinate (BoxRange)
- `w` - Width (BoxRange)
- `h` - Height (BoxRange)
**Outputs (Return values):** None (drawing command)
**Usage examples:**
```
DRAW_ELLIPSE 10 10 80 40
STRING 12x16 30 25 Ellipse
END
```
**Description:** Draws an ellipse outline.
---
### DRAW LINE
**Command name:** `DRAW_LINE x1 y1 x2 y2` or `LINE x1 y1 x2 y2`
**Alternative formats:** Extended: `DRAW_LINE x y x2 y2 [t] [c]` or `DL x y x2 y2 [t] [c]`
**Parameters (Inputs):**
- `x1` - Start X coordinate (BoxRange)
- `y1` - Start Y coordinate (BoxRange)
- `x2` - End X coordinate (BoxRange)
- `y2` - End Y coordinate (BoxRange)
- `t` (optional) - Line thickness (ui32000_range)
- `c` (optional) - Color (enumColorValue: B or W)
**Outputs (Return values):** None (drawing command)
**Usage examples:**
```
DRAW_LINE 10 10 100 50
STRING 12x16 20 30 Line Text
END
```
```
DRAW_LINE 10 10 100 50 2 B
STRING 12x16 20 30 Thick Black Line
END
```
**Description:** Draws a straight line between two points, with optional thickness and color in extended mode.
---
### DRAW SYMBOL
**Command name:** `DRAW_SYMBOL x y symbol` or `SYMBOL x y symbol`
**Alternative formats:** None
**Parameters (Inputs):**
- `x` - X coordinate (BoxRange)
- `y` - Y coordinate (BoxRange)
- `symbol` - Symbol identifier (enumSymValue: A, B, C, D, E)
**Outputs (Return values):** None (symbol rendering)
**Usage examples:**
```
DRAW_SYMBOL 10 10 A
STRING 12x16 30 10 Symbol Text
END
```
**Description:** Draws a predefined symbol at specified coordinates.
---
### FILL BOX
**Command name:** `FILL_BOX x y w h` or `FBOX x y w h`
**Alternative formats:** None
**Parameters (Inputs):**
- `x` - X coordinate (BoxRange)
- `y` - Y coordinate (BoxRange)
- `w` - Width (BoxRange)
- `h` - Height (BoxRange)
**Outputs (Return values):** None (drawing command)
**Usage examples:**
```
FILL_BOX 10 10 100 50
STRING 12x16 20 25 Filled Box
END
```
**Description:** Draws a filled rectangular box.
---
### GRAPHIC
**Command name:** `GRAPHIC x y data` or `G x y data`
**Alternative formats:** Extended: `GRAPHIC x y width height data`
**Parameters (Inputs):**
- `x` - X coordinate (BoxRange)
- `y` - Y coordinate (BoxRange)
- `width` (extended) - Image width in dots
- `height` (extended) - Image height in dots
- `data` - Graphic data (raw hex/binary)
**Outputs (Return values):** None (graphic rendering)
**Usage examples:**
```
GRAPHIC 10 10 graphic_data
END
```
```
! 0 100 200 1
GRAPHIC 10 10 100 50 [binary data]
STRING 12x16 10 70 Direct Graphic
END
```
**Description:** Renders graphic data at specified coordinates, with extended dimensions.
---
### GRAPHIC RECALL
**Command name:** `!R G ID` or `GRAPHIC RECALL graphicname x y`
**Alternative formats:** `RECALL_GRAPHIC ID`
**Parameters (Inputs):**
- `ID` or `graphicname` - Graphic identifier
- `x` (extended) - X coordinate for placement
- `y` (extended) - Y coordinate for placement
**Outputs (Return values):** None (graphic recall)
**Usage examples:**
```
!R G LOGO
END
```
```
! 0 100 200 1
GRAPHIC RECALL LOGO1 10 10
STRING 12x16 10 120 Company Name
END
```
**Description:** Recalls a stored graphic for printing at specified position.
---
### GRAPHIC STORE
**Command name:** `!Sx storage Cm<crlf>graphic_data_file` or `GRAPHIC STORE graphicname width height data`
**Alternative formats:** `GRAPHIC_STORE`
**Parameters (Inputs):**
- `x` - Storage parameters
- `storage` - Storage location
- `graphicname` (extended) - Unique graphic identifier
- `width` (extended) - Image width in dots
- `height` (extended) - Image height in dots
- `graphic_data_file` or `data` - Graphic data file/raw data
**Outputs (Return values):** None (graphic storage)
**Usage examples:**
```
!S1 3 Cm
[graphic data]
END
```
```
GRAPHIC STORE LOGO1 200 100 [binary data]
END
```
**Description:** Stores graphic data in printer memory for later recall.
---
### RECALL GRAPHIC
**Command name:** `RECALL GRAPHIC ID` or `GRAPHIC RECALL`
**Alternative formats:** See GRAPHIC RECALL
**Parameters (Inputs):** See GRAPHIC RECALL
**Outputs (Return values):** See GRAPHIC RECALL
**Usage examples:** See GRAPHIC RECALL
**Description:** Alias for recalling stored graphics.
---
### STORE GRAPHIC
**Command name:** `STORE GRAPHIC`
**Alternative formats:** See GRAPHIC STORE
**Parameters (Inputs):** See GRAPHIC STORE
**Outputs (Return values):** See GRAPHIC STORE
**Usage examples:** See GRAPHIC STORE
**Description:** Alias for storing graphics.
---
## Barcode Commands
Commands for generating 1D and 2D barcodes. Sorted lexicographically.
### BARCODE
**Command name:** `BARCODE type x y w h data` or `B type x y w h data`
**Alternative formats:** Various barcode-specific formats
**Parameters (Inputs):**
- `type` - Barcode type (CODE39, CODE128, EAN13, etc.)
- `x` - X coordinate (BoxRange)
- `y` - Y coordinate (BoxRange)
- `w` - Width (BoxRange)
- `h` - Height (BoxRange)
- `data` - Barcode data string
**Outputs (Return values):** None (barcode generation)
**Usage examples:**
```
BARCODE CODE39 10 10 100 30 ABC123
STRING 12x16 10 45 Barcode Text
END
```
**Description:** Generates various types of 1D barcodes.
---
### BARCODE AZTEC
**Command name:** `BARCODE_AZTEC x y size data` or `AZTEC x y size data`
**Alternative formats:** None
**Parameters (Inputs):**
- `x` - X coordinate (BoxRange)
- `y` - Y coordinate (BoxRange)
- `size` - Aztec code size (BoxRange)
- `data` - Data to encode
**Outputs (Return values):** None (2D barcode generation)
**Usage examples:**
```
BARCODE_AZTEC 10 10 80 AZTEC123
STRING 12x16 100 30 Aztec Code
END
```
**Description:** Generates Aztec 2D barcodes.
---
### BARCODE DATAMATRIX
**Command name:** `BARCODE_DATAMATRIX x y size data` or `DM x y size data`
**Alternative formats:** None
**Parameters (Inputs):**
- `x` - X coordinate (BoxRange)
- `y` - Y coordinate (BoxRange)
- `size` - DataMatrix size (BoxRange)
- `data` - Data to encode
**Outputs (Return values):** None (2D barcode generation)
**Usage examples:**
```
BARCODE_DATAMATRIX 10 10 80 ABC123
STRING 12x16 100 30 DataMatrix
END
```
**Description:** Generates DataMatrix 2D barcodes.
---
### BARCODE FONT (String)
**Command name:** `BARCODE_FONT_STRING fontID(spacing,rotation,xmult,ymult) x y data` or `BSTRING fontID(spacing,rotation,xmult,ymult) x y data`
**Alternative formats:** None
**Parameters (Inputs):**
- `fontID` - Font identifier
- `spacing` - Character spacing
- `rotation` - Rotation angle
- `xmult` - X multiplier
- `ymult` - Y multiplier
- `x` - X coordinate (BoxRange)
- `y` - Y coordinate (BoxRange)
- `data` - Data to encode
**Outputs (Return values):** None (barcode generation)
**Usage examples:**
```
BARCODE_FONT_STRING 3(0,0,1,1) 10 10 CODE128DATA
END
```
**Description:** Generates barcode using string font format.
---
### BARCODE FONT (Text)
**Command name:** `BARCODE_FONT_TEXT fontID(spacing,rotation,xmult,ymult) x y data` or `BTEXT fontID(spacing,rotation,xmult,ymult) x y data`
**Alternative formats:** None
**Parameters (Inputs):**
- `fontID` - Font identifier
- `spacing` - Character spacing
- `rotation` - Rotation angle
- `xmult` - X multiplier
- `ymult` - Y multiplier
- `x` - X coordinate (BoxRange)
- `y` - Y coordinate (BoxRange)
- `data` - Data to encode
**Outputs (Return values):** None (barcode generation)
**Usage examples:**
```
BARCODE_FONT_TEXT 3(0,0,1,1) 10 10 CODE128DATA
END
```
**Description:** Generates barcode using text font format.
---
### BARCODE FONT (Ultra)
**Command name:** `BARCODE_FONT_ULTRA fontID(spacing,rotation,xmult,ymult) x y data` or `BULTRA fontID(spacing,rotation,xmult,ymult) x y data`
**Alternative formats:** None
**Parameters (Inputs):**
- `fontID` - Font identifier
- `spacing` - Character spacing
- `rotation` - Rotation angle
- `xmult` - X multiplier
- `ymult` - Y multiplier
- `x` - X coordinate (BoxRange)
- `y` - Y coordinate (BoxRange)
- `data` - Data to encode
**Outputs (Return values):** None (barcode generation)
**Usage examples:**
```
BARCODE_FONT_ULTRA 3(0,0,1,1) 10 10 CODE128DATA
END
```
**Description:** Generates barcode using ultra font format.
---
### BARCODE MICRO PDF417
**Command name:** `BARCODE_MICROPDF x y w h data` or `MICROPDF x y w h data`
**Alternative formats:** None
**Parameters (Inputs):**
- `x` - X coordinate (BoxRange)
- `y` - Y coordinate (BoxRange)
- `w` - Width (BoxRange)
- `h` - Height (BoxRange)
- `data` - Data to encode
**Outputs (Return values):** None (2D barcode generation)
**Usage examples:**
```
BARCODE_MICROPDF 10 10 100 50 MICRODATA
STRING 12x16 10 65 Micro PDF417
END
```
**Description:** Generates Micro PDF417 2D barcodes.
---
### BARCODE PDF417
**Command name:** `BARCODE_PDF417 x y w h data` or `PDF417 x y w h data`
**Alternative formats:** None
**Parameters (Inputs):**
- `x` - X coordinate (BoxRange)
- `y` - Y coordinate (BoxRange)
- `w` - Width (BoxRange)
- `h` - Height (BoxRange)
- `data` - Data to encode
**Outputs (Return values):** None (2D barcode generation)
**Usage examples:**
```
BARCODE_PDF417 10 10 100 50 Sample PDF417 Data
STRING 12x16 10 65 PDF417 Barcode
END
```
**Description:** Generates PDF417 2D barcodes.
---
### BARCODE QR
**Command name:** `BARCODE_QR x y size data` or `QR x y size data`
**Alternative formats:** None
**Parameters (Inputs):**
- `x` - X coordinate (BoxRange)
- `y` - Y coordinate (BoxRange)
- `size` - QR code size (BoxRange)
- `data` - Data to encode
**Outputs (Return values):** None (2D barcode generation)
**Usage examples:**
```
BARCODE_QR 10 10 100 https://example.com
STRING 12x16 120 30 QR Code
END
```
**Description:** Generates QR code 2D barcodes.
---
### BARCODE RSS
**Command name:** `BARCODE_RSS x y w h data` or `RSS x y w h data`
**Alternative formats:** None
**Parameters (Inputs):**
- `x` - X coordinate (BoxRange)
- `y` - Y coordinate (BoxRange)
- `w` - Width (BoxRange)
- `h` - Height (BoxRange)
- `data` - Data to encode
**Outputs (Return values):** None (2D barcode generation)
**Usage examples:**
```
BARCODE_RSS 10 10 100 50 RSS123456789
STRING 12x16 10 65 RSS Barcode
END
```
**Description:** Generates RSS (Reduced Space Symbology) barcodes.
---
### BARCODE UPS
**Command name:** `BARCODE_UPS x y w h data` or `UPS x y w h data`
**Alternative formats:** None
**Parameters (Inputs):**
- `x` - X coordinate (BoxRange)
- `y` - Y coordinate (BoxRange)
- `w` - Width (BoxRange)
- `h` - Height (BoxRange)
- `data` - Data to encode
**Outputs (Return values):** None (1D barcode generation)
**Usage examples:**
```
BARCODE_UPS 10 10 100 50 1Z12345678
STRING 12x16 10 65 UPS Barcode
END
```
**Description:** Generates UPS MaxiCode barcodes for shipping.
---
## Text and Font Commands
Commands for rendering text, fonts, and international characters. Sorted lexicographically.
### COMMENT
**Command name:** `COMMENT text` or `; text`
**Alternative formats:** `C text`
**Parameters (Inputs):**
- `text` - Comment text
**Outputs (Return values):** None (documentation)
**Usage examples:**
```
COMMENT This is a comment
STRING 12x16 10 10 Test
END
```
**Description:** Adds comments to label format for documentation purposes.
---
### DATASKIP
**Command name:** `DATASKIP count` or `DATASKIP UNTIL char [repeat]`
**Alternative formats:** None
**Parameters (Inputs):**
- `count` - Number of characters to skip (UIntRange)
- `UNTIL` - Skip until character found
- `char` - Target character to find
- `repeat` (optional) - Number of repetitions (UIntRange)
**Outputs (Return values):** None (data parsing control)
**Usage examples:**
```
DATASKIP 5
DATASKIP UNTIL , 2
STRING 12x16 10 10 Processed Data
END
```
**Description:** Skips specified number of characters or skips until specified character.
---
### DEFINE VARIABLE
**Command name:** `DEFINE_VAR name value` or `DV name value`
**Alternative formats:** None
**Parameters (Inputs):**
- `name` - Variable name (IDSize)
- `value` - Initial value
**Outputs (Return values):** None (variable definition)
**Usage examples:**
```
DEFINE_VAR COUNTER 001
STRING 12x16 10 10 COUNTER: COUNTER
ADJUST COUNTER 01
END
```
**Description:** Defines a variable that can be used throughout the label format.
---
### DOUBLE FONT
**Command name:** `DOUBLE font(exspace,rotation,xmult,ymult) x y mtid characters` or `DOUBLE`
**Alternative formats:** None
**Parameters (Inputs):**
- `font` - Font identifier
- `exspace` - Extra spacing
- `rotation` - Rotation angle
- `xmult` - X multiplier
- `ymult` - Y multiplier
- `x` - X coordinate (BoxRange)
- `y` - Y coordinate (BoxRange)
- `mtid` - Multi-byte text identifier
- `characters` - Double-byte characters
**Outputs (Return values):** None (double-byte text rendering)
**Usage examples:**
```
DOUBLE 3(1,0,2,2) 10 10 1234 
STRING 12x16 10 40 Double-byte Text
END
```
**Description:** Renders double-byte character text (e.g., Chinese, Japanese) with formatting.
---
### RECALL VARIABLE
**Command name:** `!R V ID [HIDE]` or `RECALL_VAR ID [HIDE]`
**Alternative formats:** None
**Parameters (Inputs):**
- `ID` - Variable identifier (IDSize)
- `HIDE` (optional) - Hide parameter (Hideptr)
**Outputs (Return values):** Variable value
**Usage examples:**
```
!R V COUNTER
STRING 12x16 10 10 Recalled: COUNTER
END
```
**Description:** Recalls a stored variable value for use in the current label.
---
### STRING
**Command name:** `STRING font x y text` or `S font x y text`
**Alternative formats:** None
**Parameters (Inputs):**
- `font` - Font specification (e.g., 12x16)
- `x` - X coordinate (BoxRange)
- `y` - Y coordinate (BoxRange)
- `text` - Text string to print
**Outputs (Return values):** None (text rendering)
**Usage examples:**
```
STRING 12x16 10 10 Hello World
STRING 8x8 10 30 Small Text
END
```
**Description:** Prints text using specified font and coordinates.
---
### TEXT
**Command name:** `TEXT font x y text` or `T font x y text`
**Alternative formats:** None
**Parameters (Inputs):**
- `font` - Font specification
- `x` - X coordinate (BoxRange)
- `y` - Y coordinate (BoxRange)
- `text` - Text string to print
**Outputs (Return values):** None (text rendering)
**Usage examples:**
```
TEXT 12x16 10 10 Text Command
END
```
**Description:** Alternative text command with similar functionality to STRING.
---
### THAI FONT
**Command name:** `THAI fontID(spacing,rotation,xmult,ymult) x y characters` or `THAI`
**Alternative formats:** None
**Parameters (Inputs):**
- `fontID` - Font identifier
- `spacing` - Character spacing
- `rotation` - Rotation angle
- `xmult` - X multiplier
- `ymult` - Y multiplier
- `x` - X coordinate (BoxRange)
- `y` - Y coordinate (BoxRange)
- `characters` - Thai text characters
**Outputs (Return values):** None (Thai text rendering)
**Usage examples:**
```
THAI 3(0,0,1,1) 10 10 
STRING 12x16 10 30 Thai Text Above
END
```
**Description:** Renders Thai text with specified font and formatting parameters.
---
### ULTRA FONT
**Command name:** `ULTRA_FONT TnnnXmmm IGz(Boldness,ExtraSpace,Rotation) x y characters` or `U TnnnXmmm IGz(...) x y characters`
**Alternative formats:** None
**Parameters (Inputs):**
- `TnnnXmmm` - Font size specification (Tnnn = horizontal, Xmmm = vertical)
- `IGz` - Format parameters: Boldness (level), ExtraSpace (spacing), Rotation (angle)
- `x` - X coordinate (BoxRange)
- `y` - Y coordinate (BoxRange)
- `characters` - Text to render
**Outputs (Return values):** None (vector font rendering)
**Usage examples:**
```
ULTRA_FONT T10X15 IGz(2,1,0) 10 10 Ultra Text
STRING 12x16 10 40 Standard Text
END
```
**Description:** Renders text using ultra vector font with advanced formatting options.
---
### VARIABLE (General)
**Command name:** `VARIABLE parameter value` or `V parameter value`
**Alternative formats:** Various specific VARIABLE commands
**Parameters (Inputs):**
- `parameter` - Specific variable parameter (e.g., ERROR_LEVEL, MODE, PITCH)
- `value` - Parameter value
**Outputs (Return values):** None (printer configuration)
**Usage examples:**
```
VARIABLE ERROR_LEVEL 1
VARIABLE MODE 3
VARIABLE WRITE
END
```
**Description:** Sets various printer configuration parameters.
---
## Variable and Data Management Commands
Commands for variables, data skipping, and limits. Sorted lexicographically.
### DUMP VARIABLES
**Command name:** `!DUMP VariablesType` or `DUMP VARIABLES`
**Alternative formats:** None
**Parameters (Inputs):**
- `VariablesType` - Variable type: USERVARS, FACTORYAVARS, or FACTORYBVARS
**Outputs (Return values):** Contents of specified variable area
**Usage examples:**
```
!DUMP USERVARS
!DUMP FACTORYAVARS
!DUMP FACTORYBVARS
END
```
**Description:** Dumps the selected copy of the Printer Variables object for debugging.
---
## Printer Configuration Variables
All VARIABLE subcommands for printer settings. Sorted lexicographically by full command name.
### VARIABLE ALLOCATE
**Command name:** `VARIABLE ALLOCATE size` or `V ALLOCATE size`
**Alternative formats:** None
**Parameters (Inputs):**
- `size` - Memory allocation size (UIntRange)
**Outputs (Return values):** None (memory management)
**Usage examples:**
```
VARIABLE ALLOCATE 1024
VARIABLE WRITE
END
```
**Description:** Allocates memory for printer operations and data storage.
---
### VARIABLE AUDIO_FREQ
**Command name:** `VARIABLE AUDIO_FREQ freq` or `V AUDIO_FREQ freq`
**Alternative formats:** None
**Parameters (Inputs):**
- `freq` - Audio frequency in Hz (UIntRange)
**Outputs (Return values):** None (audio setting)
**Usage examples:**
```
VARIABLE AUDIO_FREQ 2000
VARIABLE WRITE
END
```
**Description:** Sets the frequency for printer beeper audio feedback.
---
### VARIABLE AUTOCUT
**Command name:** `VARIABLE AUTOCUT on/off/?` or `V AUTOCUT on/off/?`
**Alternative formats:** None
**Parameters (Inputs):**
- `on/off/?` - Autocut setting or query (OnOffStat)
**Outputs (Return values):** Current autocut status if queried
**Usage examples:**
```
VARIABLE AUTOCUT ON
VARIABLE WRITE
END
```
**Description:** Enables or disables automatic label cutting functionality.
---
### VARIABLE AUTO_TOF
**Command name:** `VARIABLE AUTO_TOF mode` or `V AUTO_TOF mode`
**Alternative formats:** None
**Parameters (Inputs):**
- `mode` - Automatic top-of-form setting (ON/OFF)
**Outputs (Return values):** None (media detection)
**Usage examples:**
```
VARIABLE AUTO_TOF ON
VARIABLE WRITE
END
```
**Description:** Enables automatic top-of-form detection during media loading.
---
### VARIABLE AUX_POWER
**Command name:** `VARIABLE AUX_POWER mode` or `V AUX_POWER mode`
**Alternative formats:** None
**Parameters (Inputs):**
- `mode` - Auxiliary power control (ON/OFF)
**Outputs (Return values):** None (power management)
**Usage examples:**
```
VARIABLE AUX_POWER ON
VARIABLE WRITE
END
```
**Description:** Controls auxiliary power output for external devices.
---
### VARIABLE BACKLIGHT
**Command name:** `VARIABLE BACKLIGHT level` or `V BACKLIGHT level`
**Alternative formats:** None
**Parameters (Inputs):**
- `level` - Backlight intensity level (0-100)
**Outputs (Return values):** None (display setting)
**Usage examples:**
```
VARIABLE BACKLIGHT 75
VARIABLE WRITE
END
```
**Description:** Adjusts LCD display backlight intensity.
---
### VARIABLE BEEPER
**Command name:** `VARIABLE BEEPER on/off/? [volume] [duration]` or `V BEEPER on/off/? [volume] [duration]`
**Alternative formats:** `V BEEPER mode` (extended)
**Parameters (Inputs):**
- `on/off/?` - Beeper control setting (OnOffStat)
- `volume` (optional) - Beeper volume (BeeperVolumeRange: 0-3)
- `duration` (optional) - Duration in 10ths of second (BeeperDurationRange: 0-255)
- `mode` (extended) - Beeper control (ON/OFF/VOLUME)
**Outputs (Return values):** Current beeper status if queried
**Usage examples:**
```
VARIABLE BEEPER ON 2 50
VARIABLE WRITE
END
```
```
VARIABLE BEEPER ON
VARIABLE WRITE
END
```
**Description:** Controls beeper volume and duration settings.
---
### VARIABLE BLUETOOTH BDADDR
**Command name:** `VARIABLE BLUETOOTH BDADDR [address]` or `V BLUETOOTH BDADDR [address]`
**Alternative formats:** None
**Parameters (Inputs):**
- `address` - Bluetooth device address (optional, query if omitted)
**Outputs (Return values):** Current BD address if queried
**Usage examples:**
```
VARIABLE BLUETOOTH BDADDR
END
```
**Description:** Queries or sets the Bluetooth device address (BD_ADDR).
---
### VARIABLE BLUETOOTH CLASS
**Command name:** `VARIABLE BLUETOOTH CLASS code` or `V BLUETOOTH CLASS code`
**Alternative formats:** None
**Parameters (Inputs):**
- `code` - Device class code (hexadecimal)
**Outputs (Return values):** None (device classification)
**Usage examples:**
```
VARIABLE BLUETOOTH CLASS 0x180204
VARIABLE WRITE
END
```
**Description:** Sets the Bluetooth device class identification.
---
### VARIABLE BLUETOOTH CONFIGURE
**Command name:** `VARIABLE BLUETOOTH CONFIGURE params` or `V BLUETOOTH CONFIGURE params`
**Alternative formats:** None
**Parameters (Inputs):**
- `params` - Complete Bluetooth configuration parameters (e.g., AUTO)
**Outputs (Return values):** Configuration result
**Usage examples:**
```
VARIABLE BLUETOOTH CONFIGURE AUTO
VARIABLE WRITE
END
```
**Description:** Configures comprehensive Bluetooth module settings.
---
### VARIABLE BLUETOOTH DEFAULT
**Command name:** `VARIABLE BLUETOOTH DEFAULT` or `V BLUETOOTH DEFAULT`
**Alternative formats:** None
**Parameters (Inputs):** None
**Outputs (Return values):** Default restore confirmation
**Usage examples:**
```
VARIABLE BLUETOOTH DEFAULT
END
```
**Description:** Restores Bluetooth settings to factory defaults.
---
### VARIABLE BLUETOOTH DEVICENAME
**Command name:** `VARIABLE BLUETOOTH DEVICENAME "name"` or `V BLUETOOTH DEVICENAME "name"`
**Alternative formats:** None
**Parameters (Inputs):**
- `"name"` - Bluetooth device name (up to 32 characters)
**Outputs (Return values):** None (device identification)
**Usage examples:**
```
VARIABLE BLUETOOTH DEVICENAME "Printer_001"
VARIABLE WRITE
END
```
**Description:** Sets the Bluetooth discoverable device name.
---
### VARIABLE BLUETOOTH DEVICEPIN
**Command name:** `VARIABLE BLUETOOTH DEVICEPIN "pin"` or `V BLUETOOTH DEVICEPIN "pin"`
**Alternative formats:** None
**Parameters (Inputs):**
- `"pin"` - Bluetooth pairing PIN code (4-16 digits)
**Outputs (Return values):** None (security setting)
**Usage examples:**
```
VARIABLE BLUETOOTH DEVICEPIN "1234"
VARIABLE WRITE
END
```
**Description:** Sets the Bluetooth pairing PIN code for security.
---
### VARIABLE BLUETOOTH DIAGNOSTIC
**Command name:** `VARIABLE BLUETOOTH DIAGNOSTIC` or `V BLUETOOTH DIAGNOSTIC`
**Alternative formats:** None
**Parameters (Inputs):** None
**Outputs (Return values):** Bluetooth diagnostic information
**Usage examples:**
```
VARIABLE BLUETOOTH DIAGNOSTIC
END
```
**Description:** Runs comprehensive Bluetooth module diagnostics.
---
### VARIABLE BLUETOOTH DISCOVERABLE
**Command name:** `VARIABLE BLUETOOTH DISCOVERABLE mode` or `V BLUETOOTH DISCOVERABLE mode`
**Alternative formats:** None
**Parameters (Inputs):**
- `mode` - Discoverability mode (ON/OFF/LIMITED)
**Outputs (Return values):** None (visibility setting)
**Usage examples:**
```
VARIABLE BLUETOOTH DISCOVERABLE ON
VARIABLE WRITE
END
```
**Description:** Controls Bluetooth device discoverability by other devices.
---
### VARIABLE BLUETOOTH ENCRYPTION
**Command name:** `VARIABLE BLUETOOTH ENCRYPTION mode` or `V BLUETOOTH ENCRYPTION mode`
**Alternative formats:** None
**Parameters (Inputs):**
- `mode` - Encryption enable/disable
**Outputs (Return values):** None (security setting)
**Usage examples:**
```
VARIABLE BLUETOOTH ENCRYPTION ON
VARIABLE WRITE
END
```
**Description:** Enables or disables Bluetooth connection encryption.
---
### VARIABLE BLUETOOTH FORGET
**Command name:** `VARIABLE BLUETOOTH FORGET [address]` or `V BLUETOOTH FORGET [address]`
**Alternative formats:** None
**Parameters (Inputs):**
- `address` - Bluetooth device address to forget (optional, defaults to all)
**Outputs (Return values):** Forget operation result
**Usage examples:**
```
VARIABLE BLUETOOTH FORGET
VARIABLE WRITE
END
```
**Description:** Removes paired device(s) from memory.
---
### VARIABLE BLUETOOTH RESET
**Command name:** `VARIABLE BLUETOOTH RESET` or `V BLUETOOTH RESET`
**Alternative formats:** None
**Parameters (Inputs):** None
**Outputs (Return values):** Reset confirmation
**Usage examples:**
```
VARIABLE BLUETOOTH RESET
END
```
**Description:** Resets Bluetooth module to factory defaults.
---
### VARIABLE BLUETOOTH SECURITY
**Command name:** `VARIABLE BLUETOOTH SECURITY level` or `V BLUETOOTH SECURITY level`
**Alternative formats:** None
**Parameters (Inputs):**
- `level` - Security level (0-3): 0=No security, 1=Service level, 2=Link level, 3=Service and link level
**Outputs (Return values):** None (security setting)
**Usage examples:**
```
VARIABLE BLUETOOTH SECURITY 2
VARIABLE WRITE
END
```
**Description:** Sets the Bluetooth security level.
---
### VARIABLE BUFFER_TIMED_RESET
**Command name:** `VARIABLE BUFFER_TIMED_RESET seconds` or `V BUFFER_TIMED_RESET seconds`
**Alternative formats:** None
**Parameters (Inputs):**
- `seconds` - Reset timeout in seconds (UIntRange)
**Outputs (Return values):** None (buffer management)
**Usage examples:**
```
VARIABLE BUFFER_TIMED_RESET 30
VARIABLE WRITE
END
```
**Description:** Sets automatic buffer reset timeout after idle period.
---
### VARIABLE CODE PAGE
**Command name:** `VARIABLE CODE_PAGE mode` or `V CODE_PAGE mode`
**Alternative formats:** None
**Parameters (Inputs):**
- `mode` - Code page setting (e.g., 850)
**Outputs (Return values):** None (character encoding)
**Usage examples:**
```
VARIABLE CODE_PAGE 850
VARIABLE WRITE
END
```
**Description:** Sets character code page for international text support.
---
### VARIABLE COMM
**Command name:** `VARIABLE COMM settings` or `V COMM settings`
**Alternative formats:** None
**Parameters (Inputs):**
- `settings` - Communication port settings (baud, parity, data bits, stop bits, e.g., 9600,N,8,1)
**Outputs (Return values):** None (serial configuration)
**Usage examples:**
```
VARIABLE COMM 9600,N,8,1
VARIABLE WRITE
END
```
**Description:** Configures serial communication parameters.
---
### VARIABLE COMPATIBLE
**Command name:** `VARIABLE COMPATIBLE type` or `V COMPATIBLE type`
**Alternative formats:** None
**Parameters (Inputs):**
- `type` - Compatibility mode (e.g., ZPL)
**Outputs (Return values):** None (emulation setting)
**Usage examples:**
```
VARIABLE COMPATIBLE ZPL
VARIABLE WRITE
END
```
**Description:** Sets printer compatibility mode for different command languages.
---
### VARIABLE CONTRAST
**Command name:** `VARIABLE CONTRAST level` or `V CONTRAST level`
**Alternative formats:** None
**Parameters (Inputs):**
- `level` - LCD contrast level (0-100)
**Outputs (Return values):** None (display setting)
**Usage examples:**
```
VARIABLE CONTRAST 50
VARIABLE WRITE
END
```
**Description:** Adjusts LCD display contrast for optimal visibility.
---
### VARIABLE CPL_COMMAND_MASK
**Command name:** `VARIABLE CPL_COMMAND_MASK mask` or `V CPL_COMMAND_MASK mask`
**Alternative formats:** None
**Parameters (Inputs):**
- `mask` - CPL command filtering mask value (UIntRange)
**Outputs (Return values):** None (command filtering)
**Usage examples:**
```
VARIABLE CPL_COMMAND_MASK 255
VARIABLE WRITE
END
```
**Description:** Controls which CPL commands are accepted by the printer.
---
### VARIABLE DARKNESS
**Command name:** `VARIABLE DARKNESS darkness` or `V D darkness`
**Alternative formats:** `V DARKNESS level` (extended)
**Parameters (Inputs):**
- `darkness` or `level` - Print darkness level (DarkRange: 0-30)
**Outputs (Return values):** None (print quality setting)
**Usage examples:**
```
VARIABLE DARKNESS 10
VARIABLE WRITE
END
```
```
VARIABLE DARKNESS 15
VARIABLE WRITE
END
```
**Description:** Adjusts print darkness for optimal print quality.
---
### VARIABLE DHCP
**Command name:** `VARIABLE DHCP` (with sub-commands) or `V DHCP`
**Alternative formats:** Various DHCP settings
**Parameters (Inputs):** DHCP configuration parameters (e.g., ON)
**Outputs (Return values):** DHCP status if queried
**Usage examples:**
```
VARIABLE DHCP ON
VARIABLE WRITE
END
```
**Description:** Configures DHCP client settings for network connectivity.
---
### VARIABLE ETHERNET BOOTP
**Command name:** `VARIABLE ETHERNET BOOTP mode` or `V ETHERNET BOOTP mode`
**Alternative formats:** None
**Parameters (Inputs):**
- `mode` - BOOTP protocol enable/disable (ON/OFF)
**Outputs (Return values):** None (network protocol)
**Usage examples:**
```
VARIABLE ETHERNET BOOTP OFF
VARIABLE WRITE
END
```
**Description:** Enables or disables BOOTP protocol for network configuration.
---
### VARIABLE ETHERNET DHCP_CRIT
**Command name:** `VARIABLE ETHERNET DHCP_CRIT mode` or `V ETHERNET DHCP_CRIT mode`
**Alternative formats:** None
**Parameters (Inputs):**
- `mode` - DHCP critical mode setting (ENABLED/DISABLED)
**Outputs (Return values):** None (network behavior)
**Usage examples:**
```
VARIABLE ETHERNET DHCP_CRIT ENABLED
VARIABLE WRITE
END
```
**Description:** Configures DHCP critical operation mode behavior.
---
### VARIABLE ETHERNET DHCP_OFFERS
**Command name:** `VARIABLE ETHERNET DHCP_OFFERS count` or `V ETHERNET DHCP_OFFERS count`
**Alternative formats:** None
**Parameters (Inputs):**
- `count` - Number of DHCP offers to wait for (UIntRange)
**Outputs (Return values):** None (network timing)
**Usage examples:**
```
VARIABLE ETHERNET DHCP_OFFERS 3
VARIABLE WRITE
END
```
**Description:** Sets how many DHCP offers to collect before accepting one.
---
### VARIABLE ETHERNET FIRMWARE
**Command name:** `VARIABLE ETHERNET FIRMWARE` or `V ETHERNET FIRMWARE`
**Alternative formats:** None
**Parameters (Inputs):** None (query only)
**Outputs (Return values):** Ethernet firmware version
**Usage examples:**
```
VARIABLE ETHERNET FIRMWARE
END
```
**Description:** Queries the Ethernet module firmware version.
---
### VARIABLE ETHERNET GARP
**Command name:** `VARIABLE ETHERNET GARP mode` or `V ETHERNET GARP mode`
**Alternative formats:** None
**Parameters (Inputs):**
- `mode` - Gratuitous ARP enable/disable (ON/OFF)
**Outputs (Return values):** None (network protocol)
**Usage examples:**
```
VARIABLE ETHERNET GARP ON
VARIABLE WRITE
END
```
**Description:** Enables gratuitous ARP broadcasts for network presence.
---
### VARIABLE ETHERNET GATEWAY
**Command name:** `VARIABLE ETHERNET GATEWAY a.b.c.d` or `V ETHERNET GATEWAY a.b.c.d`
**Alternative formats:** `VARIABLE GATEWAY address` (general)
**Parameters (Inputs):**
- `a.b.c.d` - Gateway IP address
**Outputs (Return values):** None (network routing)
**Usage examples:**
```
VARIABLE ETHERNET GATEWAY 192.168.1.1
VARIABLE WRITE
END
```
**Description:** Sets the default gateway IP address for network routing.
---
### VARIABLE ETHERNET IP ADDRESS
**Command name:** `VARIABLE ETHERNET IP ADDRESS a.b.c.d` or `V ETHERNET IP ADDRESS a.b.c.d`
**Alternative formats:** `VARIABLE IPADDR address`
**Parameters (Inputs):**
- `a.b.c.d` - IP address
**Outputs (Return values):** None (network addressing)
**Usage examples:**
```
VARIABLE ETHERNET IP ADDRESS 192.168.1.100
VARIABLE WRITE
END
```
**Description:** Sets the printer's static IP address.
---
### VARIABLE ETHERNET JOBSOKINERROR
**Command name:** `VARIABLE ETHERNET JOBSOKINERROR mode` or `V ETHERNET JOBSOKINERROR mode`
**Alternative formats:** None
**Parameters (Inputs):**
- `mode` - Jobs OK in error mode setting (ENABLED/DISABLED)
**Outputs (Return values):** None (error handling)
**Usage examples:**
```
VARIABLE ETHERNET JOBSOKINERROR ENABLED
VARIABLE WRITE
END
```
**Description:** Controls whether print jobs are accepted during error conditions.
---
### VARIABLE ETHERNET LPD
**Command name:** `VARIABLE ETHERNET LPD mode` or `V ETHERNET LPD mode`
**Alternative formats:** None
**Parameters (Inputs):**
- `mode` - LPD protocol enable/disable (ON/OFF)
**Outputs (Return values):** None (print protocol)
**Usage examples:**
```
VARIABLE ETHERNET LPD ON
VARIABLE WRITE
END
```
**Description:** Enables or disables LPD (Line Printer Daemon) protocol.
---
### VARIABLE ETHERNET NETMASK
**Command name:** `VARIABLE ETHERNET NETMASK a.b.c.d` or `V ETHERNET NETMASK a.b.c.d`
**Alternative formats:** `VARIABLE NETMASK mask`
**Parameters (Inputs):**
- `a.b.c.d` - Subnet mask
**Outputs (Return values):** None (network configuration)
**Usage examples:**
```
VARIABLE ETHERNET NETMASK 255.255.255.0
VARIABLE WRITE
END
```
**Description:** Sets the network subnet mask.
---
### VARIABLE ETHERNET RESET
**Command name:** `VARIABLE ETHERNET RESET` or `V ETHERNET RESET`
**Alternative formats:** None
**Parameters (Inputs):** None
**Outputs (Return values):** Reset confirmation
**Usage examples:**
```
VARIABLE ETHERNET RESET
END
```
**Description:** Resets the Ethernet module to default settings.
---
### VARIABLE ETHERNET RESET COMMUNITY
**Command name:** `VARIABLE ETHERNET RESET COMMUNITY` or `V ETHERNET RESET COMMUNITY`
**Alternative formats:** None
**Parameters (Inputs):** None
**Outputs (Return values):** Reset confirmation
**Usage examples:**
```
VARIABLE ETHERNET RESET COMMUNITY
END
```
**Description:** Resets SNMP community strings to default values.
---
### VARIABLE ETHERNET RTEL
**Command name:** `VARIABLE ETHERNET RTEL mode` or `V ETHERNET RTEL mode`
**Alternative formats:** None
**Parameters (Inputs):**
- `mode` - Remote telnet enable/disable (ON/OFF)
**Outputs (Return values):** None (remote access)
**Usage examples:**
```
VARIABLE ETHERNET RTEL ON
VARIABLE WRITE
END
```
**Description:** Enables or disables remote telnet access.
---
### VARIABLE ETHERNET RTEL PORT
**Command name:** `VARIABLE ETHERNET RTEL PORT port` or `V ETHERNET RTEL PORT port`
**Alternative formats:** None
**Parameters (Inputs):**
- `port` - Telnet port number (UIntRange)
**Outputs (Return values):** None (network service)
**Usage examples:**
```
VARIABLE ETHERNET RTEL PORT 23
VARIABLE WRITE
END
```
**Description:** Sets the TCP port number for telnet service.
---
### VARIABLE ETHERNET RTEL TIMEOUT
**Command name:** `VARIABLE ETHERNET RTEL TIMEOUT seconds` or `V ETHERNET RTEL TIMEOUT seconds`
**Alternative formats:** None
**Parameters (Inputs):**
- `seconds` - Telnet session timeout in seconds (UIntRange)
**Outputs (Return values):** None (session management)
**Usage examples:**
```
VARIABLE ETHERNET RTEL TIMEOUT 300
VARIABLE WRITE
END
```
**Description:** Sets automatic telnet session timeout.
---
### VARIABLE ETHERNET SNMP
**Command name:** `VARIABLE ETHERNET SNMP mode` or `V ETHERNET SNMP mode`
**Alternative formats:** None
**Parameters (Inputs):**
- `mode` - SNMP protocol enable/disable (ON/OFF)
**Outputs (Return values):** None (network management)
**Usage examples:**
```
VARIABLE ETHERNET SNMP ON
VARIABLE WRITE
END
```
**Description:** Enables or disables SNMP network management protocol.
---
### VARIABLE ETHERNET TELNET
**Command name:** `VARIABLE ETHERNET TELNET mode` or `V ETHERNET TELNET mode`
**Alternative formats:** None
**Parameters (Inputs):**
- `mode` - Telnet service enable/disable (ON/OFF)
**Outputs (Return values):** None (remote access)
**Usage examples:**
```
VARIABLE ETHERNET TELNET ON
VARIABLE WRITE
END
```
**Description:** Enables or disables telnet service.
---
### VARIABLE ETHERNET TELNET TIMEOUT
**Command name:** `VARIABLE ETHERNET TELNET TIMEOUT seconds` or `V ETHERNET TELNET TIMEOUT seconds`
**Alternative formats:** None
**Parameters (Inputs):**
- `seconds` - Telnet connection timeout in seconds (UIntRange)
**Outputs (Return values):** None (connection management)
**Usage examples:**
```
VARIABLE ETHERNET TELNET TIMEOUT 180
VARIABLE WRITE
END
```
**Description:** Sets telnet connection idle timeout.
---
### VARIABLE ETHERNET TEXT BUFFER
**Command name:** `VARIABLE ETHERNET TEXT BUFFER size` or `V ETHERNET TEXT BUFFER size`
**Alternative formats:** None
**Parameters (Inputs):**
- `size` - Network text buffer size in bytes (UIntRange)
**Outputs (Return values):** None (buffer management)
**Usage examples:**
```
VARIABLE ETHERNET TEXT BUFFER 8192
VARIABLE WRITE
END
```
**Description:** Sets the Ethernet interface text buffer size.
---
### VARIABLE EPL_COMMAND_MASK
**Command name:** `VARIABLE EPL_COMMAND_MASK mask` or `V EPL_COMMAND_MASK mask`
**Alternative formats:** None
**Parameters (Inputs):**
- `mask` - EPL command filtering mask value (UIntRange)
**Outputs (Return values):** None (command filtering)
**Usage examples:**
```
VARIABLE EPL_COMMAND_MASK 0
VARIABLE WRITE
END
```
**Description:** Controls which EPL commands are accepted by the printer.
---
### VARIABLE ERROR_LEVEL
**Command name:** `VARIABLE ERROR_LEVEL level` or `V ERROR_LEVEL level`
**Alternative formats:** None
**Parameters (Inputs):**
- `level` - Error level setting (ErrorLvlEnum: 0-3)
**Outputs (Return values):** None (configuration command)
**Usage examples:**
```
VARIABLE ERROR_LEVEL 1
VARIABLE WRITE
END
```
**Description:** Sets the error reporting level for the printer.
---
### VARIABLE FACTORY_RESTORE
**Command name:** `VARIABLE FACTORY_RESTORE` or `V FACTORY_RESTORE`
**Alternative formats:** None
**Parameters (Inputs):** Restore parameters (e.g., ALL)
**Outputs (Return values):** Restore operation results
**Usage examples:**
```
VARIABLE FACTORY_RESTORE ALL
END
```
**Description:** Restores printer to factory default settings.
---
### VARIABLE FEED
**Command name:** `VARIABLE FEED amount` or `V FEED amount`
**Alternative formats:** None
**Parameters (Inputs):**
- `amount` - Feed distance in dots (UIntRange)
**Outputs (Return values):** None (media control)
**Usage examples:**
```
VARIABLE FEED 100
VARIABLE WRITE
END
```
**Description:** Sets default feed distance for media advance.
---
### VARIABLE FEED_BUTTON
**Command name:** `VARIABLE FEED_BUTTON mode` or `V FEED_BUTTON mode`
**Alternative formats:** None
**Parameters (Inputs):**
- `mode` - Feed button behavior configuration (ENABLE/DISABLE)
**Outputs (Return values):** None (button control)
**Usage examples:**
```
VARIABLE FEED_BUTTON ENABLE
VARIABLE WRITE
END
```
**Description:** Configures the behavior of the manual feed button.
---
### VARIABLE FEED_CONFIG
**Command name:** `VARIABLE FEED_CONFIG P,D / ?` or `V FEED_CONFIG P,D / ?`
**Alternative formats:** None
**Parameters (Inputs):**
- `P` - Feed type (e.g., L for continuous)
- `D` - Print mode (e.g., F for direct thermal)
- `?` - Query current settings
**Outputs (Return values):** Current feed configuration if queried
**Usage examples:**
```
VARIABLE FEED_CONFIG L,F
VARIABLE WRITE
END
```
**Description:** Configures feed type and print mode combination.
---
### VARIABLE FEED_SPEED
**Command name:** `VARIABLE FEED_SPEED speed` or `V FEED_SPEED speed`
**Alternative formats:** None
**Parameters (Inputs):**
- `speed` - Feed speed (PrintSpeedRange: 0-65535)
**Outputs (Return values):** None (speed setting)
**Usage examples:**
```
VARIABLE FEED_SPEED 6000
VARIABLE WRITE
END
```
**Description:** Sets the media feed speed in milli-IPS.
---
### VARIABLE FEED_TYPE
**Command name:** `VARIABLE FEED_TYPE type` or `V FEED_TYPE type`
**Alternative formats:** None
**Parameters (Inputs):**
- `type` - Media feed type (GAP, NOTCH, CONTINUOUS, MARK)
**Outputs (Return values):** None (media detection)
**Usage examples:**
```
VARIABLE FEED_TYPE GAP
VARIABLE WRITE
END
```
**Description:** Sets the media type for proper feed detection.
---
### VARIABLE GAP_SIZE
**Command name:** `VARIABLE GAP_SIZE nnn` or `V GAP_SIZE nnn`
**Alternative formats:** None
**Parameters (Inputs):**
- `nnn` - Gap size in dots (UIntRange)
**Outputs (Return values):** None (media setting)
**Usage examples:**
```
VARIABLE GAP_SIZE 50
VARIABLE WRITE
END
```
**Description:** Sets the gap size between labels for gap media.
---
### VARIABLE HIGHSPEED
**Command name:** `VARIABLE HIGHSPEED mode` or `V HIGHSPEED mode`
**Alternative formats:** None
**Parameters (Inputs):**
- `mode` - High-speed communication mode (ON/OFF)
**Outputs (Return values):** None (performance setting)
**Usage examples:**
```
VARIABLE HIGHSPEED ON
VARIABLE WRITE
END
```
**Description:** Enables high-speed data transfer mode.
---
### VARIABLE INDEX
**Command name:** `VARIABLE INDEX on/off/?` or `V INDEX on/off/?`
**Alternative formats:** `INDEX` or `I` (toggle); `V INDEX value` (adjustment)
**Parameters (Inputs):**
- `on/off/?` - Index enable/disable setting (OnOffStat)
- `value` (adjustment) - Index sensor adjustment value (IntRange)
**Outputs (Return values):** Current index status if queried
**Usage examples:**
```
VARIABLE INDEX ON
VARIABLE WRITE
END
```
```
VARIABLE INDEX 50
VARIABLE WRITE
END
```
**Description:** Enables or disables label indexing functionality; adjusts sensor sensitivity.
---
### VARIABLE INDEX SETTING
**Command name:** `VARIABLE INDEX SETTING CALIBRATE` or `V INDEX SETTING CALIBRATE`
**Alternative formats:** `VARIABLE INDEX SETTING [parameters]` (extended); `V INDEX SETTING params`
**Parameters (Inputs):**
- `CALIBRATE` - Initiates index calibration
- Additional parameters for manual index setting (e.g., GAP,DIRECT,50,50,100,200)
**Outputs (Return values):** None (calibration command)
**Usage examples:**
```
VARIABLE INDEX SETTING CALIBRATE
VARIABLE WRITE
END
```
```
VARIABLE INDEX SETTING GAP,DIRECT,50,50,100,200
VARIABLE WRITE
END
```
**Description:** Calibrates or manually sets index parameters for label detection.
---
### VARIABLE IRDA
**Command name:** `VARIABLE IRDA mode` or `V IRDA mode`
**Alternative formats:** None
**Parameters (Inputs):**
- `mode` - IrDA infrared interface control (ON/OFF)
**Outputs (Return values):** None (interface control)
**Usage examples:**
```
VARIABLE IRDA ON
VARIABLE WRITE
END
```
**Description:** Enables or disables infrared communication interface.
---
### VARIABLE IRDA COMM
**Command name:** `VARIABLE IRDA COMM settings` or `V IRDA COMM settings`
**Alternative formats:** None
**Parameters (Inputs):**
- `settings` - IrDA communication parameters (e.g., 115200)
**Outputs (Return values):** None (infrared configuration)
**Usage examples:**
```
VARIABLE IRDA COMM 115200
VARIABLE WRITE
END
```
**Description:** Configures IrDA communication speed and parameters.
---
### VARIABLE IRDA PROTOCOL
**Command name:** `VARIABLE IRDA PROTOCOL protocol` or `V IRDA PROTOCOL protocol`
**Alternative formats:** None
**Parameters (Inputs):**
- `protocol` - IrDA protocol selection (UIntRange)
**Outputs (Return values):** None (protocol setting)
**Usage examples:**
```
VARIABLE IRDA PROTOCOL 1
VARIABLE WRITE
END
```
**Description:** Selects the IrDA protocol version and mode.
---
### VARIABLE KBLAYOUT
**Command name:** `VARIABLE KBLAYOUT mode` or `V KBLAYOUT mode`
**Alternative formats:** None
**Parameters (Inputs):**
- `mode` - Keyboard layout (0-9, ? for query): 0=US English, 1=Canadian French, etc.
**Outputs (Return values):** Current layout if queried
**Usage examples:**
```
VARIABLE KBLAYOUT 4
VARIABLE WRITE
END
```
**Description:** Selects keyboard layout for data entry.
---
### VARIABLE LABEL_LENGTH
**Command name:** `VARIABLE LABEL_LENGTH nnn` or `V LABEL_LENGTH nnn`
**Alternative formats:** None
**Parameters (Inputs):**
- `nnn` - Label length in dots (UIntRange)
**Outputs (Return values):** None (dimension setting)
**Usage examples:**
```
VARIABLE LABEL_LENGTH 800
VARIABLE WRITE
END
```
**Description:** Sets fixed label length for media handling.
---
### VARIABLE LANGUAGE
**Command name:** `VARIABLE LANGUAGE code` or `V LANGUAGE code`
**Alternative formats:** None
**Parameters (Inputs):**
- `code` - Language code for printer firmware (e.g., EN)
**Outputs (Return values):** None (localization)
**Usage examples:**
```
VARIABLE LANGUAGE EN
VARIABLE WRITE
END
```
**Description:** Sets the firmware language for status messages.
---
### VARIABLE LIMIT_PERCENT
**Command name:** `VARIABLE LIMIT_PERCENT` or `V LIMIT_PERCENT`
**Alternative formats:** None
**Parameters (Inputs):** Various developer parameters (e.g., 90)
**Outputs (Return values):** None (developer setting)
**Usage examples:**
```
VARIABLE LIMIT_PERCENT 90
VARIABLE WRITE
END
```
**Description:** Developer command to limit maximum strobe duty cycle during printing.
---
### VARIABLE LOWSPEED
**Command name:** `VARIABLE LOWSPEED mode` or `V LOWSPEED mode`
**Alternative formats:** None
**Parameters (Inputs):**
- `mode` - Low-speed communication mode (ON/OFF)
**Outputs (Return values):** None (performance setting)
**Usage examples:**
```
VARIABLE LOWSPEED OFF
VARIABLE WRITE
END
```
**Description:** Enables low-speed communication mode for compatibility.
---
### VARIABLE MAX_WIDTH
**Command name:** `VARIABLE MAX_WIDTH nnn` or `V MAX_WIDTH nnn`
**Alternative formats:** None
**Parameters (Inputs):**
- `nnn` - Maximum print width in dots (UIntRange)
**Outputs (Return values):** None (dimension limit)
**Usage examples:**
```
VARIABLE MAX_WIDTH 832
VARIABLE WRITE
END
```
**Description:** Sets the maximum printable width limit to prevent edge overflow.
---
### VARIABLE MEASURE_LABEL
**Command name:** `VARIABLE MEASURE_LABEL mode` or `V MEASURE_LABEL mode`
**Alternative formats:** None
**Parameters (Inputs):**
- `mode` - Enable/disable automatic label measurement during calibration (ON/OFF)
**Outputs (Return values):** None (calibration setting)
**Usage examples:**
```
VARIABLE MEASURE_LABEL ON
VARIABLE WRITE
END
```
**Description:** Enables automatic label dimension measurement during media calibration process.
---
### VARIABLE MEDIA_ADJUST
**Command name:** `VARIABLE MEDIA_ADJUST value` or `V MEDIA_ADJUST value`
**Alternative formats:** None
**Parameters (Inputs):**
- `value` - Media sensor adjustment value (IntRange)
**Outputs (Return values):** None (sensor calibration)
**Usage examples:**
```
VARIABLE MEDIA_ADJUST 10
VARIABLE WRITE
END
```
**Description:** Fine-tunes media sensor detection thresholds.
---
### VARIABLE MENU_LANGUAGE
**Command name:** `VARIABLE MENU_LANGUAGE mode` or `V MENU_LANGUAGE mode`
**Alternative formats:** None
**Parameters (Inputs):**
- `mode` - Language mode number (UIntRange)
**Outputs (Return values):** None (localization)
**Usage examples:**
```
VARIABLE MENU_LANGUAGE 1
VARIABLE WRITE
END
```
**Description:** Sets the language for printer menus and messages.
---
### VARIABLE MIRROR_LABEL
**Command name:** `VARIABLE MIRROR_LABEL mode` or `V MIRROR_LABEL mode`
**Alternative formats:** None
**Parameters (Inputs):**
- `mode` - Mirror/flip label horizontally (ON/OFF)
**Outputs (Return values):** None (print orientation)
**Usage examples:**
```
VARIABLE MIRROR_LABEL ON
VARIABLE WRITE
END
```
**Description:** Mirrors the entire label horizontally.
---
### VARIABLE MODE
**Command name:** `VARIABLE MODE mode [scale]` or `V MODE mode [scale]`
**Alternative formats:** `V MODE type` (extended)
**Parameters (Inputs):**
- `mode` - Printer mode (ModeRange: 0-2) or type (THERMAL/DIRECT)
- `scale` (optional) - Mode scale (ModeScaleRange: 0-255)
**Outputs (Return values):** None (mode setting)
**Usage examples:**
```
VARIABLE MODE 1
VARIABLE WRITE
END
```
```
VARIABLE MODE THERMAL
VARIABLE WRITE
END
```
**Description:** Sets the printer operating mode.
---
### VARIABLE NO_MEDIA
**Command name:** `VARIABLE NO_MEDIA length` or `V NO_MEDIA length`
**Alternative formats:** `V NO_MEDIA action` (extended)
**Parameters (Inputs):**
- `length` - No media length in inches (FloatRange)
- `action` (extended) - Action to take when media is not detected (e.g., HALT)
**Outputs (Return values):** None (media setting)
**Usage examples:**
```
VARIABLE NO_MEDIA 1
VARIABLE WRITE
END
```
```
VARIABLE NO_MEDIA HALT
VARIABLE WRITE
END
```
**Description:** Sets the no media condition handling.
---
### VARIABLE NORMAL
**Command name:** `VARIABLE NORMAL` or `V NORMAL`
**Alternative formats:** None
**Parameters (Inputs):** None
**Outputs (Return values):** None (reset to defaults)
**Usage examples:**
```
VARIABLE NORMAL
VARIABLE WRITE
END
```
**Description:** Resets settings to normal/default values.
---
### VARIABLE OFF AFTER
**Command name:** `VARIABLE OFF_AFTER seconds` or `V OFF_AFTER seconds`
**Alternative formats:** `V OFF AFTER minutes` (extended)
**Parameters (Inputs):**
- `seconds` or `minutes` - Auto-off time in seconds/minutes (SleepRange: 0-255)
**Outputs (Return values):** None (power management)
**Usage examples:**
```
VARIABLE OFF_AFTER 300
VARIABLE WRITE
END
```
```
VARIABLE OFF AFTER 30
VARIABLE WRITE
END
```
**Description:** Sets automatic power-off timer for energy conservation.
---
### VARIABLE ON TIME
**Command name:** `VARIABLE ON_TIME seconds` or `V ON_TIME seconds`
**Alternative formats:** `V ON_TIME milliseconds` (extended)
**Parameters (Inputs):**
- `seconds` or `milliseconds` - On time in seconds/milliseconds (OnTimeRange: 0-65535)
**Outputs (Return values):** None (power management)
**Usage examples:**
```
VARIABLE ON_TIME 60
VARIABLE WRITE
END
```
```
VARIABLE ON_TIME 2
VARIABLE WRITE
END
```
**Description:** Sets the duration the printer remains active after last command; or print head energizing time.
---
### VARIABLE ON/OFF
**Command name:** `VARIABLE ON/OFF mode` or `V ON/OFF mode`
**Alternative formats:** None
**Parameters (Inputs):**
- `mode` - Power control (ON/OFF)
**Outputs (Return values):** None (power control)
**Usage examples:**
```
VARIABLE ON/OFF ON
VARIABLE WRITE
END
```
**Description:** Controls printer power state.
---
### VARIABLE OOP_TLED
**Command name:** `VARIABLE OOP_TLED mode` or `V OOP_TLED mode`
**Alternative formats:** None
**Parameters (Inputs):**
- `mode` - Out-of-paper transmissive LED setting (UIntRange)
**Outputs (Return values):** None (sensor configuration)
**Usage examples:**
```
VARIABLE OOP_TLED 1
VARIABLE WRITE
END
```
**Description:** Configures the transmissive LED for out-of-paper detection.
---
### VARIABLE POSITION
**Command name:** `VARIABLE POSITION pos` or `V POSITION pos`
**Alternative formats:** `V POSITION x,y` (extended)
**Parameters (Inputs):**
- `pos` - Position offset in motor steps (IntRange)
- `x,y` (extended) - X and Y offset positions
**Outputs (Return values):** None (position adjustment)
**Usage examples:**
```
VARIABLE POSITION 50
VARIABLE WRITE
END
```
```
VARIABLE POSITION 10,5
VARIABLE WRITE
END
```
**Description:** Adjusts the top of form position by specified motor steps.
---
### VARIABLE PRESENTLABEL
**Command name:** `VARIABLE PRESENTLABEL mode` or `V PRESENTLABEL mode`
**Alternative formats:** None
**Parameters (Inputs):**
- `mode` - Label presentation mode (ON/OFF)
**Outputs (Return values):** None (peeler control)
**Usage examples:**
```
VARIABLE PRESENTLABEL ON
VARIABLE WRITE
END
```
**Description:** Enables label presentation mode for peeler operation.
---
### VARIABLE PRINT_MODE
**Command name:** `VARIABLE PRINT_MODE mode` or `V PRINT_MODE mode`
**Alternative formats:** None
**Parameters (Inputs):**
- `mode` - Print mode (PrintModes: Auto, TT, DT; or DIRECT/THERMAL)
**Outputs (Return values):** None (print mode setting)
**Usage examples:**
```
VARIABLE PRINT_MODE TT
VARIABLE WRITE
END
```
```
VARIABLE PRINT_MODE THERMAL
VARIABLE WRITE
END
```
**Description:** Sets the print mode to Thermal Transfer (TT), Direct Thermal (DT), or Auto.
---
### VARIABLE PRINT_SPEED
**Command name:** `VARIABLE PRINT_SPEED speed` or `V PRINT_SPEED speed`
**Alternative formats:** `V PRINT_SPEED ips` (extended)
**Parameters (Inputs):**
- `speed` or `ips` - Print speed in milli-IPS or inches per second (PrintSpeedRange: 0-65535)
**Outputs (Return values):** None (speed setting)
**Usage examples:**
```
VARIABLE PRINT_SPEED 8000
VARIABLE WRITE
END
```
```
VARIABLE PRINT_SPEED 4
VARIABLE WRITE
END
```
**Description:** Sets the print speed in milli-IPS (inches per second).
---
### VARIABLE READ
**Command name:** `VARIABLE READ` or `V READ`
**Alternative formats:** None
**Parameters (Inputs):** None
**Outputs (Return values):** Current variable settings
**Usage examples:**
```
VARIABLE READ
END
```
**Description:** Displays current variable settings.
---
### VARIABLE RECALIBRATE
**Command name:** `VARIABLE RECALIBRATE` or `V RECALIBRATE`
**Alternative formats:** None
**Parameters (Inputs):** None
**Outputs (Return values):** Calibration results
**Usage examples:**
```
VARIABLE RECALIBRATE
END
```
**Description:** Initiates media calibration sequence.
---
### VARIABLE REPRINT
**Command name:** `VARIABLE REPRINT on/off` or `V REPRINT on/off`
**Alternative formats:** `V REPRINT mode` (extended)
**Parameters (Inputs):**
- `on/off` or `mode` - Reprint enable/disable setting (ON/OFF)
**Outputs (Return values):** None (reprint control)
**Usage examples:**
```
VARIABLE REPRINT ON
VARIABLE WRITE
END
```
**Description:** Enables or disables label reprint functionality.
---
### VARIABLE REPORT_LEVEL
**Command name:** `VARIABLE REPORT_LEVEL level` or `V REPORT_LEVEL level`
**Alternative formats:** None
**Parameters (Inputs):**
- `level` - Status reporting level (0-3)
**Outputs (Return values):** None (reporting control)
**Usage examples:**
```
VARIABLE REPORT_LEVEL 2
VARIABLE WRITE
END
```
**Description:** Sets the verbosity level for status reporting.
---
### VARIABLE REPORT_TYPE
**Command name:** `VARIABLE REPORT_TYPE type` or `V REPORT_TYPE type`
**Alternative formats:** None
**Parameters (Inputs):**
- `type` - Type of status reports to generate (e.g., FULL)
**Outputs (Return values):** None (reporting control)
**Usage examples:**
```
VARIABLE REPORT_TYPE FULL
VARIABLE WRITE
END
```
**Description:** Specifies which types of status reports are generated.
---
### VARIABLE RESET
**Command name:** `VARIABLE RESET` or `V RESET`
**Alternative formats:** None
**Parameters (Inputs):** None
**Outputs (Return values):** None (reset command)
**Usage examples:**
```
VARIABLE RESET
END
```
**Description:** Resets printer variables to default values.
---
### VARIABLE ROTATE_LABEL
**Command name:** `VARIABLE ROTATE_LABEL degrees` or `V ROTATE_LABEL degrees`
**Alternative formats:** None
**Parameters (Inputs):**
- `degrees` - Rotation angle (0, 90, 180, 270)
**Outputs (Return values):** None (print orientation)
**Usage examples:**
```
VARIABLE ROTATE_LABEL 180
VARIABLE WRITE
END
```
**Description:** Rotates the entire label by specified degrees.
---
### VARIABLE SCRIPT_INPUT_RESET
**Command name:** `VARIABLE SCRIPT_INPUT_RESET mode` or `V SCRIPT_INPUT_RESET mode`
**Alternative formats:** None
**Parameters (Inputs):**
- `mode` - Script input buffer reset mode (ON/OFF)
**Outputs (Return values):** None (buffer management)
**Usage examples:**
```
VARIABLE SCRIPT_INPUT_RESET ON
VARIABLE WRITE
END
```
**Description:** Controls automatic script input buffer reset behavior.
---
### VARIABLE SHIFT LEFT
**Command name:** `VARIABLE SHIFT LEFT dots` or `V SHIFT LEFT dots`
**Alternative formats:** None
**Parameters (Inputs):**
- `dots` - Number of dots to shift left (UIntRange)
**Outputs (Return values):** None (position adjustment)
**Usage examples:**
```
VARIABLE SHIFT LEFT 10
VARIABLE WRITE
END
```
**Description:** Shifts entire print image left by specified dots.
---
### VARIABLE SLEEP_AFTER
**Command name:** `VARIABLE SLEEP_AFTER seconds` or `V SLEEP_AFTER seconds`
**Alternative formats:** `V SLEEP_AFTER minutes` (extended)
**Parameters (Inputs):**
- `seconds` or `minutes` - Sleep delay in seconds/minutes (SleepRange: 0-255)
**Outputs (Return values):** None (timing control)
**Usage examples:**
```
VARIABLE SLEEP_AFTER 5
VARIABLE WRITE
END
```
```
VARIABLE SLEEP_AFTER 15
VARIABLE WRITE
END
```
**Description:** Sets delay after label completion or automatic sleep mode after idle.
---
### VARIABLE SNMP SETTINGS
**Command name:** Various SNMP configuration commands or `V SNMP`
**Alternative formats:** None
**Parameters (Inputs):** SNMP parameters (addresses, communities, etc.)
**Outputs (Return values):** SNMP status if queried
**Usage examples:**
```
VARIABLE SNMP_ACTIVE ON
VARIABLE SNMP_ADDR 192.168.1.100
VARIABLE WRITE
END
```
**Description:** Configures SNMP for network management.
---
### VARIABLE TERMINAL
**Command name:** `VARIABLE TERMINAL mode` or `V TERMINAL mode`
**Alternative formats:** None
**Parameters (Inputs):**
- `mode` - Terminal emulation mode (e.g., VT100)
**Outputs (Return values):** None (interface mode)
**Usage examples:**
```
VARIABLE TERMINAL VT100
VARIABLE WRITE
END
```
**Description:** Sets terminal emulation mode for interactive communication.
---
### VARIABLE TIME
**Command name:** `VARIABLE TIME hh:mm:ss` or `V TIME hh:mm:ss`
**Alternative formats:** None
**Parameters (Inputs):**
- `hh:mm:ss` - Time in 24-hour format
**Outputs (Return values):** None (time setting)
**Usage examples:**
```
VARIABLE TIME 14:30:00
VARIABLE WRITE
END
```
**Description:** Sets the printer's internal clock time.
---
### VARIABLE TOF
**Command name:** `VARIABLE TOF value` or `V TOF value`
**Alternative formats:** None
**Parameters (Inputs):**
- `value` - Top-of-form offset value (IntRange)
**Outputs (Return values):** None (media positioning)
**Usage examples:**
```
VARIABLE TOF 50
VARIABLE WRITE
END
```
**Description:** Adjusts the top-of-form position offset.
---
### VARIABLE TXTBFR
**Command name:** `VARIABLE TXTBFR size` or `V TXTBFR size`
**Alternative formats:** None
**Parameters (Inputs):**
- `size` - Text buffer size in bytes (UIntRange)
**Outputs (Return values):** None (buffer management)
**Usage examples:**
```
VARIABLE TXTBFR 2048
VARIABLE WRITE
END
```
**Description:** Sets the size of the text input buffer.
---
### VARIABLE USB_TXTBFR
**Command name:** `VARIABLE USB_TXTBFR size` or `V USB_TXTBFR size`
**Alternative formats:** None
**Parameters (Inputs):**
- `size` - USB text buffer size in bytes (UIntRange)
**Outputs (Return values):** None (buffer management)
**Usage examples:**
```
VARIABLE USB_TXTBFR 4096
VARIABLE WRITE
END
```
**Description:** Sets the USB interface text buffer size.
---
### VARIABLE USER_FEEDBACK
**Command name:** `VARIABLE USER_FEEDBACK mode` or `V USER_FEEDBACK mode`
**Alternative formats:** None
**Parameters (Inputs):**
- `mode` - User feedback mode (VISUAL/AUDIO/BOTH/NONE)
**Outputs (Return values):** None (user interface)
**Usage examples:**
```
VARIABLE USER_FEEDBACK BOTH
VARIABLE WRITE
END
```
**Description:** Configures user feedback mechanisms (beeper, LED, etc.).
---
### VARIABLE WIDTH
**Command name:** `VARIABLE WIDTH width` or `V WIDTH width`
**Alternative formats:** `V WIDTH dots` (extended)
**Parameters (Inputs):**
- `width` or `dots` - Label width in user units/dots (WidthRange: 0-65535)
**Outputs (Return values):** None (width setting)
**Usage examples:**
```
VARIABLE WIDTH 400
VARIABLE WRITE
END
```
```
VARIABLE WIDTH 832
VARIABLE WRITE
END
```
**Description:** Sets the label width for formatting purposes.
---
### VARIABLE WRITE
**Command name:** `VARIABLE WRITE` or `V WRITE`
**Alternative formats:** None
**Parameters (Inputs):** None
**Outputs (Return values):** None (save command)
**Usage examples:**
```
VARIABLE DARKNESS 10
VARIABLE WRITE
END
```
**Description:** Saves current variable settings to non-volatile memory.
---
### VARIABLE ZPL_COMMAND_MASK
**Command name:** `VARIABLE ZPL_COMMAND_MASK mask` or `V ZPL_COMMAND_MASK mask`
**Alternative formats:** None
**Parameters (Inputs):**
- `mask` - ZPL command filtering mask value (UIntRange)
**Outputs (Return values):** None (command filtering)
**Usage examples:**
```
VARIABLE ZPL_COMMAND_MASK 0
VARIABLE WRITE
END
```
**Description:** Controls which ZPL commands are accepted by the printer.
---
## Object and Storage Commands
Commands for managing stored objects, formats, and memory. Sorted lexicographically.
### ALL OBJECT DELETE
**Command name:** `!I 3` or `ALLOBJECTSDELETE`
**Alternative formats:** `!F`
**Parameters (Inputs):** None
**Outputs (Return values):** Delete operation results
**Usage examples:**
```
!I 3
END
```
**Description:** Deletes all stored objects from printer memory.
---
### OBJECT DELETE
**Command name:** `!DELETE ID` or `!D ID`
**Alternative formats:** `OBJECT_DELETE ID`
**Parameters (Inputs):**
- `ID` - Object identifier (IDSize)
**Outputs (Return values):** None (object management)
**Usage examples:**
```
!DELETE MYFONT
END
```
**Description:** Deletes a stored object from printer memory.
---
### OBJECT INFO
**Command name:** `!OBJECT INFO id type ver` or `!OI id type ver`
**Alternative formats:** `!OBJECT INFO objectname` (extended)
**Parameters (Inputs):**
- `id` or `objectname` - Object identifier
- `type` - Object type (UIntRange)
- `ver` - Version information (UIntRange)
**Outputs (Return values):** Object information
**Usage examples:**
```
!OBJECT INFO MYFONT 1 100
END
```
```
!OBJECT INFO LOGO1
```
**Description:** Retrieves information about a specific stored object.
---
### OBJECT LIST
**Command name:** `!LS` or `OBJECT_LIST`
**Alternative formats:** `!LS`; `OBJECT LIST SERIAL` or `EPL OBJECT LIST SERIAL`
**Parameters (Inputs):** None
**Outputs (Return values):** List of stored objects (with serial numbers in extended)
**Usage examples:**
```
!LS
END
```
**Description:** Lists all objects stored in printer memory.
---
### OBJECT MARK
**Command name:** `!OBJECT MARK ID` or `!OM ID`
**Alternative formats:** None
**Parameters (Inputs):**
- `ID` - Object identifier to mark for deletion (IDSize)
**Outputs (Return values):** None (mark operation)
**Usage examples:**
```
!OBJECT MARK OLDFONT
!OBJECT PACK
END
```
**Description:** Marks an object for deletion (requires OBJECT PACK to actually delete).
---
### OBJECT MARK TYPE
**Command name:** `!OBJECT MARK_TYPE TYPE` or `!OMT TYPE`
**Alternative formats:** None
**Parameters (Inputs):**
- `TYPE` - Object type to mark for deletion (e.g., FONT)
**Outputs (Return values):** None (mark operation)
**Usage examples:**
```
!OBJECT MARK_TYPE FONT
!OBJECT PACK
END
```
**Description:** Marks all objects of specified type for deletion.
---
### OBJECT MEMORY_REMAINING
**Command name:** `!OBJECT MEMORY_REMAINING`
**Alternative formats:** None
**Parameters (Inputs):** None
**Outputs (Return values):** Available object memory in bytes
**Usage examples:**
```
!OBJECT MEMORY_REMAINING
```
**Description:** Reports available memory for object storage.
---
### OBJECT PACK
**Command name:** `!OBJECT PACK` or `!OP`
**Alternative formats:** None
**Parameters (Inputs):** None
**Outputs (Return values):** Pack operation results
**Usage examples:**
```
!OBJECT MARK OLDFONT
!OBJECT PACK
END
```
**Description:** Removes objects marked for deletion and compacts flash memory.
---
### OBJECT UPLOAD
**Command name:** `!OBJECT UPLOAD LOC ID` or `!OU LOC ID`
**Alternative formats:** `!OBJECT UPLOAD objectname` (extended)
**Parameters (Inputs):**
- `LOC` - Storage location (UIntRange)
- `ID` or `objectname` - Object identifier
**Outputs (Return values):** Upload operation results or object data stream
**Usage examples:**
```
!OBJECT UPLOAD 3 NEWFONT
[font data]
END
```
```
!OBJECT UPLOAD LOGO1
```
**Description:** Uploads object data to specified storage location or streams stored data.
---
## Diagnostic and Internal Bang Commands
Internal diagnostic, manufacturing, and maintenance commands. Sorted lexicographically.
### !! (Double Bang Test)
**Command name:** `!! x dottime maxY numlbls` or `!!`
**Alternative formats:** None
**Parameters (Inputs):**
- `x` - Test pattern parameter (UIntRange)
- `dottime` - Dot timing parameter (UIntRange)
- `maxY` - Maximum Y coordinate (UIntRange)
- `numlbls` - Number of test labels (UIntRange)
**Outputs (Return values):** Test pattern execution results
**Usage examples:**
```
!! 1 10 100 5
END
```
```
!!
```
**Description:** Executes internal test patterns for manufacturing diagnostics; simple form prints test header.
---
### !CAL
**Command name:** `!CAL mode` or `!CAL`
**Alternative formats:** None
**Parameters (Inputs):**
- `mode` - Calibration mode (0-3, 23, 254): 0=Direct Thermal Bar, 1=Direct Thermal Gap, etc.
**Outputs (Return values):** Calibration results
**Usage examples:**
```
!CAL 0
!CAL 254
END
```
```
!CAL
```
**Description:** Calibrates index settings for different feed and print types.
---
### !DUMP DATAFLASH
**Command name:** `!DUMP DATAFLASH`
**Alternative formats:** None
**Parameters (Inputs):** None
**Outputs (Return values):** DataFlash contents
**Usage examples:**
```
!DUMP DATAFLASH
```
**Description:** Dumps DataFlash memory contents.
---
### !DUMP FACTORYAVARS
**Command name:** `!DUMP FACTORYAVARS`
**Alternative formats:** None
**Parameters (Inputs):** None
**Outputs (Return values):** Factory variables contents
**Usage examples:**
```
!DUMP FACTORYAVARS
END
```
**Description:** Displays contents of factory variable memory area.
---
### !DUMP FACTORYBVARS
**Command name:** `!DUMP FACTORYBVARS`
**Alternative formats:** None
**Parameters (Inputs):** None
**Outputs (Return values):** Factory backup variables contents
**Usage examples:**
```
!DUMP FACTORYBVARS
END
```
**Description:** Displays contents of factory backup variable memory area.
---
### !DUMP IMAGE
**Command name:** `!DUMP IMAGE`
**Alternative formats:** None
**Parameters (Inputs):** None
**Outputs (Return values):** Image buffer contents
**Usage examples:**
```
!DUMP IMAGE
END
```
**Description:** Displays current image buffer contents for debugging.
---
### !DUMP MEMORY
**Command name:** `!DUMP MEMORY size addr` or `!DUMP MEMORY address length`
**Alternative formats:** None
**Parameters (Inputs):**
- `size` or `length` - Number of bytes to dump (UIntRange)
- `addr` or `address` - Starting memory address (hex)
**Outputs (Return values):** Memory contents
**Usage examples:**
```
!DUMP MEMORY 20 0x20123456
END
```
```
!DUMP MEMORY 0x1000 256
```
**Description:** Displays contents of RAM memory for debugging.
---
### !DUMP USERVARS
**Command name:** `!DUMP USERVARS`
**Alternative formats:** None
**Parameters (Inputs):** None
**Outputs (Return values):** User variables contents
**Usage examples:**
```
!DUMP USERVARS
END
```
**Description:** Displays contents of user variable memory area.
---
### !ERASE EVENTLOG
**Command name:** `!ERASE EVENTLOG`
**Alternative formats:** None
**Parameters (Inputs):** None
**Outputs (Return values):** Erase operation results
**Usage examples:**
```
!ERASE EVENTLOG
END
```
**Description:** Clears the printer's event log.
---
### !ERASE SECTOR
**Command name:** `!ERASE SECTOR[A|B]` or `!ERASE SECTORA` / `!ERASE SECTORB`
**Alternative formats:** None
**Parameters (Inputs):**
- `SECTOR[A|B]` - Sector to erase (A or B)
**Outputs (Return values):** Erase operation results
**Usage examples:**
```
!ERASE SECTORA
END
```
**Description:** Erases specified flash memory sector for maintenance.
---
### !GET INDEX
**Command name:** `!GET INDEX` or `!QI`
**Alternative formats:** None
**Parameters (Inputs):** None
**Outputs (Return values):** Current index settings
**Usage examples:**
```
!GET INDEX
END
```
**Description:** Retrieves current index calibration settings.
---
### !GET SHIFT
**Command name:** `!GET SHIFT`
**Alternative formats:** None
**Parameters (Inputs):** None
**Outputs (Return values):** Shift settings
**Usage examples:**
```
!GET SHIFT
```
**Description:** Retrieves current print shift/offset settings.
---
### !GET TOF
**Command name:** `!GET TOF`
**Alternative formats:** None
**Parameters (Inputs):** None
**Outputs (Return values):** Current TOF (Top of Form) setting
**Usage examples:**
```
!GET TOF
END
```
**Description:** Retrieves current Top of Form setting.
---
### !HISTORY DISABLE
**Command name:** `!HISTORY DISABLE`
**Alternative formats:** None
**Parameters (Inputs):** None
**Outputs (Return values):** Disable confirmation
**Usage examples:**
```
!HISTORY DISABLE
```
**Description:** Disables all history tracking.
---
### !HISTORY ENABLE
**Command name:** `!HISTORY ENABLE hexvalue`
**Alternative formats:** None
**Parameters (Inputs):**
- `hexvalue` - History enable mask (hexadecimal)
**Outputs (Return values):** Enable confirmation
**Usage examples:**
```
!HISTORY ENABLE 0xFF
```
**Description:** Enables specific history tracking with bitmask.
---
### !HISTORY INIT
**Command name:** `!HISTORY INIT hexvalue`
**Alternative formats:** None
**Parameters (Inputs):**
- `hexvalue` - History initialization value (hexadecimal)
**Outputs (Return values):** Initialization confirmation
**Usage examples:**
```
!HISTORY INIT 0x00
```
**Description:** Initializes history system with specified parameters.
---
### !HISTORY OUTPUT
**Command name:** `!HISTORY OUTPUT enable/disable`
**Alternative formats:** None
**Parameters (Inputs):**
- `enable/disable` - History output control
**Outputs (Return values):** Output control confirmation
**Usage examples:**
```
!HISTORY OUTPUT ENABLE
```
**Description:** Enables or disables history output logging.
---
### !LOAD INCHCOUNT
**Command name:** `!LOAD INCHCOUNT nnn`
**Alternative formats:** None
**Parameters (Inputs):**
- `nnn` - Inch count value to load (UIntRange)
**Outputs (Return values):** Load operation results
**Usage examples:**
```
!LOAD INCHCOUNT 1000
END
```
**Description:** Loads inch count value for factory tracking.
---
### !LOAD LICENSE
**Command name:** `!LOAD LICENSE "key"`
**Alternative formats:** None
**Parameters (Inputs):**
- `"key"` - License key string
**Outputs (Return values):** Load confirmation
**Usage examples:**
```
!LOAD LICENSE "ABC123-DEF456-GHI789"
```
**Description:** Loads software license key (manufacturing use).
---
### !LOAD MAC
**Command name:** `!LOAD MAC addr`
**Alternative formats:** None
**Parameters (Inputs):**
- `addr` - MAC address string (e.g., 00:11:22:33:44:55)
**Outputs (Return values):** Load operation results
**Usage examples:**
```
!LOAD MAC 00:11:22:33:44:55
END
```
**Description:** Sets the network interface MAC address.
---
### !LOAD MODELNUMBER
**Command name:** `!LOAD MODELNUMBER model`
**Alternative formats:** None
**Parameters (Inputs):**
- `model` - Model number string
**Outputs (Return values):** Load operation results
**Usage examples:**
```
!LOAD MODELNUMBER BT200
END
```
**Description:** Sets the printer's model number.
---
### !LOAD OOBVARS
**Command name:** `!LOAD OOBVARS`
**Alternative formats:** None
**Parameters (Inputs):** None
**Outputs (Return values):** Load operation results
**Usage examples:**
```
!LOAD OOBVARS
END
```
**Description:** Loads out-of-box variables to factory defaults.
---
### !LOAD SERIALNUMBER
**Command name:** `!LOAD SERIALNUMBER serial`
**Alternative formats:** None
**Parameters (Inputs):**
- `serial` - Serial number string
**Outputs (Return values):** Load operation results
**Usage examples:**
```
!LOAD SERIALNUMBER ABC123456
END
```
**Description:** Sets the printer's serial number.
---
### !PRINT TESTLABEL
**Command name:** `!PRINT TESTLABEL`
**Alternative formats:** None
**Parameters (Inputs):** None
**Outputs (Return values):** Prints test label
**Usage examples:**
```
!PRINT TESTLABEL
```
**Description:** Prints comprehensive printer test label with configuration.
---
### !QIB
**Command name:** `!QIB [I|D]`
**Alternative formats:** None
**Parameters (Inputs):**
- `I` - Initialize buffer (optional)
- `D` - Dump buffer (optional, default)
**Outputs (Return values):** Buffered index sensor values
**Usage examples:**
```
!QIB I
!QIB D
!QIB
```
**Description:** Queries buffered index sensor values log. `!QIB I` initializes buffer, `!QIB D` or `!QIB` dumps the buffer.
---
### !QM
**Command name:** `!QM`
**Alternative formats:** None
**Parameters (Inputs):** None
**Outputs (Return values):** Memory type and size
**Usage examples:**
```
!QM
```
**Description:** Queries memory type and total size information.
---
### !QSA
**Command name:** `!QSA`
**Alternative formats:** None
**Parameters (Inputs):** None
**Outputs (Return values):** Sector architecture
**Usage examples:**
```
!QSA
```
**Description:** Queries flash memory sector architecture details.
---
### !QSTACK
**Command name:** `!QSTACK`
**Alternative formats:** None
**Parameters (Inputs):** None
**Outputs (Return values):** Stack status
**Usage examples:**
```
!QSTACK
```
**Description:** Queries current stack usage and status.
---
### !SET HOST_NAME
**Command name:** `!SET HOST_NAME "hostname"` or `!SET HOSTNAME hostname`
**Alternative formats:** None
**Parameters (Inputs):**
- `"hostname"` - Host name string
**Outputs (Return values):** Hostname setting confirmation
**Usage examples:**
```
!SET HOST_NAME "PRINTER001"
END
```
```
!SET HOSTNAME PRINTER001
STRING 12x16 10 10 Hostname Set
END
```
**Description:** Sets network host name for the printer.
---
### !SET INDEX
**Command name:** `!SET INDEX "FeedType" "PrintMode" "R%" "T%" "Gain" "WhiteLevel"`
**Alternative formats:** None
**Parameters (Inputs):**
- `"FeedType"` - Media feed type (e.g., GAP)
- `"PrintMode"` - Print mode (e.g., DIRECT)
- `"R%"` - Reflective LED percentage (UIntRange)
- `"T%"` - Transmissive LED percentage (UIntRange)
- `"Gain"` - Sensor gain value (UIntRange)
- `"WhiteLevel"` - White level threshold (UIntRange)
**Outputs (Return values):** Index configuration confirmation
**Usage examples:**
```
!SET INDEX GAP DIRECT 50 50 100 200
```
**Description:** Sets comprehensive index sensor parameters.
---
### !SET OEMIDENTIFIER
**Command name:** `!SET OEMIDENTIFIER identifier`
**Alternative formats:** None
**Parameters (Inputs):**
- `identifier` - OEM identifier string
**Outputs (Return values):** Set confirmation
**Usage examples:**
```
!SET OEMIDENTIFIER CUSTOM_OEM
```
**Description:** Sets OEM identifier for custom branding (manufacturing use).
---
### !SET OEMMODELID
**Command name:** `!SET OEMMODELID modelid`
**Alternative formats:** None
**Parameters (Inputs):**
- `modelid` - OEM model identifier (string or number)
**Outputs (Return values):** Set confirmation
**Usage examples:**
```
!SET OEMMODELID 12345
```
**Description:** Sets OEM model ID (manufacturing use).
---
### !SET PEELER
**Command name:** `!SET PEELER mode`
**Alternative formats:** None
**Parameters (Inputs):**
- `mode` - Peeler configuration mode (e.g., ENABLED)
**Outputs (Return values):** Configuration confirmation
**Usage examples:**
```
!SET PEELER ENABLED
```
**Description:** Configures label peeler operation mode.
---
### !SET PRINTHEAD
**Command name:** `!SET PRINTHEAD parameters`
**Alternative formats:** None
**Parameters (Inputs):**
- `parameters` - Print head configuration parameters (e.g., 203,832 for DPI,width)
**Outputs (Return values):** Configuration confirmation
**Usage examples:**
```
!SET PRINTHEAD 203,832
```
**Description:** Configures print head specifications (manufacturing use).
---
### !SET SHIFT
**Command name:** `!SET SHIFT value`
**Alternative formats:** None
**Parameters (Inputs):**
- `value` - Print shift/offset value (IntRange)
**Outputs (Return values):** Set confirmation
**Usage examples:**
```
!SET SHIFT 10
```
**Description:** Sets the global print position shift/offset.
---
### !SET TIME
**Command name:** `!SET TIME YYYY MM DD hh mm ss` or `!SET TIME hh:mm:ss`
**Alternative formats:** None
**Parameters (Inputs):**
- `YYYY` - Year (4 digits, 1970-2069)
- `MM` - Month (2 digits, 1-12)
- `DD` - Day (2 digits, 1-31)
- `hh` - Hour (2 digits, 0-23)
- `mm` - Minute (2 digits, 0-59)
- `ss` - Second (2 digits, 0-59)
**Outputs (Return values):** Time setting confirmation
**Usage examples:**
```
!SET TIME 2024 12 25 14 30 00
END
```
```
!SET TIME 14:30:00
```
**Description:** Sets the printer's internal clock.
---
### !SET TOF
**Command name:** `!SET TOF nnn` or `!SET TOF value`
**Alternative formats:** None
**Parameters (Inputs):**
- `nnn` or `value` - TOF value (IntRange)
**Outputs (Return values):** TOF setting confirmation
**Usage examples:**
```
!SET TOF 100
END
```
```
!SET TOF 50
```
**Description:** Sets the Top of Form value.
---
### !SHOW AD
**Command name:** `!SHOW AD`
**Alternative formats:** None
**Parameters (Inputs):** None
**Outputs (Return values):** A/D converter readings
**Usage examples:**
```
!SHOW AD
END
```
**Description:** Displays analog-to-digital converter readings for diagnostic purposes.
---
### !SHOW EVENTLOG
**Command name:** `!SHOW EVENTLOG`
**Alternative formats:** None
**Parameters (Inputs):** None
**Outputs (Return values):** Event log contents
**Usage examples:**
```
!SHOW EVENTLOG
END
```
**Description:** Displays the printer's event log for troubleshooting.
---
### !SHOW HEAP
**Command name:** `!SHOW HEAP`
**Alternative formats:** None
**Parameters (Inputs):** None
**Outputs (Return values):** Heap memory statistics
**Usage examples:**
```
!SHOW HEAP
```
**Description:** Shows heap memory allocation and usage statistics.
---
### !SHOW HISTORY
**Command name:** `!SHOW HISTORY` or `!QH`
**Alternative formats:** None
**Parameters (Inputs):** None
**Outputs (Return values):** Command history buffer
**Usage examples:**
```
!SHOW HISTORY
END
```
**Description:** Displays the command history buffer for debugging.
---
### !SHOW HOST_NAME
**Command name:** `!SHOW HOST_NAME`
**Alternative formats:** None
**Parameters (Inputs):** None
**Outputs (Return values):** Current hostname
**Usage examples:**
```
!SHOW HOST_NAME
```
**Description:** Displays the printer's network hostname.
---
### !SHOW INCHCOUNT
**Command name:** `!SHOW INCHCOUNT`
**Alternative formats:** None
**Parameters (Inputs):** None
**Outputs (Return values):** Total inches printed
**Usage examples:**
```
!SHOW INCHCOUNT
```
**Description:** Shows cumulative count of inches printed.
---
### !SHOW MAC
**Command name:** `!SHOW MAC`
**Alternative formats:** None
**Parameters (Inputs):** None
**Outputs (Return values):** MAC address
**Usage examples:**
```
!SHOW MAC
```
**Description:** Displays the Ethernet MAC address.
---
### !SHOW MEMORY
**Command name:** `!SHOW MEMORY`
**Alternative formats:** None
**Parameters (Inputs):** None
**Outputs (Return values):** Memory usage information
**Usage examples:**
```
!SHOW MEMORY
END
```
**Description:** Displays current memory usage statistics.
---
### !SHOW MODELNUMBER
**Command name:** `!SHOW MODELNUMBER`
**Alternative formats:** None
**Parameters (Inputs):** None
**Outputs (Return values):** Printer model number
**Usage examples:**
```
!SHOW MODELNUMBER
```
**Description:** Displays the printer model number.
---
### !SHOW OEMIDENTIFIER
**Command name:** `!SHOW OEMIDENTIFIER`
**Alternative formats:** None
**Parameters (Inputs):** None
**Outputs (Return values):** OEM identifier information
**Usage examples:**
```
!SHOW OEMIDENTIFIER
END
```
**Description:** Displays the current OEM identifier for the printer.
---
### !SHOW OEMMODELID
**Command name:** `!SHOW OEMMODELID`
**Alternative formats:** None
**Parameters (Inputs):** None
**Outputs (Return values):** OEM model ID information
**Usage examples:**
```
!SHOW OEMMODELID
END
```
**Description:** Displays the OEM model identifier for the printer.
---
### !SHOW PRINTHEAD
**Command name:** `!SHOW PRINTHEAD`
**Alternative formats:** None
**Parameters (Inputs):** None
**Outputs (Return values):** Print head specifications
**Usage examples:**
```
!SHOW PRINTHEAD
```
**Description:** Displays print head type, resolution, and width.
---
### !SHOW SECTORADDR
**Command name:** `!SHOW SECTORADDR` or `!QSA`
**Alternative formats:** None
**Parameters (Inputs):** None
**Outputs (Return values):** Flash sector architecture information
**Usage examples:**
```
!SHOW SECTORADDR
END
```
**Description:** Displays flash memory sector architecture information.
---
### !SHOW SERIALNUMBER
**Command name:** `!SHOW SERIALNUMBER`
**Alternative formats:** None
**Parameters (Inputs):** None
**Outputs (Return values):** Printer serial number
**Usage examples:**
```
!SHOW SERIALNUMBER
```
**Description:** Displays the printer serial number.
---
### !SHOW STACK
**Command name:** `!SHOW STACK` or `!QSTACK`
**Alternative formats:** None
**Parameters (Inputs):** None
**Outputs (Return values):** Stack status information
**Usage examples:**
```
!SHOW STACK
END
```
**Description:** Displays current stack status and usage information.
---
### !SET OOBVARS
**Command name:** `!SET OOBVARS parameters`
**Alternative formats:** None
**Parameters (Inputs):**
- `parameters` - Out-of-box variable parameters (e.g., DEFAULT)
**Outputs (Return values):** Set confirmation
**Usage examples:**
```
!SET OOBVARS DEFAULT
```
**Description:** Sets out-of-box configuration variables (manufacturing).
---
### TRACE COMMANDS
**Command name:** Various trace control commands (DATA_TRACE_OPEN, etc.)
**Alternative formats:** Multiple trace functions
**Parameters (Inputs):** Trace parameters (e.g., open/close)
**Outputs (Return values):** Trace operation results
**Commands Include:**
- `DATA_TRACE_OPEN` - Open data trace
- `DATA_TRACE_CLOSE` - Close data trace
- `MESSAGE_TRACE_OPEN` - Open message trace
- `MESSAGE_TRACE_CLOSE` - Close message trace
- `TRACE_MARK` - Add trace marker
- `TRACE_FLUSH` - Flush trace buffer
**Usage examples:**
```
DATA_TRACE_OPEN
[commands to trace]
DATA_TRACE_CLOSE
END
```
**Description:** Comprehensive tracing system for debugging and analysis.
---
## Menu and User Interface Commands
Commands for menu systems and user interaction. Sorted lexicographically.
### MENU ACTION
**Command name:** `MENU ACTION "..."` or `MU ACTION "..."`
**Alternative formats:** `MENU ACTION itemname action` (extended)
**Parameters (Inputs):**
- `"..."` - Action command string
- `itemname` (extended) - Menu item identifier
- `action` (extended) - Action to perform when selected (e.g., PRINT)
**Outputs (Return values):** Menu action execution
**Usage examples:**
```
MENU START
MENU ACTION "PRINT_LABEL"
MENU END
END
```
```
MENU ACTION Option1 PRINT
MENU ACTION Option2 FEED
END
```
**Description:** Defines an action to be executed when menu item is selected.
---
### MENU CONTROL
**Command name:** `MENU CONTROL can nxt prv sel` or `MU CONTROL can nxt prv sel`
**Alternative formats:** `MENU CONTROL option` (extended)
**Parameters (Inputs):**
- `can` - Cancel key (CtrlKeyRange)
- `nxt` - Next key (CtrlKeyRange)
- `prv` - Previous key (CtrlKeyRange)
- `sel` - Select key (CtrlKeyRange)
- `option` (extended) - Control option (SHOW/HIDE/ENABLE/DISABLE)
**Outputs (Return values):** Menu control key mapping
**Usage examples:**
```
MENU CONTROL ESC PGDN PGUP ENTER
MENU START
MENU ITEM Option1
MENU END
END
```
```
MENU CONTROL SHOW
END
```
**Description:** Defines control key mappings for menu navigation or controls visibility/interaction.
---
### MENU END
**Command name:** `MENU END` or `MU END`
**Alternative formats:** None
**Parameters (Inputs):** None
**Outputs (Return values):** None (menu system)
**Usage examples:**
```
MENU START
MENU ITEM Test Option
MENU END
END
```
**Description:** Terminates menu system definition.
---
### MENU EXIT
**Command name:** `MENU EXIT` or `MU EXIT`
**Alternative formats:** None
**Parameters (Inputs):** None
**Outputs (Return values):** None (menu system)
**Usage examples:**
```
MENU START
MENU ITEM Option1
MENU EXIT
END
```
**Description:** Defines menu exit point or action; exits current menu level.
---
### MENU ITEM
**Command name:** `MENU ITEM label` or `MU ITEM "...."`
**Alternative formats:** `MENU ITEM itemname "display text"` (extended)
**Parameters (Inputs):**
- `label` - Menu item label
- `"...."` - Menu item text (up to 4 characters)
- `itemname` (extended) - Unique item identifier
- `"display text"` (extended) - Text displayed in menu
**Outputs (Return values):** None (menu system)
**Usage examples:**
```
MENU START
MENU ITEM Print Label
MENU ITEM Configure
MENU END
END
```
```
MENU START
MENU ITEM "Opt1"
MENU ITEM "Opt2"
MENU END
END
```
```
MENU ITEM PrintLabel "Print Test Label"
MENU ITEM Configure "Configuration Menu"
END
```
**Description:** Defines a menu item in the menu system.
---
### MENU MESSAGE
**Command name:** `MENU MESSAGE "text"`
**Alternative formats:** None
**Parameters (Inputs):**
- `"text"` - Message text to display
**Outputs (Return values):** None (message display)
**Usage examples:**
```
MENU MESSAGE "Please select an option"
END
```
**Description:** Displays a message within the menu system.
---
### MENU START
**Command name:** `MENU START` or `MENU START menuname`
**Alternative formats:** `!S~ 3 F/E`
**Parameters (Inputs):**
- Storage location and format parameters
- `menuname` (extended) - Unique menu identifier
**Outputs (Return values):** None (menu system)
**Usage examples:**
```
MENU START
MENU ITEM Option1
MENU END
END
```
```
MENU START MainMenu
MENU ITEM Option1 "First Option"
MENU ITEM Option2 "Second Option"
MENU END
END
```
**Description:** Initiates menu system for user interaction.
---
### RECALL MENU
**Command name:** `RECALL MENU menuname`
**Alternative formats:** None
**Parameters (Inputs):**
- `menuname` - Name of menu to display
**Outputs (Return values):** None (menu activation)
**Usage examples:**
```
RECALL MENU MainMenu
END
```
**Description:** Activates and displays a previously defined menu.
---
## Network and Communication Commands
Commands for network setup and protocols. Sorted lexicographically.
### SET HOST NAME
**Command name:** `!SET HOSTNAME hostname`
**Alternative formats:** See !SET HOST_NAME
**Parameters (Inputs):** See !SET HOST_NAME
**Outputs (Return values):** See !SET HOST_NAME
**Usage examples:** See !SET HOST_NAME
**Description:** Alias for setting hostname.
---
## Bluetooth Commands
Bluetooth-specific configuration. Sorted lexicographically.
### BLUETOOTH COMMANDS (Complete Set)
**Command name:** Various Bluetooth configuration functions
**Alternative formats:** Multiple specific commands (see VARIABLE BLUETOOTH subcommands)
**Parameters (Inputs):** Various Bluetooth parameters
**Outputs (Return values):** Bluetooth operation results
**Commands Include:**
- See VARIABLE BLUETOOTH subcommands above
**Usage examples:**
```
BLUETOOTH_DISCOVERABLE ON
STRING 12x16 10 10 Bluetooth Configured
END
```
```
BLUETOOTH_DEVICE_NAME "My Printer"
BLUETOOTH_DISCOVERABLE ON
BLUETOOTH_SECURITY 2
END
```
**Description:** Configure various Bluetooth settings including discoverability, security, encryption, etc. (complete suite via VARIABLE BLUETOOTH).
---
## Time and Date Commands
Commands for time management. Sorted lexicographically.
### TIME ADD
**Command name:** `TIME ADD YY MM DD hh mm ss`
**Alternative formats:** None
**Parameters (Inputs):**
- `YY` - Years to add (UIntRange)
- `MM` - Months to add (UIntRange)
- `DD` - Days to add (UIntRange)
- `hh` - Hours to add (UIntRange)
- `mm` - Minutes to add (UIntRange)
- `ss` - Seconds to add (UIntRange)
**Outputs (Return values):** Time addition results
**Usage examples:**
```
TIME ADD 0 1 0 0 0 0
STRING 12x16 10 10 Added One Month
END
```
**Description:** Adds specified time to current time.
---
### TIME GET
**Command name:** `TIME GET`
**Alternative formats:** None
**Parameters (Inputs):** None
**Outputs (Return values):** Current time
**Usage examples:**
```
TIME GET
STRING 12x16 10 10 Current Time Retrieved
END
```
**Description:** Retrieves current printer time.
---
### TIME QUERY
**Command name:** `TIME ?` or `!QT`
**Alternative formats:** None
**Parameters (Inputs):** None
**Outputs (Return values):** Current time and date
**Usage examples:**
```
TIME ?
STRING 12x16 10 10 Time Queried
END
```
**Description:** Queries current time and date.
---
### TIME SET
**Command name:** `TIME SET YYYY MM DD hh mm ss` or `!SET TIME YYYY MM DD hh mm ss`
**Alternative formats:** None
**Parameters (Inputs):**
- `YYYY` - Year (1970-2069)
- `MM` - Month (1-12)
- `DD` - Day (1-31)
- `hh` - Hour (0-23)
- `mm` - Minute (0-59)
- `ss` - Second (0-59)
**Outputs (Return values):** Time setting confirmation
**Usage examples:**
```
TIME SET 2024 12 25 14 30 00
STRING 12x16 10 10 Time Set
END
```
**Description:** Sets the printer's internal clock.
---
## Query Commands
General query commands for system info. Sorted lexicographically.
### !QB
**Command name:** `!QB`
**Alternative formats:** None
**Parameters (Inputs):** None
**Outputs (Return values):** Bootcode revision
**Usage examples:**
```
!QB
```
**Description:** Queries the bootloader firmware revision.
---
### !QD
**Command name:** `!QD`
**Alternative formats:** None
**Parameters (Inputs):** None
**Outputs (Return values):** Current date
**Usage examples:**
```
!QD
```
**Description:** Queries the printer's current date setting.
---
### !QH
**Command name:** `!QH`
**Alternative formats:** See !SHOW HISTORY
**Parameters (Inputs):** None
**Outputs (Return values):** Command history
**Usage examples:**
```
!QH
```
**Description:** Queries the command history log.
---
### !QI
**Command name:** `!QI`
**Alternative formats:** See !GET INDEX
**Parameters (Inputs):** None
**Outputs (Return values):** Index settings
**Usage examples:**
```
!QI
```
**Description:** Queries current index sensor settings.
---
### !QT
**Command name:** `!QT`
**Alternative formats:** See TIME QUERY
**Parameters (Inputs):** None
**Outputs (Return values):** Current time
**Usage examples:**
```
!QT
```
**Description:** Queries the printer's current time setting.
---
## Command Categories Summary
This unified guide consolidates all CPL commands into logical categories, eliminating duplicates and ensuring completeness. Total unique commands: ~250 (including variants).
## Cross-References
- **Pairs:** ADJUST  ADJUST_DUP; STORE_*  RECALL_*; HEADER variants (HEADER, HEADER_PLUS, HEADER_AUTO, BACKGROUND HEADER)
- **Complements:** DRAW_*  FILL_*; Time: TIME SET  TIME GET  TIME ADD  TIME QUERY
- **Network:** IPADDR/NETMASK/GATEWAY/HOSTNAME; VARIABLE WRITE for persistence
- **Security:** PASSWORD HEADER; Bluetooth security levels
## Notes
- All label formats end with END (or variants) to execute.
- Coordinates in printer dots; ranges model-dependent.
- Bang (!) commands often require privileged access.
- Save with VARIABLE WRITE for NVM.
- Consult manufacturer docs for model variations.
````
`````